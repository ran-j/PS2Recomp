// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1300a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1300a4: 0xc04bffa
    SET_GPR_U32(ctx, 31, 0x1300ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FinishSpooling__18CBinaryAsyncStream(rdram, ctx, runtime); return;
}


// Function: entry_1300ac
// Address: 0x1300ac - 0x1300bc

void entry_1300ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1300ac) {
        switch (ctx->pc) {
            case 0x1300b4: ctx->pc = 0; goto label_1300b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1300ac: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1300C8; return;
    }
label_1300b4:
    // 0x1300b4: 0xc04bffa
    SET_GPR_U32(ctx, 31, 0x1300bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FinishSpooling__18CBinaryAsyncStream(rdram, ctx, runtime); return;
}


// Function: entry_1300bc
// Address: 0x1300bc - 0x1300c4

void entry_1300bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1300bc: 0xc04bf9c
    SET_GPR_U32(ctx, 31, 0x1300c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StartSpooling__18CBinaryAsyncStream(rdram, ctx, runtime); return;
}


// Function: entry_1300c4
// Address: 0x1300c4 - 0x1300d8

void entry_1300c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1300c4) {
        switch (ctx->pc) {
            case 0x1300c8: ctx->pc = 0; goto label_1300c8;
            case 0x1300cc: ctx->pc = 0; goto label_1300cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1300c4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1300c8:
    // 0x1300c8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1300cc:
    // 0x1300cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1300d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1300d8; return;
}


// Function: Skip__18CBinaryAsyncStreami
// Address: 0x1300d8 - 0x1300e8

void entry_130134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x130134: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x130138: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x13013c: 0x24849f38
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    // 0x130140: 0xc0469c2
    SET_GPR_U32(ctx, 31, 0x130148);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    AddRootSidebag__3CGcP8CSidebag(rdram, ctx, runtime); return;
}


// Function: entry_130148
// Address: 0x130148 - 0x130158

void entry_130148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x130148) {
        switch (ctx->pc) {
            case 0x13014c: ctx->pc = 0; goto label_13014c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x130148: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13014c:
    // 0x13014c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x130150: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetBasicCid__FP5BASICP3CID
// Address: 0x130158 - 0x130168

void entry_130854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x130854) {
        switch (ctx->pc) {
            case 0x130904: ctx->pc = 0; goto label_130904;
            case 0x130914: ctx->pc = 0; goto label_130914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x130854: 0xdae70000
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 23), 0)));
    // 0x130858: 0x26828d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294937888));
    // 0x13085c: 0x4bc7386a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x130860: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x130864: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x130868: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13086c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x130870: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x130874: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x130878: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13087c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x130880: 0x4b000220
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x130884: 0xda430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x130888: 0x48234000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x13088c: 0xda440010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x130890: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x130894: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x130898: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13089c: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1308a0: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1308a4: 0xda460020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1308a8: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1308ac: 0x4bc328bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1308b0: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1308b4: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1308b8: 0x4bc428bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1308bc: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1308c0: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1308c4: 0x4bc611bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1308c8: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1308cc: 0x4bc6088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1308d0: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1308d4: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1308d8: 0xfba300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1308dc: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1308e0: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1308e4: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1308e8: 0xfba200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1308ec: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1308f0: 0x45000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[7]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_130904;
    }
    // 0x1308f8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1308fc: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_130914;
    }
label_130904:
    // 0x130904: 0x4a6803bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x130908: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13090c: 0x4be0385c
    ctx->vu0_vf[7] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x130910: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_130914:
    // 0x130914: 0x4600b307
    ctx->f[12] = FPU_NEG_S(ctx->f[22]);
    // 0x130918: 0x48224000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x13091c: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x130920: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x130924: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x130928: 0x46156302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[21]);
    // 0x13092c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x130934);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_130934
// Address: 0x130934 - 0x1309a4

void entry_130934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x130934: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x130938: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13093c: 0xda240010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x130940: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x130944: 0xdba60080
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x130948: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13094c: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x130950: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x130954: 0xda250020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x130958: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13095c: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x130960: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x130964: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x130968: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13096c: 0x4bc4190a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x130970: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x130974: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x130978: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x13097c: 0x4bc5184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x130980: 0xfba40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x130984: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x130988: 0xfba200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13098c: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x130990: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x130994: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x130998: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13099c: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1309a4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1309a4
// Address: 0x1309a4 - 0x1309b4

void entry_1309a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1309a4: 0x27a50100
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1309a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1309ac: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1309b4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1309b4
// Address: 0x1309b4 - 0x1309dc

void entry_1309b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1309b4: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1309b8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1309bc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1309c0: 0xc7a00100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[0] = *(float*)&val; }
    // 0x1309c4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1309c8: 0x46156301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[21]);
    // 0x1309cc: 0x460cb302
    ctx->f[12] = FPU_MUL_S(ctx->f[22], ctx->f[12]);
    // 0x1309d0: 0x46176300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[23]);
    // 0x1309d4: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1309dc);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1309dc
// Address: 0x1309dc - 0x130a50

void entry_1309dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1309dc) {
        switch (ctx->pc) {
            case 0x130a3c: ctx->pc = 0; goto label_130a3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1309dc: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1309e0: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1309e4: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1309e8: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1309ec: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1309f0: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1309f4: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1309f8: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1309fc: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x130a00: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x130a04: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x130a08: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x130a0c: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x130a10: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x130a14: 0x4bc6104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x130a18: 0xfa030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x130a1c: 0xfa010020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x130a20: 0xfa050010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x130a24: 0xfba300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x130a28: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x130a2c: 0xfba500e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x130a30: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x130a34: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x130a38: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
label_130a3c:
    // 0x130a3c: 0x12a00032
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x130B08; return;
    }
    // 0x130a44: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x130a48: 0xc062454
    SET_GPR_U32(ctx, 31, 0x130a50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_130a50
// Address: 0x130a50 - 0x130a60

void entry_130a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x130a50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x130a54: 0x27a50104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 260));
    // 0x130a58: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x130a60);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_130a60
// Address: 0x130a60 - 0x130b48

void entry_130a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x130a60) {
        switch (ctx->pc) {
            case 0x130b08: ctx->pc = 0; goto label_130b08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x130a60: 0x3c0140c0
    SET_GPR_U32(ctx, 1, ((uint32_t)16576 << 16));
    // 0x130a64: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x130a68: 0xc7a10104
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 260)); ctx->f[1] = *(float*)&val; }
    // 0x130a6c: 0x4603a182
    ctx->f[6] = FPU_MUL_S(ctx->f[20], ctx->f[3]);
    // 0x130a70: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x130a74: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x130a78: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x130a7c: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x130a80: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x130a84: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x130a88: 0x3c01c000
    SET_GPR_U32(ctx, 1, ((uint32_t)49152 << 16));
    // 0x130a8c: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x130a90: 0x460618c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[6]);
    // 0x130a94: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x130a98: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x130a9c: 0x4403c000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[24]);
    // 0x130aa0: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x130aa4: 0x48a33800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x130aa8: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x130aac: 0xdac60000
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x130ab0: 0x46050000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[5]);
    // 0x130ab4: 0xdae50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 23), 0)));
    // 0x130ab8: 0x4602a082
    ctx->f[2] = FPU_MUL_S(ctx->f[20], ctx->f[2]);
    // 0x130abc: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x130ac0: 0x46150843
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[21];
    // 0x130ac4: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x130ac8: 0x46022101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[2]);
    // 0x130acc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x130ad0: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x130ad4: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x130ad8: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x130adc: 0x44022000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[4]);
    // 0x130ae0: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x130ae4: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x130ae8: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x130aec: 0x4be119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x130af0: 0x4be230bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x130af4: 0x4be42848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x130af8: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x130afc: 0x4be708d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x130b00: 0xfaa30000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x130b04: 0xfba70040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[7]));
label_130b08:
    // 0x130b08: 0x7bbf0190
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x130b0c: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x130b10: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x130b14: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x130b18: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x130b1c: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x130b20: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x130b24: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x130b28: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x130b2c: 0xc7b801c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 448)); ctx->f[24] = *(float*)&val; }
    // 0x130b30: 0xc7b701b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 440)); ctx->f[23] = *(float*)&val; }
    // 0x130b34: 0xc7b601b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[22] = *(float*)&val; }
    // 0x130b38: 0xc7b501a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 424)); ctx->f[21] = *(float*)&val; }
    // 0x130b3c: 0xc7b401a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 416)); ctx->f[20] = *(float*)&val; }
    // 0x130b40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 464));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TesselateBezier__FfffP6VECTORN33iT3
// Address: 0x130b48 - 0x130be0

void entry_130be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x130be0) {
        switch (ctx->pc) {
            case 0x130bf0: ctx->pc = 0; goto label_130bf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x130be0: 0x4615a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[21]);
    // 0x130be4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x130be8: 0x1600fff1
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x130BB0; return;
    }
label_130bf0:
    // 0x130bf0: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x130bf4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x130bf8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x130bfc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x130c00: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x130c04: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x130c08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x130c0c: 0xc7b60080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[22] = *(float*)&val; }
    // 0x130c10: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x130c14: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x130c18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SBezierPosLength__FffP6VECTORN32
// Address: 0x130c20 - 0x130c3c

void entry_130c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x130c3c: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x130c40: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x130c44: 0xc05342a
    SET_GPR_U32(ctx, 31, 0x130c4c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SMeasureApos__FiP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_130c4c
// Address: 0x130c4c - 0x130c58

void entry_130c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x130c4c: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x130c50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LimitBezierMulti__Fie
// Address: 0x130c58 - 0x130d20

void entry_130d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x130d20) {
        switch (ctx->pc) {
            case 0x130d28: ctx->pc = 0; goto label_130d28;
            case 0x130d48: ctx->pc = 0; goto label_130d48;
            case 0x130d60: ctx->pc = 0; goto label_130d60;
            case 0x130d90: ctx->pc = 0; goto label_130d90;
            case 0x130dc4: ctx->pc = 0; goto label_130dc4;
            case 0x130dcc: ctx->pc = 0; goto label_130dcc;
            case 0x130dd0: ctx->pc = 0; goto label_130dd0;
            case 0x130df8: ctx->pc = 0; goto label_130df8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x130d20: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x130d24: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_130d28:
    // 0x130d28: 0x12620019
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_130d90;
    }
    // 0x130d30: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_130d48;
    }
    // 0x130d38: 0x52600009
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
        goto label_130d60;
    }
    // 0x130d40: 0x10000030
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x130E04; return;
    }
label_130d48:
    // 0x130d48: 0x5276001e
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 22)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
        goto label_130dc4;
    }
    // 0x130d50: 0x527e001e
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 30)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
        goto label_130dcc;
    }
    // 0x130d58: 0x1000002a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x130E04; return;
    }
label_130d60:
    // 0x130d60: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x130d64: 0xc60d000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[13] = *(float*)&val; }
    // 0x130d68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x130d6c: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x130d70: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x130d74: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x130d78: 0x460d6b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[13]);
    // 0x130d7c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x130d80: 0x46157382
    ctx->f[14] = FPU_MUL_S(ctx->f[14], ctx->f[21]);
    // 0x130d84: 0x460d0b40
    ctx->f[13] = FPU_ADD_S(ctx->f[1], ctx->f[13]);
    // 0x130d88: 0x1000001b
    ctx->f[14] = FPU_SUB_S(ctx->f[0], ctx->f[14]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_130df8;
    }
label_130d90:
    // 0x130d90: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x130d94: 0x4600a307
    ctx->f[12] = FPU_NEG_S(ctx->f[20]);
    // 0x130d98: 0xc60d000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[13] = *(float*)&val; }
    // 0x130d9c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x130da0: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x130da4: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x130da8: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x130dac: 0x460d6b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[13]);
    // 0x130db0: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x130db4: 0x46157382
    ctx->f[14] = FPU_MUL_S(ctx->f[14], ctx->f[21]);
    // 0x130db8: 0x460d0b40
    ctx->f[13] = FPU_ADD_S(ctx->f[1], ctx->f[13]);
    // 0x130dbc: 0x1000000e
    ctx->f[14] = FPU_SUB_S(ctx->f[0], ctx->f[14]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_130df8;
    }
label_130dc4:
    // 0x130dc4: 0x10000002
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_130dd0;
    }
label_130dcc:
    // 0x130dcc: 0x4600a307
    ctx->f[12] = FPU_NEG_S(ctx->f[20]);
label_130dd0:
    // 0x130dd0: 0xc60d000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[13] = *(float*)&val; }
    // 0x130dd4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x130dd8: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x130ddc: 0x46180842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[24]);
    // 0x130de0: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x130de4: 0x46166b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[22]);
    // 0x130de8: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x130dec: 0x46157382
    ctx->f[14] = FPU_MUL_S(ctx->f[14], ctx->f[21]);
    // 0x130df0: 0x460d0b41
    ctx->f[13] = FPU_SUB_S(ctx->f[1], ctx->f[13]);
    // 0x130df4: 0x460e0380
    ctx->f[14] = FPU_ADD_S(ctx->f[0], ctx->f[14]);
label_130df8:
    // 0x130df8: 0xc07ab28
    SET_GPR_U32(ctx, 31, 0x130e00);
    CSolveQuadratic__FfffPf(rdram, ctx, runtime); return;
}


// Function: entry_130e00
// Address: 0x130e00 - 0x130f48

void entry_130e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x130e00) {
        switch (ctx->pc) {
            case 0x130e04: ctx->pc = 0; goto label_130e04;
            case 0x130e30: ctx->pc = 0; goto label_130e30;
            case 0x130e34: ctx->pc = 0; goto label_130e34;
            case 0x130e50: ctx->pc = 0; goto label_130e50;
            case 0x130e68: ctx->pc = 0; goto label_130e68;
            case 0x130e6c: ctx->pc = 0; goto label_130e6c;
            case 0x130e88: ctx->pc = 0; goto label_130e88;
            case 0x130e8c: ctx->pc = 0; goto label_130e8c;
            case 0x130eb8: ctx->pc = 0; goto label_130eb8;
            case 0x130ee8: ctx->pc = 0; goto label_130ee8;
            case 0x130ef4: ctx->pc = 0; goto label_130ef4;
            case 0x130efc: ctx->pc = 0; goto label_130efc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x130e00: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_130e04:
    // 0x130e04: 0x5656000b
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 22)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        goto label_130e34;
    }
    // 0x130e0c: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x130e10: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x130e14: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x130e18: 0x0
    // NOP
    // 0x130e1c: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
        goto label_130e30;
    }
    // 0x130e24: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x130e28: 0xe6210004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    // 0x130e2c: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
label_130e30:
    // 0x130e30: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_130e34:
    // 0x130e34: 0x2a620004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 4));
    // 0x130e38: 0x1440ffbb
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x130D28; return;
    }
    // 0x130e40: 0x2a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x130e44: 0x217102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 23)));
    // 0x130e48: 0x5440ffaf
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 8));
        ctx->pc = 0x130D08; return;
    }
label_130e50:
    // 0x130e50: 0x23d1023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 29)));
    // 0x130e54: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x130e58: 0x29083
    SET_GPR_S32(ctx, 18, SRA32(GPR_S32(ctx, 2), 2));
    // 0x130e5c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x130e60: 0xc4639c90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294941840)); ctx->f[3] = *(float*)&val; }
    // 0x130e64: 0x26860008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 8));
label_130e68:
    // 0x130e68: 0xb2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 18)));
label_130e6c:
    // 0x130e6c: 0x50400023
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4294967288)));
        goto label_130efc;
    }
    // 0x130e74: 0x4a00004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 2));
    if (GPR_S32(ctx, 5) < 0) {
        goto label_130e88;
    }
    // 0x130e7c: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x130e80: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_130e8c;
    }
label_130e88:
    // 0x130e88: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
label_130e8c:
    // 0x130e8c: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x130e90: 0x0
    // NOP
    // 0x130e94: 0x4501fff4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_130e68;
    }
    // 0x130e9c: 0x1a400015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_130ef4;
    }
    // 0x130ea4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x130ea8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x130eac: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x130eb0: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x130eb4: 0x0
    // NOP
label_130eb8:
    // 0x130eb8: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x130ebc: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x130ec0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x130ec4: 0x0
    // NOP
    // 0x130ec8: 0x45000007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_130ee8;
    }
    // 0x130ed0: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x130ed4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x130ed8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x130edc: 0x0
    // NOP
    // 0x130ee0: 0x4501ffe2
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 18)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_130e6c;
    }
label_130ee8:
    // 0x130ee8: 0x92102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 18)));
    // 0x130eec: 0x1440fff2
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_130eb8;
    }
label_130ef4:
    // 0x130ef4: 0x1000ffdc
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_130e68;
    }
label_130efc:
    // 0x130efc: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x130f00: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x130f04: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x130f08: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x130f0c: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x130f10: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x130f14: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x130f18: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x130f1c: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x130f20: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x130f24: 0xc7b80160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[24] = *(float*)&val; }
    // 0x130f28: 0xc7b70158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[23] = *(float*)&val; }
    // 0x130f2c: 0xc7b60150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[22] = *(float*)&val; }
    // 0x130f30: 0xc7b50148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[21] = *(float*)&val; }
    // 0x130f34: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x130f38: 0xe4430000
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x130f3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 496));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x130f44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x130f48; return;
}


// Function: InitBei
// Address: 0x130f48 - 0x131000

void entry_131134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131134: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x131138: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ResetBinoc__FP5BINOC
// Address: 0x131140 - 0x131160

void entry_131160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131160: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x131164: 0xc04d968
    SET_GPR_U32(ctx, 31, 0x13116c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetBinocLookat__FP5BINOCP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13116c
// Address: 0x13116c - 0x131198

void entry_13116c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13116c: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x131170: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x131174: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x131178: 0xae000300
    WRITE32(ADD32(GPR_U32(ctx, 16), 768), GPR_U32(ctx, 0));
    // 0x13117c: 0xe6000314
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 788), *(uint32_t*)&val); }
    // 0x131180: 0xae000304
    WRITE32(ADD32(GPR_U32(ctx, 16), 772), GPR_U32(ctx, 0));
    // 0x131184: 0xae000308
    WRITE32(ADD32(GPR_U32(ctx, 16), 776), GPR_U32(ctx, 0));
    // 0x131188: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13118c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x131190: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostBinocLoad__FP5BINOC
// Address: 0x131198 - 0x1311ec

void entry_1311ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1311ec: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1311f0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1311f4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1311f8: 0xc04c450
    SET_GPR_U32(ctx, 31, 0x131200);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResetBinoc__FP5BINOC(rdram, ctx, runtime); return;
}


// Function: entry_131200
// Address: 0x131200 - 0x131228

void entry_131200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131200: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x131204: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x131208: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x13120c: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x131210: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x131214: 0x8ca3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x131218: 0x84640008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13121c: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x131220: 0x40f809
    SET_GPR_U32(ctx, 31, 0x131228);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_131228
// Address: 0x131228 - 0x131264

void entry_131228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131228: 0xae220310
    WRITE32(ADD32(GPR_U32(ctx, 17), 784), GPR_U32(ctx, 2));
    // 0x13122c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x131230: 0x3c030003
    SET_GPR_U32(ctx, 3, ((uint32_t)3 << 16));
    // 0x131234: 0x3463f001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 61441));
    // 0x131238: 0xac440030
    WRITE32(ADD32(GPR_U32(ctx, 2), 48), GPR_U32(ctx, 4));
    // 0x13123c: 0xfc430038
    WRITE64(ADD32(GPR_U32(ctx, 2), 56), GPR_U64(ctx, 3));
    // 0x131240: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x131244: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x131248: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13124c: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x131250: 0x8ca3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x131254: 0x84640008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x131258: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x13125c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x131264);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_131264
// Address: 0x131264 - 0x131270

void entry_131264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131264: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x131268: 0xc057062
    SET_GPR_U32(ctx, 31, 0x131270);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_131270
// Address: 0x131270 - 0x131288

void entry_131270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131270: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x131290; return;
    }
    // 0x131278: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x13127c: 0x24421148
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4424));
    // 0x131280: 0xc057070
    SET_GPR_U32(ctx, 31, 0x131288);
    WRITE32(ADD32(GPR_U32(ctx, 17), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_131288
// Address: 0x131288 - 0x1312ac

void entry_131288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x131288) {
        switch (ctx->pc) {
            case 0x131290: ctx->pc = 0; goto label_131290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x131288: 0x8e230210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x13128c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_131290:
    // 0x131290: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x131294: 0x8e240310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 784)));
    // 0x131298: 0x8e051128
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4392)));
    // 0x13129c: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1312a0: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x1312a4: 0xc057106
    SET_GPR_U32(ctx, 31, 0x1312ac);
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_1312ac
// Address: 0x1312ac - 0x1312dc

void entry_1312ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1312ac) {
        switch (ctx->pc) {
            case 0x1312c8: ctx->pc = 0; goto label_1312c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1312ac: 0x26360318
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 17), 792));
    // 0x1312b0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1312b4: 0x26101128
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4392));
    // 0x1312b8: 0xe4401310
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4880), *(uint32_t*)&val); }
    // 0x1312bc: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1312c0: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1312c4: 0x2637031c
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 17), 796));
label_1312c8:
    // 0x1312c8: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1312cc: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1312d0: 0x8e240310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 784)));
    // 0x1312d4: 0xc057106
    SET_GPR_U32(ctx, 31, 0x1312dc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_1312dc
// Address: 0x1312dc - 0x131308

void entry_1312dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1312dc: 0xc6611310
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4880)); ctx->f[1] = *(float*)&val; }
    // 0x1312e0: 0x2e420008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 8));
    // 0x1312e4: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1312e8: 0x1440fff7
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 4880), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1312C8; return;
    }
    // 0x1312f0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1312f4: 0xae200324
    WRITE32(ADD32(GPR_U32(ctx, 17), 804), GPR_U32(ctx, 0));
    // 0x1312f8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1312fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x131300: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x131308);
    WRITE32(ADD32(GPR_U32(ctx, 17), 608), GPR_U32(ctx, 2));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_131308
// Address: 0x131308 - 0x131318

void entry_131308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131308: 0x3c013e30
    SET_GPR_U32(ctx, 1, ((uint32_t)15920 << 16));
    // 0x13130c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x131310: 0xc063582
    SET_GPR_U32(ctx, 31, 0x131318);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_131318
// Address: 0x131318 - 0x131334

void entry_131318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131318: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x13131c: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x131320: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x131324: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x131328: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x13132c: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x131334);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_131334
// Address: 0x131334 - 0x13134c

void entry_131334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131334: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x131338: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x13133c: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x131340: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x131344: 0xc063596
    SET_GPR_U32(ctx, 31, 0x13134c);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_13134c
// Address: 0x13134c - 0x131370

void entry_13134c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13134c: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x131350: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x131354: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x131358: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13135c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131360: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x131364: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x131368: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x131370);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_131370
// Address: 0x131370 - 0x131388

void entry_131370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131370: 0x4600ddc6
    ctx->f[23] = FPU_MOV_S(ctx->f[27]);
    // 0x131374: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131378: 0x240701ee
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 494));
    // 0x13137c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131380: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x131388);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_131388
// Address: 0x131388 - 0x131398

void entry_131388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131388: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13138c: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x131390: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x131398);
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_131398
// Address: 0x131398 - 0x1313a8

void entry_131398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131398: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13139c: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1313a0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1313a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1313a8
// Address: 0x1313a8 - 0x1313d4

void entry_1313a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1313a8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1313ac: 0x24030060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1313b0: 0x244710d0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4304));
    // 0x1313b4: 0x88e40003
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x1313b8: 0x98e40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x1313bc: 0xaba40033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1313c0: 0xbba40030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1313c4: 0xa3a30033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 3));
    // 0x1313c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1313cc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1313d4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1313d4
// Address: 0x1313d4 - 0x1313e8

void entry_1313d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1313d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1313d8: 0x24070004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1313dc: 0x24050044
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1313e0: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1313e8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1313e8
// Address: 0x1313e8 - 0x131408

void entry_1313e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1313e8: 0x3c014220
    SET_GPR_U32(ctx, 1, ((uint32_t)16928 << 16));
    // 0x1313ec: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1313f0: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1313f4: 0x24a510a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4256));
    // 0x1313f8: 0x26841280
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4736));
    // 0x1313fc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x131400: 0xc04c3d2
    SET_GPR_U32(ctx, 31, 0x131408);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    InitBei(rdram, ctx, runtime); return;
}


// Function: entry_131408
// Address: 0x131408 - 0x131428

void entry_131408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131408: 0x3c01c270
    SET_GPR_U32(ctx, 1, ((uint32_t)49776 << 16));
    // 0x13140c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x131410: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x131414: 0x24a510b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4272));
    // 0x131418: 0x26a412b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 4784));
    // 0x13141c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x131420: 0xc04c3d2
    SET_GPR_U32(ctx, 31, 0x131428);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    InitBei(rdram, ctx, runtime); return;
}


// Function: entry_131428
// Address: 0x131428 - 0x131454

void entry_131428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131428: 0x3c013e92
    SET_GPR_U32(ctx, 1, ((uint32_t)16018 << 16));
    // 0x13142c: 0x34214925
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 18725));
    // 0x131430: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x131434: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x131438: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x13143c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x131440: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x131444: 0x248412e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4832));
    // 0x131448: 0x24a510c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4288));
    // 0x13144c: 0xc04c3d2
    SET_GPR_U32(ctx, 31, 0x131454);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    InitBei(rdram, ctx, runtime); return;
}


// Function: entry_131454
// Address: 0x131454 - 0x131470

void entry_131454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131454: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x131458: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13145c: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x131460: 0x24067900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    // 0x131464: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x131468: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x131470);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131470
// Address: 0x131470 - 0x13148c

void entry_131470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131470: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x131474: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131478: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x13147c: 0x24067b45
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31557));
    // 0x131480: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x131484: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x13148c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13148c
// Address: 0x13148c - 0x1314a0

void entry_13148c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13148c) {
        switch (ctx->pc) {
            case 0x131490: ctx->pc = 0; goto label_131490;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13148c: 0x461cbd42
    ctx->f[21] = FPU_MUL_S(ctx->f[23], ctx->f[28]);
label_131490:
    // 0x131490: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x131494: 0x26841280
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4736));
    // 0x131498: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x1314a0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_1314a0
// Address: 0x1314a0 - 0x1314d4

void entry_1314a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1314a0: 0x461bbdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[27]);
    // 0x1314a4: 0x461aad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[26]);
    // 0x1314a8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1314ac: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1314b0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1314b4: 0x24067900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    // 0x1314b8: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1314bc: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x1314c0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1314c4: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1314c8: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x1314cc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1314d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1314d4
// Address: 0x1314d4 - 0x131500

void entry_1314d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1314d4: 0x4619a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x1314d8: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1314dc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1314e0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1314e4: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1314e8: 0x4618a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
    // 0x1314ec: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x1314f0: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1314f4: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1314f8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131500);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131500
// Address: 0x131500 - 0x131528

void entry_131500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131500: 0x2a220018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 24));
    // 0x131504: 0x5440ffe2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_MUL_S(ctx->f[23], ctx->f[28]);
        ctx->pc = 0x131490; return;
    }
    // 0x13150c: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x131510: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131514: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x131518: 0x24067900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    // 0x13151c: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x131520: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131528);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131528
// Address: 0x131528 - 0x131550

void entry_131528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131528: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x13152c: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x131530: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x131534: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x131538: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13153c: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x131540: 0x24067b45
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31557));
    // 0x131544: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x131548: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131550);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131550
// Address: 0x131550 - 0x131574

void entry_131550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131550: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x131554: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x131558: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x13155c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131560: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x131564: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x131568: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x13156c: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x131574);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131574
// Address: 0x131574 - 0x1315a0

void entry_131574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131574: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x131578: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x13157c: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x131580: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131584: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x131588: 0x340680fa
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 33018));
    // 0x13158c: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x131590: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x131594: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x131598: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1315a0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1315a0
// Address: 0x1315a0 - 0x1315d0

void entry_1315a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1315a0) {
        switch (ctx->pc) {
            case 0x1315c0: ctx->pc = 0; goto label_1315c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1315a0: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1315a4: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1315a8: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1315ac: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1315b0: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1315b4: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1315b8: 0x461cbd42
    ctx->f[21] = FPU_MUL_S(ctx->f[23], ctx->f[28]);
    // 0x1315bc: 0x0
    // NOP
label_1315c0:
    // 0x1315c0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1315c4: 0x26a412b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 4784));
    // 0x1315c8: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x1315d0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_1315d0
// Address: 0x1315d0 - 0x131604

void entry_1315d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1315d0: 0x461bbdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[27]);
    // 0x1315d4: 0x461aad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[26]);
    // 0x1315d8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1315dc: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1315e0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1315e4: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x1315e8: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1315ec: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x1315f0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1315f4: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1315f8: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x1315fc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131604);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131604
// Address: 0x131604 - 0x131630

void entry_131604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131604: 0x4619a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x131608: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x13160c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x131610: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131614: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x131618: 0x4618a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
    // 0x13161c: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x131620: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x131624: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x131628: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131630);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131630
// Address: 0x131630 - 0x131658

void entry_131630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131630: 0x2a220018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 24));
    // 0x131634: 0x5440ffe2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_MUL_S(ctx->f[23], ctx->f[28]);
        ctx->pc = 0x1315C0; return;
    }
    // 0x13163c: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x131640: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131644: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x131648: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x13164c: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x131650: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131658);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131658
// Address: 0x131658 - 0x131674

void entry_131658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131658: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x13165c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131660: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x131664: 0x340680fa
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 33018));
    // 0x131668: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x13166c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131674);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131674
// Address: 0x131674 - 0x13168c

void entry_131674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131674: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x131678: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x13167c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131680: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131684: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x13168c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 21));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_13168c
// Address: 0x13168c - 0x131694

void entry_13168c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13168c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x131694);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_131694
// Address: 0x131694 - 0x1316e8

void entry_131694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131694: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x131698: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13169c: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1316a0: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1316a4: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1316a8: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1316ac: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1316b0: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1316b4: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1316b8: 0xc7bc0110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[28] = *(float*)&val; }
    // 0x1316bc: 0xc7bb0108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[27] = *(float*)&val; }
    // 0x1316c0: 0xc7ba0100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[26] = *(float*)&val; }
    // 0x1316c4: 0xc7b900f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[25] = *(float*)&val; }
    // 0x1316c8: 0xc7b800f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[24] = *(float*)&val; }
    // 0x1316cc: 0xc7b700e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[23] = *(float*)&val; }
    // 0x1316d0: 0xc7b600e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    // 0x1316d4: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x1316d8: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x1316dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1316e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1316e8; return;
}


// Function: DrawBinocCompass
// Address: 0x1316e8 - 0x131768

void entry_131768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131768: 0x3c014388
    SET_GPR_U32(ctx, 1, ((uint32_t)17288 << 16));
    // 0x13176c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x131770: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x131774: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131778: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x13177c: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x131780: 0x3c014228
    SET_GPR_U32(ctx, 1, ((uint32_t)16936 << 16));
    // 0x131784: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x131788: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x13178c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x131794);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_131794
// Address: 0x131794 - 0x1317b8

void entry_131794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131794: 0x3c0142bc
    SET_GPR_U32(ctx, 1, ((uint32_t)17084 << 16));
    // 0x131798: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x13179c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1317a0: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1317a4: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1317a8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1317ac: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1317b0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1317b8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 90));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1317b8
// Address: 0x1317b8 - 0x1317f0

void entry_1317b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1317b8: 0x3c0140f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16624 << 16));
    // 0x1317bc: 0x3421a3d8
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 41944));
    // 0x1317c0: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1317c4: 0x3c060012
    SET_GPR_U32(ctx, 6, ((uint32_t)18 << 16));
    // 0x1317c8: 0x34c60003
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 3));
    // 0x1317cc: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1317d0: 0x34c6016e
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 366));
    // 0x1317d4: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1317d8: 0x34c60111
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 273));
    // 0x1317dc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1317e0: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1317e4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1317e8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1317f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1317f0
// Address: 0x1317f0 - 0x131804

void entry_1317f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1317f0: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1317f4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1317f8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1317fc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x131804);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_131804
// Address: 0x131804 - 0x131830

void entry_131804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131804: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x131808: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x13180c: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x131810: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131814: 0x24057d10
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32016));
    // 0x131818: 0x2406793a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31034));
    // 0x13181c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131820: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x131824: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x131828: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131830);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131830
// Address: 0x131830 - 0x131848

void entry_131830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131830: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131834: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131838: 0x340582f0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 33520));
    // 0x13183c: 0x24067a32
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31282));
    // 0x131840: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131848);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131848
// Address: 0x131848 - 0x13185c

void entry_131848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131848: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13184c: 0x24074441
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 17473));
    // 0x131850: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131854: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x13185c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 67));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_13185c
// Address: 0x13185c - 0x131868

void entry_13185c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13185c: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x131860: 0xc058516
    SET_GPR_U32(ctx, 31, 0x131868);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_131868
// Address: 0x131868 - 0x131880

void entry_131868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131868: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x13186c: 0x24057d10
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32016));
    // 0x131870: 0x2406793a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31034));
    // 0x131874: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131878: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131880);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131880
// Address: 0x131880 - 0x131898

void entry_131880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131880: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131884: 0x340582f0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 33520));
    // 0x131888: 0x2406793a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31034));
    // 0x13188c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131890: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x131898);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131898
// Address: 0x131898 - 0x1318b0

void entry_131898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131898: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13189c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1318a0: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1318a4: 0x24067a32
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31282));
    // 0x1318a8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1318b0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1318b0
// Address: 0x1318b0 - 0x1318c4

void entry_1318b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1318b0: 0x240701ee
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 494));
    // 0x1318b4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1318b8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1318bc: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1318c4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1318c4
// Address: 0x1318c4 - 0x1318d8

void entry_1318c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1318c4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1318c8: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1318cc: 0x34c6f001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 61441));
    // 0x1318d0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1318d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1318d8
// Address: 0x1318d8 - 0x1318e8

void entry_1318d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1318d8: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1318dc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1318e0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1318e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1318e8
// Address: 0x1318e8 - 0x1318f8

void entry_1318e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1318e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1318ec: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1318f0: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1318f8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4320)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1318f8
// Address: 0x1318f8 - 0x13190c

void entry_1318f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1318f8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1318fc: 0x24050084
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 132));
    // 0x131900: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x131904: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x13190c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_13190c
// Address: 0x13190c - 0x13195c

void entry_13190c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13190c) {
        switch (ctx->pc) {
            case 0x131910: ctx->pc = 0; goto label_131910;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13190c: 0x27b70020
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 32));
label_131910:
    // 0x131910: 0x4492a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 18);
    // 0x131914: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x131918: 0xc6a00314
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 788)); ctx->f[0] = *(float*)&val; }
    // 0x13191c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131920: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x131924: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131928: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13192c: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x131930: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x131934: 0x461aa502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[26]);
    // 0x131938: 0x461ba502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[27]);
    // 0x13193c: 0x4614ed00
    ctx->f[20] = FPU_ADD_S(ctx->f[29], ctx->f[20]);
    // 0x131940: 0x4616a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
    // 0x131944: 0x4619a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[25]);
    // 0x131948: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x13194c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131950: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x131954: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x13195c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13195c
// Address: 0x13195c - 0x131984

void entry_13195c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13195c: 0x4616a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
    // 0x131960: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131964: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x131968: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13196c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131970: 0x4615a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x131974: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x131978: 0x44110000
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[0]);
    // 0x13197c: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x131984);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_131984
// Address: 0x131984 - 0x1319b0

void entry_131984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131984: 0x4618e002
    ctx->f[0] = FPU_MUL_S(ctx->f[28], ctx->f[24]);
    // 0x131988: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13198c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131990: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131994: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131998: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x13199c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1319a0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1319a4: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1319a8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1319b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1319b0
// Address: 0x1319b0 - 0x1319c8

void entry_1319b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1319b0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1319b4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1319b8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1319bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1319c0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1319c8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1319c8
// Address: 0x1319c8 - 0x131a30

void entry_1319c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1319c8: 0x2a42000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 11));
    // 0x1319cc: 0x1440ffd0
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x131910; return;
    }
    // 0x1319d4: 0x3c013ec9
    SET_GPR_U32(ctx, 1, ((uint32_t)16073 << 16));
    // 0x1319d8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1319dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1319e0: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1319e4: 0x3c13ff80
    SET_GPR_U32(ctx, 19, ((uint32_t)65408 << 16));
    // 0x1319e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1319ec: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1319f0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1319f4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1319f8: 0xc46c0468
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 1128)); ctx->f[12] = *(float*)&val; }
    // 0x1319fc: 0x24521128
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 4392));
    // 0x131a00: 0x3c013f49
    SET_GPR_U32(ctx, 1, ((uint32_t)16201 << 16));
    // 0x131a04: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x131a08: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x131a0c: 0x36738080
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 19), 32896));
    // 0x131a10: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x131a14: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x131a18: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x131a1c: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x131a20: 0x3c0140c0
    SET_GPR_U32(ctx, 1, ((uint32_t)16576 << 16));
    // 0x131a24: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x131a28: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x131a30);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_131a30
// Address: 0x131a30 - 0x131a60

void entry_131a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131a30: 0x46140043
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[20];
    // 0x131a34: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x131a38: 0xc7d71310
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4880)); ctx->f[23] = *(float*)&val; }
    // 0x131a3c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x131a40: 0x461bbdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[27]);
    // 0x131a44: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x131a48: 0x44160000
    SET_GPR_U32(ctx, 22, *(uint32_t*)&ctx->f[0]);
    // 0x131a4c: 0x26d00007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 22), 7));
    // 0x131a50: 0x26d10001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 22), 1));
    // 0x131a54: 0x32100007
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 7));
    // 0x131a58: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x131a60);
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), 7));
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_131a60
// Address: 0x131a60 - 0x131a78

void entry_131a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131a60: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x131a64: 0x8ea40310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 784)));
    // 0x131a68: 0x521021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x131a6c: 0x46140683
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[26] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[26] = ctx->f[0] / ctx->f[20];
    // 0x131a70: 0xc057106
    SET_GPR_U32(ctx, 31, 0x131a78);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_131a78
// Address: 0x131a78 - 0x131a94

void entry_131a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131a78: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x131a7c: 0x8ea40310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 784)));
    // 0x131a80: 0x2128021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 18)));
    // 0x131a84: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x131a88: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x131a8c: 0xc057106
    SET_GPR_U32(ctx, 31, 0x131a94);
    ctx->f[22] = FPU_MUL_S(ctx->f[26], ctx->f[23]);
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_131a94
// Address: 0x131a94 - 0x131aac

void entry_131a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131a94: 0x118880
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 2));
    // 0x131a98: 0x8ea40310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 784)));
    // 0x131a9c: 0x2328821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 18)));
    // 0x131aa0: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x131aa4: 0xc057106
    SET_GPR_U32(ctx, 31, 0x131aac);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_131aac
// Address: 0x131aac - 0x131afc

void entry_131aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131aac: 0x4600b801
    ctx->f[0] = FPU_SUB_S(ctx->f[23], ctx->f[0]);
    // 0x131ab0: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x131ab4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x131ab8: 0x4614bd01
    ctx->f[20] = FPU_SUB_S(ctx->f[23], ctx->f[20]);
    // 0x131abc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131ac0: 0x4615bd41
    ctx->f[21] = FPU_SUB_S(ctx->f[23], ctx->f[21]);
    // 0x131ac4: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x131ac8: 0x4618a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[24]);
    // 0x131acc: 0x4618ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[24]);
    // 0x131ad0: 0x4601be40
    ctx->f[25] = FPU_ADD_S(ctx->f[23], ctx->f[1]);
    // 0x131ad4: 0x4600b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[0]);
    // 0x131ad8: 0x4614b501
    ctx->f[20] = FPU_SUB_S(ctx->f[22], ctx->f[20]);
    // 0x131adc: 0x46170dc1
    ctx->f[23] = FPU_SUB_S(ctx->f[1], ctx->f[23]);
    // 0x131ae0: 0x4615b581
    ctx->f[22] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    // 0x131ae4: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x131ae8: 0x4600ce41
    ctx->f[25] = FPU_SUB_S(ctx->f[25], ctx->f[0]);
    // 0x131aec: 0x46140d01
    ctx->f[20] = FPU_SUB_S(ctx->f[1], ctx->f[20]);
    // 0x131af0: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x131af4: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x131afc);
    ctx->f[23] = FPU_SUB_S(ctx->f[23], ctx->f[22]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_131afc
// Address: 0x131afc - 0x131b18

void entry_131afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131afc: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x131b00: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x131b04: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x131b08: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x131b0c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x131b10: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x131b18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_131b18
// Address: 0x131b18 - 0x131b28

void entry_131b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131b18: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131b1c: 0xafb30020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 19));
    // 0x131b20: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x131b28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_131b28
// Address: 0x131b28 - 0x131b34

void entry_131b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131b28: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131b2c: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x131b34);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_131b34
// Address: 0x131b34 - 0x131b40

void entry_131b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131b34: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131b38: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x131b40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_131b40
// Address: 0x131b40 - 0x131ba4

void entry_131b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131b40: 0x8ea40310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 784)));
    // 0x131b44: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x131b48: 0xc7c11310
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4880)); ctx->f[1] = *(float*)&val; }
    // 0x131b4c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131b50: 0xc4800008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[0] = *(float*)&val; }
    // 0x131b54: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x131b58: 0xc4820048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 72)); ctx->f[2] = *(float*)&val; }
    // 0x131b5c: 0xe7a10008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x131b60: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131b64: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131b68: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x131b6c: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x131b70: 0xe7a0000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 12), *(uint32_t*)&val); }
    // 0x131b74: 0x244b10d8
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 2), 4312));
    // 0x131b78: 0x89630003
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x131b7c: 0x99630000
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x131b80: 0xaba30023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131b84: 0xbba30020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131b88: 0x8ba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x131b8c: 0x9ba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x131b90: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131b94: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131b98: 0xe7b70000
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x131b9c: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x131ba4);
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_131ba4
// Address: 0x131ba4 - 0x131bc4

void entry_131ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131ba4: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x131ba8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131bac: 0x8ea40310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 784)));
    // 0x131bb0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131bb4: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131bb8: 0xe7b90000
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x131bbc: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x131bc4);
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_131bc4
// Address: 0x131bc4 - 0x131ed4

void entry_131bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x131bc4) {
        switch (ctx->pc) {
            case 0x131c6c: ctx->pc = 0; goto label_131c6c;
            case 0x131cac: ctx->pc = 0; goto label_131cac;
            case 0x131cc4: ctx->pc = 0; goto label_131cc4;
            case 0x131d08: ctx->pc = 0; goto label_131d08;
            case 0x131d48: ctx->pc = 0; goto label_131d48;
            case 0x131d60: ctx->pc = 0; goto label_131d60;
            case 0x131da4: ctx->pc = 0; goto label_131da4;
            case 0x131de4: ctx->pc = 0; goto label_131de4;
            case 0x131dfc: ctx->pc = 0; goto label_131dfc;
            case 0x131e40: ctx->pc = 0; goto label_131e40;
            case 0x131e80: ctx->pc = 0; goto label_131e80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x131bc4: 0x3c01c080
    SET_GPR_U32(ctx, 1, ((uint32_t)49280 << 16));
    // 0x131bc8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x131bcc: 0x70005ca9
    SET_GPR_VEC(ctx, 11, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x131bd0: 0x7fab0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 11));
    // 0x131bd4: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x131bd8: 0x4601d002
    ctx->f[0] = FPU_MUL_S(ctx->f[26], ctx->f[1]);
    // 0x131bdc: 0xe7bb0024
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x131be0: 0xc7a20020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[2] = *(float*)&val; }
    // 0x131be4: 0x24040084
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 132));
    // 0x131be8: 0xe7a10028
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    // 0x131bec: 0x24050032
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 50));
    // 0x131bf0: 0x461b0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[27]);
    // 0x131bf4: 0x24ca10d8
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 6), 4312));
    // 0x131bf8: 0x89470003
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x131bfc: 0x99470000
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x131c00: 0xaba70043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131c04: 0xbba70040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131c08: 0xa3a40051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 4));
    // 0x131c0c: 0x240300b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 176));
    // 0x131c10: 0x24020080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 128));
    // 0x131c14: 0x93a40040
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x131c18: 0x4600d682
    ctx->f[26] = FPU_MUL_S(ctx->f[26], ctx->f[0]);
    // 0x131c1c: 0xa3a30052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 3));
    // 0x131c20: 0xa3a20053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 2));
    // 0x131c24: 0xa3a50050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 5));
    // 0x131c28: 0x461a1100
    ctx->f[4] = FPU_ADD_S(ctx->f[2], ctx->f[26]);
    // 0x131c2c: 0x1085001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 50));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 5)) {
        goto label_131cac;
    }
    // 0x131c34: 0x28820032
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 50));
    // 0x131c38: 0x1040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_131c6c;
    }
    // 0x131c40: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x131c44: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x131c48: 0x3c01424b
    SET_GPR_U32(ctx, 1, ((uint32_t)16971 << 16));
    // 0x131c4c: 0x3421fefa
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 65274));
    // 0x131c50: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x131c54: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x131c58: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x131c5c: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x131c60: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x131c64: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_131cac;
    }
label_131c6c:
    // 0x131c6c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x131c70: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x131c74: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x131c78: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x131c7c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x131c80: 0x44851800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 5);
    // 0x131c84: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x131c88: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x131c8c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x131c90: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x131c94: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x131c98: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x131c9c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x131ca0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131ca4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x131ca8: 0x24420032
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 50));
label_131cac:
    // 0x131cac: 0x93a40041
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 65)));
    // 0x131cb0: 0x93a30051
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 81)));
    // 0x131cb4: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 96), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_131cc4;
    }
    // 0x131cbc: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_131d48;
    }
label_131cc4:
    // 0x131cc4: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x131cc8: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_131d08;
    }
    // 0x131cd0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x131cd4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x131cd8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x131cdc: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x131ce0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x131ce4: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x131ce8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x131cec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x131cf0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x131cf4: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x131cf8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131cfc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x131d00: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_131d48;
    }
label_131d08:
    // 0x131d08: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x131d0c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x131d10: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x131d14: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x131d18: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x131d1c: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x131d20: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x131d24: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x131d28: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x131d2c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x131d30: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x131d34: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x131d38: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x131d3c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131d40: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x131d44: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_131d48:
    // 0x131d48: 0x93a40042
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 66)));
    // 0x131d4c: 0x93a30052
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 82)));
    // 0x131d50: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 97), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_131d60;
    }
    // 0x131d58: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_131de4;
    }
label_131d60:
    // 0x131d60: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x131d64: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_131da4;
    }
    // 0x131d6c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x131d70: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x131d74: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x131d78: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x131d7c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x131d80: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x131d84: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x131d88: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x131d8c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x131d90: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x131d94: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131d98: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x131d9c: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_131de4;
    }
label_131da4:
    // 0x131da4: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x131da8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x131dac: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x131db0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x131db4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x131db8: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x131dbc: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x131dc0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x131dc4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x131dc8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x131dcc: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x131dd0: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x131dd4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x131dd8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131ddc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x131de0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_131de4:
    // 0x131de4: 0x93a40043
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x131de8: 0x93a30053
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 83)));
    // 0x131dec: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 98), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_131dfc;
    }
    // 0x131df4: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_131e80;
    }
label_131dfc:
    // 0x131dfc: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x131e00: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_131e40;
    }
    // 0x131e08: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x131e0c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x131e10: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x131e14: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x131e18: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x131e1c: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x131e20: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x131e24: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x131e28: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x131e2c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x131e30: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131e34: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x131e38: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_131e80;
    }
label_131e40:
    // 0x131e40: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x131e44: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x131e48: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x131e4c: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x131e50: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x131e54: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x131e58: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x131e5c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x131e60: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x131e64: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x131e68: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x131e6c: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x131e70: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x131e74: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x131e78: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x131e7c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_131e80:
    // 0x131e80: 0xa3a20063
    WRITE8(ADD32(GPR_U32(ctx, 29), 99), (uint8_t)GPR_U32(ctx, 2));
    // 0x131e84: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x131e88: 0x8ba40063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x131e8c: 0x9ba40060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x131e90: 0xaba40033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131e94: 0xbba40030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131e98: 0x24431128
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4392));
    // 0x131e9c: 0x8ea40310
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 784)));
    // 0x131ea0: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x131ea4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x131ea8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x131eac: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131eb0: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x131eb4: 0x8ba80033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x131eb8: 0x9ba80030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x131ebc: 0xaba80013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131ec0: 0xbba80010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x131ec4: 0xe7b40000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x131ec8: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131ecc: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x131ed4);
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_131ed4
// Address: 0x131ed4 - 0x131ee8

void entry_131ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131ed4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131ed8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x131edc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x131ee0: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x131ee8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_131ee8
// Address: 0x131ee8 - 0x131f04

void entry_131ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131ee8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x131eec: 0x3c0600df
    SET_GPR_U32(ctx, 6, ((uint32_t)223 << 16));
    // 0x131ef0: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x131ef4: 0x34c6027f
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 639));
    // 0x131ef8: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x131efc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x131f04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_131f04
// Address: 0x131f04 - 0x131f60

void entry_131f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131f04: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x131f08: 0x7bbe00f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x131f0c: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x131f10: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x131f14: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x131f18: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x131f1c: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x131f20: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x131f24: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x131f28: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x131f2c: 0xc7bd0158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[29] = *(float*)&val; }
    // 0x131f30: 0xc7bc0150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[28] = *(float*)&val; }
    // 0x131f34: 0xc7bb0148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[27] = *(float*)&val; }
    // 0x131f38: 0xc7ba0140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[26] = *(float*)&val; }
    // 0x131f3c: 0xc7b90138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[25] = *(float*)&val; }
    // 0x131f40: 0xc7b80130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[24] = *(float*)&val; }
    // 0x131f44: 0xc7b70128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[23] = *(float*)&val; }
    // 0x131f48: 0xc7b60120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[22] = *(float*)&val; }
    // 0x131f4c: 0xc7b50118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[21] = *(float*)&val; }
    // 0x131f50: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x131f54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x131f5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x131f60; return;
}


// Function: DrawBinocZoom
// Address: 0x131f60 - 0x131fe8

void entry_131fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x131fe8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x131fec: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x131ff0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x131ff4: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x131ff8: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x131ffc: 0x3c014110
    SET_GPR_U32(ctx, 1, ((uint32_t)16656 << 16));
    // 0x132000: 0x4481f800
    *(uint32_t*)&ctx->f[31] = GPR_U32(ctx, 1);
    // 0x132004: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x13200c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_13200c
// Address: 0x13200c - 0x13202c

void entry_13200c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13200c: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x132010: 0x4481f000
    *(uint32_t*)&ctx->f[30] = GPR_U32(ctx, 1);
    // 0x132014: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132018: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x13201c: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x132020: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x132024: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x13202c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_13202c
// Address: 0x13202c - 0x132054

void entry_13202c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13202c: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x132030: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x132034: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132038: 0x24050084
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 132));
    // 0x13203c: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x132040: 0x34e74441
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17473));
    // 0x132044: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x132048: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x13204c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x132054);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_132054
// Address: 0x132054 - 0x132118

void entry_132054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x132054) {
        switch (ctx->pc) {
            case 0x132068: ctx->pc = 0; goto label_132068;
            case 0x1320f8: ctx->pc = 0; goto label_1320f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x132054: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x132058: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x13205c: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x132060: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x132064: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
label_132068:
    // 0x132068: 0x44920000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 18);
    // 0x13206c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132070: 0x3c013de3
    SET_GPR_U32(ctx, 1, ((uint32_t)15843 << 16));
    // 0x132074: 0x34218e39
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 36409));
    // 0x132078: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13207c: 0x3c013d88
    SET_GPR_U32(ctx, 1, ((uint32_t)15752 << 16));
    // 0x132080: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x132084: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132088: 0x3c01425c
    SET_GPR_U32(ctx, 1, ((uint32_t)16988 << 16));
    // 0x13208c: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x132090: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132094: 0x8ea21990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 6544)));
    // 0x132098: 0xc4450478
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1144)); ctx->f[5] = *(float*)&val; }
    // 0x13209c: 0x460200c0
    ctx->f[3] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1320a0: 0x4600d881
    ctx->f[2] = FPU_SUB_S(ctx->f[27], ctx->f[0]);
    // 0x1320a4: 0x461e0102
    ctx->f[4] = FPU_MUL_S(ctx->f[0], ctx->f[30]);
    // 0x1320a8: 0x4603d841
    ctx->f[1] = FPU_SUB_S(ctx->f[27], ctx->f[3]);
    // 0x1320ac: 0x46061082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[6]);
    // 0x1320b0: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x1320b4: 0x46060842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[6]);
    // 0x1320b8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1320bc: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x1320c0: 0x461f1541
    ctx->f[21] = FPU_SUB_S(ctx->f[2], ctx->f[31]);
    // 0x1320c4: 0x461e18c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[30]);
    // 0x1320c8: 0x3c0143ba
    SET_GPR_U32(ctx, 1, ((uint32_t)17338 << 16));
    // 0x1320cc: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1320d0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1320d4: 0x46060002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[6]);
    // 0x1320d8: 0x461b0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[27]);
    // 0x1320dc: 0x46041501
    ctx->f[20] = FPU_SUB_S(ctx->f[2], ctx->f[4]);
    // 0x1320e0: 0x46050036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1320e4: 0x461f0d81
    ctx->f[22] = FPU_SUB_S(ctx->f[1], ctx->f[31]);
    // 0x1320e8: 0x46031601
    ctx->f[24] = FPU_SUB_S(ctx->f[2], ctx->f[3]);
    // 0x1320ec: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4312));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1320f8;
    }
    // 0x1320f4: 0x266210e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 4320));
label_1320f8:
    // 0x1320f8: 0x88430003
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1320fc: 0x98430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x132100: 0xaba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132104: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x132108: 0xbba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x13210c: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x132110: 0xc058516
    SET_GPR_U32(ctx, 31, 0x132118);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_132118
// Address: 0x132118 - 0x132154

void entry_132118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132118: 0x461da042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[29]);
    // 0x13211c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132120: 0x4615d001
    ctx->f[0] = FPU_SUB_S(ctx->f[26], ctx->f[21]);
    // 0x132124: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132128: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13212c: 0x461c0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[28]);
    // 0x132130: 0x46190000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[25]);
    // 0x132134: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x132138: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x13213c: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x132140: 0x44101000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[2]);
    // 0x132144: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132148: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x13214c: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x132154);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_132154
// Address: 0x132154 - 0x13217c

void entry_132154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132154: 0x461aa800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[26]);
    // 0x132158: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13215c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132160: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132164: 0x46190000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[25]);
    // 0x132168: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x13216c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132170: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x132174: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x13217c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13217c
// Address: 0x13217c - 0x1321b8

void entry_13217c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13217c: 0x461dc042
    ctx->f[1] = FPU_MUL_S(ctx->f[24], ctx->f[29]);
    // 0x132180: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132184: 0x4616d001
    ctx->f[0] = FPU_SUB_S(ctx->f[26], ctx->f[22]);
    // 0x132188: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13218c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132190: 0x461c0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[28]);
    // 0x132194: 0x46190000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[25]);
    // 0x132198: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x13219c: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1321a0: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1321a4: 0x44101000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[2]);
    // 0x1321a8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1321ac: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1321b0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1321b8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1321b8
// Address: 0x1321b8 - 0x1321e0

void entry_1321b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1321b8: 0x461ab000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[26]);
    // 0x1321bc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1321c0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1321c4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1321c8: 0x46190000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[25]);
    // 0x1321cc: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1321d0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1321d4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1321d8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1321e0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1321e0
// Address: 0x1321e0 - 0x132220

void entry_1321e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1321e0: 0x2a420008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 8));
    // 0x1321e4: 0x1440ffa0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x132068; return;
    }
    // 0x1321ec: 0x8ee30260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 608)));
    // 0x1321f0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1321f4: 0x146200aa
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1324A0; return;
    }
    // 0x1321fc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x132200: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x132204: 0x3c10ff80
    SET_GPR_U32(ctx, 16, ((uint32_t)65408 << 16));
    // 0x132208: 0x3c0143c3
    SET_GPR_U32(ctx, 1, ((uint32_t)17347 << 16));
    // 0x13220c: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x132210: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x132214: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x132218: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x132220);
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 32896));
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_132220
// Address: 0x132220 - 0x13223c

void entry_132220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132220: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x132224: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x132228: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x13222c: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x132230: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x132234: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x13223c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_13223c
// Address: 0x13223c - 0x13224c

void entry_13223c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13223c: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x132240: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x132244: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x13224c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_13224c
// Address: 0x13224c - 0x132258

void entry_13224c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13224c: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x132250: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x132258);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_132258
// Address: 0x132258 - 0x132264

void entry_132258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132258: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x13225c: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x132264);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_132264
// Address: 0x132264 - 0x132294

void entry_132264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x132264) {
        switch (ctx->pc) {
            case 0x132280: ctx->pc = 0; goto label_132280;
            case 0x132288: ctx->pc = 0; goto label_132288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x132264: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x132268: 0x8c622c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11368)));
    // 0x13226c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x132270: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132280;
    }
    // 0x132278: 0x10000003
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 2), 11376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132288;
    }
label_132280:
    // 0x132280: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x132284: 0x24552d38
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 2), 11576));
label_132288:
    // 0x132288: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13228c: 0xc057070
    SET_GPR_U32(ctx, 31, 0x132294);
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_132294
// Address: 0x132294 - 0x1322a4

void entry_132294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132294: 0x200f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x132298: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13229c: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1322a4);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1322a4
// Address: 0x1322a4 - 0x1322bc

void entry_1322a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1322a4: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1322a8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1322ac: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1322b0: 0x26059ce0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4294941920));
    // 0x1322b4: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1322bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 40));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1322bc
// Address: 0x1322bc - 0x132318

void entry_1322bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1322bc) {
        switch (ctx->pc) {
            case 0x13230c: ctx->pc = 0; goto label_13230c;
            case 0x132310: ctx->pc = 0; goto label_132310;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1322bc: 0x27a30020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1322c0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1322c4: 0xac620018
    WRITE32(ADD32(GPR_U32(ctx, 3), 24), GPR_U32(ctx, 2));
    // 0x1322c8: 0x60b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1322cc: 0xac620014
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 2));
    // 0x1322d0: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x1322d4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1322d8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1322dc: 0x8ee4025c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 604)));
    // 0x1322e0: 0xafa00028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 0));
    // 0x1322e4: 0x10800009
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_13230c;
    }
    // 0x1322ec: 0xc6a10048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1322f0: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1322f4: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1322f8: 0x0
    // NOP
    // 0x1322fc: 0x45010004
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_132310;
    }
    // 0x132304: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x132308: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
label_13230c:
    // 0x13230c: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
label_132310:
    // 0x132310: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x132318);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_132318
// Address: 0x132318 - 0x132344

void entry_132318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132318: 0x3c014384
    SET_GPR_U32(ctx, 1, ((uint32_t)17284 << 16));
    // 0x13231c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x132320: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132324: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x132328: 0xe7b40024
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x13232c: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x132330: 0xe7a00020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x132334: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132338: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13233c: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x132344);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_132344
// Address: 0x132344 - 0x13234c

void entry_132344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132344: 0xc057240
    SET_GPR_U32(ctx, 31, 0x13234c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_13234c
// Address: 0x13234c - 0x13235c

void entry_13234c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13234c: 0x27c59ce0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 4294941920));
    // 0x132350: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x132354: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x13235c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 41));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_13235c
// Address: 0x13235c - 0x13239c

void entry_13235c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13235c) {
        switch (ctx->pc) {
            case 0x132394: ctx->pc = 0; goto label_132394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13235c: 0x8ee3025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 604)));
    // 0x132360: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x132364: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x132368: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13236c: 0x10600009
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_132394;
    }
    // 0x132374: 0xc6a1007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 124)); ctx->f[1] = *(float*)&val; }
    // 0x132378: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x13237c: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x132380: 0x45010004
    if ((ctx->fcr31 & 0x800000)) {
        goto label_132394;
    }
    // 0x132388: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x13238c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x132390: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
label_132394:
    // 0x132394: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x13239c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_13239c
// Address: 0x13239c - 0x1323cc

void entry_13239c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13239c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1323a0: 0x3c0143bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17339 << 16));
    // 0x1323a4: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1323a8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1323ac: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1323b0: 0xe7b40024
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x1323b4: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1323b8: 0xe7a00020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x1323bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1323c0: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1323c4: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1323cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1323cc
// Address: 0x1323cc - 0x1323d4

void entry_1323cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1323cc: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1323d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1323d4
// Address: 0x1323d4 - 0x13241c

void entry_1323d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1323d4: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1323d8: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1323dc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1323e0: 0x24020032
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 50));
    // 0x1323e4: 0x24030084
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 132));
    // 0x1323e8: 0x24050080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1323ec: 0x240400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 176));
    // 0x1323f0: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1323f4: 0xa3a30001
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 3));
    // 0x1323f8: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1323fc: 0xa3a40002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 4));
    // 0x132400: 0xa3a50003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 5));
    // 0x132404: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x132408: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x13240c: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132410: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132414: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x13241c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_13241c
// Address: 0x13241c - 0x13245c

void entry_13241c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13241c: 0x8e031090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4240)));
    // 0x132420: 0x24020140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 320));
    // 0x132424: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x132428: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x13242c: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x132430: 0xaec40014
    WRITE32(ADD32(GPR_U32(ctx, 22), 20), GPR_U32(ctx, 4));
    // 0x132434: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x132438: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x13243c: 0x24a59ce8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294941928));
    // 0x132440: 0xe7b40024
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x132444: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x132448: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x13244c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132450: 0xe7a00020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x132454: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x13245c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_13245c
// Address: 0x13245c - 0x132494

void entry_13245c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13245c: 0x8e021090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4240)));
    // 0x132460: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x132464: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x132468: 0xe7b40024
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x13246c: 0x24420140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 320));
    // 0x132470: 0x24a59cf0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294941936));
    // 0x132474: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x132478: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x13247c: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x132480: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132484: 0xafa00034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 0));
    // 0x132488: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13248c: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x132494);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_132494
// Address: 0x132494 - 0x13249c

void entry_132494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132494: 0xc057240
    SET_GPR_U32(ctx, 31, 0x13249c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_13249c
// Address: 0x13249c - 0x132500

void entry_13249c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13249c) {
        switch (ctx->pc) {
            case 0x1324a0: ctx->pc = 0; goto label_1324a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13249c: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1324a0:
    // 0x1324a0: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1324a4: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1324a8: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1324ac: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1324b0: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1324b4: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1324b8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1324bc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1324c0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1324c4: 0xc7bf0148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[31] = *(float*)&val; }
    // 0x1324c8: 0xc7be0140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[30] = *(float*)&val; }
    // 0x1324cc: 0xc7bd0138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[29] = *(float*)&val; }
    // 0x1324d0: 0xc7bc0130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[28] = *(float*)&val; }
    // 0x1324d4: 0xc7bb0128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[27] = *(float*)&val; }
    // 0x1324d8: 0xc7ba0120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[26] = *(float*)&val; }
    // 0x1324dc: 0xc7b90118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[25] = *(float*)&val; }
    // 0x1324e0: 0xc7b80110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[24] = *(float*)&val; }
    // 0x1324e4: 0xc7b70108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[23] = *(float*)&val; }
    // 0x1324e8: 0xc7b60100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[22] = *(float*)&val; }
    // 0x1324ec: 0xc7b500f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[21] = *(float*)&val; }
    // 0x1324f0: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1324f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1324fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x132500; return;
}


// Function: DrawBinocReticle
// Address: 0x132500 - 0x132568

void entry_132568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132568: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13256c: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x132570: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x132574: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x13257c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_13257c
// Address: 0x13257c - 0x13258c

void entry_13257c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13257c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132580: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x132584: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x13258c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_13258c
// Address: 0x13258c - 0x1325ac

void entry_13258c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13258c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132590: 0x3c0600a9
    SET_GPR_U32(ctx, 6, ((uint32_t)169 << 16));
    // 0x132594: 0x34c60003
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 3));
    // 0x132598: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x13259c: 0x34c6027f
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 639));
    // 0x1325a0: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1325a4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1325ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1325ac
// Address: 0x1325ac - 0x13262c

void entry_1325ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1325ac) {
        switch (ctx->pc) {
            case 0x1325c8: ctx->pc = 0; goto label_1325c8;
            case 0x1325d0: ctx->pc = 0; goto label_1325d0;
            case 0x132600: ctx->pc = 0; goto label_132600;
            case 0x13261c: ctx->pc = 0; goto label_13261c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1325ac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1325b0: 0x8c622c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11368)));
    // 0x1325b4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1325b8: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1325c8;
    }
    // 0x1325c0: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 11376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1325d0;
    }
label_1325c8:
    // 0x1325c8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1325cc: 0x24422d38
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 11576));
label_1325d0:
    // 0x1325d0: 0xc4400078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 120)); ctx->f[0] = *(float*)&val; }
    // 0x1325d4: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1325d8: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1325dc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1325e0: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1325e4: 0x0
    // NOP
    // 0x1325e8: 0x45000005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_132600;
    }
    // 0x1325f0: 0x3c0140c0
    SET_GPR_U32(ctx, 1, ((uint32_t)16576 << 16));
    // 0x1325f4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1325f8: 0x10000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 780)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13261c;
    }
label_132600:
    // 0x132600: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x132604: 0x0
    // NOP
    // 0x132608: 0x45000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 780)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13261c;
    }
    // 0x132610: 0x3c01c0c0
    SET_GPR_U32(ctx, 1, ((uint32_t)49344 << 16));
    // 0x132614: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132618: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_13261c:
    // 0x13261c: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x132620: 0x46016302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x132624: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x13262c);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_13262c
// Address: 0x13262c - 0x1327f8

void entry_13262c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13262c) {
        switch (ctx->pc) {
            case 0x132688: ctx->pc = 0; goto label_132688;
            case 0x132698: ctx->pc = 0; goto label_132698;
            case 0x1326f4: ctx->pc = 0; goto label_1326f4;
            case 0x13273c: ctx->pc = 0; goto label_13273c;
            case 0x132788: ctx->pc = 0; goto label_132788;
            case 0x1327d0: ctx->pc = 0; goto label_1327d0;
            case 0x1327e8: ctx->pc = 0; goto label_1327e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13262c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x132630: 0xe660030c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 780), *(uint32_t*)&val); }
    // 0x132634: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x132638: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13263c: 0x3c0141c7
    SET_GPR_U32(ctx, 1, ((uint32_t)16839 << 16));
    // 0x132640: 0x3421fdf4
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 65012));
    // 0x132644: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132648: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13264c: 0xc4600478
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 1144)); ctx->f[0] = *(float*)&val; }
    // 0x132650: 0x8e660320
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 800)));
    // 0x132654: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132658: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x13265c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132660: 0x24420030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 48));
    // 0x132664: 0x10c40035
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 2), 255));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 4)) {
        goto label_13273c;
    }
    // 0x13266c: 0x28c20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 2));
    // 0x132670: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132688;
    }
    // 0x132678: 0x10c00007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_132698;
    }
    // 0x132680: 0x10000059
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1327e8;
    }
label_132688:
    // 0x132688: 0x10c2003f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_132788;
    }
    // 0x132690: 0x10000055
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1327e8;
    }
label_132698:
    // 0x132698: 0x8e630260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    // 0x13269c: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1326a0: 0x14620014
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1326f4;
    }
    // 0x1326a8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1326ac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1326b0: 0x24481110
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4368));
    // 0x1326b4: 0x89040003
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x1326b8: 0x99040000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x1326bc: 0xaba40023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1326c0: 0xbba40020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1326c4: 0xa3a50023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
    // 0x1326c8: 0x8ba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1326cc: 0x9ba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1326d0: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1326d4: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1326d8: 0x24661108
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4360));
    // 0x1326dc: 0x88c80003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x1326e0: 0x98c80000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x1326e4: 0xaba80023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1326e8: 0xbba80020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1326ec: 0x10000038
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1327d0;
    }
label_1326f4:
    // 0x1326f4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1326f8: 0x244810e0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4320));
    // 0x1326fc: 0x89040003
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x132700: 0x99040000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x132704: 0xaba40023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132708: 0xbba40020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x13270c: 0xa3a50023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
    // 0x132710: 0x8ba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x132714: 0x9ba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x132718: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x13271c: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132720: 0x246610d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4312));
    // 0x132724: 0x88c80003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x132728: 0x98c80000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x13272c: 0xaba80023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132730: 0xbba80020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132734: 0x10000026
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1327d0;
    }
label_13273c:
    // 0x13273c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x132740: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x132744: 0x24481100
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4352));
    // 0x132748: 0x89040003
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x13274c: 0x99040000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x132750: 0xaba40023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132754: 0xbba40020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132758: 0xa3a50023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
    // 0x13275c: 0x8ba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x132760: 0x9ba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x132764: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132768: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x13276c: 0x246610f8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4344));
    // 0x132770: 0x88c80003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x132774: 0x98c80000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x132778: 0xaba80023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x13277c: 0xbba80020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132780: 0x10000013
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1327d0;
    }
label_132788:
    // 0x132788: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13278c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x132790: 0x244810f0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4336));
    // 0x132794: 0x89040003
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x132798: 0x99040000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x13279c: 0xaba40023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327a0: 0xbba40020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327a4: 0xa3a50023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
    // 0x1327a8: 0x8ba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1327ac: 0x9ba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1327b0: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327b4: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327b8: 0x246610e8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4328));
    // 0x1327bc: 0x88c80003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x1327c0: 0x98c80000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x1327c4: 0xaba80023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327c8: 0xbba80020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327cc: 0xa3a50023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 5));
label_1327d0:
    // 0x1327d0: 0x8ba70023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x1327d4: 0x9ba70020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x1327d8: 0xaba70013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327dc: 0xbba70010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1327e0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1327e4: 0x27a500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
label_1327e8:
    // 0x1327e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1327ec: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1327f0: 0xc04dbb2
    SET_GPR_U32(ctx, 31, 0x1327f8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 212));
    GetBinocReticleFocus__FP5BINOCPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1327f8
// Address: 0x1327f8 - 0x13281c

void entry_1327f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1327f8: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1327fc: 0xc660030c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 780)); ctx->f[0] = *(float*)&val; }
    // 0x132800: 0x3c01be49
    SET_GPR_U32(ctx, 1, ((uint32_t)48713 << 16));
    // 0x132804: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x132808: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13280c: 0xc4410478
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1144)); ctx->f[1] = *(float*)&val; }
    // 0x132810: 0x460c0300
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    // 0x132814: 0xc081484
    SET_GPR_U32(ctx, 31, 0x13281c);
    ctx->f[25] = FPU_ADD_S(ctx->f[1], ctx->f[20]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_13281c
// Address: 0x13281c - 0x132af4

void entry_13281c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13281c) {
        switch (ctx->pc) {
            case 0x132860: ctx->pc = 0; goto label_132860;
            case 0x1328a4: ctx->pc = 0; goto label_1328a4;
            case 0x1328d8: ctx->pc = 0; goto label_1328d8;
            case 0x1328f0: ctx->pc = 0; goto label_1328f0;
            case 0x132934: ctx->pc = 0; goto label_132934;
            case 0x132974: ctx->pc = 0; goto label_132974;
            case 0x13298c: ctx->pc = 0; goto label_13298c;
            case 0x1329d0: ctx->pc = 0; goto label_1329d0;
            case 0x132a10: ctx->pc = 0; goto label_132a10;
            case 0x132a28: ctx->pc = 0; goto label_132a28;
            case 0x132a6c: ctx->pc = 0; goto label_132a6c;
            case 0x132aac: ctx->pc = 0; goto label_132aac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13281c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x132820: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132824: 0x8ba40003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x132828: 0x9ba40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x13282c: 0xaba40033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132830: 0xbba40030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132834: 0x8ba80013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x132838: 0x9ba80010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x13283c: 0xaba80043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132840: 0xbba80040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132844: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132848: 0x93a40030
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13284c: 0x93a30040
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x132850: 0x14830003
    ctx->f[4] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_132860;
    }
    // 0x132858: 0x1000001f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1328d8;
    }
label_132860:
    // 0x132860: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x132864: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[20], ctx->f[4]);
        goto label_1328a4;
    }
    // 0x13286c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x132870: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132874: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132878: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x13287c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132880: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x132884: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x132888: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x13288c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x132890: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x132894: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132898: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13289c: 0x1000000e
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1328d8;
    }
label_1328a4:
    // 0x1328a4: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1328a8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1328ac: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1328b0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1328b4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1328b8: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1328bc: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1328c0: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1328c4: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1328c8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1328cc: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1328d0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1328d4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1328d8:
    // 0x1328d8: 0x93a40031
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 49)));
    // 0x1328dc: 0x93a30041
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 65)));
    // 0x1328e0: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1328f0;
    }
    // 0x1328e8: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132974;
    }
label_1328f0:
    // 0x1328f0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1328f4: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132934;
    }
    // 0x1328fc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x132900: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132904: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132908: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x13290c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132910: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x132914: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x132918: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x13291c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x132920: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x132924: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132928: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13292c: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132974;
    }
label_132934:
    // 0x132934: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x132938: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x13293c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132940: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132944: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132948: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x13294c: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x132950: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x132954: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132958: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x13295c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x132960: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x132964: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132968: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x13296c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132970: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_132974:
    // 0x132974: 0x93a40032
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 50)));
    // 0x132978: 0x93a30042
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 66)));
    // 0x13297c: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_13298c;
    }
    // 0x132984: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132a10;
    }
label_13298c:
    // 0x13298c: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x132990: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1329d0;
    }
    // 0x132998: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x13299c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1329a0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1329a4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1329a8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1329ac: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1329b0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1329b4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1329b8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1329bc: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1329c0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1329c4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1329c8: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132a10;
    }
label_1329d0:
    // 0x1329d0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1329d4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1329d8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1329dc: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1329e0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1329e4: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1329e8: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1329ec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1329f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1329f4: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1329f8: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1329fc: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x132a00: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132a04: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132a08: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132a0c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_132a10:
    // 0x132a10: 0x93a40033
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 51)));
    // 0x132a14: 0x93a30043
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x132a18: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_132a28;
    }
    // 0x132a20: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132aac;
    }
label_132a28:
    // 0x132a28: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x132a2c: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132a6c;
    }
    // 0x132a34: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x132a38: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132a3c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132a40: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132a44: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132a48: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x132a4c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x132a50: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x132a54: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x132a58: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x132a5c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132a60: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132a64: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132aac;
    }
label_132a6c:
    // 0x132a6c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x132a70: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x132a74: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132a78: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132a7c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132a80: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x132a84: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x132a88: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x132a8c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132a90: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x132a94: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x132a98: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x132a9c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132aa0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132aa4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132aa8: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_132aac:
    // 0x132aac: 0x3c014380
    SET_GPR_U32(ctx, 1, ((uint32_t)17280 << 16));
    // 0x132ab0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132ab4: 0x3c01c190
    SET_GPR_U32(ctx, 1, ((uint32_t)49552 << 16));
    // 0x132ab8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x132abc: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x132ac0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x132ac4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132ac8: 0x46026303
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[2];
    // 0x132acc: 0xc660030c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 780)); ctx->f[0] = *(float*)&val; }
    // 0x132ad0: 0xa3a20053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 2));
    // 0x132ad4: 0x8ba20053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x132ad8: 0x9ba20050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x132adc: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132ae0: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132ae4: 0x460c6300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[12]);
    // 0x132ae8: 0x46016302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x132aec: 0xc081484
    SET_GPR_U32(ctx, 31, 0x132af4);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_132af4
// Address: 0x132af4 - 0x132e28

void entry_132af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x132af4) {
        switch (ctx->pc) {
            case 0x132b38: ctx->pc = 0; goto label_132b38;
            case 0x132b7c: ctx->pc = 0; goto label_132b7c;
            case 0x132bbc: ctx->pc = 0; goto label_132bbc;
            case 0x132bd4: ctx->pc = 0; goto label_132bd4;
            case 0x132c18: ctx->pc = 0; goto label_132c18;
            case 0x132c58: ctx->pc = 0; goto label_132c58;
            case 0x132c70: ctx->pc = 0; goto label_132c70;
            case 0x132cb4: ctx->pc = 0; goto label_132cb4;
            case 0x132cf4: ctx->pc = 0; goto label_132cf4;
            case 0x132d0c: ctx->pc = 0; goto label_132d0c;
            case 0x132d50: ctx->pc = 0; goto label_132d50;
            case 0x132d90: ctx->pc = 0; goto label_132d90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x132af4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x132af8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132afc: 0x8ba60003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x132b00: 0x9ba60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x132b04: 0xaba60063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132b08: 0xbba60060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132b0c: 0x8ba30013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x132b10: 0x9ba30010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x132b14: 0xaba30073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132b18: 0xbba30070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132b1c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132b20: 0x93a40060
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x132b24: 0x93a30070
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x132b28: 0x14830003
    ctx->f[4] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_132b38;
    }
    // 0x132b30: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132bbc;
    }
label_132b38:
    // 0x132b38: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x132b3c: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132b7c;
    }
    // 0x132b44: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x132b48: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132b4c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132b50: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132b54: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132b58: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x132b5c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x132b60: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x132b64: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x132b68: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x132b6c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132b70: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132b74: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132bbc;
    }
label_132b7c:
    // 0x132b7c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x132b80: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x132b84: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132b88: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132b8c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132b90: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x132b94: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x132b98: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x132b9c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132ba0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x132ba4: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x132ba8: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x132bac: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132bb0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132bb4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132bb8: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_132bbc:
    // 0x132bbc: 0x93a40061
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 97)));
    // 0x132bc0: 0x93a30071
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 113)));
    // 0x132bc4: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 128), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_132bd4;
    }
    // 0x132bcc: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132c58;
    }
label_132bd4:
    // 0x132bd4: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x132bd8: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132c18;
    }
    // 0x132be0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x132be4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132be8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132bec: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132bf0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132bf4: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x132bf8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x132bfc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x132c00: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x132c04: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x132c08: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132c0c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132c10: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132c58;
    }
label_132c18:
    // 0x132c18: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x132c1c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x132c20: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132c24: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132c28: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132c2c: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x132c30: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x132c34: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x132c38: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132c3c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x132c40: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x132c44: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x132c48: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132c4c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132c50: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132c54: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_132c58:
    // 0x132c58: 0x93a40062
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 98)));
    // 0x132c5c: 0x93a30072
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 114)));
    // 0x132c60: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 129), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_132c70;
    }
    // 0x132c68: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132cf4;
    }
label_132c70:
    // 0x132c70: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x132c74: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132cb4;
    }
    // 0x132c7c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x132c80: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132c84: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132c88: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132c8c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132c90: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x132c94: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x132c98: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x132c9c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x132ca0: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x132ca4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132ca8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132cac: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132cf4;
    }
label_132cb4:
    // 0x132cb4: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x132cb8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x132cbc: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132cc0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132cc4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132cc8: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x132ccc: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x132cd0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x132cd4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132cd8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x132cdc: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x132ce0: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x132ce4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132ce8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132cec: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132cf0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_132cf4:
    // 0x132cf4: 0x93a40063
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 99)));
    // 0x132cf8: 0x93a30073
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 115)));
    // 0x132cfc: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 130), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_132d0c;
    }
    // 0x132d04: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132d90;
    }
label_132d0c:
    // 0x132d0c: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x132d10: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_132d50;
    }
    // 0x132d18: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x132d1c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x132d20: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132d24: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132d28: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132d2c: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x132d30: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x132d34: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x132d38: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x132d3c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x132d40: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132d44: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132d48: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_132d90;
    }
label_132d50:
    // 0x132d50: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x132d54: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x132d58: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x132d5c: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x132d60: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132d64: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x132d68: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x132d6c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x132d70: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132d74: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x132d78: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x132d7c: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x132d80: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x132d84: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132d88: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x132d8c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_132d90:
    // 0x132d90: 0xa3a20083
    WRITE8(ADD32(GPR_U32(ctx, 29), 131), (uint8_t)GPR_U32(ctx, 2));
    // 0x132d94: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x132d98: 0x3c01420c
    SET_GPR_U32(ctx, 1, ((uint32_t)16908 << 16));
    // 0x132d9c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132da0: 0x24070041
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 65));
    // 0x132da4: 0x8ba20083
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 131); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x132da8: 0x9ba20080
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 128); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x132dac: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132db0: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x132db4: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x132db8: 0x4601c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x132dbc: 0x3c01428c
    SET_GPR_U32(ctx, 1, ((uint32_t)17036 << 16));
    // 0x132dc0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x132dc4: 0xc7a200d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[2] = *(float*)&val; }
    // 0x132dc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132dcc: 0x4600c802
    ctx->f[0] = FPU_MUL_S(ctx->f[25], ctx->f[0]);
    // 0x132dd0: 0x2405004c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    // 0x132dd4: 0x460116c1
    ctx->f[27] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x132dd8: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x132ddc: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x132de0: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x132de4: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x132de8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x132dec: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x132df0: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x132df4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x132df8: 0x4600bf46
    ctx->f[29] = FPU_MOV_S(ctx->f[23]);
    // 0x132dfc: 0x4600d800
    ctx->f[0] = FPU_ADD_S(ctx->f[27], ctx->f[0]);
    // 0x132e00: 0x4600a7c6
    ctx->f[31] = FPU_MOV_S(ctx->f[20]);
    // 0x132e04: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x132e08: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x132e0c: 0x4600b706
    ctx->f[28] = FPU_MOV_S(ctx->f[22]);
    // 0x132e10: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x132e14: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x132e18: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x132e1c: 0xe7a000e0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 224), *(uint32_t*)&val); }
    // 0x132e20: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x132e28);
    ctx->f[24] = FPU_MOV_S(ctx->f[21]);
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_132e28
// Address: 0x132e28 - 0x132e3c

void entry_132e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132e28: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x132e2c: 0x4481f000
    *(uint32_t*)&ctx->f[30] = GPR_U32(ctx, 1);
    // 0x132e30: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x132e34: 0xc058516
    SET_GPR_U32(ctx, 31, 0x132e3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_132e3c
// Address: 0x132e3c - 0x132e88

void entry_132e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132e3c: 0x3c01c100
    SET_GPR_U32(ctx, 1, ((uint32_t)49408 << 16));
    // 0x132e40: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132e44: 0x4614dd00
    ctx->f[20] = FPU_ADD_S(ctx->f[27], ctx->f[20]);
    // 0x132e48: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x132e4c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132e50: 0x4601c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x132e54: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132e58: 0x4615a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x132e5c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132e60: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x132e64: 0x4600a064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[20]);
    // 0x132e68: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x132e6c: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x132e70: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x132e74: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x132e78: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132e7c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x132e80: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x132e88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_132e88
// Address: 0x132e88 - 0x132e94

void entry_132e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132e88: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x132e8c: 0xc058516
    SET_GPR_U32(ctx, 31, 0x132e94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_132e94
// Address: 0x132e94 - 0x132ed0

void entry_132e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132e94: 0x3c01c040
    SET_GPR_U32(ctx, 1, ((uint32_t)49216 << 16));
    // 0x132e98: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x132e9c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x132ea0: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x132ea4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132ea8: 0x4601c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x132eac: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132eb0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x132eb4: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x132eb8: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x132ebc: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x132ec0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x132ec4: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x132ec8: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x132ed0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_132ed0
// Address: 0x132ed0 - 0x132f08

void entry_132ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x132ed0) {
        switch (ctx->pc) {
            case 0x132ed8: ctx->pc = 0; goto label_132ed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x132ed0: 0x461acd42
    ctx->f[21] = FPU_MUL_S(ctx->f[25], ctx->f[26]);
    // 0x132ed4: 0x0
    // NOP
label_132ed8:
    // 0x132ed8: 0x3c01428c
    SET_GPR_U32(ctx, 1, ((uint32_t)17036 << 16));
    // 0x132edc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x132ee0: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x132ee4: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x132ee8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x132eec: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x132ef0: 0x268412e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4832));
    // 0x132ef4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x132ef8: 0x4603ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[3]);
    // 0x132efc: 0x4602d680
    ctx->f[26] = FPU_ADD_S(ctx->f[26], ctx->f[2]);
    // 0x132f00: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x132f08);
    ctx->f[21] = FPU_ADD_S(ctx->f[27], ctx->f[21]);
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_132f08
// Address: 0x132f08 - 0x132f28

void entry_132f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132f08: 0x4600c802
    ctx->f[0] = FPU_MUL_S(ctx->f[25], ctx->f[0]);
    // 0x132f0c: 0xc7b400d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[20] = *(float*)&val; }
    // 0x132f10: 0x461ecd82
    ctx->f[22] = FPU_MUL_S(ctx->f[25], ctx->f[30]);
    // 0x132f14: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x132f18: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132f1c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x132f20: 0xc058516
    SET_GPR_U32(ctx, 31, 0x132f28);
    ctx->f[22] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_132f28
// Address: 0x132f28 - 0x132f60

void entry_132f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132f28: 0x461da502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[29]);
    // 0x132f2c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132f30: 0x461fad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[31]);
    // 0x132f34: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132f38: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132f3c: 0x461ca500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[28]);
    // 0x132f40: 0x4618ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[24]);
    // 0x132f44: 0x4618a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[24]);
    // 0x132f48: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x132f4c: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x132f50: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x132f54: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x132f58: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x132f60);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_132f60
// Address: 0x132f60 - 0x132f6c

void entry_132f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132f60: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x132f64: 0xc058516
    SET_GPR_U32(ctx, 31, 0x132f6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_132f6c
// Address: 0x132f6c - 0x132f94

void entry_132f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132f6c: 0x461db582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[29]);
    // 0x132f70: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x132f74: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132f78: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132f7c: 0x461cb580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[28]);
    // 0x132f80: 0x4618b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[24]);
    // 0x132f84: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x132f88: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x132f8c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x132f94);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_132f94
// Address: 0x132f94 - 0x132fbc

void entry_132f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132f94: 0x2a420018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 24));
    // 0x132f98: 0x5440ffcf
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_MUL_S(ctx->f[25], ctx->f[26]);
        ctx->pc = 0x132ED8; return;
    }
    // 0x132fa0: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x132fa4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132fa8: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x132fac: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x132fb0: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x132fb4: 0xc058516
    SET_GPR_U32(ctx, 31, 0x132fbc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_132fbc
// Address: 0x132fbc - 0x133044

void entry_132fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x132fbc: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x132fc0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x132fc4: 0x3c01c100
    SET_GPR_U32(ctx, 1, ((uint32_t)49408 << 16));
    // 0x132fc8: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x132fcc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132fd0: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x132fd4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x132fd8: 0x4616cd82
    ctx->f[22] = FPU_MUL_S(ctx->f[25], ctx->f[22]);
    // 0x132fdc: 0xc7a200e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[2] = *(float*)&val; }
    // 0x132fe0: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x132fe4: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x132fe8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x132fec: 0x46141040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[20]);
    // 0x132ff0: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x132ff4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x132ff8: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x132ffc: 0x4600c786
    ctx->f[30] = FPU_MOV_S(ctx->f[24]);
    // 0x133000: 0x4600bf46
    ctx->f[29] = FPU_MOV_S(ctx->f[23]);
    // 0x133004: 0x4600af06
    ctx->f[28] = FPU_MOV_S(ctx->f[21]);
    // 0x133008: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x13300c: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x133010: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x133014: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x133018: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x13301c: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x133020: 0x4481f800
    *(uint32_t*)&ctx->f[31] = GPR_U32(ctx, 1);
    // 0x133024: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133028: 0x44101000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[2]);
    // 0x13302c: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x133030: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x133034: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133038: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x13303c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x133044);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_133044
// Address: 0x133044 - 0x133050

void entry_133044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133044: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x133048: 0xc058516
    SET_GPR_U32(ctx, 31, 0x133050);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_133050
// Address: 0x133050 - 0x13308c

void entry_133050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133050: 0x3c01c080
    SET_GPR_U32(ctx, 1, ((uint32_t)49280 << 16));
    // 0x133054: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133058: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13305c: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x133060: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133064: 0x4601c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x133068: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13306c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x133070: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x133074: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x133078: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x13307c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133080: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x133084: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x13308c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13308c
// Address: 0x13308c - 0x133098

void entry_13308c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13308c: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x133090: 0xc058516
    SET_GPR_U32(ctx, 31, 0x133098);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_133098
// Address: 0x133098 - 0x1330d8

void entry_133098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133098: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x13309c: 0x4614dd00
    ctx->f[20] = FPU_ADD_S(ctx->f[27], ctx->f[20]);
    // 0x1330a0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1330a4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1330a8: 0x46160001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[22]);
    // 0x1330ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1330b0: 0x4615a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x1330b4: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x1330b8: 0x4600a064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1330bc: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1330c0: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x1330c4: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1330c8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1330cc: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1330d0: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1330d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1330d8
// Address: 0x1330d8 - 0x1330e4

void entry_1330d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1330d8: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1330dc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1330e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1330e4
// Address: 0x1330e4 - 0x133120

void entry_1330e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1330e4: 0x3c01c040
    SET_GPR_U32(ctx, 1, ((uint32_t)49216 << 16));
    // 0x1330e8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1330ec: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1330f0: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x1330f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1330f8: 0x4601c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x1330fc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133100: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x133104: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x133108: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x13310c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x133110: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133114: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x133118: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x133120);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_133120
// Address: 0x133120 - 0x133158

void entry_133120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x133120) {
        switch (ctx->pc) {
            case 0x133128: ctx->pc = 0; goto label_133128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x133120: 0x461acd42
    ctx->f[21] = FPU_MUL_S(ctx->f[25], ctx->f[26]);
    // 0x133124: 0x0
    // NOP
label_133128:
    // 0x133128: 0x3c01428c
    SET_GPR_U32(ctx, 1, ((uint32_t)17036 << 16));
    // 0x13312c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x133130: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x133134: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x133138: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x13313c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x133140: 0x268412e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4832));
    // 0x133144: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x133148: 0x4603ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[3]);
    // 0x13314c: 0x4602d680
    ctx->f[26] = FPU_ADD_S(ctx->f[26], ctx->f[2]);
    // 0x133150: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x133158);
    ctx->f[21] = FPU_ADD_S(ctx->f[27], ctx->f[21]);
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_133158
// Address: 0x133158 - 0x133178

void entry_133158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133158: 0x4600c802
    ctx->f[0] = FPU_MUL_S(ctx->f[25], ctx->f[0]);
    // 0x13315c: 0xc7b400d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[20] = *(float*)&val; }
    // 0x133160: 0x461fcd82
    ctx->f[22] = FPU_MUL_S(ctx->f[25], ctx->f[31]);
    // 0x133164: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x133168: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13316c: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x133170: 0xc058516
    SET_GPR_U32(ctx, 31, 0x133178);
    ctx->f[22] = FPU_SUB_S(ctx->f[20], ctx->f[22]);
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_133178
// Address: 0x133178 - 0x1331b8

void entry_133178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133178: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x13317c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133180: 0x461ea502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[30]);
    // 0x133184: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133188: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13318c: 0x4600ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x133190: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133194: 0x461da500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[29]);
    // 0x133198: 0x461cad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[28]);
    // 0x13319c: 0x461ca502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[28]);
    // 0x1331a0: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1331a4: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x1331a8: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1331ac: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1331b0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1331b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1331b8
// Address: 0x1331b8 - 0x1331c4

void entry_1331b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1331b8: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1331bc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1331c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1331c4
// Address: 0x1331c4 - 0x1331ec

void entry_1331c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1331c4: 0x461eb582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[30]);
    // 0x1331c8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1331cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1331d0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1331d4: 0x461db580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[29]);
    // 0x1331d8: 0x461cb582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[28]);
    // 0x1331dc: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x1331e0: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1331e4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1331ec);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1331ec
// Address: 0x1331ec - 0x133210

void entry_1331ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1331ec: 0x2a420018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 24));
    // 0x1331f0: 0x5440ffcd
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_MUL_S(ctx->f[25], ctx->f[26]);
        ctx->pc = 0x133128; return;
    }
    // 0x1331f8: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1331fc: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x133200: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x133204: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x133208: 0xc058516
    SET_GPR_U32(ctx, 31, 0x133210);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_133210
// Address: 0x133210 - 0x133278

void entry_133210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133210: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x133214: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x133218: 0x3c01c100
    SET_GPR_U32(ctx, 1, ((uint32_t)49408 << 16));
    // 0x13321c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133220: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133224: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x133228: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13322c: 0x4601c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x133230: 0xc7a300e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[3] = *(float*)&val; }
    // 0x133234: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x133238: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x13323c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133240: 0x46171880
    ctx->f[2] = FPU_ADD_S(ctx->f[3], ctx->f[23]);
    // 0x133244: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x133248: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x13324c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x133250: 0x46141082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[20]);
    // 0x133254: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x133258: 0x46001064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[2]);
    // 0x13325c: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x133260: 0x46150000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x133264: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x133268: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x13326c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x133270: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x133278);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_133278
// Address: 0x133278 - 0x133284

void entry_133278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133278: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13327c: 0xc058516
    SET_GPR_U32(ctx, 31, 0x133284);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_133284
// Address: 0x133284 - 0x1332c0

void entry_133284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133284: 0x3c01c080
    SET_GPR_U32(ctx, 1, ((uint32_t)49280 << 16));
    // 0x133288: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13328c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x133290: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x133294: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133298: 0x4601c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x13329c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1332a0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1332a4: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1332a8: 0x46150000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x1332ac: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1332b0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1332b4: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1332b8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1332c0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1332c0
// Address: 0x1332c0 - 0x13331c

void entry_1332c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1332c0: 0x8e630260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    // 0x1332c4: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1332c8: 0x10620202
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x133AD4; return;
    }
    // 0x1332d0: 0x3c014224
    SET_GPR_U32(ctx, 1, ((uint32_t)16932 << 16));
    // 0x1332d4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1332d8: 0x4619cfc0
    ctx->f[31] = FPU_ADD_S(ctx->f[25], ctx->f[25]);
    // 0x1332dc: 0x3c01c0a0
    SET_GPR_U32(ctx, 1, ((uint32_t)49312 << 16));
    // 0x1332e0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1332e4: 0x240500c6
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 198));
    // 0x1332e8: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1332ec: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x1332f0: 0x34e74441
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17473));
    // 0x1332f4: 0xe7a200d8
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 216), *(uint32_t*)&val); }
    // 0x1332f8: 0xe7a300dc
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 220), *(uint32_t*)&val); }
    // 0x1332fc: 0x4600bf06
    ctx->f[28] = FPU_MOV_S(ctx->f[23]);
    // 0x133300: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133304: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133308: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x13330c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133310: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x133314: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x13331c);
    ctx->f[30] = FPU_MOV_S(ctx->f[31]);
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_13331c
// Address: 0x13331c - 0x133360

void entry_13331c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13331c) {
        switch (ctx->pc) {
            case 0x133330: ctx->pc = 0; goto label_133330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13331c: 0x4600a5c6
    ctx->f[23] = FPU_MOV_S(ctx->f[20]);
    // 0x133320: 0x4600b6c6
    ctx->f[27] = FPU_MOV_S(ctx->f[22]);
    // 0x133324: 0x4600ae86
    ctx->f[26] = FPU_MOV_S(ctx->f[21]);
    // 0x133328: 0x2410003f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 63));
    // 0x13332c: 0x0
    // NOP
label_133330:
    // 0x133330: 0xc7a000d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[0] = *(float*)&val; }
    // 0x133334: 0x3c014400
    SET_GPR_U32(ctx, 1, ((uint32_t)17408 << 16));
    // 0x133338: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13333c: 0x46010303
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[1];
    // 0x133340: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x133344: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x133348: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13334c: 0xc661030c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 780)); ctx->f[1] = *(float*)&val; }
    // 0x133350: 0x460c6300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[12]);
    // 0x133354: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x133358: 0xc081484
    SET_GPR_U32(ctx, 31, 0x133360);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_133360
// Address: 0x133360 - 0x1335b0

void entry_133360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x133360) {
        switch (ctx->pc) {
            case 0x1333c4: ctx->pc = 0; goto label_1333c4;
            case 0x1333fc: ctx->pc = 0; goto label_1333fc;
            case 0x133424: ctx->pc = 0; goto label_133424;
            case 0x13343c: ctx->pc = 0; goto label_13343c;
            case 0x133474: ctx->pc = 0; goto label_133474;
            case 0x13349c: ctx->pc = 0; goto label_13349c;
            case 0x1334b4: ctx->pc = 0; goto label_1334b4;
            case 0x1334ec: ctx->pc = 0; goto label_1334ec;
            case 0x133514: ctx->pc = 0; goto label_133514;
            case 0x13352c: ctx->pc = 0; goto label_13352c;
            case 0x133564: ctx->pc = 0; goto label_133564;
            case 0x13358c: ctx->pc = 0; goto label_13358c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x133360: 0xc7a100d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[1] = *(float*)&val; }
    // 0x133364: 0xc7a300d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[3] = *(float*)&val; }
    // 0x133368: 0x4601c882
    ctx->f[2] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x13336c: 0xc7a500d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[5] = *(float*)&val; }
    // 0x133370: 0xc7a100dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 220)); ctx->f[1] = *(float*)&val; }
    // 0x133374: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x133378: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x13337c: 0xaba20093
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 147); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133380: 0xbba20090
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 144); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133384: 0x4601c902
    ctx->f[4] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x133388: 0x8ba60013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x13338c: 0x9ba60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x133390: 0xaba600a3
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 163); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133394: 0xbba600a0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 160); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133398: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x13339c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1333a0: 0x46021d40
    ctx->f[21] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1333a4: 0x93a40090
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1333a8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1333ac: 0x93a300a0
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1333b0: 0x46042d80
    ctx->f[22] = FPU_ADD_S(ctx->f[5], ctx->f[4]);
    // 0x1333b4: 0x14830003
    ctx->f[3] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1333c4;
    }
    // 0x1333bc: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133424;
    }
label_1333c4:
    // 0x1333c4: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1333c8: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_1333fc;
    }
    // 0x1333d0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1333d4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1333d8: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1333dc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1333e0: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1333e4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1333e8: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1333ec: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1333f0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1333f4: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133424;
    }
label_1333fc:
    // 0x1333fc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x133400: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133404: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x133408: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x13340c: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133410: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133414: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133418: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x13341c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x133420: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133424:
    // 0x133424: 0x93a40091
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 145)));
    // 0x133428: 0x93a300a1
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 161)));
    // 0x13342c: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 176), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_13343c;
    }
    // 0x133434: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13349c;
    }
label_13343c:
    // 0x13343c: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133440: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_133474;
    }
    // 0x133448: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x13344c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133450: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133454: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133458: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x13345c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x133460: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x133464: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133468: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13346c: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13349c;
    }
label_133474:
    // 0x133474: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x133478: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x13347c: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x133480: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133484: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133488: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x13348c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133490: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133494: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x133498: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_13349c:
    // 0x13349c: 0x93a40092
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 146)));
    // 0x1334a0: 0x93a300a2
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 162)));
    // 0x1334a4: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 177), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1334b4;
    }
    // 0x1334ac: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133514;
    }
label_1334b4:
    // 0x1334b4: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1334b8: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_1334ec;
    }
    // 0x1334c0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1334c4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1334c8: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1334cc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1334d0: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1334d4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1334d8: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1334dc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1334e0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1334e4: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133514;
    }
label_1334ec:
    // 0x1334ec: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1334f0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1334f4: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1334f8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1334fc: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133500: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133504: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133508: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x13350c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x133510: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133514:
    // 0x133514: 0x93a40093
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 147)));
    // 0x133518: 0x93a300a3
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 163)));
    // 0x13351c: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 178), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_13352c;
    }
    // 0x133524: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13358c;
    }
label_13352c:
    // 0x13352c: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133530: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_133564;
    }
    // 0x133538: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x13353c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133540: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133544: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133548: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x13354c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x133550: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x133554: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133558: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13355c: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13358c;
    }
label_133564:
    // 0x133564: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x133568: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x13356c: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x133570: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133574: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133578: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x13357c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133580: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133584: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x133588: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_13358c:
    // 0x13358c: 0xa3a200b3
    WRITE8(ADD32(GPR_U32(ctx, 29), 179), (uint8_t)GPR_U32(ctx, 2));
    // 0x133590: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133594: 0x8ba200b3
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 179); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x133598: 0x9ba200b0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 176); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x13359c: 0xaba20063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1335a0: 0xbba20060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1335a4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1335a8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1335b0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1335b0
// Address: 0x1335b0 - 0x1335e4

void entry_1335b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1335b0: 0x461bb002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[27]);
    // 0x1335b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1335b8: 0x461ca840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[28]);
    // 0x1335bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1335c0: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x1335c4: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x1335c8: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1335cc: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1335d0: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1335d4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1335d8: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1335dc: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1335e4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1335e4
// Address: 0x1335e4 - 0x13362c

void entry_1335e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1335e4: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1335e8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1335ec: 0x461ea840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[30]);
    // 0x1335f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1335f4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1335f8: 0x4614cd02
    ctx->f[20] = FPU_MUL_S(ctx->f[25], ctx->f[20]);
    // 0x1335fc: 0x461c0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[28]);
    // 0x133600: 0x4614b000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x133604: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x133608: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x13360c: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133610: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x133614: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x133618: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x13361c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133620: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x133624: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x13362c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13362c
// Address: 0x13362c - 0x133680

void entry_13362c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13362c: 0xc7a300dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 220)); ctx->f[3] = *(float*)&val; }
    // 0x133630: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133634: 0xc7a100d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[1] = *(float*)&val; }
    // 0x133638: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13363c: 0x4603c882
    ctx->f[2] = FPU_MUL_S(ctx->f[25], ctx->f[3]);
    // 0x133640: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x133644: 0x4601c8c2
    ctx->f[3] = FPU_MUL_S(ctx->f[25], ctx->f[1]);
    // 0x133648: 0xc7a100d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[1] = *(float*)&val; }
    // 0x13364c: 0x46020580
    ctx->f[22] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x133650: 0x46030d41
    ctx->f[21] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x133654: 0x461bb002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[27]);
    // 0x133658: 0x461ca840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[28]);
    // 0x13365c: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x133660: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x133664: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x133668: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x13366c: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x133670: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133674: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x133678: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x133680);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_133680
// Address: 0x133680 - 0x1336bc

void entry_133680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133680: 0x4614b500
    ctx->f[20] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x133684: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133688: 0x461ea801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[30]);
    // 0x13368c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133690: 0x461ba502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[27]);
    // 0x133694: 0x461c0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[28]);
    // 0x133698: 0x461aa500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[26]);
    // 0x13369c: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1336a0: 0x4617a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[23]);
    // 0x1336a4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1336a8: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1336ac: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1336b0: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1336b4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1336bc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1336bc
// Address: 0x1336bc - 0x133760

void entry_1336bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1336bc) {
        switch (ctx->pc) {
            case 0x133730: ctx->pc = 0; goto label_133730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1336bc: 0xc7a100d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[1] = *(float*)&val; }
    // 0x1336c0: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x1336c4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1336c8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1336cc: 0x601ff18
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 216), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x133330; return;
    }
    // 0x1336d4: 0x3c01c0a0
    SET_GPR_U32(ctx, 1, ((uint32_t)49312 << 16));
    // 0x1336d8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1336dc: 0x2410001f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 31));
    // 0x1336e0: 0x3c0141c0
    SET_GPR_U32(ctx, 1, ((uint32_t)16832 << 16));
    // 0x1336e4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1336e8: 0xe7a200d8
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 216), *(uint32_t*)&val); }
    // 0x1336ec: 0xe7bf00e4
    { float val = ctx->f[31]; WRITE32(ADD32(GPR_U32(ctx, 29), 228), *(uint32_t*)&val); }
    // 0x1336f0: 0xe7a300dc
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 220), *(uint32_t*)&val); }
    // 0x1336f4: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1336f8: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1336fc: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x133700: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133704: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x133708: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x13370c: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x133710: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x133714: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x133718: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x13371c: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x133720: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x133724: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x133728: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x13372c: 0x0
    // NOP
label_133730:
    // 0x133730: 0xc7a000dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 220)); ctx->f[0] = *(float*)&val; }
    // 0x133734: 0x3c014380
    SET_GPR_U32(ctx, 1, ((uint32_t)17280 << 16));
    // 0x133738: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13373c: 0x46010303
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[1];
    // 0x133740: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x133744: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x133748: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13374c: 0xc661030c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 780)); ctx->f[1] = *(float*)&val; }
    // 0x133750: 0x460c6300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[12]);
    // 0x133754: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x133758: 0xc081484
    SET_GPR_U32(ctx, 31, 0x133760);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_133760
// Address: 0x133760 - 0x1339b8

void entry_133760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x133760) {
        switch (ctx->pc) {
            case 0x1337cc: ctx->pc = 0; goto label_1337cc;
            case 0x133804: ctx->pc = 0; goto label_133804;
            case 0x13382c: ctx->pc = 0; goto label_13382c;
            case 0x133844: ctx->pc = 0; goto label_133844;
            case 0x13387c: ctx->pc = 0; goto label_13387c;
            case 0x1338a4: ctx->pc = 0; goto label_1338a4;
            case 0x1338bc: ctx->pc = 0; goto label_1338bc;
            case 0x1338f4: ctx->pc = 0; goto label_1338f4;
            case 0x13391c: ctx->pc = 0; goto label_13391c;
            case 0x133934: ctx->pc = 0; goto label_133934;
            case 0x13396c: ctx->pc = 0; goto label_13396c;
            case 0x133994: ctx->pc = 0; goto label_133994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x133760: 0xc7a200d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[2] = *(float*)&val; }
    // 0x133764: 0xc7a500d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[5] = *(float*)&val; }
    // 0x133768: 0x4602c8c2
    ctx->f[3] = FPU_MUL_S(ctx->f[25], ctx->f[2]);
    // 0x13376c: 0xc7a400d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[4] = *(float*)&val; }
    // 0x133770: 0xc7a200dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 220)); ctx->f[2] = *(float*)&val; }
    // 0x133774: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x133778: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x13377c: 0xaba20073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133780: 0xbba20070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133784: 0x4602c842
    ctx->f[1] = FPU_MUL_S(ctx->f[25], ctx->f[2]);
    // 0x133788: 0x8ba60013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x13378c: 0x9ba60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x133790: 0xaba60083
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 131); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133794: 0xbba60080
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 128); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133798: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x13379c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1337a0: 0x46001fc6
    ctx->f[31] = FPU_MOV_S(ctx->f[3]);
    // 0x1337a4: 0x46032d80
    ctx->f[22] = FPU_ADD_S(ctx->f[5], ctx->f[3]);
    // 0x1337a8: 0x93a40070
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1337ac: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1337b0: 0x93a30080
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1337b4: 0x46000f86
    ctx->f[30] = FPU_MOV_S(ctx->f[1]);
    // 0x1337b8: 0x46012540
    ctx->f[21] = FPU_ADD_S(ctx->f[4], ctx->f[1]);
    // 0x1337bc: 0x14830003
    ctx->f[3] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1337cc;
    }
    // 0x1337c4: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13382c;
    }
label_1337cc:
    // 0x1337cc: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1337d0: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_133804;
    }
    // 0x1337d8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1337dc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1337e0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1337e4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1337e8: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1337ec: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1337f0: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1337f4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1337f8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1337fc: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13382c;
    }
label_133804:
    // 0x133804: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x133808: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x13380c: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x133810: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133814: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133818: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x13381c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133820: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133824: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x133828: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_13382c:
    // 0x13382c: 0x93a40071
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 113)));
    // 0x133830: 0x93a30081
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 129)));
    // 0x133834: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 192), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133844;
    }
    // 0x13383c: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1338a4;
    }
label_133844:
    // 0x133844: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133848: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_13387c;
    }
    // 0x133850: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133854: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133858: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x13385c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133860: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133864: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x133868: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x13386c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133870: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133874: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1338a4;
    }
label_13387c:
    // 0x13387c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x133880: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133884: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x133888: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x13388c: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133890: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133894: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133898: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x13389c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1338a0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1338a4:
    // 0x1338a4: 0x93a40072
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 114)));
    // 0x1338a8: 0x93a30082
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 130)));
    // 0x1338ac: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 193), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1338bc;
    }
    // 0x1338b4: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13391c;
    }
label_1338bc:
    // 0x1338bc: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1338c0: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_1338f4;
    }
    // 0x1338c8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1338cc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1338d0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1338d4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1338d8: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1338dc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1338e0: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1338e4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1338e8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1338ec: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13391c;
    }
label_1338f4:
    // 0x1338f4: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1338f8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1338fc: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x133900: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133904: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133908: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x13390c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133910: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133914: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x133918: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_13391c:
    // 0x13391c: 0x93a40073
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 115)));
    // 0x133920: 0x93a30083
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 131)));
    // 0x133924: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 194), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133934;
    }
    // 0x13392c: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133994;
    }
label_133934:
    // 0x133934: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133938: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[29], ctx->f[3]);
        goto label_13396c;
    }
    // 0x133940: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133944: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133948: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x13394c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133950: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133954: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x133958: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x13395c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133960: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133964: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133994;
    }
label_13396c:
    // 0x13396c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x133970: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133974: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x133978: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x13397c: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x133980: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133984: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x133988: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x13398c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x133990: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133994:
    // 0x133994: 0xa3a200c3
    WRITE8(ADD32(GPR_U32(ctx, 29), 195), (uint8_t)GPR_U32(ctx, 2));
    // 0x133998: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13399c: 0x8ba200c3
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 195); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1339a0: 0x9ba200c0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 192); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1339a4: 0xaba20063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1339a8: 0xbba20060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1339ac: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1339b0: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1339b8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1339b8
// Address: 0x1339b8 - 0x1339ec

void entry_1339b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1339b8: 0x461ba802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[27]);
    // 0x1339bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1339c0: 0x461cb040
    ctx->f[1] = FPU_ADD_S(ctx->f[22], ctx->f[28]);
    // 0x1339c4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1339c8: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x1339cc: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x1339d0: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1339d4: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1339d8: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1339dc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1339e0: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1339e4: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1339ec);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1339ec
// Address: 0x1339ec - 0x133a38

void entry_1339ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1339ec: 0xc7a200e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 228)); ctx->f[2] = *(float*)&val; }
    // 0x1339f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1339f4: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1339f8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1339fc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133a00: 0x4602a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[2]);
    // 0x133a04: 0x4614cd02
    ctx->f[20] = FPU_MUL_S(ctx->f[25], ctx->f[20]);
    // 0x133a08: 0x461b0842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[27]);
    // 0x133a0c: 0x4614b000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x133a10: 0x461a0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[26]);
    // 0x133a14: 0x461c0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[28]);
    // 0x133a18: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x133a1c: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x133a20: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133a24: 0x44061000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[2]);
    // 0x133a28: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133a2c: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x133a30: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x133a38);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_133a38
// Address: 0x133a38 - 0x133a7c

void entry_133a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133a38: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x133a3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133a40: 0xc7a100d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[1] = *(float*)&val; }
    // 0x133a44: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133a48: 0x461e0541
    ctx->f[21] = FPU_SUB_S(ctx->f[0], ctx->f[30]);
    // 0x133a4c: 0x461f0d80
    ctx->f[22] = FPU_ADD_S(ctx->f[1], ctx->f[31]);
    // 0x133a50: 0x461ba802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[27]);
    // 0x133a54: 0x461cb040
    ctx->f[1] = FPU_ADD_S(ctx->f[22], ctx->f[28]);
    // 0x133a58: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x133a5c: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x133a60: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x133a64: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x133a68: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x133a6c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133a70: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x133a74: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x133a7c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_133a7c
// Address: 0x133a7c - 0x133abc

void entry_133a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133a7c: 0xc7a200e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 228)); ctx->f[2] = *(float*)&val; }
    // 0x133a80: 0x4614b500
    ctx->f[20] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x133a84: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133a88: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133a8c: 0x4602a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[2]);
    // 0x133a90: 0x461ca500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[28]);
    // 0x133a94: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x133a98: 0x4617a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[23]);
    // 0x133a9c: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x133aa0: 0x4600a064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[20]);
    // 0x133aa4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x133aa8: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x133aac: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133ab0: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x133ab4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x133abc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_133abc
// Address: 0x133abc - 0x133ae8

void entry_133abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x133abc) {
        switch (ctx->pc) {
            case 0x133ad4: ctx->pc = 0; goto label_133ad4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x133abc: 0xc7a200dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 220)); ctx->f[2] = *(float*)&val; }
    // 0x133ac0: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x133ac4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133ac8: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x133acc: 0x601ff18
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 220), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x133730; return;
    }
label_133ad4:
    // 0x133ad4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133ad8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x133adc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x133ae0: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x133ae8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_133ae8
// Address: 0x133ae8 - 0x133b04

void entry_133ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133ae8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x133aec: 0x3c0600df
    SET_GPR_U32(ctx, 6, ((uint32_t)223 << 16));
    // 0x133af0: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x133af4: 0x34c6027f
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 639));
    // 0x133af8: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x133afc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x133b04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_133b04
// Address: 0x133b04 - 0x133b58

void entry_133b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x133b04: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x133b08: 0x7bb40130
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x133b0c: 0x7bb30120
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x133b10: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x133b14: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x133b18: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x133b1c: 0xc7bf01a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 424)); ctx->f[31] = *(float*)&val; }
    // 0x133b20: 0xc7be01a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 416)); ctx->f[30] = *(float*)&val; }
    // 0x133b24: 0xc7bd0198
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 408)); ctx->f[29] = *(float*)&val; }
    // 0x133b28: 0xc7bc0190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 400)); ctx->f[28] = *(float*)&val; }
    // 0x133b2c: 0xc7bb0188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 392)); ctx->f[27] = *(float*)&val; }
    // 0x133b30: 0xc7ba0180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[26] = *(float*)&val; }
    // 0x133b34: 0xc7b90178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[25] = *(float*)&val; }
    // 0x133b38: 0xc7b80170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[24] = *(float*)&val; }
    // 0x133b3c: 0xc7b70168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[23] = *(float*)&val; }
    // 0x133b40: 0xc7b60160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[22] = *(float*)&val; }
    // 0x133b44: 0xc7b50158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[21] = *(float*)&val; }
    // 0x133b48: 0xc7b40150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[20] = *(float*)&val; }
    // 0x133b4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 432));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x133b54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x133b58; return;
}


// Function: DrawBinocOutline
// Address: 0x133b58 - 0x133bbc

void entry_133bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x133bbc) {
        switch (ctx->pc) {
            case 0x133c18: ctx->pc = 0; goto label_133c18;
            case 0x133c5c: ctx->pc = 0; goto label_133c5c;
            case 0x133c9c: ctx->pc = 0; goto label_133c9c;
            case 0x133cb4: ctx->pc = 0; goto label_133cb4;
            case 0x133cf8: ctx->pc = 0; goto label_133cf8;
            case 0x133d38: ctx->pc = 0; goto label_133d38;
            case 0x133d50: ctx->pc = 0; goto label_133d50;
            case 0x133d94: ctx->pc = 0; goto label_133d94;
            case 0x133dd4: ctx->pc = 0; goto label_133dd4;
            case 0x133dec: ctx->pc = 0; goto label_133dec;
            case 0x133e30: ctx->pc = 0; goto label_133e30;
            case 0x133e70: ctx->pc = 0; goto label_133e70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x133bbc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x133bc0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x133bc4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133bc8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x133bcc: 0x244710e0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4320));
    // 0x133bd0: 0x88e40003
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x133bd4: 0x98e40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x133bd8: 0xaba40043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133bdc: 0xbba40040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133be0: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x133be4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x133be8: 0x246410d8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 4312));
    // 0x133bec: 0x88880003
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x133bf0: 0x98880000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x133bf4: 0xaba80053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133bf8: 0xbba80050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133bfc: 0x60902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x133c00: 0x93a40040
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x133c04: 0x93a30050
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x133c08: 0x14830003
    ctx->f[4] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133c18;
    }
    // 0x133c10: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133c9c;
    }
label_133c18:
    // 0x133c18: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133c1c: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_133c5c;
    }
    // 0x133c24: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133c28: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133c2c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133c30: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133c34: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133c38: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x133c3c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133c40: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x133c44: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133c48: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x133c4c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133c50: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133c54: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133c9c;
    }
label_133c5c:
    // 0x133c5c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133c60: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133c64: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133c68: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133c6c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x133c70: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x133c74: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x133c78: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133c7c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133c80: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x133c84: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x133c88: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x133c8c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x133c90: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133c94: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133c98: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133c9c:
    // 0x133c9c: 0x93a40041
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 65)));
    // 0x133ca0: 0x93a30051
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 81)));
    // 0x133ca4: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 96), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133cb4;
    }
    // 0x133cac: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133d38;
    }
label_133cb4:
    // 0x133cb4: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133cb8: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_133cf8;
    }
    // 0x133cc0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133cc4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133cc8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133ccc: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133cd0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133cd4: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x133cd8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133cdc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x133ce0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133ce4: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x133ce8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133cec: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133cf0: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133d38;
    }
label_133cf8:
    // 0x133cf8: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133cfc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133d00: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133d04: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133d08: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x133d0c: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x133d10: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x133d14: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133d18: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133d1c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x133d20: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x133d24: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x133d28: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x133d2c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133d30: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133d34: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133d38:
    // 0x133d38: 0x93a40042
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 66)));
    // 0x133d3c: 0x93a30052
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 82)));
    // 0x133d40: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 97), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133d50;
    }
    // 0x133d48: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133dd4;
    }
label_133d50:
    // 0x133d50: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133d54: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_133d94;
    }
    // 0x133d5c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133d60: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133d64: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133d68: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133d6c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133d70: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x133d74: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133d78: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x133d7c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133d80: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x133d84: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133d88: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133d8c: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133dd4;
    }
label_133d94:
    // 0x133d94: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133d98: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133d9c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133da0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133da4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x133da8: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x133dac: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x133db0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133db4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133db8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x133dbc: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x133dc0: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x133dc4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x133dc8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133dcc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133dd0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133dd4:
    // 0x133dd4: 0x93a40043
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x133dd8: 0x93a30053
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 83)));
    // 0x133ddc: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 98), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133dec;
    }
    // 0x133de4: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133e70;
    }
label_133dec:
    // 0x133dec: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133df0: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_133e30;
    }
    // 0x133df8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133dfc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133e00: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133e04: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133e08: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133e0c: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x133e10: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133e14: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x133e18: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133e1c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x133e20: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133e24: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133e28: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133e70;
    }
label_133e30:
    // 0x133e30: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133e34: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133e38: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133e3c: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133e40: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x133e44: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x133e48: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x133e4c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133e50: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133e54: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x133e58: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x133e5c: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x133e60: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x133e64: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133e68: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133e6c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133e70:
    // 0x133e70: 0xc600030c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 780)); ctx->f[0] = *(float*)&val; }
    // 0x133e74: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x133e78: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x133e7c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x133e80: 0xa3a20063
    WRITE8(ADD32(GPR_U32(ctx, 29), 99), (uint8_t)GPR_U32(ctx, 2));
    // 0x133e84: 0x8ba20063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x133e88: 0x9ba20060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x133e8c: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133e90: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133e94: 0x8ba60033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x133e98: 0x9ba60030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x133e9c: 0xaba60003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133ea0: 0xbba60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133ea4: 0xc081484
    SET_GPR_U32(ctx, 31, 0x133eac);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_133eac
// Address: 0x133eac - 0x13418c

void entry_133eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x133eac) {
        switch (ctx->pc) {
            case 0x133ef8: ctx->pc = 0; goto label_133ef8;
            case 0x133f3c: ctx->pc = 0; goto label_133f3c;
            case 0x133f7c: ctx->pc = 0; goto label_133f7c;
            case 0x133f94: ctx->pc = 0; goto label_133f94;
            case 0x133fd8: ctx->pc = 0; goto label_133fd8;
            case 0x134018: ctx->pc = 0; goto label_134018;
            case 0x134030: ctx->pc = 0; goto label_134030;
            case 0x134074: ctx->pc = 0; goto label_134074;
            case 0x1340b4: ctx->pc = 0; goto label_1340b4;
            case 0x1340cc: ctx->pc = 0; goto label_1340cc;
            case 0x134110: ctx->pc = 0; goto label_134110;
            case 0x134150: ctx->pc = 0; goto label_134150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x133eac: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x133eb0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133eb4: 0x266510e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 4320));
    // 0x133eb8: 0x88a20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x133ebc: 0x98a20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x133ec0: 0xaba20073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133ec4: 0xbba20070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133ec8: 0x264910d8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 4312));
    // 0x133ecc: 0x89260003
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x133ed0: 0x99260000
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x133ed4: 0xaba60083
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 131); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133ed8: 0xbba60080
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 128); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x133edc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x133ee0: 0x93a40070
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x133ee4: 0x93a30080
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x133ee8: 0x14830003
    ctx->f[4] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133ef8;
    }
    // 0x133ef0: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133f7c;
    }
label_133ef8:
    // 0x133ef8: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133efc: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_133f3c;
    }
    // 0x133f04: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133f08: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133f0c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133f10: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133f14: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133f18: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x133f1c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133f20: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x133f24: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133f28: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x133f2c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133f30: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133f34: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_133f7c;
    }
label_133f3c:
    // 0x133f3c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133f40: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133f44: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133f48: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133f4c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x133f50: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x133f54: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x133f58: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133f5c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133f60: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x133f64: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x133f68: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x133f6c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x133f70: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133f74: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133f78: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_133f7c:
    // 0x133f7c: 0x93a40071
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 113)));
    // 0x133f80: 0x93a30081
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 129)));
    // 0x133f84: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 144), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_133f94;
    }
    // 0x133f8c: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134018;
    }
label_133f94:
    // 0x133f94: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x133f98: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_133fd8;
    }
    // 0x133fa0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x133fa4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x133fa8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133fac: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133fb0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x133fb4: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x133fb8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x133fbc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x133fc0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x133fc4: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x133fc8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x133fcc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x133fd0: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134018;
    }
label_133fd8:
    // 0x133fd8: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x133fdc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x133fe0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x133fe4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x133fe8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x133fec: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x133ff0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x133ff4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x133ff8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x133ffc: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x134000: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x134004: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x134008: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x13400c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134010: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x134014: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_134018:
    // 0x134018: 0x93a40072
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 114)));
    // 0x13401c: 0x93a30082
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 130)));
    // 0x134020: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 145), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_134030;
    }
    // 0x134028: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1340b4;
    }
label_134030:
    // 0x134030: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x134034: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_134074;
    }
    // 0x13403c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x134040: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x134044: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x134048: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x13404c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x134050: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x134054: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x134058: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x13405c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x134060: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x134064: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134068: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13406c: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1340b4;
    }
label_134074:
    // 0x134074: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x134078: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x13407c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x134080: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x134084: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x134088: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x13408c: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x134090: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x134094: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x134098: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x13409c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1340a0: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1340a4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1340a8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1340ac: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1340b0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1340b4:
    // 0x1340b4: 0x93a40073
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 115)));
    // 0x1340b8: 0x93a30083
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 131)));
    // 0x1340bc: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 146), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1340cc;
    }
    // 0x1340c4: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134150;
    }
label_1340cc:
    // 0x1340cc: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1340d0: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_134110;
    }
    // 0x1340d8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1340dc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1340e0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1340e4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1340e8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1340ec: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1340f0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1340f4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1340f8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1340fc: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x134100: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134104: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x134108: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134150;
    }
label_134110:
    // 0x134110: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x134114: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x134118: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x13411c: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x134120: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x134124: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x134128: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x13412c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x134130: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x134134: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x134138: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x13413c: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x134140: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x134144: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134148: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13414c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_134150:
    // 0x134150: 0xc600030c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 780)); ctx->f[0] = *(float*)&val; }
    // 0x134154: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x134158: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x13415c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x134160: 0xa3a20093
    WRITE8(ADD32(GPR_U32(ctx, 29), 147), (uint8_t)GPR_U32(ctx, 2));
    // 0x134164: 0x8ba20093
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 147); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x134168: 0x9ba20090
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 144); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x13416c: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x134170: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x134174: 0x8ba60033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x134178: 0x9ba60030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x13417c: 0xaba60013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x134180: 0xbba60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x134184: 0xc081484
    SET_GPR_U32(ctx, 31, 0x13418c);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_13418c
// Address: 0x13418c - 0x13446c

void entry_13418c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13418c) {
        switch (ctx->pc) {
            case 0x1341d8: ctx->pc = 0; goto label_1341d8;
            case 0x13421c: ctx->pc = 0; goto label_13421c;
            case 0x13425c: ctx->pc = 0; goto label_13425c;
            case 0x134274: ctx->pc = 0; goto label_134274;
            case 0x1342b8: ctx->pc = 0; goto label_1342b8;
            case 0x1342f8: ctx->pc = 0; goto label_1342f8;
            case 0x134310: ctx->pc = 0; goto label_134310;
            case 0x134354: ctx->pc = 0; goto label_134354;
            case 0x134394: ctx->pc = 0; goto label_134394;
            case 0x1343ac: ctx->pc = 0; goto label_1343ac;
            case 0x1343f0: ctx->pc = 0; goto label_1343f0;
            case 0x134430: ctx->pc = 0; goto label_134430;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13418c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x134190: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x134194: 0x266510e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 4320));
    // 0x134198: 0x88a20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x13419c: 0x98a20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1341a0: 0xaba20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1341a4: 0xbba20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1341a8: 0x264910d8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 4312));
    // 0x1341ac: 0x89260003
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1341b0: 0x99260000
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1341b4: 0xaba60053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1341b8: 0xbba60050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1341bc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1341c0: 0x93a40040
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1341c4: 0x93a30050
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1341c8: 0x14830003
    ctx->f[4] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1341d8;
    }
    // 0x1341d0: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13425c;
    }
label_1341d8:
    // 0x1341d8: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1341dc: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13421c;
    }
    // 0x1341e4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1341e8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1341ec: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1341f0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1341f4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1341f8: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1341fc: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x134200: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x134204: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x134208: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x13420c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134210: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x134214: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13425c;
    }
label_13421c:
    // 0x13421c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x134220: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x134224: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x134228: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x13422c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x134230: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x134234: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x134238: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13423c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x134240: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x134244: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x134248: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x13424c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x134250: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134254: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x134258: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_13425c:
    // 0x13425c: 0x93a40041
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 65)));
    // 0x134260: 0x93a30051
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 81)));
    // 0x134264: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 160), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_134274;
    }
    // 0x13426c: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1342f8;
    }
label_134274:
    // 0x134274: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x134278: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1342b8;
    }
    // 0x134280: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x134284: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x134288: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x13428c: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x134290: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x134294: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x134298: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x13429c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1342a0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1342a4: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1342a8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1342ac: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1342b0: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1342f8;
    }
label_1342b8:
    // 0x1342b8: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1342bc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1342c0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1342c4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1342c8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1342cc: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1342d0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1342d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1342d8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1342dc: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1342e0: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1342e4: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1342e8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1342ec: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1342f0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1342f4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1342f8:
    // 0x1342f8: 0x93a40042
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 66)));
    // 0x1342fc: 0x93a30052
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 82)));
    // 0x134300: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 161), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_134310;
    }
    // 0x134308: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134394;
    }
label_134310:
    // 0x134310: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x134314: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_134354;
    }
    // 0x13431c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x134320: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x134324: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x134328: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x13432c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x134330: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x134334: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x134338: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x13433c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x134340: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x134344: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134348: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13434c: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134394;
    }
label_134354:
    // 0x134354: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x134358: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x13435c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x134360: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x134364: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x134368: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x13436c: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x134370: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x134374: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x134378: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x13437c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x134380: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x134384: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x134388: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x13438c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x134390: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_134394:
    // 0x134394: 0x93a40043
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x134398: 0x93a30053
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 83)));
    // 0x13439c: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 162), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1343ac;
    }
    // 0x1343a4: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134430;
    }
label_1343ac:
    // 0x1343ac: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1343b0: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1343f0;
    }
    // 0x1343b8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1343bc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1343c0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1343c4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1343c8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1343cc: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1343d0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1343d4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1343d8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1343dc: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1343e0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1343e4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1343e8: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134430;
    }
label_1343f0:
    // 0x1343f0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1343f4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1343f8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1343fc: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x134400: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x134404: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x134408: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x13440c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x134410: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x134414: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x134418: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x13441c: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x134420: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x134424: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134428: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x13442c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_134430:
    // 0x134430: 0xa3a200a3
    WRITE8(ADD32(GPR_U32(ctx, 29), 163), (uint8_t)GPR_U32(ctx, 2));
    // 0x134434: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x134438: 0x8ba200a3
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 163); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x13443c: 0x9ba200a0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 160); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x134440: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x134444: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x134448: 0x24070041
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 65));
    // 0x13444c: 0x8ba80033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | ((word >> shift) & mask)); }
    // 0x134450: 0x9ba80030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 8, (GPR_U32(ctx,8) & ~mask) | (word << shift)); }
    // 0x134454: 0xaba80023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x134458: 0xbba80020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 8) & mask); WRITE32(aligned_addr, new_data); }
    // 0x13445c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134460: 0x2405008c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 140));
    // 0x134464: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x13446c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_13446c
// Address: 0x13446c - 0x134490

void entry_13446c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13446c: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x134470: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x134474: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x134478: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13447c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134480: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x134484: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x134488: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134490);
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134490
// Address: 0x134490 - 0x1344b8

void entry_134490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134490: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x134494: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x134498: 0x24067b45
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31557));
    // 0x13449c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1344a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1344a4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1344a8: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1344ac: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x1344b0: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1344b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1344b8
// Address: 0x1344b8 - 0x1344dc

void entry_1344b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1344b8: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1344bc: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1344c0: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1344c4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1344c8: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1344cc: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1344d0: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1344d4: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1344dc);
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1344dc
// Address: 0x1344dc - 0x1344fc

void entry_1344dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1344dc: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1344e0: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1344e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1344e8: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x1344ec: 0x24067b62
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31586));
    // 0x1344f0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1344f4: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1344fc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1344fc
// Address: 0x1344fc - 0x134508

void entry_1344fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1344fc) {
        switch (ctx->pc) {
            case 0x134500: ctx->pc = 0; goto label_134500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1344fc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_134500:
    // 0x134500: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x134508);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4736));
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_134508
// Address: 0x134508 - 0x134520

void entry_134508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134508: 0x461dbd82
    ctx->f[22] = FPU_MUL_S(ctx->f[23], ctx->f[29]);
    // 0x13450c: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x134510: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x134514: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134518: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134520);
    ctx->f[21] = FPU_ADD_S(ctx->f[20], ctx->f[28]);
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134520
// Address: 0x134520 - 0x134560

void entry_134520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134520: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x134524: 0x461aa502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[26]);
    // 0x134528: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13452c: 0x461bb580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[27]);
    // 0x134530: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134534: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134538: 0x461ebdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[30]);
    // 0x13453c: 0x4619a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[25]);
    // 0x134540: 0x4618b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[24]);
    // 0x134544: 0x4618a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[24]);
    // 0x134548: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x13454c: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x134550: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x134554: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x134558: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x134560);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134560
// Address: 0x134560 - 0x13456c

void entry_134560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134560: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134564: 0xc058516
    SET_GPR_U32(ctx, 31, 0x13456c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_13456c
// Address: 0x13456c - 0x134594

void entry_13456c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13456c: 0x461aad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[26]);
    // 0x134570: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x134574: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134578: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13457c: 0x4619ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[25]);
    // 0x134580: 0x4618ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[24]);
    // 0x134584: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x134588: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x13458c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x134594);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134594
// Address: 0x134594 - 0x1345bc

void entry_134594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134594: 0x2a420018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 24));
    // 0x134598: 0x5440ffd9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x134500; return;
    }
    // 0x1345a0: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1345a4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1345a8: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x1345ac: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x1345b0: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1345b4: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1345bc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1345bc
// Address: 0x1345bc - 0x1345e4

void entry_1345bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1345bc: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1345c0: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x1345c4: 0x24067b45
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31557));
    // 0x1345c8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1345cc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1345d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1345d4: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1345d8: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1345dc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1345e4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1345e4
// Address: 0x1345e4 - 0x134600

void entry_1345e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1345e4: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1345e8: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x1345ec: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1345f0: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1345f4: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1345f8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134600);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134600
// Address: 0x134600 - 0x13462c

void entry_134600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134600: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x134604: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x134608: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x13460c: 0x24067b62
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31586));
    // 0x134610: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134614: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134618: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13461c: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x134620: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x134624: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x13462c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13462c
// Address: 0x13462c - 0x134638

void entry_13462c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13462c: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x134630: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134638);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134638
// Address: 0x134638 - 0x134650

void entry_134638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134638: 0x340680fa
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 33018));
    // 0x13463c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134640: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134644: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134648: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x134650);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134650
// Address: 0x134650 - 0x13465c

void entry_134650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134650: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134654: 0xc058516
    SET_GPR_U32(ctx, 31, 0x13465c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_13465c
// Address: 0x13465c - 0x134674

void entry_13465c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13465c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134660: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x134664: 0x340680dd
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32989));
    // 0x134668: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13466c: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x134674);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134674
// Address: 0x134674 - 0x134680

void entry_134674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134674) {
        switch (ctx->pc) {
            case 0x134678: ctx->pc = 0; goto label_134678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134674: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_134678:
    // 0x134678: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x134680);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4784));
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_134680
// Address: 0x134680 - 0x134698

void entry_134680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134680: 0x461dbd82
    ctx->f[22] = FPU_MUL_S(ctx->f[23], ctx->f[29]);
    // 0x134684: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x134688: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x13468c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134690: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134698);
    ctx->f[21] = FPU_SUB_S(ctx->f[20], ctx->f[28]);
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134698
// Address: 0x134698 - 0x1346d8

void entry_134698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134698: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x13469c: 0x461aa502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[26]);
    // 0x1346a0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1346a4: 0x461bb580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[27]);
    // 0x1346a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1346ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1346b0: 0x461ebdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[30]);
    // 0x1346b4: 0x4619a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[25]);
    // 0x1346b8: 0x4618b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[24]);
    // 0x1346bc: 0x4618a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[24]);
    // 0x1346c0: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x1346c4: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x1346c8: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1346cc: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1346d0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1346d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1346d8
// Address: 0x1346d8 - 0x1346e4

void entry_1346d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1346d8: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1346dc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1346e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1346e4
// Address: 0x1346e4 - 0x13470c

void entry_1346e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1346e4: 0x461aad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[26]);
    // 0x1346e8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1346ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1346f0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1346f4: 0x4619ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[25]);
    // 0x1346f8: 0x4618ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[24]);
    // 0x1346fc: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x134700: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x134704: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x13470c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13470c
// Address: 0x13470c - 0x134734

void entry_13470c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13470c: 0x2a420018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 24));
    // 0x134710: 0x5440ffd9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x134678; return;
    }
    // 0x134718: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13471c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134720: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x134724: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x134728: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x13472c: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134734);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134734
// Address: 0x134734 - 0x13475c

void entry_134734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134734: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x134738: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x13473c: 0x340680fa
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 33018));
    // 0x134740: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134744: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134748: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13474c: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x134750: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x134754: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x13475c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13475c
// Address: 0x13475c - 0x134778

void entry_13475c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13475c: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x134760: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x134764: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134768: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x13476c: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x134770: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134778);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134778
// Address: 0x134778 - 0x1347a4

void entry_134778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134778: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x13477c: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x134780: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x134784: 0x340680dd
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32989));
    // 0x134788: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13478c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134790: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134794: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x134798: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x13479c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1347a4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1347a4
// Address: 0x1347a4 - 0x1347b0

void entry_1347a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1347a4: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1347a8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1347b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1347b0
// Address: 0x1347b0 - 0x1347c8

void entry_1347b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1347b0: 0x24067b62
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31586));
    // 0x1347b4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1347b8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1347bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1347c0: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1347c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1347c8
// Address: 0x1347c8 - 0x1347d4

void entry_1347c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1347c8: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1347cc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1347d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1347d4
// Address: 0x1347d4 - 0x1347ec

void entry_1347d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1347d4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1347d8: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x1347dc: 0x24067b80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31616));
    // 0x1347e0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1347e4: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1347ec);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1347ec
// Address: 0x1347ec - 0x1347f8

void entry_1347ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1347ec) {
        switch (ctx->pc) {
            case 0x1347f0: ctx->pc = 0; goto label_1347f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1347ec: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1347f0:
    // 0x1347f0: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x1347f8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4736));
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_1347f8
// Address: 0x1347f8 - 0x134810

void entry_1347f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1347f8: 0x461cbd42
    ctx->f[21] = FPU_MUL_S(ctx->f[23], ctx->f[28]);
    // 0x1347fc: 0x461a0500
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x134800: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134804: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134808: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134810);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134810
// Address: 0x134810 - 0x134850

void entry_134810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134810: 0x461ebdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[30]);
    // 0x134814: 0x4619a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x134818: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13481c: 0x461bad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[27]);
    // 0x134820: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134824: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134828: 0x461aa500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[26]);
    // 0x13482c: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x134830: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x134834: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x134838: 0x4600a864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[21]);
    // 0x13483c: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x134840: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x134844: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x134848: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x134850);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134850
// Address: 0x134850 - 0x13485c

void entry_134850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134850: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x134854: 0xc058516
    SET_GPR_U32(ctx, 31, 0x13485c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_13485c
// Address: 0x13485c - 0x134884

void entry_13485c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13485c: 0x4619a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x134860: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x134864: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134868: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13486c: 0x4618a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
    // 0x134870: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x134874: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x134878: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x13487c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x134884);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134884
// Address: 0x134884 - 0x1348ac

void entry_134884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134884: 0x2a420018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 24));
    // 0x134888: 0x5440ffd9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x1347F0; return;
    }
    // 0x134890: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134894: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134898: 0x3c013d2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15658 << 16));
    // 0x13489c: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x1348a0: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1348a4: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1348ac);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1348ac
// Address: 0x1348ac - 0x1348d4

void entry_1348ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1348ac: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1348b0: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1348b4: 0x24067b62
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31586));
    // 0x1348b8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1348bc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1348c0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1348c4: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1348c8: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1348cc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1348d4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1348d4
// Address: 0x1348d4 - 0x1348f0

void entry_1348d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1348d4: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1348d8: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x1348dc: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1348e0: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1348e4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1348e8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1348f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1348f0
// Address: 0x1348f0 - 0x13491c

void entry_1348f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1348f0: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1348f4: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1348f8: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1348fc: 0x24067b80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31616));
    // 0x134900: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134904: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134908: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13490c: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x134910: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x134914: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x13491c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_13491c
// Address: 0x13491c - 0x134928

void entry_13491c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13491c: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134920: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134928);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134928
// Address: 0x134928 - 0x134940

void entry_134928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134928: 0x340680dd
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32989));
    // 0x13492c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134930: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134934: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134938: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x134940);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134940
// Address: 0x134940 - 0x13494c

void entry_134940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134940: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x134944: 0xc058516
    SET_GPR_U32(ctx, 31, 0x13494c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_13494c
// Address: 0x13494c - 0x134964

void entry_13494c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13494c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134950: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x134954: 0x340680c0
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32960));
    // 0x134958: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13495c: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x134964);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134964
// Address: 0x134964 - 0x134970

void entry_134964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134964) {
        switch (ctx->pc) {
            case 0x134968: ctx->pc = 0; goto label_134968;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134964: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_134968:
    // 0x134968: 0xc04c400
    SET_GPR_U32(ctx, 31, 0x134970);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4784));
    GEvaluateBei(rdram, ctx, runtime); return;
}


// Function: entry_134970
// Address: 0x134970 - 0x134988

void entry_134970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134970: 0x461cbd42
    ctx->f[21] = FPU_MUL_S(ctx->f[23], ctx->f[28]);
    // 0x134974: 0x461a0501
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[26]);
    // 0x134978: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13497c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134980: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134988);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134988
// Address: 0x134988 - 0x1349c8

void entry_134988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134988: 0x461ebdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[30]);
    // 0x13498c: 0x4619a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x134990: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134994: 0x461bad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[27]);
    // 0x134998: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13499c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1349a0: 0x461aa501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[26]);
    // 0x1349a4: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1349a8: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x1349ac: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1349b0: 0x4600a864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1349b4: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1349b8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1349bc: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1349c0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1349c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1349c8
// Address: 0x1349c8 - 0x1349d4

void entry_1349c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1349c8: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1349cc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1349d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1349d4
// Address: 0x1349d4 - 0x1349fc

void entry_1349d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1349d4: 0x4619a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x1349d8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1349dc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1349e0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1349e4: 0x4618a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
    // 0x1349e8: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x1349ec: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1349f0: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1349f4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1349fc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1349fc
// Address: 0x1349fc - 0x134a14

void entry_1349fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1349fc: 0x2a420018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 24));
    // 0x134a00: 0x5440ffd9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x134968; return;
    }
    // 0x134a08: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134a0c: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134a14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134a14
// Address: 0x134a14 - 0x134a2c

void entry_134a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134a14: 0x340680dd
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32989));
    // 0x134a18: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134a1c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134a20: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134a24: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x134a2c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134a2c
// Address: 0x134a2c - 0x134a38

void entry_134a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134a2c: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x134a30: 0xc058516
    SET_GPR_U32(ctx, 31, 0x134a38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_134a38
// Address: 0x134a38 - 0x134a50

void entry_134a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134a38: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x134a3c: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x134a40: 0x340680c0
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32960));
    // 0x134a44: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134a48: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x134a50);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_134a50
// Address: 0x134a50 - 0x134aa0

void entry_134a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134a50: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x134a54: 0x7bb400f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x134a58: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x134a5c: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x134a60: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x134a64: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x134a68: 0xc7be0160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[30] = *(float*)&val; }
    // 0x134a6c: 0xc7bd0158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[29] = *(float*)&val; }
    // 0x134a70: 0xc7bc0150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[28] = *(float*)&val; }
    // 0x134a74: 0xc7bb0148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[27] = *(float*)&val; }
    // 0x134a78: 0xc7ba0140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[26] = *(float*)&val; }
    // 0x134a7c: 0xc7b90138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[25] = *(float*)&val; }
    // 0x134a80: 0xc7b80130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[24] = *(float*)&val; }
    // 0x134a84: 0xc7b70128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[23] = *(float*)&val; }
    // 0x134a88: 0xc7b60120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[22] = *(float*)&val; }
    // 0x134a8c: 0xc7b50118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[21] = *(float*)&val; }
    // 0x134a90: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x134a94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 368));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x134a9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x134aa0; return;
}


// Function: FUN_00134aa0
// Address: 0x134aa0 - 0x134abc

void FUN_00134aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134aa0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x134aa4: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x134aa8: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x134aac: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x134ab0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x134ab4: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x134abc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_134abc
// Address: 0x134abc - 0x134ac8

void entry_134abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134abc: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x134ac0: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x134ac8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_134ac8
// Address: 0x134ac8 - 0x134b48

void entry_134ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134ac8) {
        switch (ctx->pc) {
            case 0x134b28: ctx->pc = 0; goto label_134b28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134ac8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x134acc: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x134ad0: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x134ad4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x134ad8: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x134adc: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x134ae0: 0x4be208ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134ae4: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134ae8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134aec: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x134af0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134af4: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x134af8: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x134afc: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x134b00: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x134b04: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x134b08: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x134b0c: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x134b10: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x134b14: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x134b18: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x134b1c: 0x0
    // NOP
    // 0x134b20: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_134b28;
    }
label_134b28:
    // 0x134b28: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x134b2c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x134b30: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x134b34: 0x64100b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    // 0x134b38: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x134b3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x134b44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x134b48; return;
}


// Function: FUN_00134b48
// Address: 0x134b48 - 0x134bd0

void FUN_00134b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134b48: 0x27bdfcd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966480));
    // 0x134b4c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x134b50: 0x7fb60290
    WRITE128(ADD32(GPR_U32(ctx, 29), 656), GPR_VEC(ctx, 22));
    // 0x134b54: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134b58: 0x7fb50280
    WRITE128(ADD32(GPR_U32(ctx, 29), 640), GPR_VEC(ctx, 21));
    // 0x134b5c: 0x80b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x134b60: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x134b64: 0xa0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x134b68: 0x7fb702a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 672), GPR_VEC(ctx, 23));
    // 0x134b6c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x134b70: 0x7fb00230
    WRITE128(ADD32(GPR_U32(ctx, 29), 560), GPR_VEC(ctx, 16));
    // 0x134b74: 0x24060082
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 130));
    // 0x134b78: 0xe7b402d0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 720), *(uint32_t*)&val); }
    // 0x134b7c: 0x24080020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 32));
    // 0x134b80: 0x7fbf02c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 704), GPR_VEC(ctx, 31));
    // 0x134b84: 0x3a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x134b88: 0x7fbe02b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 688), GPR_VEC(ctx, 30));
    // 0x134b8c: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134b90: 0x7fb40270
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), GPR_VEC(ctx, 20));
    // 0x134b94: 0x7fb30260
    WRITE128(ADD32(GPR_U32(ctx, 29), 608), GPR_VEC(ctx, 19));
    // 0x134b98: 0x7fb20250
    WRITE128(ADD32(GPR_U32(ctx, 29), 592), GPR_VEC(ctx, 18));
    // 0x134b9c: 0x7fb10240
    WRITE128(ADD32(GPR_U32(ctx, 29), 576), GPR_VEC(ctx, 17));
    // 0x134ba0: 0xe7be0320
    { float val = ctx->f[30]; WRITE32(ADD32(GPR_U32(ctx, 29), 800), *(uint32_t*)&val); }
    // 0x134ba4: 0xe7bd0318
    { float val = ctx->f[29]; WRITE32(ADD32(GPR_U32(ctx, 29), 792), *(uint32_t*)&val); }
    // 0x134ba8: 0xe7bc0310
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 784), *(uint32_t*)&val); }
    // 0x134bac: 0xe7bb0308
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 776), *(uint32_t*)&val); }
    // 0x134bb0: 0xe7ba0300
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 768), *(uint32_t*)&val); }
    // 0x134bb4: 0xe7b902f8
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 760), *(uint32_t*)&val); }
    // 0x134bb8: 0xe7b802f0
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 752), *(uint32_t*)&val); }
    // 0x134bbc: 0xe7b702e8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 744), *(uint32_t*)&val); }
    // 0x134bc0: 0xe7b602e0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 736), *(uint32_t*)&val); }
    // 0x134bc4: 0xe7b502d8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 728), *(uint32_t*)&val); }
    // 0x134bc8: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x134bd0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 496), GPR_U32(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_134bd0
// Address: 0x134bd0 - 0x134bec

void entry_134bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134bd0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x134bd4: 0x3c070013
    SET_GPR_U32(ctx, 7, ((uint32_t)19 << 16));
    // 0x134bd8: 0x24e74aa0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 19104));
    // 0x134bdc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x134be0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x134be4: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x134bec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_134bec
// Address: 0x134bec - 0x134c2c

void entry_134bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134bec) {
        switch (ctx->pc) {
            case 0x134c20: ctx->pc = 0; goto label_134c20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134bec: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x134bf0: 0x1a000051
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294941944)); ctx->f[20] = *(float*)&val; }
    if (GPR_S32(ctx, 16) <= 0) {
        ctx->pc = 0x134D38; return;
    }
    // 0x134bf8: 0x4be00053
    // Unhandled VU0 Special1 function: 0x13
    // 0x134bfc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x134c00: 0xfba10200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x134c04: 0x245e1190
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 2), 4496));
    // 0x134c08: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x134c0c: 0x27b40080
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 128));
    // 0x134c10: 0x3a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x134c14: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x134c18: 0x8e700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x134c1c: 0x0
    // NOP
label_134c20:
    // 0x134c20: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x134c24: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x134c2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_134c2c
// Address: 0x134c2c - 0x134cd0

void entry_134c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134c2c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x134c30: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x134c34: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x134c38: 0x3c01457a
    SET_GPR_U32(ctx, 1, ((uint32_t)17786 << 16));
    // 0x134c3c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x134c40: 0xd8820040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x134c44: 0x4be2216c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x134c48: 0x4bc5286a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x134c4c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x134c50: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134c54: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x134c58: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134c5c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x134c60: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x134c64: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x134c68: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x134c6c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x134c70: 0x0
    // NOP
    // 0x134c74: 0x4503002d
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
        ctx->pc = 0x134D2C; return;
    }
    // 0x134c7c: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x134c80: 0xdba60200
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x134c84: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x134c88: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x134c8c: 0xd8830050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 80)));
    // 0x134c90: 0xd8820060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 96)));
    // 0x134c94: 0xd8810070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 112)));
    // 0x134c98: 0x4be519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x134c9c: 0x4be510bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x134ca0: 0x4be508be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x134ca4: 0x4be430fc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x134ca8: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x134cac: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x134cb0: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x134cb4: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x134cb8: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x134cbc: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x134cc0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 16));
        ctx->pc = 0x134CD8; return;
    }
    // 0x134cc8: 0xc064864
    SET_GPR_U32(ctx, 31, 0x134cd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00192190__FP3PNT(rdram, ctx, runtime); return;
}


// Function: entry_134cd0
// Address: 0x134cd0 - 0x134ce8

void entry_134cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134cd0) {
        switch (ctx->pc) {
            case 0x134cd8: ctx->pc = 0; goto label_134cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134cd0: 0x10000016
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x134D2C; return;
    }
label_134cd8:
    // 0x134cd8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x134cdc: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x134ce0: 0xc051070
    SET_GPR_U32(ctx, 31, 0x134ce8);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_134ce8
// Address: 0x134ce8 - 0x134dbc

void entry_134ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134ce8) {
        switch (ctx->pc) {
            case 0x134d2c: ctx->pc = 0; goto label_134d2c;
            case 0x134d38: ctx->pc = 0; goto label_134d38;
            case 0x134da8: ctx->pc = 0; goto label_134da8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134ce8: 0x26f70001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 1));
    // 0x134cec: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x134cf0: 0xdbc20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x134cf4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134cf8: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134cfc: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134d00: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134d04: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x134d08: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x134d0c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x134d10: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x134d14: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x134d18: 0x0
    // NOP
    // 0x134d1c: 0x45000003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_134d2c;
    }
    // 0x134d24: 0xafb001f0
    WRITE32(ADD32(GPR_U32(ctx, 29), 496), GPR_U32(ctx, 16));
    // 0x134d28: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
label_134d2c:
    // 0x134d2c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x134d30: 0x5620ffbb
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x134C20; return;
    }
label_134d38:
    // 0x134d38: 0x1ae00123
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 23) <= 0) {
        ctx->pc = 0x1351C8; return;
    }
    // 0x134d40: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x134d44: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x134d48: 0x247e11a0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 3), 4512));
    // 0x134d4c: 0x24541858
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x134d50: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x134d54: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x134d58: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x134d5c: 0x27a201d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 464));
    // 0x134d60: 0x27a301b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 432));
    // 0x134d64: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x134d68: 0x4481f000
    *(uint32_t*)&ctx->f[30] = GPR_U32(ctx, 1);
    // 0x134d6c: 0xafa5021c
    WRITE32(ADD32(GPR_U32(ctx, 29), 540), GPR_U32(ctx, 5));
    // 0x134d70: 0x27b200b0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 176));
    // 0x134d74: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x134d78: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x134d7c: 0x3c130026
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    // 0x134d80: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x134d84: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x134d88: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x134d8c: 0xafa60220
    WRITE32(ADD32(GPR_U32(ctx, 29), 544), GPR_U32(ctx, 6));
    // 0x134d90: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x134d94: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x134d98: 0xafa70210
    WRITE32(ADD32(GPR_U32(ctx, 29), 528), GPR_U32(ctx, 7));
    // 0x134d9c: 0xafa20218
    WRITE32(ADD32(GPR_U32(ctx, 29), 536), GPR_U32(ctx, 2));
    // 0x134da0: 0xafa30214
    WRITE32(ADD32(GPR_U32(ctx, 29), 532), GPR_U32(ctx, 3));
    // 0x134da4: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
label_134da8:
    // 0x134da8: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x134dac: 0x3a31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    // 0x134db0: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x134db4: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x134dbc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_134dbc
// Address: 0x134dbc - 0x134e14

void entry_134dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134dbc) {
        switch (ctx->pc) {
            case 0x134dc8: ctx->pc = 0; goto label_134dc8;
            case 0x134de8: ctx->pc = 0; goto label_134de8;
            case 0x134dfc: ctx->pc = 0; goto label_134dfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134dbc: 0x8e050050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x134dc0: 0x27a600b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 176));
    // 0x134dc4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_134dc8:
    // 0x134dc8: 0x80a30000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x134dcc: 0x1060000b
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_134dfc;
    }
    // 0x134dd4: 0x2402005f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 95));
    // 0x134dd8: 0x54620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 4));
        goto label_134de8;
    }
    // 0x134de0: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x134de4: 0xa0c20000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 2));
label_134de8:
    // 0x134de8: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x134dec: 0xd21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 18)));
    // 0x134df0: 0x2c4200ff
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 255));
    // 0x134df4: 0x1440fff4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_134dc8;
    }
label_134dfc:
    // 0x134dfc: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x134e00: 0x8ca41990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 6544)));
    // 0x134e04: 0x8fa5021c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 540)));
    // 0x134e08: 0xa0c00000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x134e0c: 0xc051070
    SET_GPR_U32(ctx, 31, 0x134e14);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 544)));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_134e14
// Address: 0x134e14 - 0x134ec4

void entry_134e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134e14) {
        switch (ctx->pc) {
            case 0x134e7c: ctx->pc = 0; goto label_134e7c;
            case 0x134e90: ctx->pc = 0; goto label_134e90;
            case 0x134ea8: ctx->pc = 0; goto label_134ea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134e14: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x134e18: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x134e1c: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134e20: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134e24: 0xc7c20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 8)); ctx->f[2] = *(float*)&val; }
    // 0x134e28: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x134e2c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x134e30: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x134e34: 0xc7c10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4)); ctx->f[1] = *(float*)&val; }
    // 0x134e38: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x134e3c: 0xc46311a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4512)); ctx->f[3] = *(float*)&val; }
    // 0x134e40: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x134e44: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x134e48: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x134e4c: 0xc4c45c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x134e50: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x134e54: 0x24e75c60
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 23648));
    // 0x134e58: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x134e5c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x134e60: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x134e64: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x134e68: 0x0
    // NOP
    // 0x134e6c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_134e7c;
    }
    // 0x134e74: 0x10000006
    ctx->f[13] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134e90;
    }
label_134e7c:
    // 0x134e7c: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x134e80: 0x0
    // NOP
    // 0x134e84: 0x45000002
    ctx->f[13] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_134e90;
    }
    // 0x134e8c: 0x46002b46
    ctx->f[13] = FPU_MOV_S(ctx->f[5]);
label_134e90:
    // 0x134e90: 0x8fa501f0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x134e94: 0x12050004
    ctx->f[23] = FPU_MOV_S(ctx->f[13]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 5)) {
        goto label_134ea8;
    }
    // 0x134e9c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x134ea0: 0xc44011bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4540)); ctx->f[0] = *(float*)&val; }
    // 0x134ea4: 0x4600bdc2
    ctx->f[23] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
label_134ea8:
    // 0x134ea8: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x134eac: 0xc60c0054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 84)); ctx->f[12] = *(float*)&val; }
    // 0x134eb0: 0xc68e0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 20)); ctx->f[14] = *(float*)&val; }
    // 0x134eb4: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x134eb8: 0x24c411b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 4528));
    // 0x134ebc: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x134ec4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_134ec4
// Address: 0x134ec4 - 0x134f08

void entry_134ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x134ec4) {
        switch (ctx->pc) {
            case 0x134ee0: ctx->pc = 0; goto label_134ee0;
            case 0x134ee4: ctx->pc = 0; goto label_134ee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x134ec4: 0xe6000054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
    // 0x134ec8: 0x8fa701f0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x134ecc: 0x16070004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 7)) {
        goto label_134ee0;
    }
    // 0x134ed4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x134ed8: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4484)); ctx->f[13] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_134ee4;
    }
label_134ee0:
    // 0x134ee0: 0xc44d1188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4488)); ctx->f[13] = *(float*)&val; }
label_134ee4:
    // 0x134ee4: 0xc68e0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 20)); ctx->f[14] = *(float*)&val; }
    // 0x134ee8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x134eec: 0xc60c0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[12] = *(float*)&val; }
    // 0x134ef0: 0x244411c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4544));
    // 0x134ef4: 0x3c01c376
    SET_GPR_U32(ctx, 1, ((uint32_t)50038 << 16));
    // 0x134ef8: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x134efc: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x134f00: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x134f08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_134f08
// Address: 0x134f08 - 0x134f30

void entry_134f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134f08: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x134f0c: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x134f10: 0xe6000058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 88), *(uint32_t*)&val); }
    // 0x134f14: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x134f18: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x134f1c: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x134f20: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x134f24: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x134f28: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x134f30);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_134f30
// Address: 0x134f30 - 0x134f40

void entry_134f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134f30: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x134f34: 0x27a401b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 432));
    // 0x134f38: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x134f40);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_134f40
// Address: 0x134f40 - 0x134f5c

void entry_134f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134f40: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x134f44: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x134f48: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x134f4c: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x134f50: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x134f54: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x134f5c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 432));
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_134f5c
// Address: 0x134f5c - 0x134f74

void entry_134f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134f5c: 0x3c02ff80
    SET_GPR_U32(ctx, 2, ((uint32_t)65408 << 16));
    // 0x134f60: 0x8fa50210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x134f64: 0x34428080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32896));
    // 0x134f68: 0x27a401b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 432));
    // 0x134f6c: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x134f74);
    WRITE32(ADD32(GPR_U32(ctx, 29), 160), GPR_U32(ctx, 2));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_134f74
// Address: 0x134f74 - 0x134f80

void entry_134f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134f74: 0x27a401b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 432));
    // 0x134f78: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x134f80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_134f80
// Address: 0x134f80 - 0x134f8c

void entry_134f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134f80: 0x27a401b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 432));
    // 0x134f84: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x134f8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_134f8c
// Address: 0x134f8c - 0x134fa4

void entry_134f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134f8c: 0xc66011cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4556)); ctx->f[0] = *(float*)&val; }
    // 0x134f90: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x134f94: 0xc60c0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[12] = *(float*)&val; }
    // 0x134f98: 0x8ec40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    // 0x134f9c: 0xc05712a
    SET_GPR_U32(ctx, 31, 0x134fa4);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    DyWrapPchz__5CFontPcf(rdram, ctx, runtime); return;
}


// Function: entry_134fa4
// Address: 0x134fa4 - 0x13504c

void entry_134fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x134fa4: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x134fa8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x134fac: 0xc7a00094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[0] = *(float*)&val; }
    // 0x134fb0: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x134fb4: 0xc6050058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[5] = *(float*)&val; }
    // 0x134fb8: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x134fbc: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x134fc0: 0xc7a10090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[1] = *(float*)&val; }
    // 0x134fc4: 0xc46311d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4564)); ctx->f[3] = *(float*)&val; }
    // 0x134fc8: 0x46180842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[24]);
    // 0x134fcc: 0xc4a211d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4560)); ctx->f[2] = *(float*)&val; }
    // 0x134fd0: 0x460518c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[5]);
    // 0x134fd4: 0xc66411cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4556)); ctx->f[4] = *(float*)&val; }
    // 0x134fd8: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x134fdc: 0x46180840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[24]);
    // 0x134fe0: 0x46051082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[5]);
    // 0x134fe4: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x134fe8: 0x46020d40
    ctx->f[21] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x134fec: 0x46160501
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[22]);
    // 0x134ff0: 0xe7b501b0
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 432), *(uint32_t*)&val); }
    // 0x134ff4: 0xe7b401b4
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 436), *(uint32_t*)&val); }
    // 0x134ff8: 0xc6000058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[0] = *(float*)&val; }
    // 0x134ffc: 0xe7b601bc
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 444), *(uint32_t*)&val); }
    // 0x135000: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x135004: 0xe7a401b8
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 440), *(uint32_t*)&val); }
    // 0x135008: 0x24c51168
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 4456));
    // 0x13500c: 0x68a70007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x135010: 0x6ca70000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x135014: 0x68a2000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x135018: 0x6ca20008
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x13501c: 0x68a30017
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x135020: 0x6ca30010
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x135024: 0xb3a701d7
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 471); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x135028: 0xb7a701d0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 464); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13502c: 0xb3a201df
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 479); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x135030: 0xb7a201d8
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 472); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x135034: 0xb3a301e7
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 487); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x135038: 0xb7a301e0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 480); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13503c: 0x8ca70018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x135040: 0xafa701e8
    WRITE32(ADD32(GPR_U32(ctx, 29), 488), GPR_U32(ctx, 7));
    // 0x135044: 0xc057070
    SET_GPR_U32(ctx, 31, 0x13504c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_13504c
// Address: 0x13504c - 0x1350b4

void entry_13504c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13504c: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x135050: 0xc7a101d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[1] = *(float*)&val; }
    // 0x135054: 0x93a201eb
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 491)));
    // 0x135058: 0xafa801d0
    WRITE32(ADD32(GPR_U32(ctx, 29), 464), GPR_U32(ctx, 8));
    // 0x13505c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x135060: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x135064: 0xc7a201dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 476)); ctx->f[2] = *(float*)&val; }
    // 0x135068: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x13506c: 0x460000e4
    *(int32_t*)&ctx->f[3] = FPU_CVT_W_S(ctx->f[0]);
    // 0x135070: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x135074: 0xa3a201eb
    WRITE8(ADD32(GPR_U32(ctx, 29), 491), (uint8_t)GPR_U32(ctx, 2));
    // 0x135078: 0xc6000058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[0] = *(float*)&val; }
    // 0x13507c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x135080: 0xe7a101d8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 472), *(uint32_t*)&val); }
    // 0x135084: 0xc6000058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[0] = *(float*)&val; }
    // 0x135088: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x13508c: 0x11000009
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 476), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1350b4(rdram, ctx, runtime); return;
    }
    // 0x135094: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x135098: 0x27a601b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 432));
    // 0x13509c: 0x8fa50218
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 536)));
    // 0x1350a0: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1350a4: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1350a8: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1350ac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1350b4);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1350b4
// Address: 0x1350b4 - 0x1350e8

void entry_1350b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1350b4: 0x93a201c3
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 451)));
    // 0x1350b8: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1350bc: 0x8fa60214
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 532)));
    // 0x1350c0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1350c4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1350c8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1350cc: 0x8ec40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    // 0x1350d0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1350d4: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1350d8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1350dc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1350e0: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1350e8);
    WRITE8(ADD32(GPR_U32(ctx, 29), 451), (uint8_t)GPR_U32(ctx, 2));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1350e8
// Address: 0x1350e8 - 0x1350fc

void entry_1350e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1350e8: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1350ec: 0x24070441
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1089));
    // 0x1350f0: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1350f4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1350fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 193));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1350fc
// Address: 0x1350fc - 0x13510c

void entry_1350fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1350fc: 0x8ec20210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 528)));
    // 0x135100: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x135104: 0xc058516
    SET_GPR_U32(ctx, 31, 0x13510c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_13510c
// Address: 0x13510c - 0x135168

void entry_13510c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13510c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x135110: 0xc6030058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[3] = *(float*)&val; }
    // 0x135114: 0xc44211dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4572)); ctx->f[2] = *(float*)&val; }
    // 0x135118: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13511c: 0xc46011d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4568)); ctx->f[0] = *(float*)&val; }
    // 0x135120: 0x4616a040
    ctx->f[1] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
    // 0x135124: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x135128: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x13512c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x135130: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135134: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x135138: 0x4600a800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x13513c: 0x461d0842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[29]);
    // 0x135140: 0x461e0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[30]);
    // 0x135144: 0x461c0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[28]);
    // 0x135148: 0x46190002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[25]);
    // 0x13514c: 0x46190842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[25]);
    // 0x135150: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x135154: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x135158: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x13515c: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x135160: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x135168);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_135168
// Address: 0x135168 - 0x1351b4

void entry_135168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135168: 0xc7a00094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[0] = *(float*)&val; }
    // 0x13516c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x135170: 0xc7a10090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[1] = *(float*)&val; }
    // 0x135174: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135178: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x13517c: 0x46180842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[24]);
    // 0x135180: 0x461a0500
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x135184: 0x46180d40
    ctx->f[21] = FPU_ADD_S(ctx->f[1], ctx->f[24]);
    // 0x135188: 0x461da002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[29]);
    // 0x13518c: 0x461ea840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[30]);
    // 0x135190: 0x461c0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[28]);
    // 0x135194: 0x46190842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[25]);
    // 0x135198: 0x46190002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[25]);
    // 0x13519c: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1351a0: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1351a4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1351a8: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1351ac: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1351b4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1351b4
// Address: 0x1351b4 - 0x1351bc

void entry_1351b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1351b4: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1351bc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1351bc
// Address: 0x1351bc - 0x135228

void entry_1351bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1351bc) {
        switch (ctx->pc) {
            case 0x1351c8: ctx->pc = 0; goto label_1351c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1351bc: 0x237102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 23)));
    // 0x1351c0: 0x1440fef9
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x134DA8; return;
    }
label_1351c8:
    // 0x1351c8: 0x7bbf02c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 704)));
    // 0x1351cc: 0x7bbe02b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 688)));
    // 0x1351d0: 0x7bb702a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 672)));
    // 0x1351d4: 0x7bb60290
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 656)));
    // 0x1351d8: 0x7bb50280
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 640)));
    // 0x1351dc: 0x7bb40270
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x1351e0: 0x7bb30260
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x1351e4: 0x7bb20250
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x1351e8: 0x7bb10240
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x1351ec: 0x7bb00230
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x1351f0: 0xc7be0320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 800)); ctx->f[30] = *(float*)&val; }
    // 0x1351f4: 0xc7bd0318
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 792)); ctx->f[29] = *(float*)&val; }
    // 0x1351f8: 0xc7bc0310
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 784)); ctx->f[28] = *(float*)&val; }
    // 0x1351fc: 0xc7bb0308
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 776)); ctx->f[27] = *(float*)&val; }
    // 0x135200: 0xc7ba0300
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 768)); ctx->f[26] = *(float*)&val; }
    // 0x135204: 0xc7b902f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 760)); ctx->f[25] = *(float*)&val; }
    // 0x135208: 0xc7b802f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 752)); ctx->f[24] = *(float*)&val; }
    // 0x13520c: 0xc7b702e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 744)); ctx->f[23] = *(float*)&val; }
    // 0x135210: 0xc7b602e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 736)); ctx->f[22] = *(float*)&val; }
    // 0x135214: 0xc7b502d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 728)); ctx->f[21] = *(float*)&val; }
    // 0x135218: 0xc7b402d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 720)); ctx->f[20] = *(float*)&val; }
    // 0x13521c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 816));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x135224: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x135228; return;
}


// Function: DrawBinocFilter
// Address: 0x135228 - 0x135290

void entry_135290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135290: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x135294: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1352a4(rdram, ctx, runtime); return;
    }
    // 0x13529c: 0xc04d2d2
    SET_GPR_U32(ctx, 31, 0x1352a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FUN_00134b48(rdram, ctx, runtime); return;
}


// Function: entry_1352a4
// Address: 0x1352a4 - 0x1352ac

void entry_1352a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1352a4: 0xc05834c
    SET_GPR_U32(ctx, 31, 0x1352ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    GetBlueprintInfo__FPiT0(rdram, ctx, runtime); return;
}


// Function: entry_1352ac
// Address: 0x1352ac - 0x1352b4

void entry_1352ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1352ac: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1352b4);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1352b4
// Address: 0x1352b4 - 0x135310

void entry_1352b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1352b4: 0x8fa30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1352b8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1352bc: 0x1040008f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1354FC; return;
    }
    // 0x1352c4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1352c8: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1352cc: 0xc4601260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4704)); ctx->f[0] = *(float*)&val; }
    // 0x1352d0: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1352d4: 0x3c03ff40
    SET_GPR_U32(ctx, 3, ((uint32_t)65344 << 16));
    // 0x1352d8: 0x3c02ff40
    SET_GPR_U32(ctx, 2, ((uint32_t)65344 << 16));
    // 0x1352dc: 0x3c04ff40
    SET_GPR_U32(ctx, 4, ((uint32_t)65344 << 16));
    // 0x1352e0: 0x34426060
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 24672));
    // 0x1352e4: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1352e8: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x1352ec: 0x34638080
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 32896));
    // 0x1352f0: 0x34844040
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 16448));
    // 0x1352f4: 0x26020330
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 816));
    // 0x1352f8: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1352fc: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135300: 0xafa20044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 2));
    // 0x135304: 0x26150340
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 16), 832));
    // 0x135308: 0xc081484
    SET_GPR_U32(ctx, 31, 0x135310);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 4));
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_135310
// Address: 0x135310 - 0x135380

void entry_135310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135310) {
        switch (ctx->pc) {
            case 0x135338: ctx->pc = 0; goto label_135338;
            case 0x13535c: ctx->pc = 0; goto label_13535c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135310: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x135314: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x135318: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x13531c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x135320: 0x27be0030
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 48));
    // 0x135324: 0x27b70020
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 32));
    // 0x135328: 0x27b60010
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13532c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x135330: 0x46010680
    ctx->f[26] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x135334: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
label_135338:
    // 0x135338: 0x8fa40044
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x13533c: 0x2a38021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 3)));
    // 0x135340: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x135344: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x135348: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13534c: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13535c;
    }
    // 0x135354: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x135358: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
label_13535c:
    // 0x13535c: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x135360: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x135364: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135368: 0xc44e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[14] = *(float*)&val; }
    // 0x13536c: 0x26340001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 1));
    // 0x135370: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x135374: 0x119100
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 17), 4));
    // 0x135378: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x135380);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4712));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_135380
// Address: 0x135380 - 0x135460

void entry_135380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135380) {
        switch (ctx->pc) {
            case 0x1353a8: ctx->pc = 0; goto label_1353a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135380: 0x461ad841
    ctx->f[1] = FPU_SUB_S(ctx->f[27], ctx->f[26]);
    // 0x135384: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x135388: 0x4600d941
    ctx->f[5] = FPU_SUB_S(ctx->f[27], ctx->f[0]);
    // 0x13538c: 0x3c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x135390: 0x461a00c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[26]);
    // 0x135394: 0x2e0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x135398: 0x46010102
    ctx->f[4] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x13539c: 0x2c0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1353a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1353a4: 0x0
    // NOP
label_1353a8:
    // 0x1353a8: 0x1481021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 8)));
    // 0x1353ac: 0x1281821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 8)));
    // 0x1353b0: 0x90440000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1353b4: 0x3a82821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 8)));
    // 0x1353b8: 0x90660000
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1353bc: 0x1683821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 8)));
    // 0x1353c0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1353c4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1353c8: 0x90a20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1353cc: 0x44861000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 6);
    // 0x1353d0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1353d4: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x1353d8: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1353dc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1353e0: 0x29030004
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 8), 4));
    // 0x1353e4: 0x46002802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x1353e8: 0x46021882
    ctx->f[2] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x1353ec: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1353f0: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1353f4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1353f8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1353fc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x135400: 0x1460ffe9
    WRITE8(ADD32(GPR_U32(ctx, 7), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1353a8;
    }
    // 0x135408: 0x93a20033
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 51)));
    // 0x13540c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x135410: 0x2405004d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 77));
    // 0x135414: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x135418: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x13541c: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x135420: 0x34e74441
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17473));
    // 0x135424: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x135428: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x13542c: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x135430: 0xa3a20033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 2));
    // 0x135434: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x135438: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x13543c: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x135440: 0x244211e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4576));
    // 0x135444: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x135448: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x13544c: 0x3c0143cf
    SET_GPR_U32(ctx, 1, ((uint32_t)17359 << 16));
    // 0x135450: 0x3421e667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 58983));
    // 0x135454: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x135458: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x135460);
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_135460
// Address: 0x135460 - 0x13548c

void entry_135460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135460: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x135464: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x135468: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x13546c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x135470: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x135474: 0x24421220
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4640));
    // 0x135478: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13547c: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x135480: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x135484: 0xc058516
    SET_GPR_U32(ctx, 31, 0x13548c);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_13548c
// Address: 0x13548c - 0x1354e4

void entry_13548c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13548c) {
        switch (ctx->pc) {
            case 0x135498: ctx->pc = 0; goto label_135498;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13548c: 0x24120003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
    // 0x135490: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x135494: 0x0
    // NOP
label_135498:
    // 0x135498: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13549c: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1354a0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1354a4: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x1354a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1354ac: 0x46190840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[25]);
    // 0x1354b0: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1354b4: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x1354b8: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1354bc: 0x46180840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[24]);
    // 0x1354c0: 0x46150000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x1354c4: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1354c8: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1354cc: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1354d0: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1354d4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1354d8: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1354dc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1354e4);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1354e4
// Address: 0x1354e4 - 0x135550

void entry_1354e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1354e4) {
        switch (ctx->pc) {
            case 0x1354fc: ctx->pc = 0; goto label_1354fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1354e4: 0x643ffec
    if (GPR_S32(ctx, 18) >= 0) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x135498; return;
    }
    // 0x1354ec: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1354f0: 0x2e220004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 4));
    // 0x1354f4: 0x1440ff90
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x135338; return;
    }
label_1354fc:
    // 0x1354fc: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x135500: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x135504: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x135508: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13550c: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x135510: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x135514: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x135518: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13551c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x135520: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x135524: 0xc7bb0128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[27] = *(float*)&val; }
    // 0x135528: 0xc7ba0120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[26] = *(float*)&val; }
    // 0x13552c: 0xc7b90118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[25] = *(float*)&val; }
    // 0x135530: 0xc7b80110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[24] = *(float*)&val; }
    // 0x135534: 0xc7b70108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[23] = *(float*)&val; }
    // 0x135538: 0xc7b60100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[22] = *(float*)&val; }
    // 0x13553c: 0xc7b500f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[21] = *(float*)&val; }
    // 0x135540: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x135544: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13554c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x135550; return;
}


// Function: FUN_00135550
// Address: 0x135550 - 0x135594

void FUN_00135550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135550: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x135554: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x135558: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x13555c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x135560: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x135564: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x135568: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x13556c: 0x8e420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 592)));
    // 0x135570: 0x1202004e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1356AC; return;
    }
    // 0x135578: 0x14400023
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x135608; return;
    }
    // 0x135580: 0x24060495
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1173));
    // 0x135584: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x135588: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x13558c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x135594);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_135594
// Address: 0x135594 - 0x1355e4

void entry_135594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135594) {
        switch (ctx->pc) {
            case 0x1355d8: ctx->pc = 0; goto label_1355d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135594: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x135598: 0x10c0001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 108));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135608; return;
    }
    // 0x1355a0: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1355a4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1355a8: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1355ac: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1355b0: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1355b4: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1355b8: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1355bc: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1355c0: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1355c4: 0x8cc2006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 108)));
    // 0x1355c8: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1355cc: 0x1040000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135600; return;
    }
    // 0x1355d4: 0x0
    // NOP
label_1355d8:
    // 0x1355d8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1355dc: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x1355e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_1355e4
// Address: 0x1355e4 - 0x135628

void entry_1355e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1355e4) {
        switch (ctx->pc) {
            case 0x135600: ctx->pc = 0; goto label_135600;
            case 0x135608: ctx->pc = 0; goto label_135608;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1355e4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1355e8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1355ec: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1355f0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1355f4: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1355f8: 0x1440fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1355D8; return;
    }
label_135600:
    // 0x135600: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x135604: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
label_135608:
    // 0x135608: 0x16000025
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1356A0; return;
    }
    // 0x135610: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x135614: 0x24060495
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1173));
    // 0x135618: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x13561c: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x135620: 0xc056906
    SET_GPR_U32(ctx, 31, 0x135628);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_135628
// Address: 0x135628 - 0x135678

void entry_135628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135628) {
        switch (ctx->pc) {
            case 0x135668: ctx->pc = 0; goto label_135668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135628: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13562c: 0x10c0001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 108));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13569C; return;
    }
    // 0x135634: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x135638: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x13563c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x135640: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x135644: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x135648: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x13564c: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x135650: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x135654: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x135658: 0x8cc2006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 108)));
    // 0x13565c: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x135660: 0x1040000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135694; return;
    }
label_135668:
    // 0x135668: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13566c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x135670: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x135678);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_135678
// Address: 0x135678 - 0x1356a8

void entry_135678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135678) {
        switch (ctx->pc) {
            case 0x135694: ctx->pc = 0; goto label_135694;
            case 0x13569c: ctx->pc = 0; goto label_13569c;
            case 0x1356a0: ctx->pc = 0; goto label_1356a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135678: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x13567c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x135680: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x135684: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x135688: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13568c: 0x1440fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x135668; return;
    }
label_135694:
    // 0x135694: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x135698: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
label_13569c:
    // 0x13569c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1356a0:
    // 0x1356a0: 0xc06aa66
    SET_GPR_U32(ctx, 31, 0x1356a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime); return;
}


// Function: entry_1356a8
// Address: 0x1356a8 - 0x1356c0

void entry_1356a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1356a8) {
        switch (ctx->pc) {
            case 0x1356ac: ctx->pc = 0; goto label_1356ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1356a8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1356ac:
    // 0x1356ac: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1356b0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1356b4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1356b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: open_close_binoc
// Address: 0x1356c0 - 0x135704

void entry_135704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135704) {
        switch (ctx->pc) {
            case 0x13570c: ctx->pc = 0; goto label_13570c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135704: 0x10000012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135750; return;
    }
label_13570c:
    // 0x13570c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x135710: 0x2404008f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 143));
    // 0x135714: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x135718: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x13571c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x135720: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135724: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x135728: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x13572c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135730: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x135734: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x135738: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13573c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x135740: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135744: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x13574c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_13574c
// Address: 0x13574c - 0x1357a8

void entry_13574c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13574c) {
        switch (ctx->pc) {
            case 0x135750: ctx->pc = 0; goto label_135750;
            case 0x135768: ctx->pc = 0; goto label_135768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13574c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_135750:
    // 0x135750: 0x12020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_135768;
    }
    // 0x135758: 0x12020015
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1357B0; return;
    }
    // 0x135760: 0x1000001b
    WRITE32(ADD32(GPR_U32(ctx, 17), 608), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1357D0; return;
    }
label_135768:
    // 0x135768: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x13576c: 0x2404008e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 142));
    // 0x135770: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x135774: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x135778: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13577c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135780: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x135784: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x135788: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13578c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x135790: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x135794: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135798: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x13579c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1357a0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1357a8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1357a8
// Address: 0x1357a8 - 0x1357cc

void entry_1357a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1357a8) {
        switch (ctx->pc) {
            case 0x1357b0: ctx->pc = 0; goto label_1357b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1357a8: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 17), 608), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1357D0; return;
    }
label_1357b0:
    // 0x1357b0: 0x24a4f138
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294963512));
    // 0x1357b4: 0xa8800467
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 1127); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1357b8: 0xb8800464
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 1124); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1357bc: 0x8ca2f138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4294963512)));
    // 0x1357c0: 0x8c43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 60)));
    // 0x1357c4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1357cc);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1357cc
// Address: 0x1357cc - 0x1357f0

void entry_1357cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1357cc) {
        switch (ctx->pc) {
            case 0x1357d0: ctx->pc = 0; goto label_1357d0;
            case 0x1357dc: ctx->pc = 0; goto label_1357dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1357cc: 0xae300260
    WRITE32(ADD32(GPR_U32(ctx, 17), 608), GPR_U32(ctx, 16));
label_1357d0:
    // 0x1357d0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1357d4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1357d8: 0xe6200264
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 612), *(uint32_t*)&val); }
label_1357dc:
    // 0x1357dc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1357e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1357e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1357e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001357f0
// Address: 0x1357f0 - 0x135810

void FUN_001357f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1357f0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1357f4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1357f8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1357fc: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x135800: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x135804: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x135808: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x135810);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_135810
// Address: 0x135810 - 0x135820

void entry_135810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135810: 0x1040000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135844; return;
    }
    // 0x135818: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x135820);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_135820
// Address: 0x135820 - 0x135858

void entry_135820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135820) {
        switch (ctx->pc) {
            case 0x135844: ctx->pc = 0; goto label_135844;
            case 0x135848: ctx->pc = 0; goto label_135848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135820: 0x10400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_135844;
    }
    // 0x135828: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x13582c: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x135830: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135834: 0x0
    // NOP
    // 0x135838: 0x45010003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_135848;
    }
    // 0x135840: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_135844:
    // 0x135844: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_135848:
    // 0x135848: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13584c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x135850: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00135858
// Address: 0x135858 - 0x13587c

void FUN_00135858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135858: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x13585c: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x135860: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x135864: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x135868: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x13586c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x135870: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x135874: 0xc066704
    SET_GPR_U32(ctx, 31, 0x13587c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    FUN_00199c10(rdram, ctx, runtime); return;
}


// Function: entry_13587c
// Address: 0x13587c - 0x135894

void entry_13587c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13587c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x135880: 0x1440000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1358BC; return;
    }
    // 0x135888: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13588c: 0xc066704
    SET_GPR_U32(ctx, 31, 0x135894);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_00199c10(rdram, ctx, runtime); return;
}


// Function: entry_135894
// Address: 0x135894 - 0x1358d0

void entry_135894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135894) {
        switch (ctx->pc) {
            case 0x1358bc: ctx->pc = 0; goto label_1358bc;
            case 0x1358c0: ctx->pc = 0; goto label_1358c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135894: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x135898: 0x14400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1358bc;
    }
    // 0x1358a0: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1358a4: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1358a8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1358ac: 0x0
    // NOP
    // 0x1358b0: 0x45010003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1358c0;
    }
    // 0x1358b8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1358bc:
    // 0x1358bc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1358c0:
    // 0x1358c0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1358c4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1358c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001358d0
// Address: 0x1358d0 - 0x13594c

void FUN_001358d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1358d0: 0x27bdecf0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294962416));
    // 0x1358d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1358d8: 0xafa51224
    WRITE32(ADD32(GPR_U32(ctx, 29), 4644), GPR_U32(ctx, 5));
    // 0x1358dc: 0x7fb712c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 4800), GPR_VEC(ctx, 23));
    // 0x1358e0: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x1358e4: 0x7fb21270
    WRITE128(ADD32(GPR_U32(ctx, 29), 4720), GPR_VEC(ctx, 18));
    // 0x1358e8: 0xc0b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1358ec: 0x7fb11260
    WRITE128(ADD32(GPR_U32(ctx, 29), 4704), GPR_VEC(ctx, 17));
    // 0x1358f0: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1358f4: 0xe7b61300
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 4864), *(uint32_t*)&val); }
    // 0x1358f8: 0x27b11000
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 4096));
    // 0x1358fc: 0xafa71228
    WRITE32(ADD32(GPR_U32(ctx, 29), 4648), GPR_U32(ctx, 7));
    // 0x135900: 0x46006586
    ctx->f[22] = FPU_MOV_S(ctx->f[12]);
    // 0x135904: 0xafa8122c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4652), GPR_U32(ctx, 8));
    // 0x135908: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13590c: 0xafa91230
    WRITE32(ADD32(GPR_U32(ctx, 29), 4656), GPR_U32(ctx, 9));
    // 0x135910: 0x24080080
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 128));
    // 0x135914: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x135918: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13591c: 0x8fa61224
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4644)));
    // 0x135920: 0x7fb612b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 4784), GPR_VEC(ctx, 22));
    // 0x135924: 0x7fb01250
    WRITE128(ADD32(GPR_U32(ctx, 29), 4688), GPR_VEC(ctx, 16));
    // 0x135928: 0x7fbf12e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 4832), GPR_VEC(ctx, 31));
    // 0x13592c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135930: 0x7fbe12d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 4816), GPR_VEC(ctx, 30));
    // 0x135934: 0x7fb512a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 4768), GPR_VEC(ctx, 21));
    // 0x135938: 0x7fb41290
    WRITE128(ADD32(GPR_U32(ctx, 29), 4752), GPR_VEC(ctx, 20));
    // 0x13593c: 0x7fb31280
    WRITE128(ADD32(GPR_U32(ctx, 29), 4736), GPR_VEC(ctx, 19));
    // 0x135940: 0xe7b512f8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 4856), *(uint32_t*)&val); }
    // 0x135944: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x13594c);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 4848), *(uint32_t*)&val); }
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13594c
// Address: 0x13594c - 0x135984

void entry_13594c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13594c) {
        switch (ctx->pc) {
            case 0x135968: ctx->pc = 0; goto label_135968;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13594c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x135950: 0x1ac00023
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 22) <= 0) {
        ctx->pc = 0x1359E0; return;
    }
    // 0x135958: 0x220a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13595c: 0x3c1e0026
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    // 0x135960: 0x27b40008
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 8));
    // 0x135964: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
label_135968:
    // 0x135968: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x13596c: 0x60882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x135970: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x135974: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x135978: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13597c: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x135984);
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_135984
// Address: 0x135984 - 0x135a10

void entry_135984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135984) {
        switch (ctx->pc) {
            case 0x1359e0: ctx->pc = 0; goto label_1359e0;
            case 0x1359fc: ctx->pc = 0; goto label_1359fc;
            case 0x135a00: ctx->pc = 0; goto label_135a00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135984: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x135988: 0x8fc21990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 6544)));
    // 0x13598c: 0x26230020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 32));
    // 0x135990: 0xda210010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x135994: 0x26940020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 32));
    // 0x135998: 0xd8420040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x13599c: 0x26730020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 32));
    // 0x1359a0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1359a4: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1359a8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1359ac: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1359b0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1359b4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1359b8: 0x26b50004
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
    // 0x1359bc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1359c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1359c4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1359c8: 0x216102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 22)));
    // 0x1359cc: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1359d0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1359d4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1359d8: 0x1440ffe3
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x135968; return;
    }
label_1359e0:
    // 0x1359e0: 0x8fa31224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4644)));
    // 0x1359e4: 0x2402002e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 46));
    // 0x1359e8: 0x14620004
    SET_GPR_U32(ctx, 2, ((uint32_t)19 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1359fc;
    }
    // 0x1359f0: 0x3c020013
    SET_GPR_U32(ctx, 2, ((uint32_t)19 << 16));
    // 0x1359f4: 0x10000002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 22616));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_135a00;
    }
label_1359fc:
    // 0x1359fc: 0x244757f0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 22512));
label_135a00:
    // 0x135a00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x135a04: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x135a08: 0xc06f82a
    SET_GPR_U32(ctx, 31, 0x135a10);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    HeapSort__FPviiPFPvPv_i(rdram, ctx, runtime); return;
}


// Function: entry_135a10
// Address: 0x135a10 - 0x135a28

void entry_135a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135a10: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x135a14: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135a18: 0xafa41234
    WRITE32(ADD32(GPR_U32(ctx, 29), 4660), GPR_U32(ctx, 4));
    // 0x135a1c: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x135a20: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x135a28);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 816));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_135a28
// Address: 0x135a28 - 0x135a98

void entry_135a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135a28) {
        switch (ctx->pc) {
            case 0x135a54: ctx->pc = 0; goto label_135a54;
            case 0x135a78: ctx->pc = 0; goto label_135a78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135a28: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x135a2c: 0xc6420350
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 848)); ctx->f[2] = *(float*)&val; }
    // 0x135a30: 0x24431858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x135a34: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x135a38: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x135a3c: 0xc4411274
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4724)); ctx->f[1] = *(float*)&val; }
    // 0x135a40: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x135a44: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135a48: 0x0
    // NOP
    // 0x135a4c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4660), GPR_U32(ctx, 0));
        goto label_135a54;
    }
label_135a54:
    // 0x135a54: 0x1ac000e3
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 22) <= 0) {
        ctx->pc = 0x135DE4; return;
    }
    // 0x135a5c: 0x4be00053
    // Unhandled VU0 Special1 function: 0x13
    // 0x135a60: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x135a64: 0xfba11240
    WRITE128(ADD32(GPR_U32(ctx, 29), 4672), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x135a68: 0x265e0358
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 18), 856));
    // 0x135a6c: 0x2657035c
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 18), 860));
    // 0x135a70: 0x101140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    // 0x135a74: 0x0
    // NOP
label_135a78:
    // 0x135a78: 0x2403002e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 46));
    // 0x135a7c: 0x3a28821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x135a80: 0x8fa21224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4644)));
    // 0x135a84: 0x54430015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 608)));
        ctx->pc = 0x135ADC; return;
    }
    // 0x135a8c: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x135a90: 0xc066704
    SET_GPR_U32(ctx, 31, 0x135a98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 4640));
    FUN_00199c10(rdram, ctx, runtime); return;
}


// Function: entry_135a98
// Address: 0x135a98 - 0x135aec

void entry_135a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135a98) {
        switch (ctx->pc) {
            case 0x135ad4: ctx->pc = 0; goto label_135ad4;
            case 0x135adc: ctx->pc = 0; goto label_135adc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135a98: 0x8fa21220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4640)));
    // 0x135a9c: 0x1440000d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_135ad4;
    }
    // 0x135aa4: 0x8e420260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x135aa8: 0x5455001b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4640), GPR_U32(ctx, 3));
        ctx->pc = 0x135B18; return;
    }
    // 0x135ab0: 0x8fa4122c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4652)));
    // 0x135ab4: 0x204102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 4)));
    // 0x135ab8: 0x50400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4640), GPR_U32(ctx, 3));
        ctx->pc = 0x135B18; return;
    }
    // 0x135ac0: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x135ac4: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135ac8: 0x0
    // NOP
    // 0x135acc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_135ad4;
    }
label_135ad4:
    // 0x135ad4: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 29), 4640), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135B18; return;
    }
label_135adc:
    // 0x135adc: 0x1455000d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x135B14; return;
    }
    // 0x135ae4: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x135aec);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_135aec
// Address: 0x135aec - 0x135b94

void entry_135aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135aec) {
        switch (ctx->pc) {
            case 0x135b14: ctx->pc = 0; goto label_135b14;
            case 0x135b18: ctx->pc = 0; goto label_135b18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135aec: 0x10400009
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4652)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_135b14;
    }
    // 0x135af4: 0x203102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x135af8: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4640), GPR_U32(ctx, 19));
        goto label_135b18;
    }
    // 0x135b00: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x135b04: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135b08: 0x0
    // NOP
    // 0x135b0c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
        goto label_135b14;
    }
label_135b14:
    // 0x135b14: 0xafb31220
    WRITE32(ADD32(GPR_U32(ctx, 29), 4640), GPR_U32(ctx, 19));
label_135b18:
    // 0x135b18: 0x3c130026
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    // 0x135b1c: 0xda230010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x135b20: 0x8e631990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 6544)));
    // 0x135b24: 0xdba61240
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 4672)));
    // 0x135b28: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x135b2c: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x135b30: 0x8fa41220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4640)));
    // 0x135b34: 0xfba31200
    WRITE128(ADD32(GPR_U32(ctx, 29), 4608), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x135b38: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x135b3c: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x135b40: 0xfba51210
    WRITE128(ADD32(GPR_U32(ctx, 29), 4624), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x135b44: 0xd8640070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x135b48: 0xd8620050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x135b4c: 0xd8610060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 96)));
    // 0x135b50: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x135b54: 0x4be308bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x135b58: 0x4be320be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[3] = READ32(addr); }
    // 0x135b5c: 0x4be530fc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x135b60: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x135b64: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x135b68: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x135b6c: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x135b70: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x135b74: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x135b78: 0x1080003f
    SET_GPR_U32(ctx, 20, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135C78; return;
    }
    // 0x135b80: 0x5680003e
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 852)));
        ctx->pc = 0x135C7C; return;
    }
    // 0x135b88: 0xc7ac1204
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4612)); ctx->f[12] = *(float*)&val; }
    // 0x135b8c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x135b94);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4608)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_135b94
// Address: 0x135b94 - 0x135bc4

void entry_135b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135b94: 0xdba11200
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 4608)));
    // 0x135b98: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x135b9c: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x135ba0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x135ba4: 0xc7ac1208
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4616)); ctx->f[12] = *(float*)&val; }
    // 0x135ba8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x135bac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x135bb0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x135bb4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x135bb8: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x135bbc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x135bc4);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_135bc4
// Address: 0x135bc4 - 0x135bd8

void entry_135bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135bc4: 0x8e621990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 6544)));
    // 0x135bc8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x135bcc: 0xc44c0468
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1128)); ctx->f[12] = *(float*)&val; }
    // 0x135bd0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x135bd8);
    ctx->f[12] = FPU_SUB_S(ctx->f[21], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_135bd8
// Address: 0x135bd8 - 0x135bec

void entry_135bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135bd8: 0x8e621990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 6544)));
    // 0x135bdc: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x135be0: 0xc44c0470
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1136)); ctx->f[12] = *(float*)&val; }
    // 0x135be4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x135bec);
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_135bec
// Address: 0x135bec - 0x135cec

void entry_135bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135bec) {
        switch (ctx->pc) {
            case 0x135c24: ctx->pc = 0; goto label_135c24;
            case 0x135c50: ctx->pc = 0; goto label_135c50;
            case 0x135c68: ctx->pc = 0; goto label_135c68;
            case 0x135c78: ctx->pc = 0; goto label_135c78;
            case 0x135c7c: ctx->pc = 0; goto label_135c7c;
            case 0x135cb0: ctx->pc = 0; goto label_135cb0;
            case 0x135cd4: ctx->pc = 0; goto label_135cd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135bec: 0x8e621990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 6544)));
    // 0x135bf0: 0x46000106
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    // 0x135bf4: 0x3c013ee6
    SET_GPR_U32(ctx, 1, ((uint32_t)16102 << 16));
    // 0x135bf8: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x135bfc: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x135c00: 0xc44201e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 480)); ctx->f[2] = *(float*)&val; }
    // 0x135c04: 0xc44101c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 452)); ctx->f[1] = *(float*)&val; }
    // 0x135c08: 0x46051002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[5]);
    // 0x135c0c: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x135c10: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135c14: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_135c24;
    }
    // 0x135c1c: 0x10000016
    WRITE32(ADD32(GPR_U32(ctx, 18), 816), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_135c78;
    }
label_135c24:
    // 0x135c24: 0x3c01bee6
    SET_GPR_U32(ctx, 1, ((uint32_t)48870 << 16));
    // 0x135c28: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x135c2c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x135c30: 0x46031002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x135c34: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x135c38: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135c3c: 0x0
    // NOP
    // 0x135c40: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[5]);
        goto label_135c50;
    }
    // 0x135c48: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 18), 820), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_135c78;
    }
label_135c50:
    // 0x135c50: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135c54: 0x0
    // NOP
    // 0x135c58: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
        goto label_135c68;
    }
    // 0x135c60: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 18), 824), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_135c78;
    }
label_135c68:
    // 0x135c68: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x135c6c: 0x0
    // NOP
    // 0x135c70: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 828), GPR_U32(ctx, 21));
        goto label_135c78;
    }
label_135c78:
    // 0x135c78: 0x8e420354
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 852)));
label_135c7c:
    // 0x135c7c: 0x26130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1));
    // 0x135c80: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135c84: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135c88: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x135c8c: 0x18400011
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 4640)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_135cd4;
    }
    // 0x135c94: 0x8e420358
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 856)));
    // 0x135c98: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x135c9c: 0x54460004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        goto label_135cb0;
    }
    // 0x135ca4: 0x1000000b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 860)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_135cd4;
    }
    // 0x135cac: 0x0
    // NOP
label_135cb0:
    // 0x135cb0: 0x207102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 7)));
    // 0x135cb4: 0x10400007
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_135cd4;
    }
    // 0x135cbc: 0x3c51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 5)));
    // 0x135cc0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x135cc4: 0x5466fffa
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 6)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        goto label_135cb0;
    }
    // 0x135ccc: 0x2e51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 5)));
    // 0x135cd0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_135cd4:
    // 0x135cd4: 0x10800013
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135D24; return;
    }
    // 0x135cdc: 0x5500003e
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
        ctx->pc = 0x135DD8; return;
    }
    // 0x135ce4: 0xc06877c
    SET_GPR_U32(ctx, 31, 0x135cec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime); return;
}


// Function: entry_135cec
// Address: 0x135cec - 0x135d14

void entry_135cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135cec: 0x8e460354
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 852)));
    // 0x135cf0: 0x1020c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 3));
    // 0x135cf4: 0x24850360
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 864));
    // 0x135cf8: 0xd03023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 16)));
    // 0x135cfc: 0x24840358
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 856));
    // 0x135d00: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x135d04: 0x2442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    // 0x135d08: 0x2452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 5)));
    // 0x135d0c: 0xc063600
    SET_GPR_U32(ctx, 31, 0x135d14);
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 3));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_135d14
// Address: 0x135d14 - 0x135d44

void entry_135d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135d14) {
        switch (ctx->pc) {
            case 0x135d24: ctx->pc = 0; goto label_135d24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135d14: 0x8e420354
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 852)));
    // 0x135d18: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x135d1c: 0x1000002d
    WRITE32(ADD32(GPR_U32(ctx, 18), 852), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135DD4; return;
    }
label_135d24:
    // 0x135d24: 0x1100002b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4660)));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135DD4; return;
    }
    // 0x135d2c: 0x1060002a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135DD8; return;
    }
    // 0x135d34: 0x12800028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 18));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135DD8; return;
    }
    // 0x135d3c: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x135d44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_135d44
// Address: 0x135d44 - 0x135d70

void entry_135d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135d44: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x135d48: 0x12000022
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135DD4; return;
    }
    // 0x135d50: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x135d54: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x135d58: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x135d5c: 0x26250010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 16));
    // 0x135d60: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x135d64: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135d68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x135d70);
    WRITE32(ADD32(GPR_U32(ctx, 29), 4660), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_135d70
// Address: 0x135d70 - 0x135d94

void entry_135d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135d70: 0x8fa41230
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4656)));
    // 0x135d74: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135d78: 0xae040020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 4));
    // 0x135d7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x135d80: 0x8fa21228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4648)));
    // 0x135d84: 0xae020130
    WRITE32(ADD32(GPR_U32(ctx, 16), 304), GPR_U32(ctx, 2));
    // 0x135d88: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x135d8c: 0xc06877c
    SET_GPR_U32(ctx, 31, 0x135d94);
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 2));
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime); return;
}


// Function: entry_135d94
// Address: 0x135d94 - 0x135e20

void entry_135d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135d94) {
        switch (ctx->pc) {
            case 0x135dd4: ctx->pc = 0; goto label_135dd4;
            case 0x135dd8: ctx->pc = 0; goto label_135dd8;
            case 0x135de4: ctx->pc = 0; goto label_135de4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135d94: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x135d98: 0x8e440354
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 852)));
    // 0x135d9c: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x135da0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x135da4: 0x420c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 3));
    // 0x135da8: 0x3c42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 4)));
    // 0x135dac: 0xe6400350
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 848), *(uint32_t*)&val); }
    // 0x135db0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x135db4: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x135db8: 0x8e420354
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 852)));
    // 0x135dbc: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x135dc0: 0x2e21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x135dc4: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x135dc8: 0x8e430354
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 852)));
    // 0x135dcc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x135dd0: 0xae430354
    WRITE32(ADD32(GPR_U32(ctx, 18), 852), GPR_U32(ctx, 3));
label_135dd4:
    // 0x135dd4: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_135dd8:
    // 0x135dd8: 0x216102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 22)));
    // 0x135ddc: 0x1440ff26
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x135A78; return;
    }
label_135de4:
    // 0x135de4: 0x7bbf12e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 4832)));
    // 0x135de8: 0x7bbe12d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 4816)));
    // 0x135dec: 0x7bb712c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 4800)));
    // 0x135df0: 0x7bb612b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 4784)));
    // 0x135df4: 0x7bb512a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 4768)));
    // 0x135df8: 0x7bb41290
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 4752)));
    // 0x135dfc: 0x7bb31280
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 4736)));
    // 0x135e00: 0x7bb21270
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 4720)));
    // 0x135e04: 0x7bb11260
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 4704)));
    // 0x135e08: 0x7bb01250
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 4688)));
    // 0x135e0c: 0xc7b61300
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4864)); ctx->f[22] = *(float*)&val; }
    // 0x135e10: 0xc7b512f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4856)); ctx->f[21] = *(float*)&val; }
    // 0x135e14: 0xc7b412f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4848)); ctx->f[20] = *(float*)&val; }
    // 0x135e18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4880));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00135E20
// Address: 0x135e20 - 0x135e30

void FUN_00135E30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135e30: 0x78820140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x135e34: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x135e38: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00135E40
// Address: 0x135e40 - 0x135e48

void FUN_00135E48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135e48: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x135e4c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x135e50: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x135e54: 0x78820140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x135e58: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x135e5c: 0xc0687d0
    SET_GPR_U32(ctx, 31, 0x135e64);
    WRITE128(ADD32(GPR_U32(ctx, 6), 0), GPR_VEC(ctx, 2));
    ChpBuildConvexHullScreen__FP6VECTORiP2HP(rdram, ctx, runtime); return;
}


// Function: entry_135e64
// Address: 0x135e64 - 0x135e70

void entry_135e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135e64: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x135e68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00135E70
// Address: 0x135e70 - 0x135e78

void entry_135ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135ed0: 0x26240340
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 832));
    // 0x135ed4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135ed8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x135ee0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_135ee0
// Address: 0x135ee0 - 0x135ef0

void entry_135ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135ee0) {
        switch (ctx->pc) {
            case 0x135ee8: ctx->pc = 0; goto label_135ee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135ee0: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 852)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x135EF4; return;
    }
label_135ee8:
    // 0x135ee8: 0xc06877c
    SET_GPR_U32(ctx, 31, 0x135ef0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime); return;
}


// Function: entry_135ef0
// Address: 0x135ef0 - 0x135f1c

void entry_135ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135ef0) {
        switch (ctx->pc) {
            case 0x135ef4: ctx->pc = 0; goto label_135ef4;
            case 0x135f04: ctx->pc = 0; goto label_135f04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135ef0: 0x8e220354
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 852)));
label_135ef4:
    // 0x135ef4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x135ef8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x135efc: 0x1440fff0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x135EC0; return;
    }
label_135f04:
    // 0x135f04: 0xae200354
    WRITE32(ADD32(GPR_U32(ctx, 17), 852), GPR_U32(ctx, 0));
    // 0x135f08: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x135f0c: 0xae200350
    WRITE32(ADD32(GPR_U32(ctx, 17), 848), GPR_U32(ctx, 0));
    // 0x135f10: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135f14: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x135f1c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_135f1c
// Address: 0x135f1c - 0x135f48

void entry_135f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135f1c) {
        switch (ctx->pc) {
            case 0x135f20: ctx->pc = 0; goto label_135f20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135f1c: 0xae340328
    WRITE32(ADD32(GPR_U32(ctx, 17), 808), GPR_U32(ctx, 20));
label_135f20:
    // 0x135f20: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x135f24: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x135f28: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x135f2c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x135f30: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x135f34: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x135f38: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x135f3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x135f44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x135f48; return;
}


// Function: FUN_00135f48
// Address: 0x135f48 - 0x135f70

void FUN_00135f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135f48: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x135f4c: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x135f50: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x135f54: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x135f58: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x135f5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x135f60: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x135f64: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x135f68: 0xc05834c
    SET_GPR_U32(ctx, 31, 0x135f70);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    GetBlueprintInfo__FPiT0(rdram, ctx, runtime); return;
}


// Function: entry_135f70
// Address: 0x135f70 - 0x135f78

void entry_135f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135f70: 0xc058344
    SET_GPR_U32(ctx, 31, 0x135f78);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_135f78
// Address: 0x135f78 - 0x135f94

void entry_135f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135f78: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x135f7c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x135f80: 0x14400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x135F9C; return;
    }
    // 0x135f88: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x135f8c: 0xc04d79e
    SET_GPR_U32(ctx, 31, 0x135f94);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    SetBinocBfk(rdram, ctx, runtime); return;
}


// Function: entry_135f94
// Address: 0x135f94 - 0x135fa8

void entry_135f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x135f94) {
        switch (ctx->pc) {
            case 0x135f9c: ctx->pc = 0; goto label_135f9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x135f94: 0x10000022
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136020; return;
    }
label_135f9c:
    // 0x135f9c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x135fa0: 0xc04d79e
    SET_GPR_U32(ctx, 31, 0x135fa8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetBinocBfk(rdram, ctx, runtime); return;
}


// Function: entry_135fa8
// Address: 0x135fa8 - 0x135ff8

void entry_135fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135fa8: 0x8e630328
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 808)));
    // 0x135fac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x135fb0: 0x1462001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x136020; return;
    }
    // 0x135fb8: 0x3c120027
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    // 0x135fbc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x135fc0: 0x8e435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x135fc4: 0x3c110013
    SET_GPR_U32(ctx, 17, ((uint32_t)19 << 16));
    // 0x135fc8: 0xc4549cfc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294941948)); ctx->f[20] = *(float*)&val; }
    // 0x135fcc: 0x3c100013
    SET_GPR_U32(ctx, 16, ((uint32_t)19 << 16));
    // 0x135fd0: 0x26315e30
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 24112));
    // 0x135fd4: 0x26105e48
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 24136));
    // 0x135fd8: 0x8c691d44
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 3), 7492)));
    // 0x135fdc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x135fe0: 0x2405002e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 46));
    // 0x135fe4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x135fe8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x135fec: 0x24080005
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 5));
    // 0x135ff0: 0xc04d634
    SET_GPR_U32(ctx, 31, 0x135ff8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    FUN_001358d0(rdram, ctx, runtime); return;
}


// Function: entry_135ff8
// Address: 0x135ff8 - 0x13601c

void entry_135ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x135ff8: 0x8e425710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x135ffc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x136000: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x136004: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x136008: 0x8c491d54
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 2), 7508)));
    // 0x13600c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x136010: 0x24050021
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 33));
    // 0x136014: 0xc04d634
    SET_GPR_U32(ctx, 31, 0x13601c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 5));
    FUN_001358d0(rdram, ctx, runtime); return;
}


// Function: entry_13601c
// Address: 0x13601c - 0x136040

void entry_13601c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13601c) {
        switch (ctx->pc) {
            case 0x136020: ctx->pc = 0; goto label_136020;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13601c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_136020:
    // 0x136020: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x136024: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x136028: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13602c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x136030: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x136034: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13603c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x136040; return;
}


// Function: FUN_00136040
// Address: 0x136040 - 0x1361c0

void FUN_00136040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136040) {
        switch (ctx->pc) {
            case 0x13607c: ctx->pc = 0; goto label_13607c;
            case 0x1360fc: ctx->pc = 0; goto label_1360fc;
            case 0x136124: ctx->pc = 0; goto label_136124;
            case 0x136134: ctx->pc = 0; goto label_136134;
            case 0x13614c: ctx->pc = 0; goto label_13614c;
            case 0x1361b4: ctx->pc = 0; goto label_1361b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136040: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x136044: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x136048: 0x7fb10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    // 0x13604c: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x136050: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x136054: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x136058: 0xe7b40080
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x13605c: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x136060: 0x10620006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_13607c;
    }
    // 0x136068: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x13606c: 0x10620066
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x136208; return;
    }
    // 0x136074: 0x10000068
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136218; return;
    }
label_13607c:
    // 0x13607c: 0xc6210040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[1] = *(float*)&val; }
    // 0x136080: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x136084: 0xc6200074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 116)); ctx->f[0] = *(float*)&val; }
    // 0x136088: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x13608c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x136090: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x136094: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x136098: 0x24479d00
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4294941952));
    // 0x13609c: 0x68e40007
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1360a0: 0x6ce40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1360a4: 0x8ce50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x1360a8: 0xb3a40037
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1360ac: 0xb7a40030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1360b0: 0xafa50038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 5));
    // 0x1360b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1360b8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1360bc: 0x24669d10
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4294941968));
    // 0x1360c0: 0x68c20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1360c4: 0x6cc20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1360c8: 0x8cc40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1360cc: 0xb3a20047
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 71); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1360d0: 0xb7a20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1360d4: 0xafa40048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 4));
    // 0x1360d8: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1360dc: 0x0
    // NOP
    // 0x1360e0: 0x45010006
    ctx->f[20] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1360fc;
    }
    // 0x1360e8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1360ec: 0x0
    // NOP
    // 0x1360f0: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1360fc;
    }
    // 0x1360f8: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
label_1360fc:
    // 0x1360fc: 0xc6250044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 68)); ctx->f[5] = *(float*)&val; }
    // 0x136100: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x136104: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x136108: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13610c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x136110: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x136114: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_136124;
    }
    // 0x13611c: 0x10000005
    ctx->f[5] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136134;
    }
label_136124:
    // 0x136124: 0x46050834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x136128: 0x0
    // NOP
    // 0x13612c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[5] = FPU_MOV_S(ctx->f[1]);
        goto label_136134;
    }
label_136134:
    // 0x136134: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x136138: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x13613c: 0x8c8319ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x136140: 0x30630200
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 512));
    // 0x136144: 0x54600001
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->f[5] = FPU_NEG_S(ctx->f[5]);
        goto label_13614c;
    }
label_13614c:
    // 0x13614c: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x136150: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x136154: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x136158: 0xc622007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 124)); ctx->f[2] = *(float*)&val; }
    // 0x13615c: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x136160: 0xc6200048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[0] = *(float*)&val; }
    // 0x136164: 0x46012942
    ctx->f[5] = FPU_MUL_S(ctx->f[5], ctx->f[1]);
    // 0x136168: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x13616c: 0xc6030304
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 772)); ctx->f[3] = *(float*)&val; }
    // 0x136170: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x136174: 0xc6040308
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 776)); ctx->f[4] = *(float*)&val; }
    // 0x136178: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x13617c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x136180: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x136184: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x136188: 0xe7a30000
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x13618c: 0xe7a40004
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x136190: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x136194: 0xe7a10010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x136198: 0xe7a50014
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    // 0x13619c: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1361a0: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x1361a4: 0x7ba40000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1361a8: 0x45000002
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1361b4;
    }
    // 0x1361b0: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
label_1361b4:
    // 0x1361b4: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1361b8: 0xc07aa06
    SET_GPR_U32(ctx, 31, 0x1361c0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PosSmooth(rdram, ctx, runtime); return;
}


// Function: entry_1361c0
// Address: 0x1361c0 - 0x136200

void entry_1361c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1361c0: 0x3c01bda3
    SET_GPR_U32(ctx, 1, ((uint32_t)48547 << 16));
    // 0x1361c4: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x1361c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1361cc: 0xc6010314
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 788)); ctx->f[1] = *(float*)&val; }
    // 0x1361d0: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1361d4: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1361d8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1361dc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1361e0: 0xc7a30020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[3] = *(float*)&val; }
    // 0x1361e4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1361e8: 0xc7a20024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[2] = *(float*)&val; }
    // 0x1361ec: 0xe6030304
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 772), *(uint32_t*)&val); }
    // 0x1361f0: 0xe6020308
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 776), *(uint32_t*)&val); }
    // 0x1361f4: 0x46000b06
    ctx->f[12] = FPU_MOV_S(ctx->f[1]);
    // 0x1361f8: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x136200);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 788), *(uint32_t*)&val); }
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_136200
// Address: 0x136200 - 0x136220

void entry_136200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136200) {
        switch (ctx->pc) {
            case 0x136208: ctx->pc = 0; goto label_136208;
            case 0x136214: ctx->pc = 0; goto label_136214;
            case 0x136218: ctx->pc = 0; goto label_136218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136200: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 788), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136214;
    }
label_136208:
    // 0x136208: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x13620c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x136210: 0xe6000308
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 776), *(uint32_t*)&val); }
label_136214:
    // 0x136214: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_136218:
    // 0x136218: 0xc04d7d2
    SET_GPR_U32(ctx, 31, 0x136220);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_00135f48(rdram, ctx, runtime); return;
}


// Function: entry_136220
// Address: 0x136220 - 0x136238

void entry_136220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136220: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x136224: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x136228: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13622c: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x136230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00136238
// Address: 0x136238 - 0x136290

void FUN_00136238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136238: 0x27bdfbc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966208));
    // 0x13623c: 0x7fb10420
    WRITE128(ADD32(GPR_U32(ctx, 29), 1056), GPR_VEC(ctx, 17));
    // 0x136240: 0x7fb00410
    WRITE128(ADD32(GPR_U32(ctx, 29), 1040), GPR_VEC(ctx, 16));
    // 0x136244: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x136248: 0x7fbf0430
    WRITE128(ADD32(GPR_U32(ctx, 29), 1072), GPR_VEC(ctx, 31));
    // 0x13624c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x136250: 0x11182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 17)));
    // 0x136254: 0x8e02025c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 604)));
    // 0x136258: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x13625c: 0x14620057
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1363BC; return;
    }
    // 0x136264: 0x8e020324
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    // 0x136268: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
        ctx->pc = 0x1362A4; return;
    }
    // 0x136270: 0x8c4302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 724)));
    // 0x136274: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x136278: 0x5462000a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
        ctx->pc = 0x1362A4; return;
    }
    // 0x136280: 0x12200005
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136298; return;
    }
    // 0x136288: 0xc06fa94
    SET_GPR_U32(ctx, 31, 0x136290);
    ContinueVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_136290
// Address: 0x136290 - 0x1362a0

void entry_136290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136290) {
        switch (ctx->pc) {
            case 0x136298: ctx->pc = 0; goto label_136298;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136290: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1362A4; return;
    }
label_136298:
    // 0x136298: 0xc06fa8a
    SET_GPR_U32(ctx, 31, 0x1362a0);
    PauseVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1362a0
// Address: 0x1362a0 - 0x1362c0

void entry_1362a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1362a0) {
        switch (ctx->pc) {
            case 0x1362a4: ctx->pc = 0; goto label_1362a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1362a0: 0xae11025c
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
label_1362a4:
    // 0x1362a4: 0x12200039
    WRITE32(ADD32(GPR_U32(ctx, 16), 800), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13638C; return;
    }
    // 0x1362ac: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1362b0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1362b4: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1362b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1362c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1362c0
// Address: 0x1362c0 - 0x1362c8

void entry_1362c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1362c0: 0xc05834c
    SET_GPR_U32(ctx, 31, 0x1362c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 1024));
    GetBlueprintInfo__FPiT0(rdram, ctx, runtime); return;
}


// Function: entry_1362c8
// Address: 0x1362c8 - 0x1362d0

void entry_1362c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1362c8: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1362d0);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1362d0
// Address: 0x1362d0 - 0x1362e8

void entry_1362d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1362d0: 0x8fa30400
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1024)));
    // 0x1362d4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1362d8: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_136318(rdram, ctx, runtime); return;
    }
    // 0x1362e0: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1362e8);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1362e8
// Address: 0x1362e8 - 0x136318

void entry_1362e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1362e8: 0x8e06032c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 812)));
    // 0x1362ec: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1362f0: 0x24841120
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4384));
    // 0x1362f4: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1362f8: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1362fc: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x136300: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x136304: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_136318(rdram, ctx, runtime); return;
    }
    // 0x13630c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x136310: 0xc04d79e
    SET_GPR_U32(ctx, 31, 0x136318);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    SetBinocBfk(rdram, ctx, runtime); return;
}


// Function: entry_136318
// Address: 0x136318 - 0x136320

void entry_136318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136318: 0xc058344
    SET_GPR_U32(ctx, 31, 0x136320);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_136320
// Address: 0x136320 - 0x136348

void entry_136320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136320: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x136324: 0x10400024
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1363b8(rdram, ctx, runtime); return;
    }
    // 0x13632c: 0x24050205
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 517));
    // 0x136330: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x136334: 0x24060082
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 130));
    // 0x136338: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13633c: 0x24080100
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 256));
    // 0x136340: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x136348);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_136348
// Address: 0x136348 - 0x13637c

void entry_136348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136348) {
        switch (ctx->pc) {
            case 0x136370: ctx->pc = 0; goto label_136370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136348: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13634c: 0x24030100
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 256));
    // 0x136350: 0x240200ff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 255));
    // 0x136354: 0x44102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
    // 0x136358: 0x62200b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 3));
    // 0x13635c: 0x18800016
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        entry_1363b8(rdram, ctx, runtime); return;
    }
    // 0x136364: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x136368: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13636c: 0x0
    // NOP
label_136370:
    // 0x136370: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x136374: 0xc064864
    SET_GPR_U32(ctx, 31, 0x13637c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    FUN_00192190__FP3PNT(rdram, ctx, runtime); return;
}


// Function: entry_13637c
// Address: 0x13637c - 0x1363a0

void entry_13637c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13637c) {
        switch (ctx->pc) {
            case 0x13638c: ctx->pc = 0; goto label_13638c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13637c: 0x5620fffc
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x136370; return;
    }
    // 0x136384: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1363BC; return;
    }
label_13638c:
    // 0x13638c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x136390: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x136394: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x136398: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1363a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1363a0
// Address: 0x1363a0 - 0x1363b8

void entry_1363a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1363a0: 0x8e020328
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 808)));
    // 0x1363a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1363a8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1363ac: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1363b0: 0xc04d79e
    SET_GPR_U32(ctx, 31, 0x1363b8);
    WRITE32(ADD32(GPR_U32(ctx, 16), 812), GPR_U32(ctx, 2));
    SetBinocBfk(rdram, ctx, runtime); return;
}


// Function: entry_1363b8
// Address: 0x1363b8 - 0x1363d0

void entry_1363b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1363b8) {
        switch (ctx->pc) {
            case 0x1363bc: ctx->pc = 0; goto label_1363bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1363b8: 0x7bbf0430
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
label_1363bc:
    // 0x1363bc: 0x7bb10420
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x1363c0: 0x7bb00410
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1040)));
    // 0x1363c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1088));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1363cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1363d0; return;
}


// Function: FUN_001363d0
// Address: 0x1363d0 - 0x1363e4

void FUN_001363d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1363d0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1363d4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1363d8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1363dc: 0xc06aa32
    SET_GPR_U32(ctx, 31, 0x1363e4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    OnBlotReset__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1363e4
// Address: 0x1363e4 - 0x1363f8

void entry_1363e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1363e4: 0x8e040324
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    // 0x1363e8: 0x10800004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1363FC; return;
    }
    // 0x1363f0: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x1363f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_1363f8
// Address: 0x1363f8 - 0x136408

void entry_1363f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1363f8) {
        switch (ctx->pc) {
            case 0x1363fc: ctx->pc = 0; goto label_1363fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1363f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1363fc:
    // 0x1363fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x136400: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBinocAchzDraw
// Address: 0x136408 - 0x136434

void entry_136434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136434: 0x10400032
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136500; return;
    }
    // 0x13643c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x136440: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x136444: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x13644c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_13644c
// Address: 0x13644c - 0x136474

void entry_13644c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13644c) {
        switch (ctx->pc) {
            case 0x13646c: ctx->pc = 0; goto label_13646c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13644c: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x136450: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x136454: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x136458: 0x14710004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 17)) {
        goto label_13646c;
    }
    // 0x136460: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x136464: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x136468: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
label_13646c:
    // 0x13646c: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x136474);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_136474
// Address: 0x136474 - 0x136484

void entry_136474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136474: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x136478: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13647c: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x136484);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_136484
// Address: 0x136484 - 0x1364a8

void entry_136484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136484) {
        switch (ctx->pc) {
            case 0x1364a0: ctx->pc = 0; goto label_1364a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136484: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x136488: 0x3c01438c
    SET_GPR_U32(ctx, 1, ((uint32_t)17292 << 16));
    // 0x13648c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x136490: 0x14710003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 17)) {
        goto label_1364a0;
    }
    // 0x136498: 0x3c0143be
    SET_GPR_U32(ctx, 1, ((uint32_t)17342 << 16));
    // 0x13649c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
label_1364a0:
    // 0x1364a0: 0xc05781a
    SET_GPR_U32(ctx, 31, 0x1364a8);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ClineWrap__9CRichTextf(rdram, ctx, runtime); return;
}


// Function: entry_1364a8
// Address: 0x1364a8 - 0x1364b0

void entry_1364a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1364a8: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1364b0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1364b0
// Address: 0x1364b0 - 0x1364b8

void entry_1364b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1364b0: 0xc0576e0
    SET_GPR_U32(ctx, 31, 0x1364b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Reset__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_1364b8
// Address: 0x1364b8 - 0x1364ec

void entry_1364b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1364b8) {
        switch (ctx->pc) {
            case 0x1364c0: ctx->pc = 0; goto label_1364c0;
            case 0x1364e4: ctx->pc = 0; goto label_1364e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1364b8: 0x1000000a
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1364e4;
    }
label_1364c0:
    // 0x1364c0: 0x54620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_1364e4;
    }
    // 0x1364c8: 0x8e03026c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 620)));
    // 0x1364cc: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1364d0: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1364d4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1364d8: 0xac510270
    WRITE32(ADD32(GPR_U32(ctx, 2), 624), GPR_U32(ctx, 17));
    // 0x1364dc: 0xae03026c
    WRITE32(ADD32(GPR_U32(ctx, 16), 620), GPR_U32(ctx, 3));
    // 0x1364e0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_1364e4:
    // 0x1364e4: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x1364ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_1364ec
// Address: 0x1364ec - 0x136530

void entry_1364ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1364ec) {
        switch (ctx->pc) {
            case 0x136500: ctx->pc = 0; goto label_136500;
            case 0x13650c: ctx->pc = 0; goto label_13650c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1364ec: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1364f0: 0x1460fff3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1364C0; return;
    }
    // 0x1364f8: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13650c;
    }
label_136500:
    // 0x136500: 0xa2000008
    WRITE8(ADD32(GPR_U32(ctx, 16), 8), (uint8_t)GPR_U32(ctx, 0));
    // 0x136504: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x136508: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
label_13650c:
    // 0x13650c: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x136510: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x136514: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x136518: 0xe6000268
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 616), *(uint32_t*)&val); }
    // 0x13651c: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x136520: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x136524: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13652c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x136530; return;
}


// Function: FDoneBinocAchz
// Address: 0x136530 - 0x136558

void entry_136558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136558: 0xc0577d6
    SET_GPR_U32(ctx, 31, 0x136560);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Cch__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_136560
// Address: 0x136560 - 0x1365a0

void entry_136560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136560) {
        switch (ctx->pc) {
            case 0x13658c: ctx->pc = 0; goto label_13658c;
            case 0x136590: ctx->pc = 0; goto label_136590;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136560: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x136564: 0xc6020268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 616)); ctx->f[2] = *(float*)&val; }
    // 0x136568: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x13656c: 0xc60102f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 752)); ctx->f[1] = *(float*)&val; }
    // 0x136570: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x136574: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x136578: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x13657c: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x136580: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x136584: 0x10000002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136590;
    }
label_13658c:
    // 0x13658c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_136590:
    // 0x136590: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x136594: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x136598: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBinocLookat__FP5BINOCP3ALO
// Address: 0x1365a0 - 0x1365a8

void FUN_001365f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1365f0) {
        switch (ctx->pc) {
            case 0x136634: ctx->pc = 0; goto label_136634;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1365f0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1365f4: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1365f8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1365fc: 0x8ca20260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 608)));
    // 0x136600: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x136604: 0x2c830005
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 5));
    // 0x136608: 0x1060000a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_136634;
    }
    // 0x136610: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x136614: 0x24429d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941984));
    // 0x136618: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13661c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x136620: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x136628: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x13662c: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136640; return;
    }
label_136634:
    // 0x136634: 0xc06aa26
    SET_GPR_U32(ctx, 31, 0x13663c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    DtAppearBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_13663c
// Address: 0x13663c - 0x136648

void entry_13663c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13663c) {
        switch (ctx->pc) {
            case 0x136640: ctx->pc = 0; goto label_136640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13663c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_136640:
    // 0x136640: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00136648
// Address: 0x136648 - 0x136694

void FUN_00136648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136648) {
        switch (ctx->pc) {
            case 0x13668c: ctx->pc = 0; goto label_13668c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136648: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x13664c: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x136650: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x136654: 0x8ca20260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 608)));
    // 0x136658: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x13665c: 0x2c830005
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 5));
    // 0x136660: 0x1060000a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_13668c;
    }
    // 0x136668: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x13666c: 0x24429d40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942016));
    // 0x136670: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x136674: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x136678: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x136680: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x136684: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136698; return;
    }
label_13668c:
    // 0x13668c: 0xc06aa2a
    SET_GPR_U32(ctx, 31, 0x136694);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    DtDisappearBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_136694
// Address: 0x136694 - 0x1366a0

void entry_136694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136694) {
        switch (ctx->pc) {
            case 0x136698: ctx->pc = 0; goto label_136698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136694: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_136698:
    // 0x136698: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawBinoc
// Address: 0x1366a0 - 0x1366ec

void entry_1366ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1366ec) {
        switch (ctx->pc) {
            case 0x13671c: ctx->pc = 0; goto label_13671c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1366ec: 0x104001e4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_136e80(rdram, ctx, runtime); return;
    }
    // 0x1366f4: 0x8e430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x1366f8: 0x10620027
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x136798; return;
    }
    // 0x136700: 0x14400006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_13671c;
    }
    // 0x136708: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x13670c: 0x1062001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x136784; return;
    }
    // 0x136714: 0x10000021
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13679C; return;
    }
label_13671c:
    // 0x13671c: 0x5040001e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 608)));
        ctx->pc = 0x136798; return;
    }
    // 0x136724: 0x1860001b
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 3) <= 0) {
        entry_136794(rdram, ctx, runtime); return;
    }
    // 0x13672c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x136730: 0x26102280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8832));
    // 0x136734: 0xc04c940
    SET_GPR_U32(ctx, 31, 0x13673c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawBinocReticle(rdram, ctx, runtime); return;
}


// Function: entry_13673c
// Address: 0x13673c - 0x13674c

void entry_13673c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13673c: 0x8e46031c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 796)));
    // 0x136740: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x136744: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x13674c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 792)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_13674c
// Address: 0x13674c - 0x136758

void entry_13674c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13674c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x136750: 0xc04c5ba
    SET_GPR_U32(ctx, 31, 0x136758);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawBinocCompass(rdram, ctx, runtime); return;
}


// Function: entry_136758
// Address: 0x136758 - 0x136764

void entry_136758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136758: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13675c: 0xc04c7d8
    SET_GPR_U32(ctx, 31, 0x136764);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawBinocZoom(rdram, ctx, runtime); return;
}


// Function: entry_136764
// Address: 0x136764 - 0x136770

void entry_136764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136764: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x136768: 0xc04ced6
    SET_GPR_U32(ctx, 31, 0x136770);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawBinocOutline(rdram, ctx, runtime); return;
}


// Function: entry_136770
// Address: 0x136770 - 0x13677c

void entry_136770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136770: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x136774: 0xc04d48a
    SET_GPR_U32(ctx, 31, 0x13677c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DrawBinocFilter(rdram, ctx, runtime); return;
}


// Function: entry_13677c
// Address: 0x13677c - 0x136794

void entry_13677c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13677c) {
        switch (ctx->pc) {
            case 0x136784: ctx->pc = 0; goto label_136784;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13677c: 0x10000006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136798; return;
    }
label_136784:
    // 0x136784: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x136788: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13678c: 0xc04c940
    SET_GPR_U32(ctx, 31, 0x136794);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8832));
    DrawBinocReticle(rdram, ctx, runtime); return;
}


// Function: entry_136794
// Address: 0x136794 - 0x1367d8

void entry_136794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136794) {
        switch (ctx->pc) {
            case 0x136798: ctx->pc = 0; goto label_136798;
            case 0x13679c: ctx->pc = 0; goto label_13679c;
            case 0x1367b8: ctx->pc = 0; goto label_1367b8;
            case 0x1367d0: ctx->pc = 0; goto label_1367d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136794: 0x8e430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 608)));
label_136798:
    // 0x136798: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
label_13679c:
    // 0x13679c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1367a0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1367a4: 0x14620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1367b8;
    }
    // 0x1367ac: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1367b0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1367b4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
label_1367b8:
    // 0x1367b8: 0x54620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        goto label_1367d0;
    }
    // 0x1367c0: 0x82420008
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1367c4: 0x104001af
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1136)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136E84; return;
    }
    // 0x1367cc: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1367d0:
    // 0x1367d0: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1367d8);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1367d8
// Address: 0x1367d8 - 0x1368b0

void entry_1367d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1367d8) {
        switch (ctx->pc) {
            case 0x13680c: ctx->pc = 0; goto label_13680c;
            case 0x136810: ctx->pc = 0; goto label_136810;
            case 0x13685c: ctx->pc = 0; goto label_13685c;
            case 0x13686c: ctx->pc = 0; goto label_13686c;
            case 0x136884: ctx->pc = 0; goto label_136884;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1367d8: 0x8e420210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x1367dc: 0x8a4302f7
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 759); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1367e0: 0x9a4302f4
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 756); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1367e4: 0xaba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1367e8: 0xbba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1367ec: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
        goto label_13680c;
    }
    // 0x1367f4: 0x8847001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x1367f8: 0x98470018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x1367fc: 0xaba70013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136800: 0xbba70010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136804: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136810;
    }
label_13680c:
    // 0x13680c: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_136810:
    // 0x136810: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x136814: 0x4480b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 0);
    // 0x136818: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x13681c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x136820: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x136824: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x136828: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x13682c: 0x4600be06
    ctx->f[24] = FPU_MOV_S(ctx->f[23]);
    // 0x136830: 0x8e440260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x136834: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x136838: 0x3c01438c
    SET_GPR_U32(ctx, 1, ((uint32_t)17292 << 16));
    // 0x13683c: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x136840: 0x10830006
    ctx->f[22] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_13685c;
    }
    // 0x136848: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13684c: 0x50820007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->f[22] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
        goto label_13686c;
    }
    // 0x136854: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136884;
    }
label_13685c:
    // 0x13685c: 0x3c01c100
    SET_GPR_U32(ctx, 1, ((uint32_t)49408 << 16));
    // 0x136860: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x136864: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136884;
    }
label_13686c:
    // 0x13686c: 0x3c0143be
    SET_GPR_U32(ctx, 1, ((uint32_t)17342 << 16));
    // 0x136870: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x136874: 0x3c01c248
    SET_GPR_U32(ctx, 1, ((uint32_t)49736 << 16));
    // 0x136878: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x13687c: 0x3c014220
    SET_GPR_U32(ctx, 1, ((uint32_t)16928 << 16));
    // 0x136880: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
label_136884:
    // 0x136884: 0x3c014334
    SET_GPR_U32(ctx, 1, ((uint32_t)17204 << 16));
    // 0x136888: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13688c: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x136890: 0x3c0143c1
    SET_GPR_U32(ctx, 1, ((uint32_t)17345 << 16));
    // 0x136894: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x136898: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x13689c: 0x3c10ff80
    SET_GPR_U32(ctx, 16, ((uint32_t)65408 << 16));
    // 0x1368a0: 0x460cc300
    ctx->f[12] = FPU_ADD_S(ctx->f[24], ctx->f[12]);
    // 0x1368a4: 0x36108080
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 32896));
    // 0x1368a8: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1368b0);
    ctx->f[13] = FPU_ADD_S(ctx->f[23], ctx->f[13]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1368b0
// Address: 0x1368b0 - 0x1368c0

void entry_1368b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1368b0: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1368b4: 0x4600cb06
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    // 0x1368b8: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1368c0);
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1368c0
// Address: 0x1368c0 - 0x1368d0

void entry_1368c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1368c0: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1368c4: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1368c8: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1368d0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1368d0
// Address: 0x1368d0 - 0x1368dc

void entry_1368d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1368d0: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1368d4: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1368dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1368dc
// Address: 0x1368dc - 0x1368e8

void entry_1368dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1368dc: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1368e0: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1368e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1368e8
// Address: 0x1368e8 - 0x136ac4

void entry_1368e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1368e8) {
        switch (ctx->pc) {
            case 0x13690c: ctx->pc = 0; goto label_13690c;
            case 0x136924: ctx->pc = 0; goto label_136924;
            case 0x136978: ctx->pc = 0; goto label_136978;
            case 0x1369a0: ctx->pc = 0; goto label_1369a0;
            case 0x136a04: ctx->pc = 0; goto label_136a04;
            case 0x136a38: ctx->pc = 0; goto label_136a38;
            case 0x136a5c: ctx->pc = 0; goto label_136a5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1368e8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1368ec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1368f0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1368f4: 0x246308e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 2272));
    // 0x1368f8: 0x8c620270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 624)));
    // 0x1368fc: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13690c;
    }
    // 0x136904: 0xc460023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 572)); ctx->f[0] = *(float*)&val; }
    // 0x136908: 0x460300e9
    ctx->f[3] = std::min(ctx->f[0], ctx->f[3]);
label_13690c:
    // 0x13690c: 0x24421558
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 5464));
    // 0x136910: 0x8c430270
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 624)));
    // 0x136914: 0x10600003
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_136924;
    }
    // 0x13691c: 0xc440023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 572)); ctx->f[0] = *(float*)&val; }
    // 0x136920: 0x460300e9
    ctx->f[3] = std::min(ctx->f[0], ctx->f[3]);
label_136924:
    // 0x136924: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x136928: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13692c: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x136930: 0x0
    // NOP
    // 0x136934: 0x45000049
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 3)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_136a5c;
    }
    // 0x13693c: 0x10600018
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1369a0;
    }
    // 0x136944: 0x5060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
        goto label_136978;
    }
    // 0x13694c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x136950: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x136954: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x136958: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x13695c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x136960: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x136964: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x136968: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x13696c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x136970: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1369a0;
    }
label_136978:
    // 0x136978: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x13697c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x136980: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x136984: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x136988: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13698c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x136990: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x136994: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x136998: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13699c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1369a0:
    // 0x1369a0: 0x8ba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1369a4: 0x9ba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1369a8: 0xaba30043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1369ac: 0xbba30040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1369b0: 0xa3a20043
    WRITE8(ADD32(GPR_U32(ctx, 29), 67), (uint8_t)GPR_U32(ctx, 2));
    // 0x1369b4: 0x8ba70043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x1369b8: 0x9ba70040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x1369bc: 0xaba70003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1369c0: 0xbba70000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1369c4: 0x93a30013
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 19)));
    // 0x1369c8: 0x1060001b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_136a38;
    }
    // 0x1369d0: 0x1060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_136a04;
    }
    // 0x1369d8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1369dc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1369e0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1369e4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1369e8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1369ec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1369f0: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1369f4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1369f8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1369fc: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136a38;
    }
label_136a04:
    // 0x136a04: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x136a08: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x136a0c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x136a10: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x136a14: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x136a18: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x136a1c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x136a20: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x136a24: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x136a28: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x136a2c: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x136a30: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x136a34: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_136a38:
    // 0x136a38: 0x8ba30013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x136a3c: 0x9ba30010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x136a40: 0xaba30053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136a44: 0xbba30050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136a48: 0xa3a20053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 2));
    // 0x136a4c: 0x8ba70053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x136a50: 0x9ba70050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x136a54: 0xaba70013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136a58: 0xbba70010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
label_136a5c:
    // 0x136a5c: 0x8e430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x136a60: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x136a64: 0x5462001d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 8)));
        ctx->pc = 0x136ADC; return;
    }
    // 0x136a6c: 0x8e430210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x136a70: 0x5060001a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 8)));
        ctx->pc = 0x136ADC; return;
    }
    // 0x136a78: 0x8865001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x136a7c: 0x98650018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x136a80: 0xaba50043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136a84: 0xbba50040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136a88: 0x8ba40013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x136a8c: 0x9ba40010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x136a90: 0xa864001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136a94: 0xb8640018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136a98: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x136a9c: 0x8e450210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x136aa0: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x136aa4: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_136ac4(rdram, ctx, runtime); return;
    }
    // 0x136aac: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x136ab0: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x136ab4: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x136ab8: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x136abc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x136ac4);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_136ac4
// Address: 0x136ac4 - 0x136afc

void entry_136ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136ac4) {
        switch (ctx->pc) {
            case 0x136adc: ctx->pc = 0; goto label_136adc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136ac4: 0x8e420210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x136ac8: 0x8ba30043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x136acc: 0x9ba30040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x136ad0: 0xa843001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136ad4: 0xb8430018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x136ad8: 0x82420008
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 8)));
label_136adc:
    // 0x136adc: 0x1040008c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_136d10(rdram, ctx, runtime); return;
    }
    // 0x136ae4: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x136ae8: 0x8e460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x136aec: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x136af0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x136af4: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x136afc);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_136afc
// Address: 0x136afc - 0x136b04

void entry_136afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136afc: 0xc0577d6
    SET_GPR_U32(ctx, 31, 0x136b04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Cch__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_136b04
// Address: 0x136b04 - 0x136c04

void entry_136b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136b04) {
        switch (ctx->pc) {
            case 0x136b70: ctx->pc = 0; goto label_136b70;
            case 0x136b8c: ctx->pc = 0; goto label_136b8c;
            case 0x136bf4: ctx->pc = 0; goto label_136bf4;
            case 0x136bf8: ctx->pc = 0; goto label_136bf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136b04: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x136b08: 0xc6410268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 616)); ctx->f[1] = *(float*)&val; }
    // 0x136b0c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x136b10: 0xc64202f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 752)); ctx->f[2] = *(float*)&val; }
    // 0x136b14: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x136b18: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x136b1c: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x136b20: 0x8e43026c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 620)));
    // 0x136b24: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x136b28: 0x27b10110
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 272));
    // 0x136b2c: 0x27b50310
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 784));
    // 0x136b30: 0x27b703c0
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 960));
    // 0x136b34: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x136b38: 0x27b60020
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 32));
    // 0x136b3c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x136b40: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x136b44: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x136b48: 0x214102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 20)));
    // 0x136b4c: 0x1860000f
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 20));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_136b8c;
    }
    // 0x136b54: 0x8e420270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 624)));
    // 0x136b58: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x136b5c: 0x1440000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_136b8c;
    }
    // 0x136b64: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x136b68: 0x26430270
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 624));
    // 0x136b6c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_136b70:
    // 0x136b70: 0x264102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 4)));
    // 0x136b74: 0x10400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_136b8c;
    }
    // 0x136b7c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x136b80: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x136b84: 0x5040fffa
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        goto label_136b70;
    }
label_136b8c:
    // 0x136b8c: 0x1a600019
    if (GPR_S32(ctx, 19) <= 0) {
        goto label_136bf4;
    }
    // 0x136b94: 0x8e42026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 620)));
    // 0x136b98: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x136b9c: 0x10400015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 624));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_136bf4;
    }
    // 0x136ba4: 0x2663ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x136ba8: 0x132080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 19), 2));
    // 0x136bac: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x136bb0: 0x442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x136bb4: 0xc64402f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 752)); ctx->f[4] = *(float*)&val; }
    // 0x136bb8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x136bbc: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x136bc0: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x136bc4: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x136bc8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x136bcc: 0xc6430268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 616)); ctx->f[3] = *(float*)&val; }
    // 0x136bd0: 0x27c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x136bd4: 0x46040843
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[4];
    // 0x136bd8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x136bdc: 0x46041083
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[4];
    // 0x136be0: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x136be4: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x136be8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x136bec: 0x10000002
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[21] = ctx->f[0] / ctx->f[1];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136bf8;
    }
label_136bf4:
    // 0x136bf4: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
label_136bf8:
    // 0x136bf8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x136bfc: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x136c04);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_136c04
// Address: 0x136c04 - 0x136c14

void entry_136c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136c04: 0x8e460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x136c08: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x136c0c: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x136c14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_136c14
// Address: 0x136c14 - 0x136c20

void entry_136c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136c14: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x136c18: 0xc0577e8
    SET_GPR_U32(ctx, 31, 0x136c20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Trim__9CRichTexti(rdram, ctx, runtime); return;
}


// Function: entry_136c20
// Address: 0x136c20 - 0x136c64

void entry_136c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136c20) {
        switch (ctx->pc) {
            case 0x136c4c: ctx->pc = 0; goto label_136c4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136c20: 0x214102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 20)));
    // 0x136c24: 0x14400009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_136c4c;
    }
    // 0x136c2c: 0x27c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x136c30: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x136c34: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x136c38: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x136c3c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x136c40: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x136c44: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x136c48: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
label_136c4c:
    // 0x136c4c: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x136C68; return;
    }
    // 0x136c54: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x136c58: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x136c5c: 0xc078860
    SET_GPR_U32(ctx, 31, 0x136c64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294942040));
    strcpy1(rdram, ctx, runtime); return;
}


// Function: entry_136c64
// Address: 0x136c64 - 0x136cc0

void entry_136c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136c64) {
        switch (ctx->pc) {
            case 0x136c68: ctx->pc = 0; goto label_136c68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136c64: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_136c68:
    // 0x136c68: 0x4493a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 19);
    // 0x136c6c: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x136c70: 0x3c0143c1
    SET_GPR_U32(ctx, 1, ((uint32_t)17345 << 16));
    // 0x136c74: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x136c78: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x136c7c: 0x27a403c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 960));
    // 0x136c80: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x136c84: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x136c88: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x136c8c: 0x4615a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[21]);
    // 0x136c90: 0x3c014334
    SET_GPR_U32(ctx, 1, ((uint32_t)17204 << 16));
    // 0x136c94: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x136c98: 0x4602b880
    ctx->f[2] = FPU_ADD_S(ctx->f[23], ctx->f[2]);
    // 0x136c9c: 0x8fb00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x136ca0: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x136ca4: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x136ca8: 0x460cc300
    ctx->f[12] = FPU_ADD_S(ctx->f[24], ctx->f[12]);
    // 0x136cac: 0x4601a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x136cb0: 0x4616a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[22]);
    // 0x136cb4: 0x46006b68
    ctx->f[13] = std::max(ctx->f[13], ctx->f[0]);
    // 0x136cb8: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x136cc0);
    ctx->f[13] = FPU_SUB_S(ctx->f[2], ctx->f[13]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_136cc0
// Address: 0x136cc0 - 0x136cd0

void entry_136cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136cc0: 0x27a403c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 960));
    // 0x136cc4: 0x4600cb06
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    // 0x136cc8: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x136cd0);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_136cd0
// Address: 0x136cd0 - 0x136ce0

void entry_136cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136cd0: 0x27a403c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 960));
    // 0x136cd4: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x136cd8: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x136ce0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_136ce0
// Address: 0x136ce0 - 0x136cec

void entry_136ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136ce0: 0x27a403c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 960));
    // 0x136ce4: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x136cec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_136cec
// Address: 0x136cec - 0x136cf8

void entry_136cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136cec: 0x27a403c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 960));
    // 0x136cf0: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x136cf8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_136cf8
// Address: 0x136cf8 - 0x136d10

void entry_136cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136cf8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x136cfc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x136d00: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x136d04: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x136d08: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x136d10);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 8832));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_136d10
// Address: 0x136d10 - 0x136d18

void entry_136d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136d10: 0xc057240
    SET_GPR_U32(ctx, 31, 0x136d18);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_136d18
// Address: 0x136d18 - 0x136d54

void entry_136d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136d18: 0x824202f8
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 760)));
    // 0x136d1c: 0x10400058
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 760)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_136e80(rdram, ctx, runtime); return;
    }
    // 0x136d24: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x136d28: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x136d2c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x136d30: 0xc44c185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[12] = *(float*)&val; }
    // 0x136d34: 0xa3a30050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 3));
    // 0x136d38: 0xa3a00051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 0));
    // 0x136d3c: 0x83a30050
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x136d40: 0x83a40051
    SET_GPR_S32(ctx, 4, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 81)));
    // 0x136d44: 0xa3a30040
    WRITE8(ADD32(GPR_U32(ctx, 29), 64), (uint8_t)GPR_U32(ctx, 3));
    // 0x136d48: 0xa3a40041
    WRITE8(ADD32(GPR_U32(ctx, 29), 65), (uint8_t)GPR_U32(ctx, 4));
    // 0x136d4c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x136d54);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_136d54
// Address: 0x136d54 - 0x136d5c

void entry_136d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136d54: 0xc081484
    SET_GPR_U32(ctx, 31, 0x136d5c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_136d5c
// Address: 0x136d5c - 0x136da4

void entry_136d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136d5c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x136d60: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x136d64: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x136d68: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x136d6c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x136d70: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x136d74: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x136d78: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x136d7c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x136d80: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x136d84: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x136d88: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x136d8c: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x136d90: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x136d94: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x136d98: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x136d9c: 0xc057070
    SET_GPR_U32(ctx, 31, 0x136da4);
    ctx->f[20] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_136da4
// Address: 0x136da4 - 0x136e00

void entry_136da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136da4) {
        switch (ctx->pc) {
            case 0x136dd4: ctx->pc = 0; goto label_136dd4;
            case 0x136df4: ctx->pc = 0; goto label_136df4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136da4: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x136da8: 0x8e430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x136dac: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x136db0: 0x14620008
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_136dd4;
    }
    // 0x136db8: 0x3c014405
    SET_GPR_U32(ctx, 1, ((uint32_t)17413 << 16));
    // 0x136dbc: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x136dc0: 0x3c0143ec
    SET_GPR_U32(ctx, 1, ((uint32_t)17388 << 16));
    // 0x136dc4: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x136dc8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x136dcc: 0x10000009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_136df4;
    }
label_136dd4:
    // 0x136dd4: 0x3c0143f1
    SET_GPR_U32(ctx, 1, ((uint32_t)17393 << 16));
    // 0x136dd8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x136ddc: 0x3c0143ec
    SET_GPR_U32(ctx, 1, ((uint32_t)17388 << 16));
    // 0x136de0: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x136de4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x136de8: 0x4600c580
    ctx->f[22] = FPU_ADD_S(ctx->f[24], ctx->f[0]);
    // 0x136dec: 0x4601bd40
    ctx->f[21] = FPU_ADD_S(ctx->f[23], ctx->f[1]);
    // 0x136df0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_136df4:
    // 0x136df4: 0x3c10ff80
    SET_GPR_U32(ctx, 16, ((uint32_t)65408 << 16));
    // 0x136df8: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x136e00);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_136e00
// Address: 0x136e00 - 0x136e14

void entry_136e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136e00: 0x36108080
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 32896));
    // 0x136e04: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x136e08: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x136e0c: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x136e14);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_136e14
// Address: 0x136e14 - 0x136e24

void entry_136e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136e14: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x136e18: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x136e1c: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x136e24);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_136e24
// Address: 0x136e24 - 0x136e34

void entry_136e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136e24: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x136e28: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x136e2c: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x136e34);
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_136e34
// Address: 0x136e34 - 0x136e40

void entry_136e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136e34: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x136e38: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x136e40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_136e40
// Address: 0x136e40 - 0x136e4c

void entry_136e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136e40: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x136e44: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x136e4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_136e4c
// Address: 0x136e4c - 0x136e78

void entry_136e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136e4c: 0x27a20050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 80));
    // 0x136e50: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x136e54: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x136e58: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x136e5c: 0xac430018
    WRITE32(ADD32(GPR_U32(ctx, 2), 24), GPR_U32(ctx, 3));
    // 0x136e60: 0x25082280
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 8832));
    // 0x136e64: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x136e68: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x136e6c: 0xac430014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 3));
    // 0x136e70: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x136e78);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_136e78
// Address: 0x136e78 - 0x136e80

void entry_136e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136e78: 0xc057240
    SET_GPR_U32(ctx, 31, 0x136e80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_136e80
// Address: 0x136e80 - 0x136ec8

void entry_136e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136e80) {
        switch (ctx->pc) {
            case 0x136e84: ctx->pc = 0; goto label_136e84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136e80: 0x7bbf0470
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1136)));
label_136e84:
    // 0x136e84: 0x7bbe0460
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 1120)));
    // 0x136e88: 0x7bb70450
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x136e8c: 0x7bb60440
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x136e90: 0x7bb50430
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x136e94: 0x7bb40420
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x136e98: 0x7bb30410
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1040)));
    // 0x136e9c: 0x7bb20400
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1024)));
    // 0x136ea0: 0x7bb103f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1008)));
    // 0x136ea4: 0x7bb003e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 992)));
    // 0x136ea8: 0xc7b904a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1192)); ctx->f[25] = *(float*)&val; }
    // 0x136eac: 0xc7b804a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1184)); ctx->f[24] = *(float*)&val; }
    // 0x136eb0: 0xc7b70498
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1176)); ctx->f[23] = *(float*)&val; }
    // 0x136eb4: 0xc7b60490
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1168)); ctx->f[22] = *(float*)&val; }
    // 0x136eb8: 0xc7b50488
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1160)); ctx->f[21] = *(float*)&val; }
    // 0x136ebc: 0xc7b40480
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1152)); ctx->f[20] = *(float*)&val; }
    // 0x136ec0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1200));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetBinocReticleFocus__FP5BINOCPfT1
// Address: 0x136ec8 - 0x136ef8

void FUN_00136ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136ef8) {
        switch (ctx->pc) {
            case 0x136f3c: ctx->pc = 0; goto label_136f3c;
            case 0x136f4c: ctx->pc = 0; goto label_136f4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136ef8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x136efc: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x136f00: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x136f04: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x136f08: 0x8e020324
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    // 0x136f0c: 0x5040001f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x136F8C; return;
    }
    // 0x136f14: 0x8c4302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 720)));
    // 0x136f18: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x136f1c: 0x1062000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x136F5C; return;
    }
    // 0x136f24: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_136f3c;
    }
    // 0x136f2c: 0x10600007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_136f4c;
    }
    // 0x136f34: 0x10000011
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136F7C; return;
    }
label_136f3c:
    // 0x136f3c: 0x1062000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x136F70; return;
    }
    // 0x136f44: 0x1000000d
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136F7C; return;
    }
label_136f4c:
    // 0x136f4c: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x136f54);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_136f54
// Address: 0x136f54 - 0x136f68

void entry_136f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136f54) {
        switch (ctx->pc) {
            case 0x136f5c: ctx->pc = 0; goto label_136f5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136f54: 0x10000009
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136F7C; return;
    }
label_136f5c:
    // 0x136f5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x136f60: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x136f68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_136f68
// Address: 0x136f68 - 0x136f78

void entry_136f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136f68) {
        switch (ctx->pc) {
            case 0x136f70: ctx->pc = 0; goto label_136f70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136f68: 0x10000004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136F7C; return;
    }
label_136f70:
    // 0x136f70: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x136f78);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_136f78
// Address: 0x136f78 - 0x136f84

void entry_136f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136f78) {
        switch (ctx->pc) {
            case 0x136f7c: ctx->pc = 0; goto label_136f7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136f78: 0x8e040324
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 804)));
label_136f7c:
    // 0x136f7c: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x136f84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_136f84
// Address: 0x136f84 - 0x136f94

void entry_136f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136f84) {
        switch (ctx->pc) {
            case 0x136f8c: ctx->pc = 0; goto label_136f8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136f84: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136F98; return;
    }
label_136f8c:
    // 0x136f8c: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x136f94);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_136f94
// Address: 0x136f94 - 0x136fa8

void entry_136f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136f94) {
        switch (ctx->pc) {
            case 0x136f98: ctx->pc = 0; goto label_136f98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136f94: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_136f98:
    // 0x136f98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x136f9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x136fa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x136fa8; return;
}


// Function: FUN_00136fa8
// Address: 0x136fa8 - 0x136fc8

void FUN_00136fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x136fa8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x136fac: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x136fb0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x136fb4: 0x8c440324
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 804)));
    // 0x136fb8: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
        ctx->pc = 0x136FD0; return;
    }
    // 0x136fc0: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x136fc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_136fc8
// Address: 0x136fc8 - 0x136fd8

void entry_136fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136fc8) {
        switch (ctx->pc) {
            case 0x136fd0: ctx->pc = 0; goto label_136fd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136fc8: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x136FDC; return;
    }
label_136fd0:
    // 0x136fd0: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x136fd8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_136fd8
// Address: 0x136fd8 - 0x136fe8

void entry_136fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x136fd8) {
        switch (ctx->pc) {
            case 0x136fdc: ctx->pc = 0; goto label_136fdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x136fd8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_136fdc:
    // 0x136fdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x136fe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x136fe8; return;
}


// Function: binoc__static_initialization_and_destruction_0
// Address: 0x136fe8 - 0x137188

void entry_137188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137188: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x13718c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x137190: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x137194: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x137198: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13719c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1371a0: 0x26101168
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4456));
    // 0x1371a4: 0xae320018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 18));
    // 0x1371a8: 0xe6200008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x1371ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1371b0: 0xa2340004
    WRITE8(ADD32(GPR_U32(ctx, 17), 4), (uint8_t)GPR_U32(ctx, 20));
    // 0x1371b4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1371b8: 0xe6340010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x1371bc: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1371c0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1371c8);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 20), *(uint32_t*)&val); }
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1371c8
// Address: 0x1371c8 - 0x137228

void entry_1371c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1371c8) {
        switch (ctx->pc) {
            case 0x1371f0: ctx->pc = 0; goto label_1371f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1371c8: 0x3c014200
    SET_GPR_U32(ctx, 1, ((uint32_t)16896 << 16));
    // 0x1371cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1371d0: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1371d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1371d8: 0xae120018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 18));
    // 0x1371dc: 0xa2140004
    WRITE8(ADD32(GPR_U32(ctx, 16), 4), (uint8_t)GPR_U32(ctx, 20));
    // 0x1371e0: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1371e4: 0xe601000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1371e8: 0xe6140014
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x1371ec: 0xe6140010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
label_1371f0:
    // 0x1371f0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1371f4: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1371f8: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1371fc: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x137200: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x137204: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x137208: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13720c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x137210: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137214: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137218: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x13721c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137224: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137228; return;
}


// Function: SetPos__8CTextBoxff
// Address: 0x137228 - 0x137238

void entry_137284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137284: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137288: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___18CBinaryInputStreamPvii
// Address: 0x137290 - 0x1372fc

void entry_1372fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1372fc: 0x32100001
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 1));
    // 0x137300: 0x12000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137314; return;
    }
    // 0x137308: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x137310);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_137310
// Address: 0x137310 - 0x137328

void entry_137310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137310) {
        switch (ctx->pc) {
            case 0x137314: ctx->pc = 0; goto label_137314;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137310: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_137314:
    // 0x137314: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137318: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13731c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137324: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137328; return;
}


// Function: FOpenSector__18CBinaryInputStreamUiUi
// Address: 0x137328 - 0x137398

void entry_1373c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1373c4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1373c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Close__18CBinaryInputStream
// Address: 0x1373d0 - 0x137410

void entry_137410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137410) {
        switch (ctx->pc) {
            case 0x137418: ctx->pc = 0; goto label_137418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137410: 0x1000000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137450; return;
    }
label_137418:
    // 0x137418: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x13741c: 0x1040000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137450; return;
    }
    // 0x137424: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x137428: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x13742c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137444; return;
    }
    // 0x137434: 0xc080f8a
    SET_GPR_U32(ctx, 31, 0x13743c);
    sceCdBreak(rdram, ctx, runtime); return;
}


// Function: entry_13743c
// Address: 0x13743c - 0x13744c

void entry_13743c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13743c) {
        switch (ctx->pc) {
            case 0x137444: ctx->pc = 0; goto label_137444;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13743c: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137450; return;
    }
label_137444:
    // 0x137444: 0xc0478a8
    SET_GPR_U32(ctx, 31, 0x13744c);
    snd_StreamSafeCdBreak(rdram, ctx, runtime); return;
}


// Function: entry_13744c
// Address: 0x13744c - 0x137480

void entry_13744c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13744c) {
        switch (ctx->pc) {
            case 0x137450: ctx->pc = 0; goto label_137450;
            case 0x137454: ctx->pc = 0; goto label_137454;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13744c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_137450:
    // 0x137450: 0xae00002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 0));
label_137454:
    // 0x137454: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x137458: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x13745c: 0xae000018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 0));
    // 0x137460: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    // 0x137464: 0xae00001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 0));
    // 0x137468: 0xae000028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 0));
    // 0x13746c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137470: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137474: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13747c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137480; return;
}


// Function: DecrementCdReadLimit__18CBinaryInputStreami
// Address: 0x137480 - 0x137490

void entry_137570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137570) {
        switch (ctx->pc) {
            case 0x137578: ctx->pc = 0; goto label_137578;
            case 0x13757c: ctx->pc = 0; goto label_13757c;
            case 0x1375a8: ctx->pc = 0; goto label_1375a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137570: 0x10000002
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13757c;
    }
label_137578:
    // 0x137578: 0x8e030044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 68)));
label_13757c:
    // 0x13757c: 0x8e05003c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x137580: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x137584: 0x8e040038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x137588: 0x65102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x13758c: 0xa2180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 5));
    // 0x137590: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x137594: 0x82202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x137598: 0x50800003
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1375a8;
    }
    // 0x1375a0: 0x10000041
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1376a8(rdram, ctx, runtime); return;
    }
label_1375a8:
    // 0x1375a8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1375ac: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1375C4; return;
    }
    // 0x1375b4: 0xc080cb2
    SET_GPR_U32(ctx, 31, 0x1375bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    sceCdSync(rdram, ctx, runtime); return;
}


// Function: entry_1375bc
// Address: 0x1375bc - 0x1375cc

void entry_1375bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1375bc) {
        switch (ctx->pc) {
            case 0x1375c4: ctx->pc = 0; goto label_1375c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1375bc: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1375cc(rdram, ctx, runtime); return;
    }
label_1375c4:
    // 0x1375c4: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x1375cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_1375cc
// Address: 0x1375cc - 0x1375ec

void entry_1375cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1375cc: 0x54400037
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x1376AC; return;
    }
    // 0x1375d4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1375d8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1375dc: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1375F4; return;
    }
    // 0x1375e4: 0xc080f64
    SET_GPR_U32(ctx, 31, 0x1375ec);
    sceCdGetError(rdram, ctx, runtime); return;
}


// Function: entry_1375ec
// Address: 0x1375ec - 0x1375fc

void entry_1375ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1375ec) {
        switch (ctx->pc) {
            case 0x1375f4: ctx->pc = 0; goto label_1375f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1375ec: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1375fc(rdram, ctx, runtime); return;
    }
label_1375f4:
    // 0x1375f4: 0xc0478ba
    SET_GPR_U32(ctx, 31, 0x1375fc);
    snd_StreamSafeCdGetError(rdram, ctx, runtime); return;
}


// Function: entry_1375fc
// Address: 0x1375fc - 0x137698

void entry_1375fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1375fc) {
        switch (ctx->pc) {
            case 0x137640: ctx->pc = 0; goto label_137640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1375fc: 0x54400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 88)));
        goto label_137640;
    }
    // 0x137604: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x137608: 0x8e060048
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x13760c: 0x248307ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 2047));
    // 0x137610: 0x264102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 4)));
    // 0x137614: 0x8e050040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x137618: 0x82180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x13761c: 0x31ac3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 11));
    // 0x137620: 0xae040038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 4));
    // 0x137624: 0xc33021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x137628: 0xa42823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x13762c: 0xae060048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 6));
    // 0x137630: 0xae050040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 5));
    // 0x137634: 0xae00003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 0));
    // 0x137638: 0x1000001b
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1376a8(rdram, ctx, runtime); return;
    }
label_137640:
    // 0x137640: 0x8e050038
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x137644: 0xf13818
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x137648: 0x8e03003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x13764c: 0x265102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 5)));
    // 0x137650: 0x24a407ff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 2047));
    // 0x137654: 0xa2200b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 5));
    // 0x137658: 0x8e060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x13765c: 0x651823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x137660: 0x8e080048
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x137664: 0x246307ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 2047));
    // 0x137668: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13766c: 0xc73021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    // 0x137670: 0x721824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x137674: 0x422c3
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 11));
    // 0x137678: 0xc53021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x13767c: 0x1042021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    // 0x137680: 0x31ac3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 11));
    // 0x137684: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x137688: 0x10400005
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1376A0; return;
    }
    // 0x137690: 0xc050332
    SET_GPR_U32(ctx, 31, 0x137698);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    ReadCdDirect__FUiUiPv(rdram, ctx, runtime); return;
}


// Function: entry_137698
// Address: 0x137698 - 0x1376a8

void entry_137698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137698) {
        switch (ctx->pc) {
            case 0x1376a0: ctx->pc = 0; goto label_1376a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137698: 0x10000004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1376AC; return;
    }
label_1376a0:
    // 0x1376a0: 0xc05030a
    SET_GPR_U32(ctx, 31, 0x1376a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    ReadCd__FUiUiPv(rdram, ctx, runtime); return;
}


// Function: entry_1376a8
// Address: 0x1376a8 - 0x137738

void entry_1376a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1376a8) {
        switch (ctx->pc) {
            case 0x1376ac: ctx->pc = 0; goto label_1376ac;
            case 0x1376f4: ctx->pc = 0; goto label_1376f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1376a8: 0x8e070050
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 80)));
label_1376ac:
    // 0x1376ac: 0x8e06004c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x1376b0: 0xe6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 6)));
    // 0x1376b4: 0x50400026
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x137750; return;
    }
    // 0x1376bc: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1376c0: 0x54400023
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x137750; return;
    }
    // 0x1376c8: 0x8e040040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1376cc: 0x1880001f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 17)));
    if (GPR_S32(ctx, 4) <= 0) {
        entry_13774c(rdram, ctx, runtime); return;
    }
    // 0x1376d4: 0x8e030058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x1376d8: 0x222200a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 17));
    // 0x1376dc: 0xae000038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 0));
    // 0x1376e0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1376e4: 0xae04003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 4));
    // 0x1376e8: 0x66001a
    { int32_t divisor = GPR_S32(ctx, 6); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 3) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 6) % divisor); } else { ctx->lo = (GPR_S32(ctx,3) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,6); } }
    // 0x1376ec: 0x50c00001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1376f4;
    }
label_1376f4:
    // 0x1376f4: 0x24e20001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1376f8: 0x248407ff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2047));
    // 0x1376fc: 0xae020050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 2));
    // 0x137700: 0x8e060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x137704: 0x922024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x137708: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13770c: 0x43ac3
    SET_GPR_S32(ctx, 7, SRA32(GPR_S32(ctx, 4), 11));
    // 0x137710: 0x8e080048
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x137714: 0x30630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 2));
    // 0x137718: 0x2810
    SET_GPR_U32(ctx, 5, ctx->hi);
    // 0x13771c: 0xb11018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x137720: 0xae050058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 5));
    // 0x137724: 0x10600006
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137740; return;
    }
    // 0x13772c: 0x100202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x137730: 0xc050332
    SET_GPR_U32(ctx, 31, 0x137738);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    ReadCdDirect__FUiUiPv(rdram, ctx, runtime); return;
}


// Function: entry_137738
// Address: 0x137738 - 0x13774c

void entry_137738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137738) {
        switch (ctx->pc) {
            case 0x137740: ctx->pc = 0; goto label_137740;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137738: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137750; return;
    }
label_137740:
    // 0x137740: 0x100202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x137744: 0xc05030a
    SET_GPR_U32(ctx, 31, 0x13774c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    ReadCd__FUiUiPv(rdram, ctx, runtime); return;
}


// Function: entry_13774c
// Address: 0x13774c - 0x1377c0

void entry_13774c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13774c) {
        switch (ctx->pc) {
            case 0x137750: ctx->pc = 0; goto label_137750;
            case 0x137760: ctx->pc = 0; goto label_137760;
            case 0x13776c: ctx->pc = 0; goto label_13776c;
            case 0x137798: ctx->pc = 0; goto label_137798;
            case 0x1377a8: ctx->pc = 0; goto label_1377a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13774c: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
label_137750:
    // 0x137750: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_137760;
    }
    // 0x137758: 0x1000000f
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137798;
    }
label_137760:
    // 0x137760: 0x14540002
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        goto label_13776c;
    }
    // 0x137768: 0x8e060038
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 56)));
label_13776c:
    // 0x13776c: 0x8e040054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x137770: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x137774: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x137778: 0x912018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13777c: 0x8e020020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x137780: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x137784: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x137788: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x13778c: 0x45182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x137790: 0x43280b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    // 0x137794: 0xae050024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 5));
label_137798:
    // 0x137798: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x13779c: 0x1040ff68
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137540; return;
    }
    // 0x1377a4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1377a8:
    // 0x1377a8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1377ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1377b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1377b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1377b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PumpHost__18CBinaryInputStream
// Address: 0x1377c0 - 0x13780c

void entry_13780c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13780c: 0xae020024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    // 0x137810: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137814: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137818: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Pump__18CBinaryInputStream
// Address: 0x137820 - 0x137854

void entry_137854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137854) {
        switch (ctx->pc) {
            case 0x13785c: ctx->pc = 0; goto label_13785c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137854: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137868; return;
    }
label_13785c:
    // 0x13785c: 0xc04dd24
    SET_GPR_U32(ctx, 31, 0x137864);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PumpCd__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_137864
// Address: 0x137864 - 0x137890

void entry_137864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137864) {
        switch (ctx->pc) {
            case 0x137868: ctx->pc = 0; goto label_137868;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137864: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_137868:
    // 0x137868: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13786c: 0x8e040024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x137870: 0x8e060030
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x137874: 0x441023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x137878: 0x2182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 2)));
    // 0x13787c: 0x43280b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    // 0x137880: 0x10c00003
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_137890(rdram, ctx, runtime); return;
    }
    // 0x137888: 0xc064ca2
    SET_GPR_U32(ctx, 31, 0x137890);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    SetRemain__5CProgi(rdram, ctx, runtime); return;
}


// Function: entry_137890
// Address: 0x137890 - 0x1378a0

void entry_137890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137890: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137894: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137898: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Decompress__18CBinaryInputStream
// Address: 0x1378a0 - 0x1378f8

void entry_1378f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1378f8) {
        switch (ctx->pc) {
            case 0x1378fc: ctx->pc = 0; goto label_1378fc;
            case 0x137908: ctx->pc = 0; goto label_137908;
            case 0x137910: ctx->pc = 0; goto label_137910;
            case 0x13792c: ctx->pc = 0; goto label_13792c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1378f8: 0x8e14002c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 44)));
label_1378fc:
    // 0x1378fc: 0x10000025
    SET_GPR_U32(ctx, 23, OR32(GPR_U32(ctx, 0), 65280));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137994; return;
    }
    // 0x137904: 0x0
    // NOP
label_137908:
    // 0x137908: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x13790c: 0x92530000
    SET_GPR_U32(ctx, 19, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
label_137910:
    // 0x137910: 0x32a20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 1));
    // 0x137914: 0x10400005
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13792c;
    }
    // 0x13791c: 0x2d41021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 20)));
    // 0x137920: 0xa0530000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 19));
    // 0x137924: 0x1000001b
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137994; return;
    }
label_13792c:
    // 0x13792c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x137930: 0x6230007
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x137950; return;
    }
    // 0x137938: 0xc04de08
    SET_GPR_U32(ctx, 31, 0x137940);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Pump__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_137940
// Address: 0x137940 - 0x1379c0

void entry_137940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137940) {
        switch (ctx->pc) {
            case 0x137950: ctx->pc = 0; goto label_137950;
            case 0x137970: ctx->pc = 0; goto label_137970;
            case 0x137994: ctx->pc = 0; goto label_137994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137940: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x137944: 0x8e120020
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x137948: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x13794c: 0x92420000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
label_137950:
    // 0x137950: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x137954: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x137958: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x13795c: 0x21b43
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 2), 13));
    // 0x137960: 0x24650002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 2));
    // 0x137964: 0x4a0000b
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 2), 8191));
    if (GPR_S32(ctx, 5) < 0) {
        goto label_137994;
    }
    // 0x13796c: 0x0
    // NOP
label_137970:
    // 0x137970: 0x30c21fff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), 8191));
    // 0x137974: 0x2d42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 20)));
    // 0x137978: 0x2c21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 2)));
    // 0x13797c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x137980: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x137984: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x137988: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x13798c: 0x4a1fff8
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_137970;
    }
label_137994:
    // 0x137994: 0x2a932000
    SET_GPR_U32(ctx, 19, SLT32(GPR_S32(ctx, 20), 8192));
    // 0x137998: 0x12600019
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137A00; return;
    }
    // 0x1379a0: 0x15a843
    SET_GPR_S32(ctx, 21, SRA32(GPR_S32(ctx, 21), 1));
    // 0x1379a4: 0x32a20100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 256));
    // 0x1379a8: 0x1440000e
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1379E4; return;
    }
    // 0x1379b0: 0x6230009
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1379D8; return;
    }
    // 0x1379b8: 0xc04de08
    SET_GPR_U32(ctx, 31, 0x1379c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Pump__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1379c0
// Address: 0x1379c0 - 0x1379f4

void entry_1379c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1379c0) {
        switch (ctx->pc) {
            case 0x1379d8: ctx->pc = 0; goto label_1379d8;
            case 0x1379e4: ctx->pc = 0; goto label_1379e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1379c0: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1379c4: 0x1840000e
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x137A00; return;
    }
    // 0x1379cc: 0x8e120020
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1379d0: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1379d4: 0x92420000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
label_1379d8:
    // 0x1379d8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1379dc: 0x57a821
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x1379e0: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_1379e4:
    // 0x1379e4: 0x623ffca
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 19, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x137910; return;
    }
    // 0x1379ec: 0xc04de08
    SET_GPR_U32(ctx, 31, 0x1379f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Pump__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1379f4
// Address: 0x1379f4 - 0x137a60

void entry_1379f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1379f4) {
        switch (ctx->pc) {
            case 0x137a00: ctx->pc = 0; goto label_137a00;
            case 0x137a1c: ctx->pc = 0; goto label_137a1c;
            case 0x137a24: ctx->pc = 0; goto label_137a24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1379f4: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1379f8: 0x5c40ffc3
    if (GPR_S32(ctx, 2) > 0) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 32)));
        ctx->pc = 0x137908; return;
    }
label_137a00:
    // 0x137a00: 0x16600006
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 22));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        goto label_137a1c;
    }
    // 0x137a08: 0x2683e000
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 4294959104));
    // 0x137a0c: 0x24022000
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8192));
    // 0x137a10: 0xae02001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 2));
    // 0x137a14: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137a24;
    }
label_137a1c:
    // 0x137a1c: 0xae14001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 20));
    // 0x137a20: 0xae00002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 0));
label_137a24:
    // 0x137a24: 0xae150028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 21));
    // 0x137a28: 0xae120020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 18));
    // 0x137a2c: 0xae110024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 17));
    // 0x137a30: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x137a34: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x137a38: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x137a3c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x137a40: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x137a44: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x137a48: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x137a4c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137a50: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137a54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137a5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137a60; return;
}


// Function: Read__18CBinaryInputStreamiPv
// Address: 0x137a60 - 0x137abc

void entry_137abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137abc) {
        switch (ctx->pc) {
            case 0x137ac4: ctx->pc = 0; goto label_137ac4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137abc: 0x1000000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137AEC; return;
    }
label_137ac4:
    // 0x137ac4: 0xc04de08
    SET_GPR_U32(ctx, 31, 0x137acc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Pump__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_137acc
// Address: 0x137acc - 0x137b1c

void entry_137acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137acc) {
        switch (ctx->pc) {
            case 0x137aec: ctx->pc = 0; goto label_137aec;
            case 0x137afc: ctx->pc = 0; goto label_137afc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137acc: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x137ad0: 0x8e230020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x137ad4: 0xae22001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x137ad8: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x137adc: 0xae230018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 3));
    // 0x137ae0: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x137ae4: 0xae200024
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
    // 0x137ae8: 0x8e23001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 28)));
label_137aec:
    // 0x137aec: 0x14600003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_137afc;
    }
    // 0x137af4: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x137B3C; return;
    }
label_137afc:
    // 0x137afc: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x137b00: 0x12600006
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        entry_137b1c(rdram, ctx, runtime); return;
    }
    // 0x137b08: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x137b0c: 0x8e250018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x137b10: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x137b14: 0xc063600
    SET_GPR_U32(ctx, 31, 0x137b1c);
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_137b1c
// Address: 0x137b1c - 0x137b60

void entry_137b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137b1c) {
        switch (ctx->pc) {
            case 0x137b3c: ctx->pc = 0; goto label_137b3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137b1c: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x137b20: 0x2509023
    SET_GPR_U32(ctx, 18, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x137b24: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x137b28: 0x701821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x137b2c: 0x501023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x137b30: 0xae230018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 3));
    // 0x137b34: 0x1e40ffd8
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 18) > 0) {
        ctx->pc = 0x137A98; return;
    }
label_137b3c:
    // 0x137b3c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x137b40: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x137b44: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x137b48: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x137b4c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137b50: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137b54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137b5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137b60; return;
}


// Function: Align__18CBinaryInputStreami
// Address: 0x137b60 - 0x137b90

void entry_137bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137bb8) {
        switch (ctx->pc) {
            case 0x137bc0: ctx->pc = 0; goto label_137bc0;
            case 0x137bd4: ctx->pc = 0; goto label_137bd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137bb8: 0x10000006
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137bd4;
    }
label_137bc0:
    // 0x137bc0: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x137bc4: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x137bc8: 0x24650001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 1));
    // 0x137bcc: 0xacc4001c
    WRITE32(ADD32(GPR_U32(ctx, 6), 28), GPR_U32(ctx, 4));
    // 0x137bd0: 0xacc50018
    WRITE32(ADD32(GPR_U32(ctx, 6), 24), GPR_U32(ctx, 5));
label_137bd4:
    // 0x137bd4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137bd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: U16Read__18CBinaryInputStream
// Address: 0x137be0 - 0x137c08

void entry_137c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137c08) {
        switch (ctx->pc) {
            case 0x137c10: ctx->pc = 0; goto label_137c10;
            case 0x137c34: ctx->pc = 0; goto label_137c34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137c08: 0x1000000a
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137c34;
    }
label_137c10:
    // 0x137c10: 0x8ce30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 24)));
    // 0x137c14: 0x2484fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967294));
    // 0x137c18: 0x90620001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 1)));
    // 0x137c1c: 0x24650002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 2));
    // 0x137c20: 0x90660000
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x137c24: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x137c28: 0xace4001c
    WRITE32(ADD32(GPR_U32(ctx, 7), 28), GPR_U32(ctx, 4));
    // 0x137c2c: 0xace50018
    WRITE32(ADD32(GPR_U32(ctx, 7), 24), GPR_U32(ctx, 5));
    // 0x137c30: 0xc21025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
label_137c34:
    // 0x137c34: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137c38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: U32Read__18CBinaryInputStream
// Address: 0x137c40 - 0x137c64

void entry_137c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137c64) {
        switch (ctx->pc) {
            case 0x137c6c: ctx->pc = 0; goto label_137c6c;
            case 0x137ca8: ctx->pc = 0; goto label_137ca8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137c64: 0x10000010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137ca8;
    }
label_137c6c:
    // 0x137c6c: 0x8d230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 24)));
    // 0x137c70: 0x24e7fffc
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967292));
    // 0x137c74: 0x90640001
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 1)));
    // 0x137c78: 0x24680004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 3), 4));
    // 0x137c7c: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x137c80: 0x90650002
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x137c84: 0x42200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 8));
    // 0x137c88: 0x90660003
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 3)));
    // 0x137c8c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x137c90: 0x52c00
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 16));
    // 0x137c94: 0xad27001c
    WRITE32(ADD32(GPR_U32(ctx, 9), 28), GPR_U32(ctx, 7));
    // 0x137c98: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x137c9c: 0x63600
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 24));
    // 0x137ca0: 0xad280018
    WRITE32(ADD32(GPR_U32(ctx, 9), 24), GPR_U32(ctx, 8));
    // 0x137ca4: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
label_137ca8:
    // 0x137ca8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137cac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137cb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137cb8; return;
}


// Function: junk_00137CB8
// Address: 0x137cb8 - 0x137cc0

void entry_137ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137ce8) {
        switch (ctx->pc) {
            case 0x137cf0: ctx->pc = 0; goto label_137cf0;
            case 0x137d04: ctx->pc = 0; goto label_137d04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137ce8: 0x10000006
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137d04;
    }
label_137cf0:
    // 0x137cf0: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x137cf4: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x137cf8: 0x24650001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 1));
    // 0x137cfc: 0xacc4001c
    WRITE32(ADD32(GPR_U32(ctx, 6), 28), GPR_U32(ctx, 4));
    // 0x137d00: 0xacc50018
    WRITE32(ADD32(GPR_U32(ctx, 6), 24), GPR_U32(ctx, 5));
label_137d04:
    // 0x137d04: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137d08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: S16Read__18CBinaryInputStream
// Address: 0x137d10 - 0x137d38

void entry_137d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137d38) {
        switch (ctx->pc) {
            case 0x137d40: ctx->pc = 0; goto label_137d40;
            case 0x137d68: ctx->pc = 0; goto label_137d68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137d38: 0x1000000b
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137d68;
    }
label_137d40:
    // 0x137d40: 0x8ce30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 24)));
    // 0x137d44: 0x2484fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967294));
    // 0x137d48: 0x90620001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 1)));
    // 0x137d4c: 0x24650002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 2));
    // 0x137d50: 0x90660000
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x137d54: 0x21600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 24));
    // 0x137d58: 0xace4001c
    WRITE32(ADD32(GPR_U32(ctx, 7), 28), GPR_U32(ctx, 4));
    // 0x137d5c: 0x21403
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 16));
    // 0x137d60: 0xace50018
    WRITE32(ADD32(GPR_U32(ctx, 7), 24), GPR_U32(ctx, 5));
    // 0x137d64: 0xc21025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
label_137d68:
    // 0x137d68: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137d6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137d74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137d78; return;
}


// Function: S32Read__18CBinaryInputStream
// Address: 0x137d78 - 0x137d9c

void entry_137d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137d9c) {
        switch (ctx->pc) {
            case 0x137da4: ctx->pc = 0; goto label_137da4;
            case 0x137de0: ctx->pc = 0; goto label_137de0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137d9c: 0x10000010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137de0;
    }
label_137da4:
    // 0x137da4: 0x8d230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 24)));
    // 0x137da8: 0x24e7fffc
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967292));
    // 0x137dac: 0x90640001
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 1)));
    // 0x137db0: 0x24680004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 3), 4));
    // 0x137db4: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x137db8: 0x90650002
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x137dbc: 0x42200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 8));
    // 0x137dc0: 0x80660003
    SET_GPR_S32(ctx, 6, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 3)));
    // 0x137dc4: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x137dc8: 0x52c00
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 16));
    // 0x137dcc: 0xad27001c
    WRITE32(ADD32(GPR_U32(ctx, 9), 28), GPR_U32(ctx, 7));
    // 0x137dd0: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x137dd4: 0x63600
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 24));
    // 0x137dd8: 0xad280018
    WRITE32(ADD32(GPR_U32(ctx, 9), 24), GPR_U32(ctx, 8));
    // 0x137ddc: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
label_137de0:
    // 0x137de0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137de4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137dec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137df0; return;
}


// Function: junk_00137DF0
// Address: 0x137df0 - 0x137df8

void entry_137e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x137e1c) {
        switch (ctx->pc) {
            case 0x137e24: ctx->pc = 0; goto label_137e24;
            case 0x137e64: ctx->pc = 0; goto label_137e64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x137e1c: 0x10000011
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_137e64;
    }
label_137e24:
    // 0x137e24: 0x8d220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 24)));
    // 0x137e28: 0x24e7fffc
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967292));
    // 0x137e2c: 0x90430001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 1)));
    // 0x137e30: 0x24480004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4));
    // 0x137e34: 0x90440000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x137e38: 0x90450002
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 2)));
    // 0x137e3c: 0x31a00
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 8));
    // 0x137e40: 0x90460003
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 3)));
    // 0x137e44: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x137e48: 0x52c00
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 16));
    // 0x137e4c: 0xad27001c
    WRITE32(ADD32(GPR_U32(ctx, 9), 28), GPR_U32(ctx, 7));
    // 0x137e50: 0x852021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x137e54: 0x63600
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 24));
    // 0x137e58: 0x862021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x137e5c: 0xad280018
    WRITE32(ADD32(GPR_U32(ctx, 9), 24), GPR_U32(ctx, 8));
    // 0x137e60: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
label_137e64:
    // 0x137e64: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137e68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReadVector__18CBinaryInputStreamP6VECTOR
// Address: 0x137e70 - 0x137e84

void entry_137e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137e84: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137e88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReadVector4__18CBinaryInputStreamP7VECTOR4
// Address: 0x137e90 - 0x137ea4

void entry_137ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137ea4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137ea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReadMatrix__18CBinaryInputStreamP7MATRIX3
// Address: 0x137eb0 - 0x137ed4

void entry_137ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137ed4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x137ed8: 0x26260010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 16));
    // 0x137edc: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x137ee4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_137ee4
// Address: 0x137ee4 - 0x137ef4

void entry_137ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137ee4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x137ee8: 0x26260020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 32));
    // 0x137eec: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x137ef4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_137ef4
// Address: 0x137ef4 - 0x137f08

void entry_137ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137ef4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x137ef8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137efc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137f00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReadMatrix4__18CBinaryInputStreamP7MATRIX4
// Address: 0x137f08 - 0x137f38

void entry_137f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137f38: 0x26330010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 16));
    // 0x137f3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x137f40: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x137f44: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x137f48: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x137f50);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 32));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_137f50
// Address: 0x137f50 - 0x137f64

void entry_137f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137f50: 0x26320030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 48));
    // 0x137f54: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x137f58: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x137f5c: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x137f64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_137f64
// Address: 0x137f64 - 0x137f74

void entry_137f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137f64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x137f68: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x137f6c: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x137f74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_137f74
// Address: 0x137f74 - 0x137fb0

void entry_137f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137f74: 0xae20000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 0));
    // 0x137f78: 0xae60000c
    WRITE32(ADD32(GPR_U32(ctx, 19), 12), GPR_U32(ctx, 0));
    // 0x137f7c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x137f80: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x137f84: 0xae80000c
    WRITE32(ADD32(GPR_U32(ctx, 20), 12), GPR_U32(ctx, 0));
    // 0x137f88: 0xe640000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
    // 0x137f8c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x137f90: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x137f94: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x137f98: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x137f9c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x137fa0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x137fa4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x137fac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x137fb0; return;
}


// Function: ReadGeom__18CBinaryInputStreamP4GEOM
// Address: 0x137fb0 - 0x137fec

void entry_137fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137fec: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x137ff0: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x137ff8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_137ff8
// Address: 0x137ff8 - 0x138004

void entry_137ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x137ff8: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x137ffc: 0xc063540
    SET_GPR_U32(ctx, 31, 0x138004);
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_138004
// Address: 0x138004 - 0x13802c

void entry_138004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138004) {
        switch (ctx->pc) {
            case 0x138018: ctx->pc = 0; goto label_138018;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138004: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x138008: 0x1860000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x13803C; return;
    }
    // 0x138010: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x138014: 0x0
    // NOP
label_138018:
    // 0x138018: 0x102900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 16), 4));
    // 0x13801c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x138020: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x138024: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x13802c);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_13802c
// Address: 0x13802c - 0x138048

void entry_13802c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13802c) {
        switch (ctx->pc) {
            case 0x13803c: ctx->pc = 0; goto label_13803c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13802c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x138030: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x138034: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x138018; return;
    }
label_13803c:
    // 0x13803c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x138040: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x138048);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_138048
// Address: 0x138048 - 0x138054

void entry_138048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138048: 0x22140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 5));
    // 0x13804c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x138054);
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_138054
// Address: 0x138054 - 0x138064

void entry_138054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138054: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x138058: 0xae220010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 2));
    // 0x13805c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x138064);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_138064
// Address: 0x138064 - 0x138074

void entry_138064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138064: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x138068: 0xae22001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x13806c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x138074);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_138074
// Address: 0x138074 - 0x138080

void entry_138074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138074: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x138078: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x138080);
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_138080
// Address: 0x138080 - 0x13808c

void entry_138080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138080: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x138084: 0xc063570
    SET_GPR_U32(ctx, 31, 0x13808c);
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_13808c
// Address: 0x13808c - 0x1380b8

void entry_13808c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13808c) {
        switch (ctx->pc) {
            case 0x1380a0: ctx->pc = 0; goto label_1380a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13808c: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x138090: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x138094: 0x1860006b
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x138244; return;
    }
    // 0x13809c: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
label_1380a0:
    // 0x1380a0: 0x131140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 5));
    // 0x1380a4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1380a8: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1380ac: 0x62b021
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1380b0: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1380b8);
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 1));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1380b8
// Address: 0x1380b8 - 0x1380c4

void entry_1380b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1380b8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1380bc: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1380c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1380c4
// Address: 0x1380c4 - 0x1380d0

void entry_1380c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1380c4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1380c8: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1380d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1380d0
// Address: 0x1380d0 - 0x138190

void entry_1380d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1380d0: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1380d4: 0x23100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1380d8: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1380dc: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1380e0: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1380e4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1380e8: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x1380ec: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1380f0: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1380f4: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1380f8: 0xc43021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x1380fc: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x138100: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x138104: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x138108: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13810c: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x138110: 0xd8c20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x138114: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x138118: 0x4bc21afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x13811c: 0x4bc310ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x138120: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x138124: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x138128: 0x4bc3192a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13812c: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x138130: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x138134: 0x4b04090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x138138: 0x4a0403bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13813c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x138140: 0x4b000120
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x138144: 0x4a6403bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x138148: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13814c: 0x4be0191c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x138150: 0xfac40000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x138154: 0x97a30000
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138158: 0xa6c3001e
    WRITE16(ADD32(GPR_U32(ctx, 22), 30), (uint16_t)GPR_U32(ctx, 3));
    // 0x13815c: 0x3062ffff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 65535));
    // 0x138160: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x138164: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x138168: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13816c: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x138170: 0x4bc1212a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x138174: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x138178: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13817c: 0x4b04110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x138180: 0x48222000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x138184: 0xaec20010
    WRITE32(ADD32(GPR_U32(ctx, 22), 16), GPR_U32(ctx, 2));
    // 0x138188: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x138190);
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_138190
// Address: 0x138190 - 0x1381b4

void entry_138190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138190: 0x8e230020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x138194: 0x131080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 2));
    // 0x138198: 0x133100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 19), 4));
    // 0x13819c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1381a0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1381a4: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1381a8: 0x8e25001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1381ac: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1381b4);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1381b4
// Address: 0x1381b4 - 0x1381bc

void entry_1381b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1381b4: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1381bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1381bc
// Address: 0x1381bc - 0x1381d4

void entry_1381bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1381bc) {
        switch (ctx->pc) {
            case 0x1381c8: ctx->pc = 0; goto label_1381c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1381bc: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1381c0: 0x5a80001c
    if (GPR_S32(ctx, 20) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x138234; return;
    }
label_1381c8:
    // 0x1381c8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1381cc: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1381d4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1381d4
// Address: 0x1381d4 - 0x1381e4

void entry_1381d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1381d4: 0x26170010
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1381d8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1381dc: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1381e4);
    WRITE16(ADD32(GPR_U32(ctx, 16), 0), (uint16_t)GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1381e4
// Address: 0x1381e4 - 0x1381f4

void entry_1381e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1381e4: 0xa6130004
    WRITE16(ADD32(GPR_U32(ctx, 16), 4), (uint16_t)GPR_U32(ctx, 19));
    // 0x1381e8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1381ec: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1381f4);
    WRITE16(ADD32(GPR_U32(ctx, 16), 2), (uint16_t)GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1381f4
// Address: 0x1381f4 - 0x138278

void entry_1381f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1381f4) {
        switch (ctx->pc) {
            case 0x138204: ctx->pc = 0; goto label_138204;
            case 0x138208: ctx->pc = 0; goto label_138208;
            case 0x138234: ctx->pc = 0; goto label_138234;
            case 0x138244: ctx->pc = 0; goto label_138244;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1381f4: 0x16a00003
    WRITE16(ADD32(GPR_U32(ctx, 16), 6), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        goto label_138204;
    }
    // 0x1381fc: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 22), 20), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_138208;
    }
label_138204:
    // 0x138204: 0xae10fff8
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294967288), GPR_U32(ctx, 16));
label_138208:
    // 0x138208: 0x86040006
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 6)));
    // 0x13820c: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x138210: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x138214: 0x2b4282a
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 20)));
    // 0x138218: 0x42140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 5));
    // 0x13821c: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x138220: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x138224: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x138228: 0x14a0ffe7
    WRITE32(ADD32(GPR_U32(ctx, 3), 24), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1381C8; return;
    }
    // 0x138230: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_138234:
    // 0x138234: 0x3c0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x138238: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x13823c: 0x5440ff98
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x1380A0; return;
    }
label_138244:
    // 0x138244: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x138248: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13824c: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x138250: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x138254: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x138258: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13825c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x138260: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x138264: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x138268: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13826c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x138274: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x138278; return;
}


// Function: ReadBspc__18CBinaryInputStreamP4GEOMP4BSPC
// Address: 0x138278 - 0x1382b4

void entry_1382b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1382b4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1382b8: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1382c0);
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1382c0
// Address: 0x1382c0 - 0x1382d4

void entry_1382c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1382c0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1382c4: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1382c8: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x1382cc: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1382d4);
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1382d4
// Address: 0x1382d4 - 0x138300

void entry_1382d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1382d4) {
        switch (ctx->pc) {
            case 0x1382f0: ctx->pc = 0; goto label_1382f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1382d4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1382d8: 0x18600024
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x13836C; return;
    }
    // 0x1382e0: 0x2416000c
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1382e4: 0x3415ffff
    SET_GPR_U32(ctx, 21, OR32(GPR_U32(ctx, 0), 65535));
    // 0x1382e8: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1382ec: 0x0
    // NOP
label_1382f0:
    // 0x1382f0: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1382f4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1382f8: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x138300);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_138300
// Address: 0x138300 - 0x138318

void entry_138300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138300: 0x8ee30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 16)));
    // 0x138304: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x138308: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13830c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x138310: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x138318);
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_138318
// Address: 0x138318 - 0x13833c

void entry_138318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138318) {
        switch (ctx->pc) {
            case 0x138334: ctx->pc = 0; goto label_138334;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138318: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13831c: 0x3062ffff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 65535));
    // 0x138320: 0x10550004
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 21)) {
        goto label_138334;
    }
    // 0x138328: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x13832c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x138330: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_138334:
    // 0x138334: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x13833c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_13833c
// Address: 0x13833c - 0x138398

void entry_13833c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13833c) {
        switch (ctx->pc) {
            case 0x138358: ctx->pc = 0; goto label_138358;
            case 0x13836c: ctx->pc = 0; goto label_13836c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13833c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x138340: 0x3062ffff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 65535));
    // 0x138344: 0x10550004
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 21)) {
        goto label_138358;
    }
    // 0x13834c: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x138350: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x138354: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
label_138358:
    // 0x138358: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13835c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x138360: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x138364: 0x1440ffe2
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1382F0; return;
    }
label_13836c:
    // 0x13836c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x138370: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x138374: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x138378: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13837c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x138380: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x138384: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138388: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13838c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138390: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReadVbsp__18CBinaryInputStreamPiPP4VBSP
// Address: 0x138398 - 0x1383cc

void entry_1383cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1383cc: 0x22140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1383d0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1383d8);
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1383d8
// Address: 0x1383d8 - 0x138404

void entry_1383d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1383d8) {
        switch (ctx->pc) {
            case 0x1383f0: ctx->pc = 0; goto label_1383f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1383d8: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x1383dc: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1383e0: 0x18400027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x138480; return;
    }
    // 0x1383e8: 0x3c158000
    SET_GPR_U32(ctx, 21, ((uint32_t)32768 << 16));
    // 0x1383ec: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_1383f0:
    // 0x1383f0: 0x111140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 5));
    // 0x1383f4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1383f8: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1383fc: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x138404);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_138404
// Address: 0x138404 - 0x13840c

void entry_138404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138404: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x13840c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_13840c
// Address: 0x13840c - 0x138418

void entry_13840c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13840c: 0xe6000010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x138410: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x138418);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_138418
// Address: 0x138418 - 0x138444

void entry_138418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138418) {
        switch (ctx->pc) {
            case 0x138430: ctx->pc = 0; goto label_138430;
            case 0x13843c: ctx->pc = 0; goto label_13843c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138418: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13841c: 0x751024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x138420: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        goto label_138430;
    }
    // 0x138428: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13843c;
    }
label_138430:
    // 0x138430: 0x31940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 5));
    // 0x138434: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x138438: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
label_13843c:
    // 0x13843c: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x138444);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_138444
// Address: 0x138444 - 0x1384a0

void entry_138444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138444) {
        switch (ctx->pc) {
            case 0x13845c: ctx->pc = 0; goto label_13845c;
            case 0x138468: ctx->pc = 0; goto label_138468;
            case 0x138480: ctx->pc = 0; goto label_138480;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138444: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x138448: 0x751024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x13844c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        goto label_13845c;
    }
    // 0x138454: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_138468;
    }
label_13845c:
    // 0x13845c: 0x31940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 5));
    // 0x138460: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x138464: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
label_138468:
    // 0x138468: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x13846c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x138470: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x138474: 0x5440ffde
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1383F0; return;
    }
    // 0x13847c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_138480:
    // 0x138480: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x138484: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x138488: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13848c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138490: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x138494: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138498: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReadStringSw__18CBinaryInputStreamPPc
// Address: 0x1384a0 - 0x1384c4

void entry_1384c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1384c4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1384c8: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1384d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1384d0
// Address: 0x1384d0 - 0x1384e4

void entry_1384d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1384d0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1384d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1384d8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1384dc: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1384e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1384e4
// Address: 0x1384e4 - 0x138510

void entry_1384e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1384e4: 0x2308021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x1384e8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1384ec: 0xa2000000
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x1384f0: 0xae710000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 17));
    // 0x1384f4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1384f8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1384fc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x138500: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138504: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13850c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x138510; return;
}


// Function: junk_00138510
// Address: 0x138510 - 0x138518

void entry_13852c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13852c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x138530: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x138534: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x13853c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_13853c
// Address: 0x13853c - 0x138550

void entry_13853c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13853c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x138540: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138544: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13854c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x138550; return;
}


// Function: Unknown2__18CBinaryInputStreamPPv
// Address: 0x138550 - 0x13856c

void entry_13856c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13856c: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x138570: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x138574: 0x10620005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x13858C; return;
    }
    // 0x13857c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x138584);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_138584
// Address: 0x138584 - 0x1385a0

void entry_138584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138584) {
        switch (ctx->pc) {
            case 0x13858c: ctx->pc = 0; goto label_13858c;
            case 0x138590: ctx->pc = 0; goto label_138590;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138584: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_138590;
    }
label_13858c:
    // 0x13858c: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
label_138590:
    // 0x138590: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x138594: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138598: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSwPox__FP2SWP3OXAT1UcUc
// Address: 0x1385a0 - 0x138654

void entry_138654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138654: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x138658: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13865c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x138660: 0xc04e1ce
    SET_GPR_U32(ctx, 31, 0x138668);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PoxAddSw__FP2SWP3OXAT1(rdram, ctx, runtime); return;
}


// Function: entry_138668
// Address: 0x138668 - 0x138698

void entry_138668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138668) {
        switch (ctx->pc) {
            case 0x138678: ctx->pc = 0; goto label_138678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138668: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13866c: 0xae510008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 17));
    // 0x138670: 0x1000002a
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_13871c(rdram, ctx, runtime); return;
    }
label_138678:
    // 0x138678: 0x10400028
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), 127));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13871c(rdram, ctx, runtime); return;
    }
    // 0x138680: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x138684: 0xa1220000
    WRITE8(ADD32(GPR_U32(ctx, 9), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x138688: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13868c: 0xa0c20000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x138690: 0xc04e1e2
    SET_GPR_U32(ctx, 31, 0x138698);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PoxRemoveSw__FP2SWP3OXAT1(rdram, ctx, runtime); return;
}


// Function: entry_138698
// Address: 0x138698 - 0x1386ac

void entry_138698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138698: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13869c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1386a0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1386a4: 0xc04e1e2
    SET_GPR_U32(ctx, 31, 0x1386ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PoxRemoveSw__FP2SWP3OXAT1(rdram, ctx, runtime); return;
}


// Function: entry_1386ac
// Address: 0x1386ac - 0x1386c8

void entry_1386ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1386ac: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1386b0: 0x10a00013
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_138700(rdram, ctx, runtime); return;
    }
    // 0x1386b8: 0x34138000
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1386bc: 0x139a3c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << (32 + 8));
    // 0x1386c0: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1386c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1386c8
// Address: 0x1386c8 - 0x1386e4

void entry_1386c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1386c8: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1386cc: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1386d0: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1386d4: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x1386E8; return;
    }
    // 0x1386dc: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1386e4);
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1386e4
// Address: 0x1386e4 - 0x138700

void entry_1386e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1386e4) {
        switch (ctx->pc) {
            case 0x1386e8: ctx->pc = 0; goto label_1386e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1386e4: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_1386e8:
    // 0x1386e8: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1386ec: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1386f0: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6896));
        ctx->pc = 0x138704; return;
    }
    // 0x1386f8: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x138700);
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_138700
// Address: 0x138700 - 0x138710

void entry_138700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138700) {
        switch (ctx->pc) {
            case 0x138704: ctx->pc = 0; goto label_138704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138700: 0x26101af0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6896));
label_138704:
    // 0x138704: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x138708: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x138710);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_138710
// Address: 0x138710 - 0x13871c

void entry_138710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138710: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x138714: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x13871c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_13871c
// Address: 0x13871c - 0x138738

void entry_13871c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13871c) {
        switch (ctx->pc) {
            case 0x138720: ctx->pc = 0; goto label_138720;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13871c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_138720:
    // 0x138720: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x138724: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138728: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13872c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138730: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PoxAddSw__FP2SWP3OXAT1
// Address: 0x138738 - 0x138758

void entry_138758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138758: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13875c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138760: 0xaca00000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 0));
    // 0x138764: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x138768: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13876c: 0xaca3000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 3));
    // 0x138770: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x138774: 0xaca40004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 4));
    // 0x138778: 0xae250000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 5));
    // 0x13877c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x138780: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PoxRemoveSw__FP2SWP3OXAT1
// Address: 0x138788 - 0x1387c0

void entry_138808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138808) {
        switch (ctx->pc) {
            case 0x138814: ctx->pc = 0; goto label_138814;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138808: 0x10400002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_138814;
    }
    // 0x138810: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_138814:
    // 0x138814: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138818: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13881c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x138824: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x138828; return;
}


// Function: AddSwAaobrObject__FP2SWP2SO
// Address: 0x138828 - 0x138894

void entry_138894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138894: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138898: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveSwAaobrObject__FP2SWP2SO
// Address: 0x1388a0 - 0x138958

void entry_138958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138958: 0x2121823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 18)));
    // 0x13895c: 0x8ea60038
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x138960: 0x741818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x138964: 0x2604fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294967284));
    // 0x138968: 0x63040
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 1));
    // 0x13896c: 0x2605000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 12));
    // 0x138970: 0x31883
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 2));
    // 0x138974: 0xc33023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x138978: 0xd73018
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13897c: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x138984);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967284));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_138984
// Address: 0x138984 - 0x1389c8

void entry_138984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138984: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x138988: 0x28820003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 3));
    // 0x13898c: 0x1440ffd8
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1388F0; return;
    }
    // 0x138994: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x138998: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13899c: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1389a0: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1389a4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1389a8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1389ac: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1389b0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1389b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1389b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1389bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1389c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1389c8; return;
}


// Function: InvalidateSwAaox__FP2SW
// Address: 0x1389c8 - 0x1389d0

void entry_138ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138ad8) {
        switch (ctx->pc) {
            case 0x138ae0: ctx->pc = 0; goto label_138ae0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138ad8: 0x10000009
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967284));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x138B00; return;
    }
label_138ae0:
    // 0x138ae0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x138ae4: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x138ae8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x138aec: 0x8c450480
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 1152)));
    // 0x138af0: 0x2e0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x138af4: 0xc04e168
    SET_GPR_U32(ctx, 31, 0x138afc);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 1152)));
    UpdateSwPox__FP2SWP3OXAT1UcUc(rdram, ctx, runtime); return;
}


// Function: entry_138afc
// Address: 0x138afc - 0x138b64

void entry_138afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138afc) {
        switch (ctx->pc) {
            case 0x138b00: ctx->pc = 0; goto label_138b00;
            case 0x138b04: ctx->pc = 0; goto label_138b04;
            case 0x138b28: ctx->pc = 0; goto label_138b28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138afc: 0x2610fff4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967284));
label_138b00:
    // 0x138b00: 0x216102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 22)));
label_138b04:
    // 0x138b04: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
        goto label_138b28;
    }
    // 0x138b0c: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x138b10: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x138b14: 0x46140036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x138b18: 0x0
    // NOP
    // 0x138b1c: 0x4502ffe2
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x138AA8; return;
    }
    // 0x138b24: 0x2610000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
label_138b28:
    // 0x138b28: 0x6a220007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x138b2c: 0x6e220000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x138b30: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x138b34: 0xb3a20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x138b38: 0xb7a20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x138b3c: 0x2303023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x138b40: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x138b44: 0xd53018
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x138b48: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x138b4c: 0x2604000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 12));
    // 0x138b50: 0x63083
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 6), 2));
    // 0x138b54: 0xc20018
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x138b58: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x138b5c: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x138b64);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_138b64
// Address: 0x138b64 - 0x138be0

void entry_138b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138b64) {
        switch (ctx->pc) {
            case 0x138b7c: ctx->pc = 0; goto label_138b7c;
            case 0x138b88: ctx->pc = 0; goto label_138b88;
            case 0x138ba8: ctx->pc = 0; goto label_138ba8;
            case 0x138bac: ctx->pc = 0; goto label_138bac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138b64: 0x6ba30007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x138b68: 0x6fa30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x138b6c: 0x8fa40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x138b70: 0xb2030007
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x138b74: 0xb6030000
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x138b78: 0xae040008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 4));
label_138b7c:
    // 0x138b7c: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x138b80: 0x1ca0ffbb
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) > 0) {
        ctx->pc = 0x138A70; return;
    }
label_138b88:
    // 0x138b88: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x138b8c: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x138b90: 0x28a20003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 3));
    // 0x138b94: 0x1440ffa4
    SET_GPR_U32(ctx, 23, AND32(GPR_U32(ctx, 3), 254));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x138A28; return;
    }
    // 0x138b9c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x138ba0: 0xae421aec
    WRITE32(ADD32(GPR_U32(ctx, 18), 6892), GPR_U32(ctx, 2));
    // 0x138ba4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_138ba8:
    // 0x138ba8: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_138bac:
    // 0x138bac: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x138bb0: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x138bb4: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x138bb8: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x138bbc: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x138bc0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x138bc4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x138bc8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138bcc: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x138bd0: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x138bd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x138bdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x138be0; return;
}


// Function: InvalidateSwXpForObject__FP2SWP2SOi
// Address: 0x138be0 - 0x138c00

void entry_138c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138c38) {
        switch (ctx->pc) {
            case 0x138c48: ctx->pc = 0; goto label_138c48;
            case 0x138cb8: ctx->pc = 0; goto label_138cb8;
            case 0x138ce4: ctx->pc = 0; goto label_138ce4;
            case 0x138ce8: ctx->pc = 0; goto label_138ce8;
            case 0x138d34: ctx->pc = 0; goto label_138d34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138c38: 0x8e71006c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 108)));
    // 0x138c3c: 0x1220008b
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x138E6C; return;
    }
    // 0x138c44: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
label_138c48:
    // 0x138c48: 0x24030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 7));
    // 0x138c4c: 0x8e2204b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1208)));
    // 0x138c50: 0x50430067
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
        ctx->pc = 0x138DF0; return;
    }
    // 0x138c58: 0xde230538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x138c5c: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138c60: 0x216f8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 27);
    // 0x138c64: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x138c68: 0x54400061
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
        ctx->pc = 0x138DF0; return;
    }
    // 0x138c70: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138c74: 0x213bc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 14));
    // 0x138c78: 0x621025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x138c7c: 0xfe220538
    WRITE64(ADD32(GPR_U32(ctx, 17), 1336), GPR_U64(ctx, 2));
    // 0x138c80: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138c84: 0x8c620480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1152)));
    // 0x138c88: 0x8c520000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x138c8c: 0x52400058
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
        ctx->pc = 0x138DF0; return;
    }
    // 0x138c94: 0x241e0007
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 7));
    // 0x138c98: 0x34178000
    SET_GPR_U32(ctx, 23, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138c9c: 0x17bdb8
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 23) << 22);
    // 0x138ca0: 0x34168000
    SET_GPR_U32(ctx, 22, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138ca4: 0x16b6f8
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 22) << 27);
    // 0x138ca8: 0x34158000
    SET_GPR_U32(ctx, 21, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138cac: 0x15abbc
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 21) << (32 + 14));
    // 0x138cb0: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x138cb4: 0x0
    // NOP
label_138cb8:
    // 0x138cb8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138cbc: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x138cc0: 0x10400008
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_138ce4;
    }
    // 0x138cc8: 0x8c6204b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1208)));
    // 0x138ccc: 0x105e0006
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 30)) {
        goto label_138ce8;
    }
    // 0x138cd4: 0xdc6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 712)));
    // 0x138cd8: 0x571024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x138cdc: 0x54400041
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x138DE4; return;
    }
label_138ce4:
    // 0x138ce4: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_138ce8:
    // 0x138ce8: 0xdc830538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x138cec: 0x761024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 22)));
    // 0x138cf0: 0x5440003c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x138DE4; return;
    }
    // 0x138cf8: 0x751025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x138cfc: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x138d00: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138d04: 0x8c6204b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1208)));
    // 0x138d08: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x138d0c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x138d10: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_138d34;
    }
    // 0x138d18: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x138d1c: 0x8c6204b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1208)));
    // 0x138d20: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x138d24: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x138d28: 0x50400023
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x138DB8; return;
    }
    // 0x138d30: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_138d34:
    // 0x138d34: 0x12000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_138d44(rdram, ctx, runtime); return;
    }
    // 0x138d3c: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x138d44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_138d44
// Address: 0x138d44 - 0x138d54

void entry_138d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138d44: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x138d48: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x138d4c: 0xc06209c
    SET_GPR_U32(ctx, 31, 0x138d54);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PxpMarkSwContactsRoot__FP2SWPP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_138d54
// Address: 0x138d54 - 0x138d94

void entry_138d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138d54: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x138d58: 0x2e040001
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 16), 1));
    // 0x138d5c: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x138d60: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x138d64: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x138d68: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x138d6c: 0x1082001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x138DE0; return;
    }
    // 0x138d74: 0x34108000
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138d78: 0x10823c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 8));
    // 0x138d7c: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x138d80: 0x501024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x138d84: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
        ctx->pc = 0x138D98; return;
    }
    // 0x138d8c: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x138d94);
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_138d94
// Address: 0x138d94 - 0x138db0

void entry_138d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138d94) {
        switch (ctx->pc) {
            case 0x138d98: ctx->pc = 0; goto label_138d98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138d94: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_138d98:
    // 0x138d98: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x138d9c: 0x501024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x138da0: 0x54400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x138DE4; return;
    }
    // 0x138da8: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x138db0);
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_138db0
// Address: 0x138db0 - 0x138dd0

void entry_138db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138db0) {
        switch (ctx->pc) {
            case 0x138db8: ctx->pc = 0; goto label_138db8;
            case 0x138dc0: ctx->pc = 0; goto label_138dc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138db0: 0x1000000c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x138DE4; return;
    }
label_138db8:
    // 0x138db8: 0x10400009
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x138DE0; return;
    }
label_138dc0:
    // 0x138dc0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x138dc4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x138dc8: 0xc06182a
    SET_GPR_U32(ctx, 31, 0x138dd0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 20));
    RecalcSwXpMovement__FP2SWiPP2XP(rdram, ctx, runtime); return;
}


// Function: entry_138dd0
// Address: 0x138dd0 - 0x138e44

void entry_138dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138dd0) {
        switch (ctx->pc) {
            case 0x138de0: ctx->pc = 0; goto label_138de0;
            case 0x138de4: ctx->pc = 0; goto label_138de4;
            case 0x138df0: ctx->pc = 0; goto label_138df0;
            case 0x138e10: ctx->pc = 0; goto label_138e10;
            case 0x138e30: ctx->pc = 0; goto label_138e30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138dd0: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x138dd4: 0x8c4300d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 208)));
    // 0x138dd8: 0x1460fff9
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x138DC0; return;
    }
label_138de0:
    // 0x138de0: 0x8e520004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_138de4:
    // 0x138de4: 0x5640ffb4
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x138CB8; return;
    }
    // 0x138dec: 0x8e310414
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
label_138df0:
    // 0x138df0: 0x5620ff95
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
        ctx->pc = 0x138C48; return;
    }
    // 0x138df8: 0x8e71006c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 108)));
    // 0x138dfc: 0x1220001b
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x138E6C; return;
    }
    // 0x138e04: 0x34128000
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138e08: 0x1293bc
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) << (32 + 14));
    // 0x138e0c: 0x8e2204b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1208)));
label_138e10:
    // 0x138e10: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x138e14: 0x54400012
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
        ctx->pc = 0x138E60; return;
    }
    // 0x138e1c: 0x8e3002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x138e20: 0x5200000c
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
        ctx->pc = 0x138E54; return;
    }
    // 0x138e28: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x138e2c: 0x0
    // NOP
label_138e30:
    // 0x138e30: 0x8c420110
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 272)));
    // 0x138e34: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x138E48; return;
    }
    // 0x138e3c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x138e44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_138e44
// Address: 0x138e44 - 0x138ecc

void entry_138e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138e44) {
        switch (ctx->pc) {
            case 0x138e48: ctx->pc = 0; goto label_138e48;
            case 0x138e54: ctx->pc = 0; goto label_138e54;
            case 0x138e60: ctx->pc = 0; goto label_138e60;
            case 0x138e6c: ctx->pc = 0; goto label_138e6c;
            case 0x138e98: ctx->pc = 0; goto label_138e98;
            case 0x138eb8: ctx->pc = 0; goto label_138eb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138e44: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_138e48:
    // 0x138e48: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x138E30; return;
    }
    // 0x138e50: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
label_138e54:
    // 0x138e54: 0x521025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x138e58: 0xfe220538
    WRITE64(ADD32(GPR_U32(ctx, 17), 1336), GPR_U64(ctx, 2));
    // 0x138e5c: 0x8e310414
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
label_138e60:
    // 0x138e60: 0x5620ffeb
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1208)));
        ctx->pc = 0x138E10; return;
    }
    // 0x138e68: 0x8e71006c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 108)));
label_138e6c:
    // 0x138e6c: 0x12200021
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x138EF4; return;
    }
    // 0x138e74: 0x34148000
    SET_GPR_U32(ctx, 20, OR32(GPR_U32(ctx, 0), 32768));
    // 0x138e78: 0x14a3bc
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 20) << (32 + 14));
    // 0x138e7c: 0x3c13dfff
    SET_GPR_U32(ctx, 19, ((uint32_t)57343 << 16));
    // 0x138e80: 0x3673ffff
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 19), 65535));
    // 0x138e84: 0x139c38
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << 16);
    // 0x138e88: 0x3673ffff
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 19), 65535));
    // 0x138e8c: 0x139c38
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << 16);
    // 0x138e90: 0x3673ffff
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 19), 65535));
    // 0x138e94: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
label_138e98:
    // 0x138e98: 0x541024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x138e9c: 0x50400012
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1208), GPR_U32(ctx, 18));
        ctx->pc = 0x138EE8; return;
    }
    // 0x138ea4: 0x8e3002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x138ea8: 0x5200000c
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
        ctx->pc = 0x138EDC; return;
    }
    // 0x138eb0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x138eb4: 0x0
    // NOP
label_138eb8:
    // 0x138eb8: 0x8c42010c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 268)));
    // 0x138ebc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x138ED0; return;
    }
    // 0x138ec4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x138ecc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_138ecc
// Address: 0x138ecc - 0x138f28

void entry_138ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138ecc) {
        switch (ctx->pc) {
            case 0x138ed0: ctx->pc = 0; goto label_138ed0;
            case 0x138edc: ctx->pc = 0; goto label_138edc;
            case 0x138ee8: ctx->pc = 0; goto label_138ee8;
            case 0x138ef4: ctx->pc = 0; goto label_138ef4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138ecc: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_138ed0:
    // 0x138ed0: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x138EB8; return;
    }
    // 0x138ed8: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
label_138edc:
    // 0x138edc: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x138ee0: 0xfe220538
    WRITE64(ADD32(GPR_U32(ctx, 17), 1336), GPR_U64(ctx, 2));
    // 0x138ee4: 0xae3204b8
    WRITE32(ADD32(GPR_U32(ctx, 17), 1208), GPR_U32(ctx, 18));
label_138ee8:
    // 0x138ee8: 0x8e310414
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
    // 0x138eec: 0x5620ffea
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
        ctx->pc = 0x138E98; return;
    }
label_138ef4:
    // 0x138ef4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x138ef8: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x138efc: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x138f00: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x138f04: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x138f08: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x138f0c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x138f10: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x138f14: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x138f18: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138f1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x138f24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x138f28; return;
}


// Function: RecalcSwOxfFilterForObject__FP2SWP2SO
// Address: 0x138f28 - 0x138f7c

void entry_138f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x138f7c: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x138FA4; return;
    }
    // 0x138f84: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x138f88: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x138f8c: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x138f90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x138f98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_138f98
// Address: 0x138f98 - 0x138fc4

void entry_138f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138f98) {
        switch (ctx->pc) {
            case 0x138fa4: ctx->pc = 0; goto label_138fa4;
            case 0x138fa8: ctx->pc = 0; goto label_138fa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138f98: 0x10400003
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_138fa8;
    }
    // 0x138fa0: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
label_138fa4:
    // 0x138fa4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_138fa8:
    // 0x138fa8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x138fac: 0x8e250480
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x138fb0: 0x292400b
    if (GPR_U32(ctx, 18) != 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 20));
    // 0x138fb4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x138fb8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x138fbc: 0xc04e168
    SET_GPR_U32(ctx, 31, 0x138fc4);
    if (GPR_U32(ctx, 18) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 20));
    UpdateSwPox__FP2SWP3OXAT1UcUc(rdram, ctx, runtime); return;
}


// Function: entry_138fc4
// Address: 0x138fc4 - 0x138ff0

void entry_138fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x138fc4) {
        switch (ctx->pc) {
            case 0x138fc8: ctx->pc = 0; goto label_138fc8;
            case 0x138fd0: ctx->pc = 0; goto label_138fd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x138fc4: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_138fc8:
    // 0x138fc8: 0x5600ffe5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x138F60; return;
    }
label_138fd0:
    // 0x138fd0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x138fd4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x138fd8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x138fdc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x138fe0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x138fe4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x138fe8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: VerifyAeaEquivalence__FiP2EAiT1
// Address: 0x138ff0 - 0x139038

void entry_1390e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1390e8: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1390ec: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1390f0: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1390f4: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1390f8: 0xc047960
    SET_GPR_U32(ctx, 31, 0x139100);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 132));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_139100
// Address: 0x139100 - 0x139114

void entry_139100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139100: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x139104: 0x8ec30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x139108: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x13910c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x139114);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_139114
// Address: 0x139114 - 0x13912c

void entry_139114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139114: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x139118: 0x8fa60000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13911c: 0xaec500b4
    WRITE32(ADD32(GPR_U32(ctx, 22), 180), GPR_U32(ctx, 5));
    // 0x139120: 0xa62018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x139124: 0xc063540
    SET_GPR_U32(ctx, 31, 0x13912c);
    WRITE32(ADD32(GPR_U32(ctx, 22), 176), GPR_U32(ctx, 6));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_13912c
// Address: 0x13912c - 0x139144

void entry_13912c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13912c: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x139130: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x139134: 0xaec200b8
    WRITE32(ADD32(GPR_U32(ctx, 22), 184), GPR_U32(ctx, 2));
    // 0x139138: 0x642018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13913c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x139144);
    WRITE32(ADD32(GPR_U32(ctx, 22), 188), GPR_U32(ctx, 3));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_139144
// Address: 0x139144 - 0x139190

void entry_139144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139144) {
        switch (ctx->pc) {
            case 0x139160: ctx->pc = 0; goto label_139160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139144: 0xaec200c0
    WRITE32(ADD32(GPR_U32(ctx, 22), 192), GPR_U32(ctx, 2));
    // 0x139148: 0x8fa4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x13914c: 0x18800013
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x13919C; return;
    }
    // 0x139154: 0x220982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x139158: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13915c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_139160:
    // 0x139160: 0x8ed000c0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 22), 192)));
    // 0x139164: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x139168: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13916c: 0x2148021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    // 0x139170: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x139174: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x139178: 0x2694000c
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 12));
    // 0x13917c: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x139180: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x139184: 0x220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    // 0x139188: 0xc063540
    SET_GPR_U32(ctx, 31, 0x139190);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_139190
// Address: 0x139190 - 0x1391ec

void entry_139190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139190) {
        switch (ctx->pc) {
            case 0x13919c: ctx->pc = 0; goto label_13919c;
            case 0x1391b0: ctx->pc = 0; goto label_1391b0;
            case 0x1391c4: ctx->pc = 0; goto label_1391c4;
            case 0x1391d8: ctx->pc = 0; goto label_1391d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139190: 0x1620fff3
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139160; return;
    }
    // 0x139198: 0x8fa60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_13919c:
    // 0x13919c: 0x18c0000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 6) <= 0) {
        goto label_1391d8;
    }
    // 0x1391a4: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1391a8: 0xafa60014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 6));
    // 0x1391ac: 0x24430004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4));
label_1391b0:
    // 0x1391b0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1391b4: 0x10400003
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1391c4;
    }
    // 0x1391bc: 0x8c420038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x1391c0: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
label_1391c4:
    // 0x1391c4: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1391c8: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x1391cc: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1391d0: 0x14c0fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 6));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_1391b0;
    }
label_1391d8:
    // 0x1391d8: 0x2404001c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1391dc: 0xafa00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    // 0x1391e0: 0xa42018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1391e4: 0xc0635aa
    SET_GPR_U32(ctx, 31, 0x1391ec);
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PvAllocStackClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1391ec
// Address: 0x1391ec - 0x139314

void entry_1391ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1391ec) {
        switch (ctx->pc) {
            case 0x139200: ctx->pc = 0; goto label_139200;
            case 0x139258: ctx->pc = 0; goto label_139258;
            case 0x13929c: ctx->pc = 0; goto label_13929c;
            case 0x1392b8: ctx->pc = 0; goto label_1392b8;
            case 0x1392d8: ctx->pc = 0; goto label_1392d8;
            case 0x1392f4: ctx->pc = 0; goto label_1392f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1391ec: 0xafa2001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 2));
    // 0x1391f0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1391f4: 0x184000d3
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 28));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x139544; return;
    }
    // 0x1391fc: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_139200:
    // 0x139200: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139204: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x139208: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x13920c: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x139210: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x139214: 0x70430000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x139218: 0xafa4002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 4));
    // 0x13921c: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x139220: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x139224: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x139228: 0x106000c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13952C; return;
    }
    // 0x139230: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x139234: 0x184000bc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x139528; return;
    }
    // 0x13923c: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x139240: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x139244: 0x3c63018
    { int64_t result = (int64_t)GPR_S32(ctx, 30) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x139248: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x13924c: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x139250: 0xafa60030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 6));
    // 0x139254: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
label_139258:
    // 0x139258: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x13925c: 0xa62018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x139260: 0x44a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x139264: 0x8e830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x139268: 0x5460000c
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_13929c;
    }
    // 0x139270: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x139274: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_13929c;
    }
    // 0x13927c: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x139280: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_13929c;
    }
    // 0x139288: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x13928c: 0x24a30001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 1));
    // 0x139290: 0x1040009e
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13950C; return;
    }
    // 0x139298: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
label_13929c:
    // 0x13929c: 0xafa50028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 5));
    // 0x1392a0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1392a4: 0x1bc0000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_S32(ctx, 30) <= 0) {
        goto label_1392d8;
    }
    // 0x1392ac: 0x8fa4001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x1392b0: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1392b4: 0x80182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1392b8:
    // 0x1392b8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1392bc: 0x10e2000d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 2)) {
        goto label_1392f4;
    }
    // 0x1392c4: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1392c8: 0x2623001c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 28));
    // 0x1392cc: 0xbe102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 30)));
    // 0x1392d0: 0x1440fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 28));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1392b8;
    }
label_1392d8:
    // 0x1392d8: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1392dc: 0x27de0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 1));
    // 0x1392e0: 0x8fa4001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x1392e4: 0x858821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1392e8: 0xae260000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 6));
    // 0x1392ec: 0x24a5001c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 28));
    // 0x1392f0: 0xafa50030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 5));
label_1392f4:
    // 0x1392f4: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x1392f8: 0x5040001d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
        ctx->pc = 0x139370; return;
    }
    // 0x139300: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x139304: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
        ctx->pc = 0x139344; return;
    }
    // 0x13930c: 0xc0483ec
    SET_GPR_U32(ctx, 31, 0x139314);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    PacpNew__F4ACVK(rdram, ctx, runtime); return;
}


// Function: entry_139314
// Address: 0x139314 - 0x139330

void entry_139314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139314: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x139318: 0x8fa60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x13931c: 0xae16000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 22));
    // 0x139320: 0x62080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 6), 2));
    // 0x139324: 0x8ec200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 192)));
    // 0x139328: 0xc063570
    SET_GPR_U32(ctx, 31, 0x139330);
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_139330
// Address: 0x139330 - 0x13938c

void entry_139330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139330) {
        switch (ctx->pc) {
            case 0x139344: ctx->pc = 0; goto label_139344;
            case 0x139358: ctx->pc = 0; goto label_139358;
            case 0x139370: ctx->pc = 0; goto label_139370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139330: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x139334: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x139338: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x13933c: 0xae300004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 16));
    // 0x139340: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
label_139344:
    // 0x139344: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x139348: 0x14600003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_139358;
    }
    // 0x139350: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x139354: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_139358:
    // 0x139358: 0x8fa50024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x13935c: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x139360: 0x8e840004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x139364: 0xa31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x139368: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x13936c: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
label_139370:
    // 0x139370: 0x5040001d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
        ctx->pc = 0x1393E8; return;
    }
    // 0x139378: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x13937c: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
        ctx->pc = 0x1393BC; return;
    }
    // 0x139384: 0xc048414
    SET_GPR_U32(ctx, 31, 0x13938c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    PacrNew__F4ACVK(rdram, ctx, runtime); return;
}


// Function: entry_13938c
// Address: 0x13938c - 0x1393a8

void entry_13938c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13938c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x139390: 0x8fa60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x139394: 0xae16000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 22));
    // 0x139398: 0x62080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 6), 2));
    // 0x13939c: 0x8ec200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 192)));
    // 0x1393a0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1393a8);
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1393a8
// Address: 0x1393a8 - 0x139404

void entry_1393a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1393a8) {
        switch (ctx->pc) {
            case 0x1393bc: ctx->pc = 0; goto label_1393bc;
            case 0x1393d0: ctx->pc = 0; goto label_1393d0;
            case 0x1393e8: ctx->pc = 0; goto label_1393e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1393a8: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x1393ac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1393b0: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x1393b4: 0xae300008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 16));
    // 0x1393b8: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
label_1393bc:
    // 0x1393bc: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1393c0: 0x14600003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1393d0;
    }
    // 0x1393c8: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x1393cc: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_1393d0:
    // 0x1393d0: 0x8fa50024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1393d4: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1393d8: 0x8e840008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x1393dc: 0xa31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1393e0: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x1393e4: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
label_1393e8:
    // 0x1393e8: 0x50400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
        ctx->pc = 0x139444; return;
    }
    // 0x1393f0: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1393f4: 0x5440000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 16)));
        ctx->pc = 0x139430; return;
    }
    // 0x1393fc: 0xc048458
    SET_GPR_U32(ctx, 31, 0x139404);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    PacgNew__F4ACGK(rdram, ctx, runtime); return;
}


// Function: entry_139404
// Address: 0x139404 - 0x139420

void entry_139404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139404: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x139408: 0x8fa60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x13940c: 0xae160008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 22));
    // 0x139410: 0x62080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 6), 2));
    // 0x139414: 0x8ec200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 192)));
    // 0x139418: 0xc063570
    SET_GPR_U32(ctx, 31, 0x139420);
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_139420
// Address: 0x139420 - 0x139468

void entry_139420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139420) {
        switch (ctx->pc) {
            case 0x139430: ctx->pc = 0; goto label_139430;
            case 0x139444: ctx->pc = 0; goto label_139444;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139420: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x139424: 0xae300010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 16));
    // 0x139428: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x13942c: 0x8e840010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 16)));
label_139430:
    // 0x139430: 0x8c430010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x139434: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x139438: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13943c: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x139440: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
label_139444:
    // 0x139444: 0x10400032
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x139510; return;
    }
    // 0x13944c: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x139450: 0x14400007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139470; return;
    }
    // 0x139458: 0xae220014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    // 0x13945c: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x139460: 0xc063570
    SET_GPR_U32(ctx, 31, 0x139468);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_139468
// Address: 0x139468 - 0x1394b8

void entry_139468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139468) {
        switch (ctx->pc) {
            case 0x139470: ctx->pc = 0; goto label_139470;
            case 0x139488: ctx->pc = 0; goto label_139488;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139468: 0xae220018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
    // 0x13946c: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
label_139470:
    // 0x139470: 0x18400026
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13950C; return;
    }
    // 0x139478: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x13947c: 0x3b880
    SET_GPR_U32(ctx, 23, SLL32(GPR_U32(ctx, 3), 2));
    // 0x139480: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x139484: 0x0
    // NOP
label_139488:
    // 0x139488: 0x139080
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 19), 2));
    // 0x13948c: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x139490: 0x8c550000
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x139494: 0x52a00019
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
        ctx->pc = 0x1394FC; return;
    }
    // 0x13949c: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1394a0: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1394a4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1394a8: 0x54600011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
        ctx->pc = 0x1394F0; return;
    }
    // 0x1394b0: 0xc048458
    SET_GPR_U32(ctx, 31, 0x1394b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    PacgNew__F4ACGK(rdram, ctx, runtime); return;
}


// Function: entry_1394b8
// Address: 0x1394b8 - 0x1394d4

void entry_1394b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1394b8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1394bc: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1394c0: 0xae160008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 22));
    // 0x1394c4: 0x52080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1394c8: 0x8ec200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 192)));
    // 0x1394cc: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1394d4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1394d4
// Address: 0x1394d4 - 0x139554

void entry_1394d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1394d4) {
        switch (ctx->pc) {
            case 0x1394f0: ctx->pc = 0; goto label_1394f0;
            case 0x1394fc: ctx->pc = 0; goto label_1394fc;
            case 0x13950c: ctx->pc = 0; goto label_13950c;
            case 0x139510: ctx->pc = 0; goto label_139510;
            case 0x139528: ctx->pc = 0; goto label_139528;
            case 0x13952c: ctx->pc = 0; goto label_13952c;
            case 0x139544: ctx->pc = 0; goto label_139544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1394d4: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x1394d8: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1394dc: 0xae130014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 19));
    // 0x1394e0: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1394e4: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1394e8: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1394ec: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
label_1394f0:
    // 0x1394f0: 0x2e21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x1394f4: 0xac550000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 21));
    // 0x1394f8: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
label_1394fc:
    // 0x1394fc: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x139500: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x139504: 0x5440ffe0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
        ctx->pc = 0x139488; return;
    }
label_13950c:
    // 0x13950c: 0x8fa60018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 24)));
label_139510:
    // 0x139510: 0x8fa50028
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x139514: 0x8cc30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x139518: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x13951c: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x139520: 0x1440ff4d
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139258; return;
    }
label_139528:
    // 0x139528: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
label_13952c:
    // 0x13952c: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x139530: 0xafa20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    // 0x139534: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x139538: 0x1440ff31
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139200; return;
    }
    // 0x139540: 0x2404001c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 28));
label_139544:
    // 0x139544: 0xaede0038
    WRITE32(ADD32(GPR_U32(ctx, 22), 56), GPR_U32(ctx, 30));
    // 0x139548: 0x3c42018
    { int64_t result = (int64_t)GPR_S32(ctx, 30) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13954c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x139554);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_139554
// Address: 0x139554 - 0x1395c4

void entry_139554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139554: 0xaec2003c
    WRITE32(ADD32(GPR_U32(ctx, 22), 60), GPR_U32(ctx, 2));
    // 0x139558: 0x8fa40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13955c: 0x8c820044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 68)));
    // 0x139560: 0xaec20044
    WRITE32(ADD32(GPR_U32(ctx, 22), 68), GPR_U32(ctx, 2));
    // 0x139564: 0x8c830078
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 120)));
    // 0x139568: 0xaec30078
    WRITE32(ADD32(GPR_U32(ctx, 22), 120), GPR_U32(ctx, 3));
    // 0x13956c: 0xc480007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 124)); ctx->f[0] = *(float*)&val; }
    // 0x139570: 0xe6c0007c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 22), 124), *(uint32_t*)&val); }
    // 0x139574: 0x8c820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 84)));
    // 0x139578: 0xaec20054
    WRITE32(ADD32(GPR_U32(ctx, 22), 84), GPR_U32(ctx, 2));
    // 0x13957c: 0x8c830058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 88)));
    // 0x139580: 0xaec30058
    WRITE32(ADD32(GPR_U32(ctx, 22), 88), GPR_U32(ctx, 3));
    // 0x139584: 0x8c820064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 100)));
    // 0x139588: 0xaec20064
    WRITE32(ADD32(GPR_U32(ctx, 22), 100), GPR_U32(ctx, 2));
    // 0x13958c: 0x8c830068
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 104)));
    // 0x139590: 0xaec30068
    WRITE32(ADD32(GPR_U32(ctx, 22), 104), GPR_U32(ctx, 3));
    // 0x139594: 0x8fa5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x139598: 0x14a0000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1395C8; return;
    }
    // 0x1395a0: 0x8fa60020
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1395a4: 0x8cc4005c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 92)));
    // 0x1395a8: 0xaec4005c
    WRITE32(ADD32(GPR_U32(ctx, 22), 92), GPR_U32(ctx, 4));
    // 0x1395ac: 0x8cc50060
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 96)));
    // 0x1395b0: 0xaec50060
    WRITE32(ADD32(GPR_U32(ctx, 22), 96), GPR_U32(ctx, 5));
    // 0x1395b4: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1395b8: 0x8cc70060
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 6), 96)));
    // 0x1395bc: 0xc04e3fc
    SET_GPR_U32(ctx, 31, 0x1395c4);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 92)));
    VerifyAeaEquivalence__FiP2EAiT1(rdram, ctx, runtime); return;
}


// Function: entry_1395c4
// Address: 0x1395c4 - 0x1395d0

void entry_1395c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1395c4) {
        switch (ctx->pc) {
            case 0x1395c8: ctx->pc = 0; goto label_1395c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1395c4: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
label_1395c8:
    // 0x1395c8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1395d0);
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 22));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1395d0
// Address: 0x1395d0 - 0x139600

void entry_1395d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1395d0: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1395d4: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1395d8: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1395dc: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1395e0: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1395e4: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1395e8: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1395ec: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1395f0: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1395f4: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1395f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FillBlAmrsg__FiiPviiP3OID
// Address: 0x139600 - 0x13969c

void entry_13969c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13969c) {
        switch (ctx->pc) {
            case 0x1396a8: ctx->pc = 0; goto label_1396a8;
            case 0x1396c0: ctx->pc = 0; goto label_1396c0;
            case 0x1396ec: ctx->pc = 0; goto label_1396ec;
            case 0x1396fc: ctx->pc = 0; goto label_1396fc;
            case 0x13970c: ctx->pc = 0; goto label_13970c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13969c: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1396a0: 0x1600fff9
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139688; return;
    }
label_1396a8:
    // 0x1396a8: 0x2a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1396ac: 0x26c2fff8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 4294967288));
    // 0x1396b0: 0x1a800012
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_1396fc;
    }
    // 0x1396b8: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1396bc: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1396c0:
    // 0x1396c0: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1396c4: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1396c8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1396cc: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1396d0: 0x0
    // NOP
    // 0x1396d4: 0x45000005
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1396ec;
    }
    // 0x1396dc: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1396e0: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1396e4: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1396e8: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
label_1396ec:
    // 0x1396ec: 0x220182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1396f0: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1396f4: 0x1600fff2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1396c0;
    }
label_1396fc:
    // 0x1396fc: 0x2e0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x139700: 0x7e102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 30)));
    // 0x139704: 0x1440ffd2
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139650; return;
    }
label_13970c:
    // 0x13970c: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x139710: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x139714: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x139718: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13971c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x139720: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x139724: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x139728: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13972c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x139730: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139734: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13973c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x139740; return;
}


// Function: CalculateBlendAmrsg__FiiPviiP4MRSGPf
// Address: 0x139740 - 0x1398fc

void entry_1398fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1398fc) {
        switch (ctx->pc) {
            case 0x139918: ctx->pc = 0; goto label_139918;
            case 0x13993c: ctx->pc = 0; goto label_13993c;
            case 0x139948: ctx->pc = 0; goto label_139948;
            case 0x139950: ctx->pc = 0; goto label_139950;
            case 0x139954: ctx->pc = 0; goto label_139954;
            case 0x139958: ctx->pc = 0; goto label_139958;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1398fc: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x139900: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x139904: 0x110102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 16)));
    // 0x139908: 0x1040000f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_139948;
    }
    // 0x139910: 0x26290008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 8));
    // 0x139914: 0x2608ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 4294967295));
label_139918:
    // 0x139918: 0xc521fff8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 4294967288)); ctx->f[1] = *(float*)&val; }
    // 0x13991c: 0xc520fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x139920: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x139924: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x139928: 0x0
    // NOP
    // 0x13992c: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 9), 0), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13993c;
    }
    // 0x139934: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x139938: 0xe5200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 9), 0), *(uint32_t*)&val); }
label_13993c:
    // 0x13993c: 0x2508ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967295));
    // 0x139940: 0x1500fff5
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 8));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 0)) {
        goto label_139918;
    }
label_139948:
    // 0x139948: 0x12400003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_139958;
    }
label_139950:
    // 0x139950: 0xe6540000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_139954:
    // 0x139954: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_139958:
    // 0x139958: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13995c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139960: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139964: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x139968: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ImrsgLookUp__FffiP4MRSGPf
// Address: 0x139970 - 0x1399f0

void entry_139a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139a64: 0x8e2200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 188)));
    // 0x139a68: 0x1440000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139A94; return;
    }
    // 0x139a70: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x139a74: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x139a78: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139a7c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139a80: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139a84: 0xc04e5d0
    SET_GPR_U32(ctx, 31, 0x139a8c);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 17), 52));
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime); return;
}


// Function: entry_139a8c
// Address: 0x139a8c - 0x139ad4

void entry_139a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139a8c) {
        switch (ctx->pc) {
            case 0x139a94: ctx->pc = 0; goto label_139a94;
            case 0x139aa8: ctx->pc = 0; goto label_139aa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139a8c: 0x10000014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 108)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x139AE0; return;
    }
label_139a94:
    // 0x139a94: 0x18400011
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x139ADC; return;
    }
    // 0x139a9c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139aa0: 0x8e2200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 192)));
    // 0x139aa4: 0x0
    // NOP
label_139aa8:
    // 0x139aa8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x139aac: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x139ab0: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x139ab4: 0x521021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x139ab8: 0x262a0034
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 17), 52));
    // 0x139abc: 0x8c490008
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x139ac0: 0x2652000c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 12));
    // 0x139ac4: 0x8c470000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x139ac8: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x139acc: 0xc04e5d0
    SET_GPR_U32(ctx, 31, 0x139ad4);
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime); return;
}


// Function: entry_139ad4
// Address: 0x139ad4 - 0x139b04

void entry_139ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139ad4) {
        switch (ctx->pc) {
            case 0x139adc: ctx->pc = 0; goto label_139adc;
            case 0x139ae0: ctx->pc = 0; goto label_139ae0;
            case 0x139af0: ctx->pc = 0; goto label_139af0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139ad4: 0x5600fff4
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 192)));
        ctx->pc = 0x139AA8; return;
    }
label_139adc:
    // 0x139adc: 0x8e30006c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 108)));
label_139ae0:
    // 0x139ae0: 0x1200000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x139B14; return;
    }
    // 0x139ae8: 0xc6010014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[1] = *(float*)&val; }
    // 0x139aec: 0x0
    // NOP
label_139af0:
    // 0x139af0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x139af4: 0xc6200034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 52)); ctx->f[0] = *(float*)&val; }
    // 0x139af8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x139afc: 0xc04bc76
    SET_GPR_U32(ctx, 31, 0x139b04);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    AdaptAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_139b04
// Address: 0x139b04 - 0x139b38

void entry_139b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139b04) {
        switch (ctx->pc) {
            case 0x139b14: ctx->pc = 0; goto label_139b14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139b04: 0x8e10003c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x139b08: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x139AF0; return;
    }
    // 0x139b10: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_139b14:
    // 0x139b14: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x139b18: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x139b1c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x139b20: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x139b24: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x139b28: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139b2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x139b34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x139b38; return;
}


// Function: SetAsegblSlerp__FP6ASEGBLP3ALO
// Address: 0x139b38 - 0x139b48

void entry_139b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139b48) {
        switch (ctx->pc) {
            case 0x139b64: ctx->pc = 0; goto label_139b64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139b48: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_139b64;
    }
    // 0x139b50: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x139b54: 0x10600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_139b64;
    }
    // 0x139b5c: 0xac620018
    WRITE32(ADD32(GPR_U32(ctx, 3), 24), GPR_U32(ctx, 2));
    // 0x139b60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_139b64:
    // 0x139b64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x139b6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x139b70; return;
}


// Function: BuildBlipAqwGifs__FiPP2QW
// Address: 0x139b70 - 0x139b90

void entry_139b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139b90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x139b94: 0xc054a3c
    SET_GPR_U32(ctx, 31, 0x139b9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    AllocGlobal__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_139b9c
// Address: 0x139b9c - 0x139bb0

void entry_139b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139b9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x139ba0: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x139ba4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139ba8: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x139bb0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_139bb0
// Address: 0x139bb0 - 0x139bc4

void entry_139bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139bb0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x139bb4: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x139bb8: 0x34c6180b
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 6155));
    // 0x139bbc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x139bc4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_139bc4
// Address: 0x139bc4 - 0x139bdc

void entry_139bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139bc4: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x139bc8: 0x1080b8
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << 2);
    // 0x139bcc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x139bd0: 0x2063025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 6)));
    // 0x139bd4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x139bdc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_139bdc
// Address: 0x139bdc - 0x139c08

void entry_139bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139bdc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x139be0: 0x24080042
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 66));
    // 0x139be4: 0x84438
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 8) << 16);
    // 0x139be8: 0x35084242
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 16962));
    // 0x139bec: 0x84438
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 8) << 16);
    // 0x139bf0: 0x3508412e
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 16686));
    // 0x139bf4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139bf8: 0x24050054
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 84));
    // 0x139bfc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139c00: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x139c08);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 10));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_139c08
// Address: 0x139c08 - 0x139c10

void entry_139c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139c08: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x139c10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_139c10
// Address: 0x139c10 - 0x139c20

void entry_139c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139c10: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x139c14: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x139c18: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x139c20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_139c20
// Address: 0x139c20 - 0x139c38

void entry_139c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139c20: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x139c24: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x139c28: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x139c2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x139c34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x139c38; return;
}


// Function: StartupBlips__Fv
// Address: 0x139c38 - 0x139c50

void entry_139c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139c50: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x139c54: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x139c58: 0xc04e6dc
    SET_GPR_U32(ctx, 31, 0x139c60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4888));
    BuildBlipAqwGifs__FiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_139c60
// Address: 0x139c60 - 0x139c70

void entry_139c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139c60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139c64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x139c6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x139c70; return;
}


// Function: PblipNew__FP5BLIPG
// Address: 0x139c70 - 0x139c90

void entry_139c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139c90) {
        switch (ctx->pc) {
            case 0x139ca4: ctx->pc = 0; goto label_139ca4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139c90: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x139c94: 0x16000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_139ca4;
    }
    // 0x139c9c: 0x1000001c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x139D10; return;
    }
label_139ca4:
    // 0x139ca4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139ca8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x139cb0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4288));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_139cb0
// Address: 0x139cb0 - 0x139ccc

void entry_139cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139cb0: 0x8e230320
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 800)));
    // 0x139cb4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x139cb8: 0x54620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 4236), GPR_U32(ctx, 17));
        ctx->pc = 0x139D00; return;
    }
    // 0x139cc0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x139cc4: 0xc06d7a8
    SET_GPR_U32(ctx, 31, 0x139ccc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6988));
    PvAllocSlotheapUnsafe__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_139ccc
// Address: 0x139ccc - 0x139ce4

void entry_139ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139ccc: 0x14400007
    WRITE32(ADD32(GPR_U32(ctx, 16), 4232), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139CEC; return;
    }
    // 0x139cd4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x139cd8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x139cdc: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x139ce4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6976));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_139ce4
// Address: 0x139ce4 - 0x139cfc

void entry_139ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139ce4) {
        switch (ctx->pc) {
            case 0x139cec: ctx->pc = 0; goto label_139cec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139ce4: 0x1000000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x139D10; return;
    }
label_139cec:
    // 0x139cec: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x139cf0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139cf4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x139cfc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1408));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_139cfc
// Address: 0x139cfc - 0x139d0c

void entry_139cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139cfc) {
        switch (ctx->pc) {
            case 0x139d00: ctx->pc = 0; goto label_139d00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139cfc: 0xae11108c
    WRITE32(ADD32(GPR_U32(ctx, 16), 4236), GPR_U32(ctx, 17));
label_139d00:
    // 0x139d00: 0x26240624
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1572));
    // 0x139d04: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x139d0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_139d0c
// Address: 0x139d0c - 0x139d28

void entry_139d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139d0c) {
        switch (ctx->pc) {
            case 0x139d10: ctx->pc = 0; goto label_139d10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139d0c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_139d10:
    // 0x139d10: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x139d14: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139d18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139d1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x139d24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x139d28; return;
}


// Function: RemoveBlip__FP4BLIP
// Address: 0x139d28 - 0x139d48

void entry_139d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139d48: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x139d4c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x139d50: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x139d58);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8944));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_139d58
// Address: 0x139d58 - 0x139d68

void entry_139d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139d58: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139d5c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139d60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PblipgNew__FP2SW
// Address: 0x139d68 - 0x139dd4

void entry_139dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139dd4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x139dd8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139ddc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139de0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitBlipg__FP5BLIPG
// Address: 0x139de8 - 0x139e08

void entry_139e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139e08: 0xc048fb4
    SET_GPR_U32(ctx, 31, 0x139e10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_139e10
// Address: 0x139e10 - 0x139e1c

void entry_139e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139e10: 0x26040624
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1572));
    // 0x139e14: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x139e1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4240));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_139e1c
// Address: 0x139e1c - 0x139e80

void entry_139e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139e1c: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x139e20: 0x3c03cfff
    SET_GPR_U32(ctx, 3, ((uint32_t)53247 << 16));
    // 0x139e24: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x139e28: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x139e2c: 0x2405fcff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x139e30: 0x52c38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 16);
    // 0x139e34: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x139e38: 0x52c38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 16);
    // 0x139e3c: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x139e40: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x139e44: 0x3c015015
    SET_GPR_U32(ctx, 1, ((uint32_t)20501 << 16));
    // 0x139e48: 0x342102f9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 761));
    // 0x139e4c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x139e50: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x139e54: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x139e58: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x139e5c: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x139e60: 0xe6000080
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 128), *(uint32_t*)&val); }
    // 0x139e64: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x139e68: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139e6c: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x139e70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139e74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x139e7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x139e80; return;
}


// Function: OnBlipgAdd__FP5BLIPG
// Address: 0x139e80 - 0x139ea0

void entry_139ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139ea0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x139ea4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x139ea8: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x139eb0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7348));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_139eb0
// Address: 0x139eb0 - 0x139eb8

void entry_139eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139eb0: 0xc04903e
    SET_GPR_U32(ctx, 31, 0x139eb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnAloAdd__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_139eb8
// Address: 0x139eb8 - 0x139ec8

void entry_139eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139eb8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139ebc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x139ec0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnBlipgRemove__FP5BLIPG
// Address: 0x139ec8 - 0x139f20

void entry_139f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139f20) {
        switch (ctx->pc) {
            case 0x139f3c: ctx->pc = 0; goto label_139f3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139f20: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x139f24: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x139f28: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x139f2c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x139f30: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x139f34: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x139F18; return;
    }
label_139f3c:
    // 0x139f3c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x139f40: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x139f44: 0xc054980
    SET_GPR_U32(ctx, 31, 0x139f4c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7348));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_139f4c
// Address: 0x139f4c - 0x139f5c

void entry_139f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139f4c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x139f50: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x139f54: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x139f5c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8928));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_139f5c
// Address: 0x139f5c - 0x139f64

void entry_139f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139f5c: 0xc0490f8
    SET_GPR_U32(ctx, 31, 0x139f64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnAloRemove__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_139f64
// Address: 0x139f64 - 0x139f80

void entry_139f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139f64: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x139f68: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x139f6c: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x139f70: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x139f74: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139f78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBlipgShader__FP5BLIPG3OID
// Address: 0x139f80 - 0x139f98

void entry_139f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x139f98) {
        switch (ctx->pc) {
            case 0x139fac: ctx->pc = 0; goto label_139fac;
            case 0x139fc8: ctx->pc = 0; goto label_139fc8;
            case 0x139ff0: ctx->pc = 0; goto label_139ff0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x139f98: 0x14400004
    WRITE32(ADD32(GPR_U32(ctx, 16), 896), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_139fac;
    }
    // 0x139fa0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x139fa4: 0x8c4344fc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 17660)));
    // 0x139fa8: 0xae030380
    WRITE32(ADD32(GPR_U32(ctx, 16), 896), GPR_U32(ctx, 3));
label_139fac:
    // 0x139fac: 0x8e020590
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1424)));
    // 0x139fb0: 0x1440000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_139ff0;
    }
    // 0x139fb8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x139fbc: 0xae020590
    WRITE32(ADD32(GPR_U32(ctx, 16), 1424), GPR_U32(ctx, 2));
    // 0x139fc0: 0x26060594
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 1428));
    // 0x139fc4: 0x0
    // NOP
label_139fc8:
    // 0x139fc8: 0x8e020380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 896)));
    // 0x139fcc: 0xc52021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x139fd0: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x139fd4: 0x90430004
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x139fd8: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x139fdc: 0x28a20004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4));
    // 0x139fe0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x139fe4: 0x31843
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 1));
    // 0x139fe8: 0x1440fff7
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_139fc8;
    }
label_139ff0:
    // 0x139ff0: 0xc04e802
    SET_GPR_U32(ctx, 31, 0x139ff8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PropagateBlipgShader__FP5BLIPG(rdram, ctx, runtime); return;
}


// Function: entry_139ff8
// Address: 0x139ff8 - 0x13a008

void entry_139ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x139ff8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x139ffc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13a000: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PropagateBlipgShader__FP5BLIPG
// Address: 0x13a008 - 0x13a0d8

void entry_13a0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a0d8) {
        switch (ctx->pc) {
            case 0x13a0f4: ctx->pc = 0; goto label_13a0f4;
            case 0x13a104: ctx->pc = 0; goto label_13a104;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a0d8: 0xfe020000
    WRITE64(ADD32(GPR_U32(ctx, 16), 0), GPR_U64(ctx, 2));
    // 0x13a0dc: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x13a0e0: 0x10400004
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13a0f4;
    }
    // 0x13a0e8: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13a0ec: 0x7e020010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 2));
    // 0x13a0f0: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
label_13a0f4:
    // 0x13a0f4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x13a0f8: 0x232102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 18)));
    // 0x13a0fc: 0x1440fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A0C8; return;
    }
label_13a104:
    // 0x13a104: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13a108: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13a10c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13a110: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13a114: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13a118: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13a11c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13a120: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBlipgEmitb__FP5BLIPGP5EMITB
// Address: 0x13a128 - 0x13a1ec

void entry_13a1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a1ec: 0x26040300
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 768));
    // 0x13a1f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a1f4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x13a1fc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_13a1fc
// Address: 0x13a1fc - 0x13a27c

void entry_13a1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a1fc) {
        switch (ctx->pc) {
            case 0x13a234: ctx->pc = 0; goto label_13a234;
            case 0x13a24c: ctx->pc = 0; goto label_13a24c;
            case 0x13a254: ctx->pc = 0; goto label_13a254;
            case 0x13a258: ctx->pc = 0; goto label_13a258;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a1fc: 0x8e030384
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 900)));
    // 0x13a200: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x13a204: 0x14400014
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_13a258;
    }
    // 0x13a20c: 0xc6410054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 84)); ctx->f[1] = *(float*)&val; }
    // 0x13a210: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x13a214: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13a218: 0x0
    // NOP
    // 0x13a21c: 0x45030005
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 80)));
        goto label_13a234;
    }
    // 0x13a224: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x13a228: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x13a22c: 0x10000007
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13a24c;
    }
label_13a234:
    // 0x13a234: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 48)));
        goto label_13a254;
    }
    // 0x13a23c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x13a240: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x13a244: 0xc62100f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 244)); ctx->f[1] = *(float*)&val; }
    // 0x13a248: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
label_13a24c:
    // 0x13a24c: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 772), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13a258;
    }
label_13a254:
    // 0x13a254: 0x7e020300
    WRITE128(ADD32(GPR_U32(ctx, 16), 768), GPR_VEC(ctx, 2));
label_13a258:
    // 0x13a258: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13a25c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x13a260: 0x26240110
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 272));
    // 0x13a264: 0xc62c00f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 244)); ctx->f[12] = *(float*)&val; }
    // 0x13a268: 0x260502f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 752));
    // 0x13a26c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x13a270: 0x460cab03
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[12] = ctx->f[21] / ctx->f[12];
    // 0x13a274: 0xc07ab4c
    SET_GPR_U32(ctx, 31, 0x13a27c);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    PrescaleClq__FP3CLQffT0(rdram, ctx, runtime); return;
}


// Function: entry_13a27c
// Address: 0x13a27c - 0x13a294

void entry_13a27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a27c: 0xc62c00f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 244)); ctx->f[12] = *(float*)&val; }
    // 0x13a280: 0x26240140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 320));
    // 0x13a284: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x13a288: 0x260502e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 736));
    // 0x13a28c: 0xc07ab4c
    SET_GPR_U32(ctx, 31, 0x13a294);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[12] = ctx->f[21] / ctx->f[12];
    PrescaleClq__FP3CLQffT0(rdram, ctx, runtime); return;
}


// Function: entry_13a294
// Address: 0x13a294 - 0x13a2ac

void entry_13a294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a294: 0xc62c00f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 244)); ctx->f[12] = *(float*)&val; }
    // 0x13a298: 0x26240160
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 352));
    // 0x13a29c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x13a2a0: 0x26050310
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 784));
    // 0x13a2a4: 0xc07ab4c
    SET_GPR_U32(ctx, 31, 0x13a2ac);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[12] = ctx->f[21] / ctx->f[12];
    PrescaleClq__FP3CLQffT0(rdram, ctx, runtime); return;
}


// Function: entry_13a2ac
// Address: 0x13a2ac - 0x13a368

void entry_13a2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a2ac) {
        switch (ctx->pc) {
            case 0x13a318: ctx->pc = 0; goto label_13a318;
            case 0x13a348: ctx->pc = 0; goto label_13a348;
            case 0x13a354: ctx->pc = 0; goto label_13a354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a2ac: 0x8e220130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x13a2b0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a2b4: 0x14400024
    WRITE32(ADD32(GPR_U32(ctx, 16), 800), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_13a348;
    }
    // 0x13a2bc: 0x7a2200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 176)));
    // 0x13a2c0: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a2c4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x13a2c8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x13a2cc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x13a2d0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13a2d4: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x13a2d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13a2dc: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13a318;
    }
    // 0x13a2e4: 0x70022fc9
    SET_GPR_VEC(ctx, 5, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x13a2e8: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x13a2ec: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x13a2f0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13a2f4: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13a318;
    }
    // 0x13a2fc: 0x70022ca8
    SET_GPR_VEC(ctx, 5, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x13a300: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x13a304: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x13a308: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13a30c: 0x0
    // NOP
    // 0x13a310: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_13a318;
    }
label_13a318:
    // 0x13a318: 0x1060000b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_13a348;
    }
    // 0x13a320: 0xc62000c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 192)); ctx->f[0] = *(float*)&val; }
    // 0x13a324: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x13a328: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13a32c: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13a348;
    }
    // 0x13a334: 0xc62000c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 196)); ctx->f[0] = *(float*)&val; }
    // 0x13a338: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13a33c: 0x0
    // NOP
    // 0x13a340: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_13a348;
    }
label_13a348:
    // 0x13a348: 0x10800002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_13a354;
    }
    // 0x13a350: 0xae020320
    WRITE32(ADD32(GPR_U32(ctx, 16), 800), GPR_U32(ctx, 2));
label_13a354:
    // 0x13a354: 0x26120330
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 816));
    // 0x13a358: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a35c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13a360: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x13a368);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 80));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_13a368
// Address: 0x13a368 - 0x13a380

void entry_13a368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a368: 0x8e030320
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 800)));
    // 0x13a36c: 0x14600005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A384; return;
    }
    // 0x13a374: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13a378: 0xc0560fa
    SET_GPR_U32(ctx, 31, 0x13a380);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetEmitdvEmitb__FP6EMITDVP5EMITB(rdram, ctx, runtime); return;
}


// Function: entry_13a380
// Address: 0x13a380 - 0x13a3a0

void entry_13a380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a380) {
        switch (ctx->pc) {
            case 0x13a384: ctx->pc = 0; goto label_13a384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a380: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_13a384:
    // 0x13a384: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13a388: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13a38c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13a390: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x13a394: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x13a398: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateBlipg__FP5BLIPGf
// Address: 0x13a3a0 - 0x13a3b4

void entry_13a3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a3b4: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x13a3bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13a3bc
// Address: 0x13a3bc - 0x13a408

void entry_13a3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a3bc) {
        switch (ctx->pc) {
            case 0x13a3ec: ctx->pc = 0; goto label_13a3ec;
            case 0x13a3f0: ctx->pc = 0; goto label_13a3f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a3bc: 0x8e040380
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 896)));
    // 0x13a3c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13a3c4: 0x8c451990
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x13a3c8: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x13a3cc: 0x8c86000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x13a3d0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a3d4: 0xc31824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x13a3d8: 0x14600004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 540)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_13a3ec;
    }
    // 0x13a3e0: 0x861024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x13a3e4: 0x14440002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_13a3f0;
    }
label_13a3ec:
    // 0x13a3ec: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
label_13a3f0:
    // 0x13a3f0: 0x14e00006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A40C; return;
    }
    // 0x13a3f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13a3fc: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x13a400: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13a408);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13a408
// Address: 0x13a408 - 0x13a418

void entry_13a408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a408) {
        switch (ctx->pc) {
            case 0x13a40c: ctx->pc = 0; goto label_13a40c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a408: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13a40c:
    // 0x13a40c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13a410: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SubscribeBlipgObject__FP5BLIPGP2LO
// Address: 0x13a418 - 0x13a434

void entry_13a434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a434: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13a438: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13a440);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13a440
// Address: 0x13a440 - 0x13a458

void entry_13a440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a440: 0x1040000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 788));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A480; return;
    }
    // 0x13a448: 0xae3002d0
    WRITE32(ADD32(GPR_U32(ctx, 17), 720), GPR_U32(ctx, 16));
    // 0x13a44c: 0xc6000080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 128)); ctx->f[0] = *(float*)&val; }
    // 0x13a450: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x13a458);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 128), *(uint32_t*)&val); }
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_13a458
// Address: 0x13a458 - 0x13a498

void entry_13a458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a458) {
        switch (ctx->pc) {
            case 0x13a480: ctx->pc = 0; goto label_13a480;
            case 0x13a484: ctx->pc = 0; goto label_13a484;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a458: 0x1440000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_13a484;
    }
    // 0x13a460: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x13a464: 0x3c03f3ff
    SET_GPR_U32(ctx, 3, ((uint32_t)62463 << 16));
    // 0x13a468: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x13a46c: 0x3c04cfff
    SET_GPR_U32(ctx, 4, ((uint32_t)53247 << 16));
    // 0x13a470: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x13a474: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13a478: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x13a47c: 0xfe2202c8
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 2));
label_13a480:
    // 0x13a480: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_13a484:
    // 0x13a484: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13a488: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13a48c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13a494: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13a498; return;
}


// Function: CblipeProjectBlipTransformAccel__FP7MATRIX4G8VU_FLOATP5BLIPPP5BLIPVP5BLIPXi6BLIPOKP6VECTORT7
// Address: 0x13a498 - 0x13a590

void entry_13a590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a590) {
        switch (ctx->pc) {
            case 0x13a598: ctx->pc = 0; goto label_13a598;
            case 0x13a5b0: ctx->pc = 0; goto label_13a5b0;
            case 0x13a5cc: ctx->pc = 0; goto label_13a5cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a590: 0xe640000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
    // 0x13a594: 0x7ba40010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13a598:
    // 0x13a598: 0x48420001
    SET_GPR_U32(ctx, 2, ctx->vu0_status);
    // 0x13a59c: 0x2161021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 22)));
    // 0x13a5a0: 0x2171821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 23)));
    // 0x13a5a4: 0xf8560000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[22]));
    // 0x13a5a8: 0xf8750000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[21]));
    // 0x13a5ac: 0xda780000
    ctx->vu0_vf[24] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
label_13a5b0:
    // 0x13a5b0: 0xda970000
    ctx->vu0_vf[23] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x13a5b4: 0x4a0000b8
    {     ctx->vu0_tpc = 0x5C0;     runtime->executeVU0Microprogram(rdram, ctx, 0x5C0); }
    // 0x13a5b8: 0x26940010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 16));
    // 0x13a5bc: 0x26730010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 16));
    // 0x13a5c0: 0x26b5ffff
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x13a5c4: 0x16a0ffdc
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A538; return;
    }
label_13a5cc:
    // 0x13a5cc: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x13a5d0: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13a5d4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13a5d8: 0xf87a0000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[26]));
    // 0x13a5dc: 0x8fa300d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13a5e0: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13a5e4: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13a5e8: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13a5ec: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13a5f0: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13a5f4: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13a5f8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13a5fc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13a600: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13a604: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x13a608: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x13a60c: 0xf8790000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[25]));
    // 0x13a610: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectBlipgTransformAccel__FP5BLIPGf
// Address: 0x13a618 - 0x13a6b8

void entry_13a6b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a6b8: 0x8fa40074
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x13a6bc: 0x24050840
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2112));
    // 0x13a6c0: 0x8fa20078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 120)));
    // 0x13a6c4: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a6c8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13a6cc: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a6d0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13a6d4: 0x60882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13a6d8: 0xafa20074
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 2));
    // 0x13a6dc: 0x8e231080
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4224)));
    // 0x13a6e0: 0x8e241084
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
    // 0x13a6e4: 0x651018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13a6e8: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x13a6ec: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13a6f0: 0x80402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13a6f4: 0x512821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x13a6f8: 0x24a702c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 704));
    // 0x13a6fc: 0xc07090c
    SET_GPR_U32(ctx, 31, 0x13a704);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 5), 1408));
    LoadSprBuf__Fie(rdram, ctx, runtime); return;
}


// Function: entry_13a704
// Address: 0x13a704 - 0x13a738

void entry_13a704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a704) {
        switch (ctx->pc) {
            case 0x13a728: ctx->pc = 0; goto label_13a728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a704: 0x12200057
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A864; return;
    }
    // 0x13a70c: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x13a710: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13a714: 0x241e0050
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 80));
    // 0x13a718: 0x246348f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 18672));
    // 0x13a71c: 0x24170840
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 2112));
    // 0x13a720: 0x24750008
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 3), 8));
    // 0x13a724: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
label_13a728:
    // 0x13a728: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a72c: 0x8ce41f24
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 7972)));
    // 0x13a730: 0xc080b0e
    SET_GPR_U32(ctx, 31, 0x13a738);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceDmaSync(rdram, ctx, runtime); return;
}


// Function: entry_13a738
// Address: 0x13a738 - 0x13a7a8

void entry_13a738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a738: 0x8ec34990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 18832)));
    // 0x13a73c: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x13a740: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13a744: 0x24e748f0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 18672));
    // 0x13a748: 0x431823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13a74c: 0xe00013
    ctx->lo = GPR_U32(ctx, 7);
    // 0x13a750: 0x707e2000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 30); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13a754: 0x8fa60074
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x13a758: 0x8fa20078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 120)));
    // 0x13a75c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x13a760: 0xaec34990
    WRITE32(ADD32(GPR_U32(ctx, 22), 18832), GPR_U32(ctx, 3));
    // 0x13a764: 0xac85004c
    WRITE32(ADD32(GPR_U32(ctx, 4), 76), GPR_U32(ctx, 5));
    // 0x13a768: 0x8cd30000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x13a76c: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x13a770: 0x1260000d
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        entry_13a7a8(rdram, ctx, runtime); return;
    }
    // 0x13a778: 0x8e621080
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4224)));
    // 0x13a77c: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a780: 0x8e641084
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13a784: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a788: 0x571818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13a78c: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x13a790: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13a794: 0x80402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13a798: 0x732821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x13a79c: 0x24a702c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 704));
    // 0x13a7a0: 0xc07090c
    SET_GPR_U32(ctx, 31, 0x13a7a8);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 5), 1408));
    LoadSprBuf__Fie(rdram, ctx, runtime); return;
}


// Function: entry_13a7a8
// Address: 0x13a7a8 - 0x13a7f8

void entry_13a7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a7a8: 0x8ec84990
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 22), 18832)));
    // 0x13a7ac: 0x27a20020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 32));
    // 0x13a7b0: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x13a7b4: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x13a7b8: 0x11e4018
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13a7bc: 0x70032ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x13a7c0: 0x8e8a0618
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 20), 1560)));
    // 0x13a7c4: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x13a7c8: 0x8e291084
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
    // 0x13a7cc: 0x27ab0010
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13a7d0: 0x7fa30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 3));
    // 0x13a7d4: 0x25030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 8), 8));
    // 0x13a7d8: 0x25020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 8), 4));
    // 0x13a7dc: 0x1154021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 21)));
    // 0x13a7e0: 0x751821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x13a7e4: 0x8d060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x13a7e8: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x13a7ec: 0x8c680000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13a7f0: 0xc04e926
    SET_GPR_U32(ctx, 31, 0x13a7f8);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    CblipeProjectBlipTransformAccel__FP7MATRIX4G8VU_FLOATP5BLIPPP5BLIPVP5BLIPXi6BLIPOKP6VECTORT7(rdram, ctx, runtime); return;
}


// Function: entry_13a7f8
// Address: 0x13a7f8 - 0x13a824

void entry_13a7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a7f8: 0x8e231080
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4224)));
    // 0x13a7fc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13a800: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13a804: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x13a808: 0x30720001
    SET_GPR_U32(ctx, 18, AND32(GPR_U32(ctx, 3), 1));
    // 0x13a80c: 0x2571018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13a810: 0x512821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x13a814: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x13a818: 0x248502c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 704));
    // 0x13a81c: 0xc07096c
    SET_GPR_U32(ctx, 31, 0x13a824);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1408));
    SaveSprBuf__FPve(rdram, ctx, runtime); return;
}


// Function: entry_13a824
// Address: 0x13a824 - 0x13a850

void entry_13a824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13a824: 0x8e221084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
    // 0x13a828: 0x501023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x13a82c: 0xae221084
    WRITE32(ADD32(GPR_U32(ctx, 17), 4228), GPR_U32(ctx, 2));
    // 0x13a830: 0x8e830620
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1568)));
    // 0x13a834: 0x701823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x13a838: 0xae830620
    WRITE32(ADD32(GPR_U32(ctx, 20), 1568), GPR_U32(ctx, 3));
    // 0x13a83c: 0x8e221084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
    // 0x13a840: 0x5c400005
    if (GPR_S32(ctx, 2) > 0) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 4224), GPR_U32(ctx, 18));
        ctx->pc = 0x13A858; return;
    }
    // 0x13a848: 0xc04e74a
    SET_GPR_U32(ctx, 31, 0x13a850);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveBlip__FP4BLIP(rdram, ctx, runtime); return;
}


// Function: entry_13a850
// Address: 0x13a850 - 0x13a880

void entry_13a850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a850) {
        switch (ctx->pc) {
            case 0x13a858: ctx->pc = 0; goto label_13a858;
            case 0x13a85c: ctx->pc = 0; goto label_13a85c;
            case 0x13a864: ctx->pc = 0; goto label_13a864;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a850: 0x10000002
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13a85c;
    }
label_13a858:
    // 0x13a858: 0x260882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_13a85c:
    // 0x13a85c: 0x1620ffb2
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A728; return;
    }
label_13a864:
    // 0x13a864: 0x8e820620
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1568)));
    // 0x13a868: 0x1c400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x13A888; return;
    }
    // 0x13a870: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x13a874: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x13a878: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13a880);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13a880
// Address: 0x13a880 - 0x13a8c4

void entry_13a880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a880) {
        switch (ctx->pc) {
            case 0x13a888: ctx->pc = 0; goto label_13a888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a880: 0x1000001f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 124)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13A900; return;
    }
label_13a888:
    // 0x13a888: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x13a88c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13a890: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13a894: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x13a898: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x13a89c: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13a8a0: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13a8a4: 0x4be209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13a8a8: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13a8ac: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x13a8b0: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13a8b4: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13a8b8: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x13a8bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13a8c4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13a8c4
// Address: 0x13a8c4 - 0x13a940

void entry_13a8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a8c4) {
        switch (ctx->pc) {
            case 0x13a900: ctx->pc = 0; goto label_13a900;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a8c4: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13a8c8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13a8cc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13a8d0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13a8d4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13a8d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13a8dc: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13a8e0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13a8e4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13a8e8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x13a8ec: 0x48270800
    SET_GPR_VEC(ctx, 7, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13a8f0: 0x44870000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 7);
    // 0x13a8f4: 0xe68002a4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 676), *(uint32_t*)&val); }
    // 0x13a8f8: 0xe68002a8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 680), *(uint32_t*)&val); }
    // 0x13a8fc: 0x8fa2007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 124)));
label_13a900:
    // 0x13a900: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x13a904: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x13a908: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x13a90c: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x13a910: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x13a914: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x13a918: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x13a91c: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13a920: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13a924: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13a928: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13a92c: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x13a930: 0xac62b314
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294947604), GPR_U32(ctx, 2));
    // 0x13a934: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13a93c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13a940; return;
}


// Function: ProjectBlipgTransform__FP5BLIPGfi
// Address: 0x13a940 - 0x13a988

void entry_13a988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13a988) {
        switch (ctx->pc) {
            case 0x13a990: ctx->pc = 0; goto label_13a990;
            case 0x13aa00: ctx->pc = 0; goto label_13aa00;
            case 0x13aa58: ctx->pc = 0; goto label_13aa58;
            case 0x13aa80: ctx->pc = 0; goto label_13aa80;
            case 0x13aa9c: ctx->pc = 0; goto label_13aa9c;
            case 0x13aac4: ctx->pc = 0; goto label_13aac4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13a988: 0x100000d2
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13ACD4; return;
    }
label_13a990:
    // 0x13a990: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13a994: 0x70001ca9
    SET_GPR_VEC(ctx, 3, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x13a998: 0xc4409d6c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294942060)); ctx->f[0] = *(float*)&val; }
    // 0x13a99c: 0x26840624
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 1572));
    // 0x13a9a0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13a9a4: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x13a9a8: 0xc4419d70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294942064)); ctx->f[1] = *(float*)&val; }
    // 0x13a9ac: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x13a9b0: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x13a9b4: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x13a9b8: 0xafa40024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 4));
    // 0x13a9bc: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x13a9c0: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x13a9c4: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x13a9c8: 0xe7a10018
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x13a9cc: 0xe7a10010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x13a9d0: 0xe7a10014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    // 0x13a9d4: 0xafa40020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 4));
    // 0x13a9d8: 0x8c65b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 4294947604)));
    // 0x13a9dc: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x13a9e0: 0xac66b314
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294947604), GPR_U32(ctx, 6));
    // 0x13a9e4: 0xafa5002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 5));
    // 0x13a9e8: 0x8e830624
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1572)));
    // 0x13a9ec: 0xafa20028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 2));
    // 0x13a9f0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13a9f4: 0x60982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13a9f8: 0x1260008c
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AC2C; return;
    }
label_13aa00:
    // 0x13aa00: 0x8e621080
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4224)));
    // 0x13aa04: 0x24040840
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2112));
    // 0x13aa08: 0x8e631084
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13aa0c: 0x682d
    SET_GPR_U64(ctx, 13, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13aa10: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13aa14: 0x602d
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13aa18: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x13aa1c: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13aa20: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x13aa24: 0xafa20050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 2));
    // 0x13aa28: 0x932821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x13aa2c: 0x24040840
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2112));
    // 0x13aa30: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13aa34: 0x934821
    SET_GPR_U32(ctx, 9, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x13aa38: 0x18600068
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x13ABDC; return;
    }
    // 0x13aa40: 0xa0f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x13aa44: 0x120b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x13aa48: 0x24b10580
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 5), 1408));
    // 0x13aa4c: 0x24b602c0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 5), 704));
    // 0x13aa50: 0x25300580
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 9), 1408));
    // 0x13aa54: 0x253502c0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 9), 704));
label_13aa58:
    // 0x13aa58: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13aa5c: 0xc62cfd4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4294966604)); ctx->f[12] = *(float*)&val; }
    // 0x13aa60: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x13aa64: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x13aa68: 0x46006036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13aa6c: 0x0
    // NOP
    // 0x13aa70: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 800)));
        goto label_13aa80;
    }
    // 0x13aa78: 0x10000050
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13ABBC; return;
    }
label_13aa80:
    // 0x13aa80: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13aa84: 0x10620005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_13aa9c;
    }
    // 0x13aa8c: 0x5064000d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4232)));
        goto label_13aac4;
    }
    // 0x13aa94: 0x10000029
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4294965900)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AB3C; return;
    }
label_13aa9c:
    // 0x13aa9c: 0xda21fd40
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 4294966592)));
    // 0x13aaa0: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x13aaa4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13aaa8: 0xfa01fd40
    WRITE128(ADD32(GPR_U32(ctx, 16), 4294966592), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13aaac: 0xda22fa80
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 4294965888)));
    // 0x13aab0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13aab4: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13aab8: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13aabc: 0x1000001d
    WRITE128(ADD32(GPR_U32(ctx, 16), 4294965888), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AB34; return;
    }
label_13aac4:
    // 0x13aac4: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x13aac8: 0xc9140
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 12), 5));
    // 0x13aacc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13aad0: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x13aad4: 0xd23021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 18)));
    // 0x13aad8: 0x7fab0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 11));
    // 0x13aadc: 0x7fac0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 12));
    // 0x13aae0: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x13aae4: 0x7fad0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 13));
    // 0x13aae8: 0x46146369
    ctx->f[13] = std::min(ctx->f[12], ctx->f[20]);
    // 0x13aaec: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x13aaf0: 0x24c70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 16));
    // 0x13aaf4: 0x2e0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x13aaf8: 0x2a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x13aafc: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x13ab04);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_13ab04
// Address: 0x13ab04 - 0x13ab7c

void entry_13ab04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ab04) {
        switch (ctx->pc) {
            case 0x13ab34: ctx->pc = 0; goto label_13ab34;
            case 0x13ab3c: ctx->pc = 0; goto label_13ab3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ab04: 0x7bac0070
    SET_GPR_VEC(ctx, 12, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13ab08: 0x7bad0080
    SET_GPR_VEC(ctx, 13, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13ab0c: 0x11ac0009
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 13) == GPR_U32(ctx, 12)) {
        goto label_13ab34;
    }
    // 0x13ab14: 0x8e631088
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4232)));
    // 0x13ab18: 0xd2140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 13), 5));
    // 0x13ab1c: 0x2432821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x13ab20: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13ab24: 0x78a20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x13ab28: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x13ab2c: 0x78a30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x13ab30: 0x7c830010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 3));
label_13ab34:
    // 0x13ab34: 0xc620fa8c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4294965900)); ctx->f[0] = *(float*)&val; }
    // 0x13ab38: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
label_13ab3c:
    // 0x13ab3c: 0xe600fa8c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4294965900), *(uint32_t*)&val); }
    // 0x13ab40: 0xc621fd4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4294966604)); ctx->f[1] = *(float*)&val; }
    // 0x13ab44: 0xe601fd4c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4294966604), *(uint32_t*)&val); }
    // 0x13ab48: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13ab4c: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x13ab50: 0x8e830618
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1560)));
    // 0x13ab54: 0x5464000e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294965888)));
        ctx->pc = 0x13AB90; return;
    }
    // 0x13ab5c: 0xc62c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    // 0x13ab60: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x13ab64: 0x46146302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    // 0x13ab68: 0x7fab0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 11));
    // 0x13ab6c: 0x7fac0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 12));
    // 0x13ab70: 0x7fad0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 13));
    // 0x13ab74: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x13ab7c);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_13ab7c
// Address: 0x13ab7c - 0x13ac04

void entry_13ab7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ab7c) {
        switch (ctx->pc) {
            case 0x13ab90: ctx->pc = 0; goto label_13ab90;
            case 0x13abbc: ctx->pc = 0; goto label_13abbc;
            case 0x13abdc: ctx->pc = 0; goto label_13abdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ab7c: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x13ab80: 0x7bad0080
    SET_GPR_VEC(ctx, 13, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13ab84: 0x7bac0070
    SET_GPR_VEC(ctx, 12, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13ab88: 0x7bab0060
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13ab8c: 0xda03fa80
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294965888)));
label_13ab90:
    // 0x13ab90: 0x26b50010
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
    // 0x13ab94: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ab98: 0x26f70010
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 16));
    // 0x13ab9c: 0x4bc3086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13aba0: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13aba4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13aba8: 0x25ad0001
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 13), 1));
    // 0x13abac: 0xda01fa80
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294965888)));
    // 0x13abb0: 0x4bc110ab
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13abb4: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x13abb8: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_13abbc:
    // 0x13abbc: 0x8e621084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13abc0: 0x258c0001
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 12), 1));
    // 0x13abc4: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x13abc8: 0x26d60010
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 16));
    // 0x13abcc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13abd0: 0x182102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 12), GPR_S32(ctx, 2)));
    // 0x13abd4: 0x1440ffa0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AA58; return;
    }
label_13abdc:
    // 0x13abdc: 0x8b1023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 11)));
    // 0x13abe0: 0xae621084
    WRITE32(ADD32(GPR_U32(ctx, 19), 4228), GPR_U32(ctx, 2));
    // 0x13abe4: 0x8e830620
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1568)));
    // 0x13abe8: 0x6b1823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 11)));
    // 0x13abec: 0xae830620
    WRITE32(ADD32(GPR_U32(ctx, 20), 1568), GPR_U32(ctx, 3));
    // 0x13abf0: 0x8e621084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13abf4: 0x1c400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x13AC0C; return;
    }
    // 0x13abfc: 0xc04e74a
    SET_GPR_U32(ctx, 31, 0x13ac04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RemoveBlip__FP4BLIP(rdram, ctx, runtime); return;
}


// Function: entry_13ac04
// Address: 0x13ac04 - 0x13ac48

void entry_13ac04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ac04) {
        switch (ctx->pc) {
            case 0x13ac0c: ctx->pc = 0; goto label_13ac0c;
            case 0x13ac14: ctx->pc = 0; goto label_13ac14;
            case 0x13ac2c: ctx->pc = 0; goto label_13ac2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ac04: 0x10000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13ac14;
    }
label_13ac0c:
    // 0x13ac0c: 0xae621080
    WRITE32(ADD32(GPR_U32(ctx, 19), 4224), GPR_U32(ctx, 2));
    // 0x13ac10: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
label_13ac14:
    // 0x13ac14: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x13ac18: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13ac1c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13ac20: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13ac24: 0x1660ff76
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AA00; return;
    }
label_13ac2c:
    // 0x13ac2c: 0x8e820620
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1568)));
    // 0x13ac30: 0x1c400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x13AC50; return;
    }
    // 0x13ac38: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x13ac3c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x13ac40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13ac48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13ac48
// Address: 0x13ac48 - 0x13ac8c

void entry_13ac48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ac48) {
        switch (ctx->pc) {
            case 0x13ac50: ctx->pc = 0; goto label_13ac50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ac48: 0x1000001f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13ACC8; return;
    }
label_13ac50:
    // 0x13ac50: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x13ac54: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13ac58: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ac5c: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x13ac60: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x13ac64: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13ac68: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ac6c: 0x4be209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13ac70: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13ac74: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x13ac78: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13ac7c: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13ac80: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x13ac84: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13ac8c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13ac8c
// Address: 0x13ac8c - 0x13ad08

void entry_13ac8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ac8c) {
        switch (ctx->pc) {
            case 0x13acc8: ctx->pc = 0; goto label_13acc8;
            case 0x13acd4: ctx->pc = 0; goto label_13acd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ac8c: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13ac90: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ac94: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13ac98: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13ac9c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13aca0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13aca4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13aca8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13acac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13acb0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x13acb4: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13acb8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x13acbc: 0xe68002a4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 676), *(uint32_t*)&val); }
    // 0x13acc0: 0xe68002a8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 680), *(uint32_t*)&val); }
    // 0x13acc4: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
label_13acc8:
    // 0x13acc8: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x13accc: 0xac62b314
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294947604), GPR_U32(ctx, 2));
    // 0x13acd0: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
label_13acd4:
    // 0x13acd4: 0x7bbe0110
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x13acd8: 0x7bb70100
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x13acdc: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x13ace0: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x13ace4: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13ace8: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13acec: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13acf0: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13acf4: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13acf8: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x13acfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13ad04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13ad08; return;
}


// Function: RenderBlipgSelf__FP5BLIPGP2CMP2RO
// Address: 0x13ad08 - 0x13ad30

void entry_13ad30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ad30) {
        switch (ctx->pc) {
            case 0x13ad58: ctx->pc = 0; goto label_13ad58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ad30: 0x3c030014
    SET_GPR_U32(ctx, 3, ((uint32_t)20 << 16));
    // 0x13ad34: 0x2402000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 15));
    // 0x13ad38: 0x2463ad80
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294946176));
    // 0x13ad3c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x13ad40: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x13ad44: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13ad48: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13ad4c: 0x12000002
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_13ad58;
    }
    // 0x13ad54: 0xc6000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[0] = *(float*)&val; }
label_13ad58:
    // 0x13ad58: 0xe7a00050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x13ad5c: 0xafb10060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 17));
    // 0x13ad60: 0xc067504
    SET_GPR_U32(ctx, 31, 0x13ad68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_13ad68
// Address: 0x13ad68 - 0x13ad80

void entry_13ad68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ad68: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13ad6c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13ad70: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13ad74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13ad7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13ad80; return;
}


// Function: DrawBlipg__FP3RPL
// Address: 0x13ad80 - 0x13adb4

void entry_13adb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13adb4: 0x8e110060
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x13adb8: 0x8e2402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x13adbc: 0x50800083
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x13AFCC; return;
    }
    // 0x13adc4: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x13adcc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 788));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_13adcc
// Address: 0x13adcc - 0x13ae14

void entry_13adcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13adcc: 0x5440007f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x13AFCC; return;
    }
    // 0x13add4: 0x8e2202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x13add8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x13addc: 0xafa000bc
    WRITE32(ADD32(GPR_U32(ctx, 29), 188), GPR_U32(ctx, 0));
    // 0x13ade0: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x13ade4: 0x24420314
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 788));
    // 0x13ade8: 0x8c86b314
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x13adec: 0xafa20050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 2));
    // 0x13adf0: 0xa0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x13adf4: 0xafa20054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 2));
    // 0x13adf8: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x13adfc: 0xafa6005c
    WRITE32(ADD32(GPR_U32(ctx, 29), 92), GPR_U32(ctx, 6));
    // 0x13ae00: 0xafa30058
    WRITE32(ADD32(GPR_U32(ctx, 29), 88), GPR_U32(ctx, 3));
    // 0x13ae04: 0xac85b314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 5));
    // 0x13ae08: 0x8e2402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x13ae0c: 0xc0549f6
    SET_GPR_U32(ctx, 31, 0x13ae14);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 788));
    CPvDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_13ae14
// Address: 0x13ae14 - 0x13ae20

void entry_13ae14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ae14: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x13ae18: 0xc063596
    SET_GPR_U32(ctx, 31, 0x13ae20);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_13ae20
// Address: 0x13ae20 - 0x13ae78

void entry_13ae20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ae20) {
        switch (ctx->pc) {
            case 0x13ae58: ctx->pc = 0; goto label_13ae58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ae20: 0xafa200b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 2));
    // 0x13ae24: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x13ae28: 0x8fa20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    // 0x13ae2c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13ae30: 0x8fb200b8
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    // 0x13ae34: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13ae38: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13ae3c: 0x1200005d
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AFB4; return;
    }
    // 0x13ae44: 0x4be00053
    // Unhandled VU0 Special1 function: 0x13
    // 0x13ae48: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13ae4c: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13ae50: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x13ae54: 0x245383d0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 4294935504));
label_13ae58:
    // 0x13ae58: 0x8e821990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    // 0x13ae5c: 0x8e030088
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 136)));
    // 0x13ae60: 0x8c44021c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 540)));
    // 0x13ae64: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x13ae68: 0x1464004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x13AF9C; return;
    }
    // 0x13ae70: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x13ae78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13ae78
// Address: 0x13ae78 - 0x13af74

void entry_13ae78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ae78) {
        switch (ctx->pc) {
            case 0x13aea4: ctx->pc = 0; goto label_13aea4;
            case 0x13aeb4: ctx->pc = 0; goto label_13aeb4;
            case 0x13aed0: ctx->pc = 0; goto label_13aed0;
            case 0x13aee4: ctx->pc = 0; goto label_13aee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ae78: 0x10400048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AF9C; return;
    }
    // 0x13ae80: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x13ae84: 0x8c42007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x13ae88: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
        goto label_13aea4;
    }
    // 0x13ae90: 0x78420140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x13ae94: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x13ae98: 0x8e0302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x13ae9c: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13aeb4;
    }
label_13aea4:
    // 0x13aea4: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x13aea8: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x13aeac: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
        goto label_13aed0;
    }
label_13aeb4:
    // 0x13aeb4: 0x78820110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 272)));
    // 0x13aeb8: 0x7fa20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    // 0x13aebc: 0x78830120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 288)));
    // 0x13aec0: 0x7fa30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 3));
    // 0x13aec4: 0x78820130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 304)));
    // 0x13aec8: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13aee4;
    }
label_13aed0:
    // 0x13aed0: 0x7a630010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x13aed4: 0x7a640020
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x13aed8: 0x7fa20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    // 0x13aedc: 0x7fa30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 3));
    // 0x13aee0: 0x7fa40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 4));
label_13aee4:
    // 0x13aee4: 0xc62c02a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 680)); ctx->f[12] = *(float*)&val; }
    // 0x13aee8: 0x8e841990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    // 0x13aeec: 0xda230100
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x13aef0: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x13aef4: 0xdba40070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13aef8: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13aefc: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13af00: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13af04: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x13af08: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13af0c: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13af10: 0xd8860040
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x13af14: 0xfba500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x13af18: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13af1c: 0x4be118e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13af20: 0x4be618ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13af24: 0xd8840050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 80)));
    // 0x13af28: 0xd8820060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 96)));
    // 0x13af2c: 0xd8810070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 112)));
    // 0x13af30: 0xdba600c0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13af34: 0x4be321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x13af38: 0x4be310bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13af3c: 0x4be308be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[3] = READ32(addr); }
    // 0x13af40: 0x4be530fc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x13af44: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13af48: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13af4c: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13af50: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13af54: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x13af58: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x13af5c: 0x1440000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AF9C; return;
    }
    // 0x13af64: 0xc60d0080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 128)); ctx->f[13] = *(float*)&val; }
    // 0x13af68: 0x48251800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13af6c: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x13af74);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 64));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_13af74
// Address: 0x13af74 - 0x13af8c

void entry_13af74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13af74: 0x10400008
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AF98; return;
    }
    // 0x13af7c: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x13af80: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x13af84: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x13af8c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 80));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_13af8c
// Address: 0x13af8c - 0x13b01c

void entry_13af8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13af8c) {
        switch (ctx->pc) {
            case 0x13af98: ctx->pc = 0; goto label_13af98;
            case 0x13af9c: ctx->pc = 0; goto label_13af9c;
            case 0x13afb4: ctx->pc = 0; goto label_13afb4;
            case 0x13afcc: ctx->pc = 0; goto label_13afcc;
            case 0x13b008: ctx->pc = 0; goto label_13b008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13af8c: 0x8fa200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    // 0x13af90: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x13af94: 0xafa200bc
    WRITE32(ADD32(GPR_U32(ctx, 29), 188), GPR_U32(ctx, 2));
label_13af98:
    // 0x13af98: 0x8fa20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
label_13af9c:
    // 0x13af9c: 0x8fa30058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    // 0x13afa0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13afa4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13afa8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13afac: 0x1600ffaa
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13AE58; return;
    }
label_13afb4:
    // 0x13afb4: 0x8fa300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    // 0x13afb8: 0x1060010b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_13b3e8(rdram, ctx, runtime); return;
    }
    // 0x13afc0: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x13afc4: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 6), 4294947604), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13b008;
    }
label_13afcc:
    // 0x13afcc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13afd0: 0xafbd00b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 29));
    // 0x13afd4: 0x24428400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935552));
    // 0x13afd8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13afdc: 0x27b50050
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 80));
    // 0x13afe0: 0x78460030
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x13afe4: 0xafa300bc
    WRITE32(ADD32(GPR_U32(ctx, 29), 188), GPR_U32(ctx, 3));
    // 0x13afe8: 0x78430020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x13afec: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13aff0: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x13aff4: 0x7fa50000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 5));
    // 0x13aff8: 0x7fa40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 4));
    // 0x13affc: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x13b000: 0x7fa60030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 6));
    // 0x13b004: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
label_13b008:
    // 0x13b008: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13b00c: 0xafa000d0
    WRITE32(ADD32(GPR_U32(ctx, 29), 208), GPR_U32(ctx, 0));
    // 0x13b010: 0x80b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13b014: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x13b01c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8872));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_13b01c
// Address: 0x13b01c - 0x13b060

void entry_13b01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b01c) {
        switch (ctx->pc) {
            case 0x13b058: ctx->pc = 0; goto label_13b058;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b01c: 0x26220624
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1572));
    // 0x13b020: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x13b024: 0xafa20054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 2));
    // 0x13b028: 0xafa20050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 2));
    // 0x13b02c: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x13b030: 0xafa30058
    WRITE32(ADD32(GPR_U32(ctx, 29), 88), GPR_U32(ctx, 3));
    // 0x13b034: 0x8c82b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x13b038: 0xafa2005c
    WRITE32(ADD32(GPR_U32(ctx, 29), 92), GPR_U32(ctx, 2));
    // 0x13b03c: 0xac95b314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 21));
    // 0x13b040: 0x8e220624
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1572)));
    // 0x13b044: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13b048: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13b04c: 0x126000e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B3E0; return;
    }
    // 0x13b054: 0x0
    // NOP
label_13b058:
    // 0x13b058: 0xc059996
    SET_GPR_U32(ctx, 31, 0x13b060);
    RotateVu1Buffer__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13b060
// Address: 0x13b060 - 0x13b098

void entry_13b060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b060: 0x8fa600d0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13b064: 0x8fa200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13b068: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x13b06c: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x13b070: 0x10400066
    WRITE32(ADD32(GPR_U32(ctx, 29), 208), GPR_U32(ctx, 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13b20c(rdram, ctx, runtime); return;
    }
    // 0x13b078: 0x26f022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 23), 8872));
    // 0x13b07c: 0x27a900b0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 176));
    // 0x13b080: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13b084: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b088: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b08c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b090: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x13b098);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 5));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_13b098
// Address: 0x13b098 - 0x13b0f4

void entry_13b098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b098: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13b09c: 0x8fa800b0
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13b0a0: 0x8c6a1990
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    // 0x13b0a4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13b0a8: 0x24521858
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x13b0ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b0b0: 0xc54000c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 10), 192)); ctx->f[0] = *(float*)&val; }
    // 0x13b0b4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b0b8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b0bc: 0x24070006
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 6));
    // 0x13b0c0: 0xe5000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 8), 0), *(uint32_t*)&val); }
    // 0x13b0c4: 0x27a900b4
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 180));
    // 0x13b0c8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13b0cc: 0xc54000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 10), 212)); ctx->f[0] = *(float*)&val; }
    // 0x13b0d0: 0x8fa200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13b0d4: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x13b0d8: 0x8fa300b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13b0dc: 0xc620061c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1564)); ctx->f[0] = *(float*)&val; }
    // 0x13b0e0: 0xe4600008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 8), *(uint32_t*)&val); }
    // 0x13b0e4: 0x8fa200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13b0e8: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x13b0ec: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x13b0f4);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_13b0f4
// Address: 0x13b0f4 - 0x13b154

void entry_13b0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b0f4) {
        switch (ctx->pc) {
            case 0x13b114: ctx->pc = 0; goto label_13b114;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b0f4: 0x8fa200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x13b0f8: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x13b0fc: 0x8e230614
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1556)));
    // 0x13b100: 0x10600004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_13b114;
    }
    // 0x13b108: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13b10c: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x13b110: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_13b114:
    // 0x13b114: 0x8fa600b4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x13b118: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x13b11c: 0x8e220590
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1424)));
    // 0x13b120: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b124: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x13b128: 0x26270594
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 1428));
    // 0x13b12c: 0xacc20004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 2));
    // 0x13b130: 0x8fa300b4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x13b134: 0x8e220384
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 900)));
    // 0x13b138: 0xac620008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 2));
    // 0x13b13c: 0x8fa200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x13b140: 0xc6400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[0] = *(float*)&val; }
    // 0x13b144: 0xe440000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x13b148: 0x8e260590
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1424)));
    // 0x13b14c: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b154);
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 8), GPR_U32(ctx, 6)));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b154
// Address: 0x13b154 - 0x13b16c

void entry_13b154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b154: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b158: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x13b15c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b160: 0x262702f0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 752));
    // 0x13b164: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b16c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b16c
// Address: 0x13b16c - 0x13b184

void entry_13b16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b16c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b170: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x13b174: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b178: 0x262702e0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 736));
    // 0x13b17c: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b184);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b184
// Address: 0x13b184 - 0x13b19c

void entry_13b184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b184: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b188: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x13b18c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b190: 0x26270300
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 768));
    // 0x13b194: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b19c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b19c
// Address: 0x13b19c - 0x13b1b4

void entry_13b19c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b19c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b1a0: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x13b1a4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b1a8: 0x26270310
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 784));
    // 0x13b1ac: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b1b4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b1b4
// Address: 0x13b1b4 - 0x13b1f0

void entry_13b1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b1b4) {
        switch (ctx->pc) {
            case 0x13b1d4: ctx->pc = 0; goto label_13b1d4;
            case 0x13b1dc: ctx->pc = 0; goto label_13b1dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b1b4: 0x8e230380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 896)));
    // 0x13b1b8: 0x90620001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 1)));
    // 0x13b1bc: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x13b1c0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x13b1c4: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13b1d4;
    }
    // 0x13b1cc: 0x10000003
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 4884)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13b1dc;
    }
label_13b1d4:
    // 0x13b1d4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13b1d8: 0x8c471318
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 4888)));
label_13b1dc:
    // 0x13b1dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b1e0: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b1e4: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13b1e8: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b1f0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b1f0
// Address: 0x13b1f0 - 0x13b20c

void entry_13b1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b1f0: 0x8e260384
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 900)));
    // 0x13b1f4: 0x26e422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
    // 0x13b1f8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b1fc: 0x26270390
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 912));
    // 0x13b200: 0x2408000f
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 15));
    // 0x13b204: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x13b20c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_13b20c
// Address: 0x13b20c - 0x13b25c

void entry_13b20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b20c: 0x8e651080
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 4224)));
    // 0x13b210: 0x24020034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    // 0x13b214: 0xa7a20060
    WRITE16(ADD32(GPR_U32(ctx, 29), 96), (uint16_t)GPR_U32(ctx, 2));
    // 0x13b218: 0x2407000a
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 10));
    // 0x13b21c: 0x24020840
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2112));
    // 0x13b220: 0x26e422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
    // 0x13b224: 0x8e631084
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13b228: 0xa23018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13b22c: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    // 0x13b230: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13b234: 0x671818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13b238: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13b23c: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x13b240: 0xd3a821
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 19)));
    // 0x13b244: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b248: 0x24630034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 52));
    // 0x13b24c: 0xa7a30062
    WRITE16(ADD32(GPR_U32(ctx, 29), 98), (uint16_t)GPR_U32(ctx, 3));
    // 0x13b250: 0x96621084
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13b254: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b25c);
    WRITE16(ADD32(GPR_U32(ctx, 29), 100), (uint16_t)GPR_U32(ctx, 2));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b25c
// Address: 0x13b25c - 0x13b290

void entry_13b25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b25c) {
        switch (ctx->pc) {
            case 0x13b278: ctx->pc = 0; goto label_13b278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b25c: 0x8fa200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    // 0x13b260: 0x18400058
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13B3C4; return;
    }
    // 0x13b268: 0x8fb200b8
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    // 0x13b26c: 0x24160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b270: 0x245022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 8872));
    // 0x13b274: 0x3c1e0000
    SET_GPR_U32(ctx, 30, ((uint32_t)0 << 16));
label_13b278:
    // 0x13b278: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b27c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b280: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13b284: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13b288: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b290);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 7));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b290
// Address: 0x13b290 - 0x13b2b0

void entry_13b290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b290: 0xc6400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 64)); ctx->f[0] = *(float*)&val; }
    // 0x13b294: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b298: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b29c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b2a0: 0xe7a00070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x13b2a4: 0x27a70070
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 112));
    // 0x13b2a8: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x13b2b0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 11));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_13b2b0
// Address: 0x13b2b0 - 0x13b2c0

void entry_13b2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b2b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b2b4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b2b8: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x13b2c0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 10));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_13b2c0
// Address: 0x13b2c0 - 0x13b2e8

void entry_13b2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b2c0: 0x8e220618
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1560)));
    // 0x13b2c4: 0x14560009
    SET_GPR_U32(ctx, 8, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 22)) {
        ctx->pc = 0x13B2EC; return;
    }
    // 0x13b2cc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b2d0: 0x8e661084
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13b2d4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b2d8: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x13b2dc: 0x26a702c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 704));
    // 0x13b2e0: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x13b2e8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_13b2e8
// Address: 0x13b2e8 - 0x13b308

void entry_13b2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b2e8) {
        switch (ctx->pc) {
            case 0x13b2ec: ctx->pc = 0; goto label_13b2ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b2e8: 0x97a80060
    SET_GPR_U32(ctx, 8, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 96)));
label_13b2ec:
    // 0x13b2ec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b2f0: 0x8e661084
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13b2f4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b2f8: 0x25080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 2));
    // 0x13b2fc: 0x26a70580
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 1408));
    // 0x13b300: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x13b308);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_13b308
// Address: 0x13b308 - 0x13b328

void entry_13b308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b308: 0x97a80060
    SET_GPR_U32(ctx, 8, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13b30c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b310: 0x8e661084
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4228)));
    // 0x13b314: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13b318: 0x25080003
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 3));
    // 0x13b31c: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x13b320: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x13b328);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_13b328
// Address: 0x13b328 - 0x13b338

void entry_13b328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b328: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b32c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b330: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x13b338);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_13b338
// Address: 0x13b338 - 0x13b37c

void entry_13b338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b338) {
        switch (ctx->pc) {
            case 0x13b35c: ctx->pc = 0; goto label_13b35c;
            case 0x13b36c: ctx->pc = 0; goto label_13b36c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b338: 0x8e230618
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1560)));
    // 0x13b33c: 0x10760011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 22)) {
        ctx->pc = 0x13B384; return;
    }
    // 0x13b344: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13b35c;
    }
    // 0x13b34c: 0x10600007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_13b36c;
    }
    // 0x13b354: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B3AC; return;
    }
label_13b35c:
    // 0x13b35c: 0x1064000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x13B39C; return;
    }
    // 0x13b364: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B3AC; return;
    }
label_13b36c:
    // 0x13b36c: 0x3c060000
    SET_GPR_U32(ctx, 6, ((uint32_t)0 << 16));
    // 0x13b370: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b374: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x13b37c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 0));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_13b37c
// Address: 0x13b37c - 0x13b394

void entry_13b37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b37c) {
        switch (ctx->pc) {
            case 0x13b384: ctx->pc = 0; goto label_13b384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b37c: 0x1000000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B3AC; return;
    }
label_13b384:
    // 0x13b384: 0x3c020000
    SET_GPR_U32(ctx, 2, ((uint32_t)0 << 16));
    // 0x13b388: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b38c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x13b394);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 920));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_13b394
// Address: 0x13b394 - 0x13b3a8

void entry_13b394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b394) {
        switch (ctx->pc) {
            case 0x13b39c: ctx->pc = 0; goto label_13b39c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b394: 0x10000005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B3AC; return;
    }
label_13b39c:
    // 0x13b39c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b3a0: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x13b3a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 2176));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_13b3a8
// Address: 0x13b3a8 - 0x13b3b4

void entry_13b3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b3a8) {
        switch (ctx->pc) {
            case 0x13b3ac: ctx->pc = 0; goto label_13b3ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b3a8: 0x26e422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
label_13b3ac:
    // 0x13b3ac: 0xc07b914
    SET_GPR_U32(ctx, 31, 0x13b3b4);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    AddVifFlush__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_13b3b4
// Address: 0x13b3b4 - 0x13b3e8

void entry_13b3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b3b4) {
        switch (ctx->pc) {
            case 0x13b3c4: ctx->pc = 0; goto label_13b3c4;
            case 0x13b3e0: ctx->pc = 0; goto label_13b3e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b3b4: 0x8fa300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    // 0x13b3b8: 0x283102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 3)));
    // 0x13b3bc: 0x1440ffae
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B278; return;
    }
label_13b3c4:
    // 0x13b3c4: 0x8fa20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x13b3c8: 0x8fa30058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    // 0x13b3cc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13b3d0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13b3d4: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13b3d8: 0x1660ff1f
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B058; return;
    }
label_13b3e0:
    // 0x13b3e0: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x13b3e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8872));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_13b3e8
// Address: 0x13b3e8 - 0x13b3f0

void entry_13b3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b3e8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x13b3f0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13b3f0
// Address: 0x13b3f0 - 0x13b430

void entry_13b3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b3f0: 0x8fa2005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    // 0x13b3f4: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x13b3f8: 0xac82b314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 2));
    // 0x13b3fc: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x13b400: 0x7bbe0160
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x13b404: 0x7bb70150
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x13b408: 0x7bb60140
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x13b40c: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x13b410: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x13b414: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x13b418: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x13b41c: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x13b420: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x13b424: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13b42c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13b430; return;
}


// Function: PropagateBlipgShaders__Fi
// Address: 0x13b430 - 0x13b498

void entry_13b498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b498) {
        switch (ctx->pc) {
            case 0x13b49c: ctx->pc = 0; goto label_13b49c;
            case 0x13b4a4: ctx->pc = 0; goto label_13b4a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b498: 0x8e100630
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1584)));
label_13b49c:
    // 0x13b49c: 0x5600fff2
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 896)));
        ctx->pc = 0x13B468; return;
    }
label_13b4a4:
    // 0x13b4a4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13b4a8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13b4ac: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13b4b0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13b4b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13b4bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13b4c0; return;
}


// Function: InitBomb__FP4BOMB
// Address: 0x13b4c0 - 0x13b4d4

void entry_13b4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b4d4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13b4d8: 0x3c014348
    SET_GPR_U32(ctx, 1, ((uint32_t)17224 << 16));
    // 0x13b4dc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13b4e0: 0xc4409d74
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294942068)); ctx->f[0] = *(float*)&val; }
    // 0x13b4e4: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x13b4e8: 0xe6010560
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1376), *(uint32_t*)&val); }
    // 0x13b4ec: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13b4f0: 0xe6000554
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1364), *(uint32_t*)&val); }
    // 0x13b4f4: 0x24841330
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4912));
    // 0x13b4f8: 0xe601055c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1372), *(uint32_t*)&val); }
    // 0x13b4fc: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x13b500: 0xae000550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 0));
    // 0x13b504: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13b508: 0x3c014448
    SET_GPR_U32(ctx, 1, ((uint32_t)17480 << 16));
    // 0x13b50c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13b510: 0x24631340
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4928));
    // 0x13b514: 0x3c01459c
    SET_GPR_U32(ctx, 1, ((uint32_t)17820 << 16));
    // 0x13b518: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x13b51c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13b520: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x13b524: 0x24ea1320
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 7), 4896));
    // 0x13b528: 0x69420007
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x13b52c: 0x6d420000
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x13b530: 0xb2020573
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1395); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13b534: 0xb602056c
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1388); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13b538: 0xe6010568
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1384), *(uint32_t*)&val); }
    // 0x13b53c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b540: 0xe6000574
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1396), *(uint32_t*)&val); }
    // 0x13b544: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13b548: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13b54c: 0x7e0205d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 1488), GPR_VEC(ctx, 2));
    // 0x13b550: 0x25091350
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 8), 4944));
    // 0x13b554: 0x69220007
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x13b558: 0x6d220000
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x13b55c: 0xb20205e7
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1511); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13b560: 0xb60205e0
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1504); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13b564: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13b568: 0x7e0205f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 1520), GPR_VEC(ctx, 2));
    // 0x13b56c: 0x24c41358
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 4952));
    // 0x13b570: 0x688a0007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x13b574: 0x6c8a0000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x13b578: 0xb20a0607
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1543); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13b57c: 0xb60a0600
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1536); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13b580: 0xae050678
    WRITE32(ADD32(GPR_U32(ctx, 16), 1656), GPR_U32(ctx, 5));
    // 0x13b584: 0xae00067c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1660), GPR_U32(ctx, 0));
    // 0x13b588: 0xae050674
    WRITE32(ADD32(GPR_U32(ctx, 16), 1652), GPR_U32(ctx, 5));
    // 0x13b58c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13b590: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadBombFromBrx__FP4BOMBP18CBinaryInputStream
// Address: 0x13b598 - 0x13b5ac

void entry_13b5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b5ac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b5b0: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x13b5b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1468));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13b5b8
// Address: 0x13b5b8 - 0x13b5c8

void entry_13b5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b5b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13b5bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13b5c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneBomb__FP4BOMBT0
// Address: 0x13b5c8 - 0x13b5e4

void entry_13b5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b5e4: 0x8e050680
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x13b5e8: 0x10a00005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B600; return;
    }
    // 0x13b5f0: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x13b5f8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 36));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_13b5f8
// Address: 0x13b5f8 - 0x13b610

void entry_13b5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b5f8) {
        switch (ctx->pc) {
            case 0x13b600: ctx->pc = 0; goto label_13b600;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b5f8: 0xae220680
    WRITE32(ADD32(GPR_U32(ctx, 17), 1664), GPR_U32(ctx, 2));
    // 0x13b5fc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_13b600:
    // 0x13b600: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13b604: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13b608: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostBombLoad__FP4BOMB
// Address: 0x13b610 - 0x13b630

void entry_13b630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b630) {
        switch (ctx->pc) {
            case 0x13b670: ctx->pc = 0; goto label_13b670;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b630: 0x26230034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 52));
    // 0x13b634: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x13b638: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x13b63c: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13b640: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x13b644: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x13b648: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13b64c: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x13b650: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x13b654: 0x8e230034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x13b658: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x13b65c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13b660: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13b664: 0x12000018
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B6C8; return;
    }
    // 0x13b66c: 0x2632057c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1404));
label_13b670:
    // 0x13b670: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b674: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13b67c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 39));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13b67c
// Address: 0x13b67c - 0x13b6ac

void entry_13b67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b67c: 0x1040000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B6B0; return;
    }
    // 0x13b684: 0x8e230578
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
    // 0x13b688: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x13b68c: 0x10400007
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13b6ac(rdram, ctx, runtime); return;
    }
    // 0x13b694: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13b698: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x13b69c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x13b6a0: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x13b6a4: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x13b6ac);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1400), GPR_U32(ctx, 3));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13b6ac
// Address: 0x13b6ac - 0x13b6dc

void entry_13b6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b6ac) {
        switch (ctx->pc) {
            case 0x13b6b0: ctx->pc = 0; goto label_13b6b0;
            case 0x13b6c8: ctx->pc = 0; goto label_13b6c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b6ac: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_13b6b0:
    // 0x13b6b0: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x13b6b4: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13b6b8: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13b6bc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13b6c0: 0x1600ffeb
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B670; return;
    }
label_13b6c8:
    // 0x13b6c8: 0x8e220684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1668)));
    // 0x13b6cc: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B6E4; return;
    }
    // 0x13b6d4: 0xc063540
    SET_GPR_U32(ctx, 31, 0x13b6dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_13b6dc
// Address: 0x13b6dc - 0x13b708

void entry_13b6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b6dc) {
        switch (ctx->pc) {
            case 0x13b6e4: ctx->pc = 0; goto label_13b6e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b6dc: 0xae22068c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1676), GPR_U32(ctx, 2));
    // 0x13b6e0: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_13b6e4:
    // 0x13b6e4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13b6e8: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x13b6ec: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13b6f0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13b6f4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13b6f8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13b6fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13b704: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13b708; return;
}


// Function: HandleBombMessage__FP4BOMB5MSGIDPv
// Address: 0x13b708 - 0x13b72c

void entry_13b72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b72c: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x13b730: 0x1602000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x13B760; return;
    }
    // 0x13b738: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x13b73c: 0x14920009
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x13B764; return;
    }
    // 0x13b744: 0x8c820550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1360)));
    // 0x13b748: 0x14400007
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B768; return;
    }
    // 0x13b750: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x13b754: 0xc04ef80
    SET_GPR_U32(ctx, 31, 0x13b75c);
    PrimeBomb__FP4BOMBf(rdram, ctx, runtime); return;
}


// Function: entry_13b75c
// Address: 0x13b75c - 0x13b778

void entry_13b75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b75c) {
        switch (ctx->pc) {
            case 0x13b760: ctx->pc = 0; goto label_13b760;
            case 0x13b764: ctx->pc = 0; goto label_13b764;
            case 0x13b768: ctx->pc = 0; goto label_13b768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b75c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_13b760:
    // 0x13b760: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_13b764:
    // 0x13b764: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13b768:
    // 0x13b768: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13b76c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13b774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13b778; return;
}


// Function: UpdateBomb__FP4BOMBf
// Address: 0x13b778 - 0x13b7f0

void entry_13b7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b7f0) {
        switch (ctx->pc) {
            case 0x13b7f8: ctx->pc = 0; goto label_13b7f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b7f0: 0x10000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B818; return;
    }
label_13b7f8:
    // 0x13b7f8: 0xc06e4fe
    SET_GPR_U32(ctx, 31, 0x13b800);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSo__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_13b800
// Address: 0x13b800 - 0x13b814

void entry_13b800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b800: 0x8e020684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1668)));
    // 0x13b804: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B818; return;
    }
    // 0x13b80c: 0xc04ee0a
    SET_GPR_U32(ctx, 31, 0x13b814);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0013b828(rdram, ctx, runtime); return;
}


// Function: entry_13b814
// Address: 0x13b814 - 0x13b828

void entry_13b814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b814) {
        switch (ctx->pc) {
            case 0x13b818: ctx->pc = 0; goto label_13b818;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b814: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13b818:
    // 0x13b818: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13b81c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13b824: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13b828; return;
}


// Function: FUN_0013b828
// Address: 0x13b828 - 0x13b884

void FUN_0013b828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b828) {
        switch (ctx->pc) {
            case 0x13b858: ctx->pc = 0; goto label_13b858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b828: 0x27bdff10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967056));
    // 0x13b82c: 0x7fb200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 18));
    // 0x13b830: 0x7fb00090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 16));
    // 0x13b834: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13b838: 0x7fbf00e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 31));
    // 0x13b83c: 0x7fb400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 20));
    // 0x13b840: 0x7fb300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 19));
    // 0x13b844: 0x7fb100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 17));
    // 0x13b848: 0x8e420688
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1672)));
    // 0x13b84c: 0x18400012
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13B898; return;
    }
    // 0x13b854: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13b858:
    // 0x13b858: 0x8e42068c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1676)));
    // 0x13b85c: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x13b860: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x13b864: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x13b868: 0x10400006
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13b884(rdram, ctx, runtime); return;
    }
    // 0x13b870: 0x8c460480
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 1152)));
    // 0x13b874: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x13b878: 0x24080040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 64));
    // 0x13b87c: 0xc04e168
    SET_GPR_U32(ctx, 31, 0x13b884);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1152)));
    UpdateSwPox__FP2SWP3OXAT1UcUc(rdram, ctx, runtime); return;
}


// Function: entry_13b884
// Address: 0x13b884 - 0x13b90c

void entry_13b884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b884) {
        switch (ctx->pc) {
            case 0x13b898: ctx->pc = 0; goto label_13b898;
            case 0x13b8b8: ctx->pc = 0; goto label_13b8b8;
            case 0x13b8e0: ctx->pc = 0; goto label_13b8e0;
            case 0x13b8ec: ctx->pc = 0; goto label_13b8ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b884: 0x8e420688
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1672)));
    // 0x13b888: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x13b88c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x13b890: 0x1440fff1
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 48));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B858; return;
    }
label_13b898:
    // 0x13b898: 0xae400688
    WRITE32(ADD32(GPR_U32(ctx, 18), 1672), GPR_U32(ctx, 0));
    // 0x13b89c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x13b8a0: 0x8c5158d0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 22736)));
    // 0x13b8a4: 0x12200044
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B9B8; return;
    }
    // 0x13b8ac: 0x24140030
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 48));
    // 0x13b8b0: 0x8e220090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 144)));
    // 0x13b8b4: 0x0
    // NOP
label_13b8b8:
    // 0x13b8b8: 0x5040003d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 128)));
        ctx->pc = 0x13B9B0; return;
    }
    // 0x13b8c0: 0x8e220088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 136)));
    // 0x13b8c4: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x13b8c8: 0x50400039
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 128)));
        ctx->pc = 0x13B9B0; return;
    }
    // 0x13b8d0: 0x12200036
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B9AC; return;
    }
    // 0x13b8d8: 0x10000004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13b8ec;
    }
label_13b8e0:
    // 0x13b8e0: 0x52000033
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 128)));
        ctx->pc = 0x13B9B0; return;
    }
    // 0x13b8e8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_13b8ec:
    // 0x13b8ec: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13b8f0: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x13b8f4: 0x5040fffa
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        goto label_13b8e0;
    }
    // 0x13b8fc: 0x5200002c
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 128)));
        ctx->pc = 0x13B9B0; return;
    }
    // 0x13b904: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x13b90c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13b90c
// Address: 0x13b90c - 0x13b91c

void entry_13b90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b90c: 0x10400027
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B9AC; return;
    }
    // 0x13b914: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x13b91c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_13b91c
// Address: 0x13b91c - 0x13b938

void entry_13b91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b91c: 0xc62c008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 140)); ctx->f[12] = *(float*)&val; }
    // 0x13b920: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13b924: 0x26450370
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 880));
    // 0x13b928: 0x26460140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 320));
    // 0x13b92c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13b930: 0xc0507d2
    SET_GPR_U32(ctx, 31, 0x13b938);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_13b938
// Address: 0x13b938 - 0x13b958

void entry_13b938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13b938: 0x1040001c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13B9AC; return;
    }
    // 0x13b940: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x13b944: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x13b948: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13b94c: 0x8c460480
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 1152)));
    // 0x13b950: 0xc04e168
    SET_GPR_U32(ctx, 31, 0x13b958);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1152)));
    UpdateSwPox__FP2SWP3OXAT1UcUc(rdram, ctx, runtime); return;
}


// Function: entry_13b958
// Address: 0x13b958 - 0x13b9d8

void entry_13b958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b958) {
        switch (ctx->pc) {
            case 0x13b9ac: ctx->pc = 0; goto label_13b9ac;
            case 0x13b9b0: ctx->pc = 0; goto label_13b9b0;
            case 0x13b9b8: ctx->pc = 0; goto label_13b9b8;
            case 0x13b9bc: ctx->pc = 0; goto label_13b9bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b958: 0x8e420688
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1672)));
    // 0x13b95c: 0x8e43068c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1676)));
    // 0x13b960: 0x542018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13b964: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x13b968: 0xae420688
    WRITE32(ADD32(GPR_U32(ctx, 18), 1672), GPR_U32(ctx, 2));
    // 0x13b96c: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x13b970: 0xac700024
    WRITE32(ADD32(GPR_U32(ctx, 3), 36), GPR_U32(ctx, 16));
    // 0x13b974: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13b978: 0xf8620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13b97c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13b980: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13b984: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13b988: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13b98c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13b990: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13b994: 0xf8610010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13b998: 0xac620020
    WRITE32(ADD32(GPR_U32(ctx, 3), 32), GPR_U32(ctx, 2));
    // 0x13b99c: 0x8e420688
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1672)));
    // 0x13b9a0: 0x28420004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 4));
    // 0x13b9a4: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13b9bc;
    }
label_13b9ac:
    // 0x13b9ac: 0x8e310080
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 128)));
label_13b9b0:
    // 0x13b9b0: 0x5620ffc1
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 144)));
        ctx->pc = 0x13B8B8; return;
    }
label_13b9b8:
    // 0x13b9b8: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_13b9bc:
    // 0x13b9bc: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13b9c0: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13b9c4: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13b9c8: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13b9cc: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13b9d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0013b9d8
// Address: 0x13b9d8 - 0x13ba60

void FUN_0013b9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13b9d8) {
        switch (ctx->pc) {
            case 0x13ba18: ctx->pc = 0; goto label_13ba18;
            case 0x13ba30: ctx->pc = 0; goto label_13ba30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13b9d8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x13b9dc: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x13b9e0: 0x8c820684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1668)));
    // 0x13b9e4: 0x1040001f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BA64; return;
    }
    // 0x13b9ec: 0x8c820688
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1672)));
    // 0x13b9f0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13b9f4: 0x1840001b
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13BA64; return;
    }
    // 0x13b9fc: 0x8c83068c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1676)));
    // 0x13ba00: 0x8c620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 36)));
    // 0x13ba04: 0x1045000a
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_13ba30;
    }
    // 0x13ba0c: 0x100302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x13ba10: 0x25430024
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 10), 36));
    // 0x13ba14: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
label_13ba18:
    // 0x13ba18: 0xe6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 6)));
    // 0x13ba1c: 0x10400010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13ba60(rdram, ctx, runtime); return;
    }
    // 0x13ba24: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13ba28: 0x5445fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
        goto label_13ba18;
    }
label_13ba30:
    // 0x13ba30: 0xe8102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 8)));
    // 0x13ba34: 0x1040000a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13ba60(rdram, ctx, runtime); return;
    }
    // 0x13ba3c: 0x120582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x13ba40: 0xe61018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13ba44: 0x24080009
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 9));
    // 0x13ba48: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13ba4c: 0x4a3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x13ba50: 0xc4cc0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 32)); ctx->f[12] = *(float*)&val; }
    // 0x13ba54: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13ba58: 0xc061748
    SET_GPR_U32(ctx, 31, 0x13ba60);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 16));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_13ba60
// Address: 0x13ba60 - 0x13ba70

void entry_13ba60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ba60) {
        switch (ctx->pc) {
            case 0x13ba64: ctx->pc = 0; goto label_13ba64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ba60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_13ba64:
    // 0x13ba64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13ba6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13ba70; return;
}


// Function: FUN_0013ba70
// Address: 0x13ba70 - 0x13baec

void FUN_0013ba70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ba70) {
        switch (ctx->pc) {
            case 0x13badc: ctx->pc = 0; goto label_13badc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ba70: 0x27bdff10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967056));
    // 0x13ba74: 0x7fb200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 18));
    // 0x13ba78: 0x7fb100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 17));
    // 0x13ba7c: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x13ba80: 0x7fb000a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 16));
    // 0x13ba84: 0x7fbf00e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 31));
    // 0x13ba88: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13ba8c: 0x7fb300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 19));
    // 0x13ba90: 0x8e02060c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1548)));
    // 0x13ba94: 0x1440003a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_13bb80(rdram, ctx, runtime); return;
    }
    // 0x13ba9c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13baa0: 0x7a030140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x13baa4: 0x921023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x13baa8: 0x8e050550
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x13baac: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x13bab0: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x13bab4: 0x2224021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x13bab8: 0x10a40031
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 8), 4)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 4)) {
        entry_13bb80(rdram, ctx, runtime); return;
    }
    // 0x13bac0: 0x28a20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    // 0x13bac4: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_13badc;
    }
    // 0x13bacc: 0x10a0000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BB0C; return;
    }
    // 0x13bad4: 0x1000002c
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BB88; return;
    }
label_13badc:
    // 0x13badc: 0x14a20029
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x13BB84; return;
    }
    // 0x13bae4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x13baec);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13baec
// Address: 0x13baec - 0x13bafc

void entry_13baec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13baec: 0x10400024
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13bb80(rdram, ctx, runtime); return;
    }
    // 0x13baf4: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x13bafc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13bafc
// Address: 0x13bafc - 0x13bb28

void entry_13bafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bafc) {
        switch (ctx->pc) {
            case 0x13bb0c: ctx->pc = 0; goto label_13bb0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bafc: 0x1440000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BB34; return;
    }
    // 0x13bb04: 0x10000020
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BB88; return;
    }
label_13bb0c:
    // 0x13bb0c: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x13bb10: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13bb14: 0x26050370
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 880));
    // 0x13bb18: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x13bb1c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13bb20: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x13bb28);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_13bb28
// Address: 0x13bb28 - 0x13bb74

void entry_13bb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bb28) {
        switch (ctx->pc) {
            case 0x13bb34: ctx->pc = 0; goto label_13bb34;
            case 0x13bb44: ctx->pc = 0; goto label_13bb44;
            case 0x13bb5c: ctx->pc = 0; goto label_13bb5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bb28: 0x10400002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13bb34;
    }
    // 0x13bb30: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
label_13bb34:
    // 0x13bb34: 0x56400003
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 128)));
        goto label_13bb44;
    }
    // 0x13bb3c: 0x10000007
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13bb5c;
    }
label_13bb44:
    // 0x13bb44: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x13bb48: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13bb4c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13bb50: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13bb54: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13bb58: 0x4be11058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
label_13bb5c:
    // 0x13bb5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13bb60: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13bb64: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13bb68: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13bb6c: 0xc04ef20
    SET_GPR_U32(ctx, 31, 0x13bb74);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    FUN_0013bc80(rdram, ctx, runtime); return;
}


// Function: entry_13bb74
// Address: 0x13bb74 - 0x13bb80

void entry_13bb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bb74: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x13bb78: 0xc04ef80
    SET_GPR_U32(ctx, 31, 0x13bb80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PrimeBomb__FP4BOMBf(rdram, ctx, runtime); return;
}


// Function: entry_13bb80
// Address: 0x13bb80 - 0x13bba0

void entry_13bb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bb80) {
        switch (ctx->pc) {
            case 0x13bb84: ctx->pc = 0; goto label_13bb84;
            case 0x13bb88: ctx->pc = 0; goto label_13bb88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bb80: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_13bb84:
    // 0x13bb84: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_13bb88:
    // 0x13bb88: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13bb8c: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13bb90: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13bb94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13bb9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13bba0; return;
}


// Function: FAbsorbBombWkr__FP4BOMBP3WKR
// Address: 0x13bba0 - 0x13bbc0

void entry_13bbc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bbc0) {
        switch (ctx->pc) {
            case 0x13bc30: ctx->pc = 0; goto label_13bc30;
            case 0x13bc3c: ctx->pc = 0; goto label_13bc3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bbc0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13bbc4: 0x12400027
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BC64; return;
    }
    // 0x13bbcc: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x13bbd0: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x13bbd4: 0x10400022
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13bc60(rdram, ctx, runtime); return;
    }
    // 0x13bbdc: 0xda030030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x13bbe0: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13bbe4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13bbe8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13bbec: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13bbf0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x13bbf4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x13bbf8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13bbfc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13bc00: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13bc04: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x13bc08: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x13bc0c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13bc10: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13bc14: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x13bc18: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13bc1c: 0x0
    // NOP
    // 0x13bc20: 0x45000003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13bc30;
    }
    // 0x13bc28: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13bc3c;
    }
label_13bc30:
    // 0x13bc30: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x13bc34: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13bc38: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_13bc3c:
    // 0x13bc3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13bc40: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13bc44: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13bc48: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13bc4c: 0xc04ef20
    SET_GPR_U32(ctx, 31, 0x13bc54);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_0013bc80(rdram, ctx, runtime); return;
}


// Function: entry_13bc54
// Address: 0x13bc54 - 0x13bc60

void entry_13bc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bc54: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x13bc58: 0xc04ef80
    SET_GPR_U32(ctx, 31, 0x13bc60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PrimeBomb__FP4BOMBf(rdram, ctx, runtime); return;
}


// Function: entry_13bc60
// Address: 0x13bc60 - 0x13bc80

void entry_13bc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bc60) {
        switch (ctx->pc) {
            case 0x13bc64: ctx->pc = 0; goto label_13bc64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bc60: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_13bc64:
    // 0x13bc64: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13bc68: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13bc6c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13bc70: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13bc74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13bc7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13bc80; return;
}


// Function: FUN_0013bc80
// Address: 0x13bc80 - 0x13bd20

void FUN_0013bc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bc80) {
        switch (ctx->pc) {
            case 0x13bcb4: ctx->pc = 0; goto label_13bcb4;
            case 0x13bcb8: ctx->pc = 0; goto label_13bcb8;
            case 0x13bcf4: ctx->pc = 0; goto label_13bcf4;
            case 0x13bd04: ctx->pc = 0; goto label_13bd04;
            case 0x13bd18: ctx->pc = 0; goto label_13bd18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bc80: 0x27bdff50
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967120));
    // 0x13bc84: 0x7fb00090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 16));
    // 0x13bc88: 0x7fbf00a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 31));
    // 0x13bc8c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13bc90: 0x8e02060c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1548)));
    // 0x13bc94: 0x14400057
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BDF4; return;
    }
    // 0x13bc9c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13bca0: 0xae050670
    WRITE32(ADD32(GPR_U32(ctx, 16), 1648), GPR_U32(ctx, 5));
    // 0x13bca4: 0x10c00003
    WRITE32(ADD32(GPR_U32(ctx, 16), 1548), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_13bcb4;
    }
    // 0x13bcac: 0x10000002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13bcb8;
    }
label_13bcb4:
    // 0x13bcb4: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
label_13bcb8:
    // 0x13bcb8: 0x7e020610
    WRITE128(ADD32(GPR_U32(ctx, 16), 1552), GPR_VEC(ctx, 2));
    // 0x13bcbc: 0x7a020150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x13bcc0: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13bcc4: 0x7a030160
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x13bcc8: 0x8e060608
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1544)));
    // 0x13bccc: 0x7e020650
    WRITE128(ADD32(GPR_U32(ctx, 16), 1616), GPR_VEC(ctx, 2));
    // 0x13bcd0: 0x10c4003b
    WRITE128(ADD32(GPR_U32(ctx, 16), 1632), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x13BDC0; return;
    }
    // 0x13bcd8: 0x28c20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 2));
    // 0x13bcdc: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_13bcf4;
    }
    // 0x13bce4: 0x10c00007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_13bd04;
    }
    // 0x13bcec: 0x10000042
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BDF8; return;
    }
label_13bcf4:
    // 0x13bcf4: 0x10c20039
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x13BDDC; return;
    }
    // 0x13bcfc: 0x1000003e
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BDF8; return;
    }
label_13bd04:
    // 0x13bd04: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x13bd08: 0x14a00003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 304));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_13bd18;
    }
    // 0x13bd10: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13bd14: 0x24458d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294937888));
label_13bd18:
    // 0x13bd18: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x13bd20);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_13bd20
// Address: 0x13bd20 - 0x13bdb8

void entry_13bd20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bd20) {
        switch (ctx->pc) {
            case 0x13bda4: ctx->pc = 0; goto label_13bda4;
            case 0x13bda8: ctx->pc = 0; goto label_13bda8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bd20: 0xda040110
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
    // 0x13bd24: 0x26020110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 272));
    // 0x13bd28: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13bd2c: 0xdba60010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13bd30: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13bd34: 0x8e050224
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x13bd38: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x13bd3c: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13bd40: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13bd44: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x13bd48: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x13bd4c: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x13bd50: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13bd54: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13bd58: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13bd5c: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13bd60: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13bd64: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x13bd68: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x13bd6c: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13bd70: 0x4bc128ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13bd74: 0xfa040620
    WRITE128(ADD32(GPR_U32(ctx, 16), 1568), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x13bd78: 0xfa020630
    WRITE128(ADD32(GPR_U32(ctx, 16), 1584), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13bd7c: 0xfa030640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13bd80: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13bd84: 0x10a00007
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_13bda4;
    }
    // 0x13bd8c: 0x8ca200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 176)));
    // 0x13bd90: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x13bd94: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        goto label_13bda8;
    }
    // 0x13bd9c: 0x10000002
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13bda8;
    }
label_13bda4:
    // 0x13bda4: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
label_13bda8:
    // 0x13bda8: 0x26060620
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 1568));
    // 0x13bdac: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13bdb0: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x13bdb8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_13bdb8
// Address: 0x13bdb8 - 0x13bdd4

void entry_13bdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bdb8) {
        switch (ctx->pc) {
            case 0x13bdc0: ctx->pc = 0; goto label_13bdc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bdb8: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13BDF4; return;
    }
label_13bdc0:
    // 0x13bdc0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x13bdc4: 0x26060620
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 1568));
    // 0x13bdc8: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x13bdcc: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x13bdd4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1616));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_13bdd4
// Address: 0x13bdd4 - 0x13be00

void entry_13bdd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bdd4) {
        switch (ctx->pc) {
            case 0x13bddc: ctx->pc = 0; goto label_13bddc;
            case 0x13bdf4: ctx->pc = 0; goto label_13bdf4;
            case 0x13bdf8: ctx->pc = 0; goto label_13bdf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bdd4: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13bdf4;
    }
label_13bddc:
    // 0x13bddc: 0x7a0200d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x13bde0: 0x7a0400e0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 224)));
    // 0x13bde4: 0x7a0300f0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 240)));
    // 0x13bde8: 0x7e020620
    WRITE128(ADD32(GPR_U32(ctx, 16), 1568), GPR_VEC(ctx, 2));
    // 0x13bdec: 0x7e030640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), GPR_VEC(ctx, 3));
    // 0x13bdf0: 0x7e040630
    WRITE128(ADD32(GPR_U32(ctx, 16), 1584), GPR_VEC(ctx, 4));
label_13bdf4:
    // 0x13bdf4: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_13bdf8:
    // 0x13bdf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PrimeBomb__FP4BOMBf
// Address: 0x13be00 - 0x13be18

void entry_13be38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13be38) {
        switch (ctx->pc) {
            case 0x13be4c: ctx->pc = 0; goto label_13be4c;
            case 0x13be58: ctx->pc = 0; goto label_13be58;
            case 0x13beb4: ctx->pc = 0; goto label_13beb4;
            case 0x13bec0: ctx->pc = 0; goto label_13bec0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13be38: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
        goto label_13be4c;
    }
    // 0x13be40: 0x7a020700
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 1792)));
    // 0x13be44: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13be58;
    }
label_13be4c:
    // 0x13be4c: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x13be50: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13be54: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_13be58:
    // 0x13be58: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x13be5c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13be60: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x13be64: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x13be68: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13be6c: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x13be70: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13be74: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13be78: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13be7c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13be80: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13be84: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13be88: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13be8c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13be90: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13be94: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x13be98: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13be9c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x13bea0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13bea4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13beb4;
    }
    // 0x13beac: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13bec0;
    }
label_13beb4:
    // 0x13beb4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x13beb8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13bebc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_13bec0:
    // 0x13bec0: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13bec4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13bec8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13becc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13bed0: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x13bed4: 0x8c631360
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4960)));
    // 0x13bed8: 0x8c841364
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4964)));
    // 0x13bedc: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13bee0: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13bee4: 0x48a42000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x13bee8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13beec: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13bef0: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x13bef4: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13bef8: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13befc: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13bf00: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13bf04: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x13bf08: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13bf0c: 0x26250440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1088));
    // 0x13bf10: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13bf14: 0xc06e8ba
    SET_GPR_U32(ctx, 31, 0x13bf1c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_13bf1c
// Address: 0x13bf1c - 0x13bf30

void entry_13bf1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bf1c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13bf20: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13bf24: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x13bf28: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13bf30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13bf30
// Address: 0x13bf30 - 0x13bf3c

void entry_13bf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bf30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13bf34: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13bf3c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13bf3c
// Address: 0x13bf3c - 0x13bf50

void entry_13bf3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bf3c: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13bf50(rdram, ctx, runtime); return;
    }
    // 0x13bf44: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13bf48: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x13bf50);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_13bf50
// Address: 0x13bf50 - 0x13bf68

void entry_13bf50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bf50: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13bf54: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13bf58: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13bf5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13bf64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13bf68; return;
}


// Function: DetonateBomb__FP4BOMB
// Address: 0x13bf68 - 0x13bfc0

void entry_13bfc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bfc0: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x13bfc8);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13bfc8
// Address: 0x13bfc8 - 0x13bfd0

void entry_13bfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bfc8: 0xc063582
    SET_GPR_U32(ctx, 31, 0x13bfd0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 2));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13bfd0
// Address: 0x13bfd0 - 0x13bfec

void entry_13bfd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13bfd0: 0x8e220564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
    // 0x13bfd4: 0x10400030
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C098; return;
    }
    // 0x13bfdc: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x13bfe0: 0x27a60074
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 116));
    // 0x13bfe4: 0xc06ee00
    SET_GPR_U32(ctx, 31, 0x13bfec);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 1552));
    GetSoContacts__FP2SOPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_13bfec
// Address: 0x13bfec - 0x13c070

void entry_13bfec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13bfec) {
        switch (ctx->pc) {
            case 0x13c038: ctx->pc = 0; goto label_13c038;
            case 0x13c058: ctx->pc = 0; goto label_13c058;
            case 0x13c060: ctx->pc = 0; goto label_13c060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13bfec: 0x26220620
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1568));
    // 0x13bff0: 0x26230650
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1616));
    // 0x13bff4: 0xafa2007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 2));
    // 0x13bff8: 0x26220660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1632));
    // 0x13bffc: 0x8e240670
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1648)));
    // 0x13c000: 0xafa30080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 3));
    // 0x13c004: 0x10800037
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C0E4; return;
    }
    // 0x13c00c: 0x8fa20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13c010: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c014: 0x18400012
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_13c060;
    }
    // 0x13c01c: 0x8fa30074
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x13c020: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13c024: 0x1082000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 7)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_13c058;
    }
    // 0x13c02c: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13c030: 0xe0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x13c034: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
label_13c038:
    // 0x13c038: 0xa6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 6)));
    // 0x13c03c: 0x10400008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13c060;
    }
    // 0x13c044: 0x8e230670
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1648)));
    // 0x13c048: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13c04c: 0x5462fffa
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_13c038;
    }
    // 0x13c054: 0xa7102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 7)));
label_13c058:
    // 0x13c058: 0x14400023
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C0E8; return;
    }
label_13c060:
    // 0x13c060: 0x8fa40070
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13c064: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x13c068: 0xc063596
    SET_GPR_U32(ctx, 31, 0x13c070);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_13c070
// Address: 0x13c070 - 0x13c090

void entry_13c070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c070: 0x8e230670
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1648)));
    // 0x13c074: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13c078: 0x26040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4));
    // 0x13c07c: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x13c080: 0x8fa60070
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13c084: 0x8fa50074
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x13c088: 0xc063600
    SET_GPR_U32(ctx, 31, 0x13c090);
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 2));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_13c090
// Address: 0x13c090 - 0x13c0c8

void entry_13c090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c090) {
        switch (ctx->pc) {
            case 0x13c098: ctx->pc = 0; goto label_13c098;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c090: 0x10000014
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C0E4; return;
    }
label_13c098:
    // 0x13c098: 0xc620055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[0] = *(float*)&val; }
    // 0x13c09c: 0x26300610
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1552));
    // 0x13c0a0: 0xc62c0560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1376)); ctx->f[12] = *(float*)&val; }
    // 0x13c0a4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c0a8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x13c0ac: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c0b0: 0x46006328
    ctx->f[12] = std::max(ctx->f[12], ctx->f[0]);
    // 0x13c0b4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c0b8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c0bc: 0x27a90070
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 112));
    // 0x13c0c0: 0xc077134
    SET_GPR_U32(ctx, 31, 0x13c0c8);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 116));
    IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_13c0c8
// Address: 0x13c0c8 - 0x13c174

void entry_13c0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c0c8) {
        switch (ctx->pc) {
            case 0x13c0e4: ctx->pc = 0; goto label_13c0e4;
            case 0x13c0e8: ctx->pc = 0; goto label_13c0e8;
            case 0x13c118: ctx->pc = 0; goto label_13c118;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c0c8: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c0cc: 0x26230620
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1568));
    // 0x13c0d0: 0x26240650
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1616));
    // 0x13c0d4: 0x26220660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1632));
    // 0x13c0d8: 0xafa3007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 3));
    // 0x13c0dc: 0xafa40080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 4));
    // 0x13c0e0: 0xafa20084
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 2));
label_13c0e4:
    // 0x13c0e4: 0x8fa20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
label_13c0e8:
    // 0x13c0e8: 0x1840011c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13C55C; return;
    }
    // 0x13c0f0: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x13c0f4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13c0f8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x13c0fc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x13c100: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x13c104: 0x26de5c60
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 22), 23648));
    // 0x13c108: 0x24771380
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 3), 4992));
    // 0x13c10c: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13c110: 0x27b30030
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 48));
    // 0x13c114: 0x8fa30074
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 116)));
label_13c118:
    // 0x13c118: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x13c11c: 0x8e240050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x13c120: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13c124: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13c128: 0x8e030050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x13c12c: 0x10640106
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        entry_13c548(rdram, ctx, runtime); return;
    }
    // 0x13c134: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x13c138: 0x10440104
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x13C54C; return;
    }
    // 0x13c140: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c144: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13c148: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x13c14c: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        ctx->pc = 0x13C17C; return;
    }
    // 0x13c154: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x13c158: 0x50440008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        ctx->pc = 0x13C17C; return;
    }
    // 0x13c160: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x13c164: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x13c168: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13c16c: 0xc04ef80
    SET_GPR_U32(ctx, 31, 0x13c174);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PrimeBomb__FP4BOMBf(rdram, ctx, runtime); return;
}


// Function: entry_13c174
// Address: 0x13c174 - 0x13c1c0

void entry_13c174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c174) {
        switch (ctx->pc) {
            case 0x13c17c: ctx->pc = 0; goto label_13c17c;
            case 0x13c1a0: ctx->pc = 0; goto label_13c1a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c174: 0x100000f5
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C54C; return;
    }
label_13c17c:
    // 0x13c17c: 0x14400013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C1CC; return;
    }
    // 0x13c184: 0x8e0203f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x13c188: 0x1040000f
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 120)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C1C8; return;
    }
    // 0x13c190: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x13c194: 0x54440002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[12] = *(float*)&val; }
        goto label_13c1a0;
    }
    // 0x13c19c: 0xc62c0560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1376)); ctx->f[12] = *(float*)&val; }
label_13c1a0:
    // 0x13c1a0: 0x8e0503f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1012)));
    // 0x13c1a4: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x13c1a8: 0x8e0603f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x13c1ac: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c1b0: 0x260803a4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 932));
    // 0x13c1b4: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13c1b8: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x13c1c0);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_13c1c0
// Address: 0x13c1c0 - 0x13c1d4

void entry_13c1c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c1c0) {
        switch (ctx->pc) {
            case 0x13c1c8: ctx->pc = 0; goto label_13c1c8;
            case 0x13c1cc: ctx->pc = 0; goto label_13c1cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c1c0: 0x104000e2
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C54C; return;
    }
label_13c1c8:
    // 0x13c1c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_13c1cc:
    // 0x13c1cc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13c1d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13c1d4
// Address: 0x13c1d4 - 0x13c1e8

void entry_13c1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c1d4: 0x1040000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C210; return;
    }
    // 0x13c1dc: 0x8e25067c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
    // 0x13c1e0: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x13c1e8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13c1e8
// Address: 0x13c1e8 - 0x13c208

void entry_13c1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c1e8: 0x3c020014
    SET_GPR_U32(ctx, 2, ((uint32_t)20 << 16));
    // 0x13c1ec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c1f0: 0x2442be18
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294950424));
    // 0x13c1f4: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x13c1f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c1fc: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x13c200: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c208);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c208
// Address: 0x13c208 - 0x13c2c4

void entry_13c208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c208) {
        switch (ctx->pc) {
            case 0x13c210: ctx->pc = 0; goto label_13c210;
            case 0x13c2a8: ctx->pc = 0; goto label_13c2a8;
            case 0x13c2b4: ctx->pc = 0; goto label_13c2b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c208: 0x100000d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C54C; return;
    }
label_13c210:
    // 0x13c210: 0xc6010368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 872)); ctx->f[1] = *(float*)&val; }
    // 0x13c214: 0xc6200574
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1396)); ctx->f[0] = *(float*)&val; }
    // 0x13c218: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c21c: 0x0
    // NOP
    // 0x13c220: 0x450000bb
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x13C510; return;
    }
    // 0x13c228: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x13c22c: 0x144000b8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C510; return;
    }
    // 0x13c234: 0xda210610
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1552)));
    // 0x13c238: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x13c23c: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x13c240: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x13c244: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13c248: 0x3c014348
    SET_GPR_U32(ctx, 1, ((uint32_t)17224 << 16));
    // 0x13c24c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13c250: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13c254: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13c258: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13c25c: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x13c260: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13c264: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x13c268: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x13c26c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13c270: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13c274: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13c278: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13c27c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13c280: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13c284: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13c288: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x13c28c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13c290: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x13c294: 0x46180034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c298: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c2a8;
    }
    // 0x13c2a0: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13c2b4;
    }
label_13c2a8:
    // 0x13c2a8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x13c2ac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13c2b0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_13c2b4:
    // 0x13c2b4: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13c2b8: 0x2624056c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1388));
    // 0x13c2bc: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x13c2c4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 872)); ctx->f[12] = *(float*)&val; }
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_13c2c4
// Address: 0x13c2c4 - 0x13c434

void entry_13c2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c2c4) {
        switch (ctx->pc) {
            case 0x13c348: ctx->pc = 0; goto label_13c348;
            case 0x13c35c: ctx->pc = 0; goto label_13c35c;
            case 0x13c3e0: ctx->pc = 0; goto label_13c3e0;
            case 0x13c3f4: ctx->pc = 0; goto label_13c3f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c2c4: 0xc621056c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1388)); ctx->f[1] = *(float*)&val; }
    // 0x13c2c8: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x13c2cc: 0x46000144
    ctx->f[5] = FPU_SQRT_S(ctx->f[0]);
    // 0x13c2d0: 0xda020150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x13c2d4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13c2d8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13c2dc: 0x24631370
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4976));
    // 0x13c2e0: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13c2e4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13c2e8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13c2ec: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13c2f0: 0xc6200568
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1384)); ctx->f[0] = *(float*)&val; }
    // 0x13c2f4: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13c2f8: 0xc4630008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[3] = *(float*)&val; }
    // 0x13c2fc: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x13c300: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x13c304: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x13c308: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13c30c: 0xc4841370
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4976)); ctx->f[4] = *(float*)&val; }
    // 0x13c310: 0xc6c65c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 23648)); ctx->f[6] = *(float*)&val; }
    // 0x13c314: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13c318: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13c31c: 0xc7c80004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4)); ctx->f[8] = *(float*)&val; }
    // 0x13c320: 0x460308c2
    ctx->f[3] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x13c324: 0x46031080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[3]);
    // 0x13c328: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x13c32c: 0x46012100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[1]);
    // 0x13c330: 0x46062034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c334: 0x0
    // NOP
    // 0x13c338: 0x45000003
    if (ctx->f[5] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[9] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[9] = ctx->f[0] / ctx->f[5];
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c348;
    }
    // 0x13c340: 0x10000006
    ctx->f[7] = FPU_MOV_S(ctx->f[6]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13c35c;
    }
label_13c348:
    // 0x13c348: 0x46044034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[8], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c34c: 0x0
    // NOP
    // 0x13c350: 0x45000002
    ctx->f[7] = FPU_MOV_S(ctx->f[4]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c35c;
    }
    // 0x13c358: 0x460041c6
    ctx->f[7] = FPU_MOV_S(ctx->f[8]);
label_13c35c:
    // 0x13c35c: 0xc62003d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 976)); ctx->f[0] = *(float*)&val; }
    // 0x13c360: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13c364: 0xc60203cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 972)); ctx->f[2] = *(float*)&val; }
    // 0x13c368: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13c36c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13c370: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13c374: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13c378: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13c37c: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x13c380: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13c384: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13c388: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x13c38c: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x13c390: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13c394: 0xc624055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[4] = *(float*)&val; }
    // 0x13c398: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x13c39c: 0xc6e10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 8)); ctx->f[1] = *(float*)&val; }
    // 0x13c3a0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x13c3a4: 0xc4651380
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4992)); ctx->f[5] = *(float*)&val; }
    // 0x13c3a8: 0xc6e20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[2] = *(float*)&val; }
    // 0x13c3ac: 0x46030028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[3]);
    // 0x13c3b0: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x13c3b4: 0xc6c35c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x13c3b8: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x13c3bc: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x13c3c0: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x13c3c4: 0x46002940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[0]);
    // 0x13c3c8: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c3cc: 0x0
    // NOP
    // 0x13c3d0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4)); ctx->f[6] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c3e0;
    }
    // 0x13c3d8: 0x10000006
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13c3f4;
    }
label_13c3e0:
    // 0x13c3e0: 0x46053034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c3e4: 0x0
    // NOP
    // 0x13c3e8: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[5]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c3f4;
    }
    // 0x13c3f0: 0x46003106
    ctx->f[4] = FPU_MOV_S(ctx->f[6]);
label_13c3f4:
    // 0x13c3f4: 0xc6200568
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1384)); ctx->f[0] = *(float*)&val; }
    // 0x13c3f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c3fc: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13c400: 0x26050440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1088));
    // 0x13c404: 0x46090002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[9]);
    // 0x13c408: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x13c40c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x13c410: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c414: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x13c418: 0x46040542
    ctx->f[21] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x13c41c: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x13c420: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13c424: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13c428: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13c42c: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x13c434);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_13c434
// Address: 0x13c434 - 0x13c45c

void entry_13c434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c434: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x13c438: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c43c: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13c440: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x13c444: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13c448: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13c44c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c450: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x13c454: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13c45c);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13c45c
// Address: 0x13c45c - 0x13c48c

void entry_13c45c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c45c: 0x4615c034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[24], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c460: 0x0
    // NOP
    // 0x13c464: 0x45000029
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x13C50C; return;
    }
    // 0x13c46c: 0x3c013c23
    SET_GPR_U32(ctx, 1, ((uint32_t)15395 << 16));
    // 0x13c470: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x13c474: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x13c478: 0x4614ad02
    ctx->f[20] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x13c47c: 0x4600a587
    ctx->f[22] = FPU_NEG_S(ctx->f[20]);
    // 0x13c480: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x13c484: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c48c);
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c48c
// Address: 0x13c48c - 0x13c49c

void entry_13c48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c48c: 0x460005c6
    ctx->f[23] = FPU_MOV_S(ctx->f[0]);
    // 0x13c490: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x13c494: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c49c);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c49c
// Address: 0x13c49c - 0x13c4ac

void entry_13c49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c49c: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x13c4a0: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x13c4a4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c4ac);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c4ac
// Address: 0x13c4ac - 0x13c4e0

void entry_13c4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c4ac: 0x4403b800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[23]);
    // 0x13c4b0: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x13c4b4: 0x70431c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13c4b8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13c4bc: 0x70431b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13c4c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c4c4: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    // 0x13c4c8: 0x26050460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1120));
    // 0x13c4cc: 0x7fa30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 3));
    // 0x13c4d0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13c4d4: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13c4d8: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x13c4e0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_13c4e0
// Address: 0x13c4e0 - 0x13c508

void entry_13c4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c4e0: 0xda010160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x13c4e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c4e8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13c4ec: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x13c4f0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13c4f4: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13c4f8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c4fc: 0x8c430094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 148)));
    // 0x13c500: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13c508);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13c508
// Address: 0x13c508 - 0x13c518

void entry_13c508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c508) {
        switch (ctx->pc) {
            case 0x13c50c: ctx->pc = 0; goto label_13c50c;
            case 0x13c510: ctx->pc = 0; goto label_13c510;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c508: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_13c50c:
    // 0x13c50c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13c510:
    // 0x13c510: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x13c518);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_13c518
// Address: 0x13c518 - 0x13c548

void entry_13c518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c518: 0x7a230610
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 1552)));
    // 0x13c51c: 0x24070010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 16));
    // 0x13c520: 0x7a220150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x13c524: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13c528: 0xafb00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 16));
    // 0x13c52c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c530: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x13c534: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c538: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x13c53c: 0xafa70010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 7));
    // 0x13c540: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x13c548);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13c548
// Address: 0x13c548 - 0x13c564

void entry_13c548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c548) {
        switch (ctx->pc) {
            case 0x13c54c: ctx->pc = 0; goto label_13c54c;
            case 0x13c55c: ctx->pc = 0; goto label_13c55c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c548: 0x8fa20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
label_13c54c:
    // 0x13c54c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x13c550: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13c554: 0x1440fef0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C118; return;
    }
label_13c55c:
    // 0x13c55c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x13c564);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13c564
// Address: 0x13c564 - 0x13c594

void entry_13c564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c564) {
        switch (ctx->pc) {
            case 0x13c584: ctx->pc = 0; goto label_13c584;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c564: 0x8e250224
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 548)));
    // 0x13c568: 0x50a00006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        goto label_13c584;
    }
    // 0x13c570: 0x8ca200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 176)));
    // 0x13c574: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x13c578: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        goto label_13c584;
    }
    // 0x13c580: 0x8ca50060
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 96)));
label_13c584:
    // 0x13c584: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x13c588: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13c58c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x13c594);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_13c594
// Address: 0x13c594 - 0x13c5a8

void entry_13c594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c594: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13c598: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13c59c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x13c5a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c5a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c5a8
// Address: 0x13c5a8 - 0x13c5bc

void entry_13c5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c5a8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13c5ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13c5b0: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x13c5b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c5bc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 124)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c5bc
// Address: 0x13c5bc - 0x13c5d0

void entry_13c5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c5bc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13c5c0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13c5c4: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x13c5c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c5d0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c5d0
// Address: 0x13c5d0 - 0x13c5e4

void entry_13c5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c5d0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13c5d4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13c5d8: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x13c5dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c5e4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c5e4
// Address: 0x13c5e4 - 0x13c628

void entry_13c5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c5e4: 0x8e230674
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1652)));
    // 0x13c5e8: 0x50600034
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
        ctx->pc = 0x13C6BC; return;
    }
    // 0x13c5f0: 0x8e2305bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1468)));
    // 0x13c5f4: 0x1060000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C630; return;
    }
    // 0x13c5fc: 0xc62105c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1472)); ctx->f[1] = *(float*)&val; }
    // 0x13c600: 0xc620055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[0] = *(float*)&val; }
    // 0x13c604: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13c608: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x13c60c: 0xe7a10040
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x13c610: 0xe7a00044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
    // 0x13c614: 0xafb10014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 17));
    // 0x13c618: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13c61c: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x13c620: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13c628);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13c628
// Address: 0x13c628 - 0x13c640

void entry_13c628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c628) {
        switch (ctx->pc) {
            case 0x13c630: ctx->pc = 0; goto label_13c630;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c628: 0x10000006
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 320));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C644; return;
    }
label_13c630:
    // 0x13c630: 0x26300140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 320));
    // 0x13c634: 0xc62c055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[12] = *(float*)&val; }
    // 0x13c638: 0xc0559b2
    SET_GPR_U32(ctx, 31, 0x13c640);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StandardSmokeCloud__FP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_13c640
// Address: 0x13c640 - 0x13c678

void entry_13c640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c640) {
        switch (ctx->pc) {
            case 0x13c644: ctx->pc = 0; goto label_13c644;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c640: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_13c644:
    // 0x13c644: 0x8e220680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1664)));
    // 0x13c648: 0x1040000d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C680; return;
    }
    // 0x13c650: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x13c654: 0xc44e000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[14] = *(float*)&val; }
    // 0x13c658: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c65c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13c660: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x13c664: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x13c668: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c66c: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x13c670: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x13c678);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_13c678
// Address: 0x13c678 - 0x13c6b8

void entry_13c678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c678) {
        switch (ctx->pc) {
            case 0x13c680: ctx->pc = 0; goto label_13c680;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c678: 0x10000010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C6BC; return;
    }
label_13c680:
    // 0x13c680: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x13c684: 0x24040035
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 53));
    // 0x13c688: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x13c68c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x13c690: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13c694: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x13c698: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x13c69c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c6a0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13c6a4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x13c6a8: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x13c6ac: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c6b0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x13c6b8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_13c6b8
// Address: 0x13c6b8 - 0x13c784

void entry_13c6b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c6b8) {
        switch (ctx->pc) {
            case 0x13c6bc: ctx->pc = 0; goto label_13c6bc;
            case 0x13c704: ctx->pc = 0; goto label_13c704;
            case 0x13c718: ctx->pc = 0; goto label_13c718;
            case 0x13c754: ctx->pc = 0; goto label_13c754;
            case 0x13c768: ctx->pc = 0; goto label_13c768;
            case 0x13c778: ctx->pc = 0; goto label_13c778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c6b8: 0x8e230578
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
label_13c6bc:
    // 0x13c6bc: 0x18600084
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1488));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x13C8D0; return;
    }
    // 0x13c6c4: 0xc621055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x13c6c8: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x13c6cc: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x13c6d0: 0x46000946
    ctx->f[5] = FPU_MOV_S(ctx->f[1]);
    // 0x13c6d4: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x13c6d8: 0xc62305d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1488)); ctx->f[3] = *(float*)&val; }
    // 0x13c6dc: 0xc63705e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1504)); ctx->f[23] = *(float*)&val; }
    // 0x13c6e0: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x13c6e4: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x13c6e8: 0x46011b40
    ctx->f[13] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x13c6ec: 0x46176834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c6f0: 0x0
    // NOP
    // 0x13c6f4: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1508)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c704;
    }
    // 0x13c6fc: 0x10000006
    ctx->f[25] = FPU_MOV_S(ctx->f[23]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13c718;
    }
label_13c704:
    // 0x13c704: 0x460d2034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c708: 0x0
    // NOP
    // 0x13c70c: 0x45000002
    ctx->f[25] = FPU_MOV_S(ctx->f[13]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c718;
    }
    // 0x13c714: 0x46002646
    ctx->f[25] = FPU_MOV_S(ctx->f[4]);
label_13c718:
    // 0x13c718: 0x262205f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1520));
    // 0x13c71c: 0xc62205f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1520)); ctx->f[2] = *(float*)&val; }
    // 0x13c720: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x13c724: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x13c728: 0x46012842
    ctx->f[1] = FPU_MUL_S(ctx->f[5], ctx->f[1]);
    // 0x13c72c: 0xc6360600
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1536)); ctx->f[22] = *(float*)&val; }
    // 0x13c730: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x13c734: 0x46002802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x13c738: 0x46001340
    ctx->f[13] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x13c73c: 0x46166834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c740: 0x0
    // NOP
    // 0x13c744: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1540)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c754;
    }
    // 0x13c74c: 0x10000006
    ctx->f[24] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13c768;
    }
label_13c754:
    // 0x13c754: 0x460d1834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13c758: 0x0
    // NOP
    // 0x13c75c: 0x45000002
    ctx->f[24] = FPU_MOV_S(ctx->f[13]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13c768;
    }
    // 0x13c764: 0x46001e06
    ctx->f[24] = FPU_MOV_S(ctx->f[3]);
label_13c768:
    // 0x13c768: 0x18600059
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x13C8D0; return;
    }
    // 0x13c770: 0x26340110
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 272));
    // 0x13c774: 0x2632057c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1404));
label_13c778:
    // 0x13c778: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13c77c: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x13c784);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13c784
// Address: 0x13c784 - 0x13c7a4

void entry_13c784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c784: 0x5440004e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
        ctx->pc = 0x13C8C0; return;
    }
    // 0x13c78c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c790: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c794: 0x4600cdc7
    ctx->f[23] = FPU_NEG_S(ctx->f[25]);
    // 0x13c798: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x13c79c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c7a4);
    ctx->f[22] = FPU_NEG_S(ctx->f[24]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c7a4
// Address: 0x13c7a4 - 0x13c7b8

void entry_13c7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c7a4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c7a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c7ac: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x13c7b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c7b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c7b8
// Address: 0x13c7b8 - 0x13c7c4

void entry_13c7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c7b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c7bc: 0xc04f75e
    SET_GPR_U32(ctx, 31, 0x13c7c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetBrkpBrkps__FP4BRKP5BRKPS(rdram, ctx, runtime); return;
}


// Function: entry_13c7c4
// Address: 0x13c7c4 - 0x13c7d8

void entry_13c7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c7c4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c7c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c7cc: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x13c7d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13c7d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13c7d8
// Address: 0x13c7d8 - 0x13c7ec

void entry_13c7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c7d8: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x13c7dc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x13c7e0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x13c7e4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c7ec);
    ctx->f[13] = FPU_MUL_S(ctx->f[25], ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c7ec
// Address: 0x13c7ec - 0x13c7fc

void entry_13c7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c7ec: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x13c7f0: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x13c7f4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c7fc);
    ctx->f[13] = FPU_MOV_S(ctx->f[25]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c7fc
// Address: 0x13c7fc - 0x13c80c

void entry_13c7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c7fc: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x13c800: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x13c804: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c80c);
    ctx->f[13] = FPU_MOV_S(ctx->f[25]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c80c
// Address: 0x13c80c - 0x13c860

void entry_13c80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c80c: 0x4403a800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[21]);
    // 0x13c810: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x13c814: 0x70431c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13c818: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13c81c: 0x70431b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13c820: 0xda240110
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x13c824: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13c828: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c82c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13c830: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x13c834: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13c838: 0xda830010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x13c83c: 0xda810020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x13c840: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13c844: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13c848: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13c84c: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13c850: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c854: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x13c858: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13c860);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13c860
// Address: 0x13c860 - 0x13c86c

void entry_13c860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c860: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x13c864: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c86c);
    ctx->f[13] = FPU_MOV_S(ctx->f[24]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c86c
// Address: 0x13c86c - 0x13c87c

void entry_13c86c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c86c: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x13c870: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x13c874: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c87c);
    ctx->f[13] = FPU_MOV_S(ctx->f[24]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c87c
// Address: 0x13c87c - 0x13c88c

void entry_13c87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c87c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x13c880: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x13c884: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13c88c);
    ctx->f[13] = FPU_MOV_S(ctx->f[24]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13c88c
// Address: 0x13c88c - 0x13c8bc

void entry_13c88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c88c: 0x4403a800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[21]);
    // 0x13c890: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x13c894: 0x70431c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13c898: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13c89c: 0x70431b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13c8a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13c8a4: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x13c8a8: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x13c8ac: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13c8b0: 0x8c430094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 148)));
    // 0x13c8b4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13c8bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13c8bc
// Address: 0x13c8bc - 0x13c8e0

void entry_13c8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c8bc) {
        switch (ctx->pc) {
            case 0x13c8c0: ctx->pc = 0; goto label_13c8c0;
            case 0x13c8d0: ctx->pc = 0; goto label_13c8d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c8bc: 0x8e220578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
label_13c8c0:
    // 0x13c8c0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x13c8c4: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x13c8c8: 0x1440ffab
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13C778; return;
    }
label_13c8d0:
    // 0x13c8d0: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13c8d4: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x13c8d8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13c8e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13c8e0
// Address: 0x13c8e0 - 0x13c8f4

void entry_13c8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c8e0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13c8e4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x13c8e8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13c8ec: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x13c8f4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_13c8f4
// Address: 0x13c8f4 - 0x13c950

void entry_13c8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c8f4: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x13c8f8: 0xae20060c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1548), GPR_U32(ctx, 0));
    // 0x13c8fc: 0xc4809d78
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294942072)); ctx->f[0] = *(float*)&val; }
    // 0x13c900: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x13c904: 0xe6200554
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1364), *(uint32_t*)&val); }
    // 0x13c908: 0x7bbe0110
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x13c90c: 0x7bb70100
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x13c910: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x13c914: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x13c918: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13c91c: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13c920: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13c924: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13c928: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13c92c: 0xc7b90158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[25] = *(float*)&val; }
    // 0x13c930: 0xc7b80150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[24] = *(float*)&val; }
    // 0x13c934: 0xc7b70148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[23] = *(float*)&val; }
    // 0x13c938: 0xc7b60140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[22] = *(float*)&val; }
    // 0x13c93c: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x13c940: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x13c944: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13c94c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13c950; return;
}


// Function: PsfxEnsureBomb__FP4BOMB4ENSK
// Address: 0x13c950 - 0x13c974

void entry_13c974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13c974) {
        switch (ctx->pc) {
            case 0x13c97c: ctx->pc = 0; goto label_13c97c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13c974: 0x8e020680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x13c978: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13c97c:
    // 0x13c97c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13c980: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Init__10CByteQueueiPv
// Address: 0x13c988 - 0x13c9a0

void entry_13c9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13c9a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13c9a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13c9ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13c9b0; return;
}


// Function: Reset__10CByteQueue
// Address: 0x13c9b0 - 0x13c9d0

void entry_13caa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13caa8) {
        switch (ctx->pc) {
            case 0x13cab4: ctx->pc = 0; goto label_13cab4;
            case 0x13cab8: ctx->pc = 0; goto label_13cab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13caa8: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13caac: 0x54c0ffdc
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x13CA20; return;
    }
label_13cab4:
    // 0x13cab4: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_13cab8:
    // 0x13cab8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13cabc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13cac0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13cac4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13cac8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13cacc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13cad0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CbDrain__10CByteQueueiP12CQueueOutput
// Address: 0x13cad8 - 0x13cb68

void entry_13cb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13cb68) {
        switch (ctx->pc) {
            case 0x13cb80: ctx->pc = 0; goto label_13cb80;
            case 0x13cb88: ctx->pc = 0; goto label_13cb88;
            case 0x13cb94: ctx->pc = 0; goto label_13cb94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13cb68: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        goto label_13cb80;
    }
    // 0x13cb70: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x13cb74: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x13cb78: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13cb88;
    }
label_13cb80:
    // 0x13cb80: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x13cb84: 0xae220010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 2));
label_13cb88:
    // 0x13cb88: 0x2b0a821
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 16)));
    // 0x13cb8c: 0x1a800012
    SET_GPR_U32(ctx, 18, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x13CBD8; return;
    }
label_13cb94:
    // 0x13cb94: 0x12400011
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13CBDC; return;
    }
    // 0x13cb9c: 0x8e28000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x13cba0: 0x8e670000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x13cba4: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x13cba8: 0x84e40008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x13cbac: 0xa82823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 8)));
    // 0x13cbb0: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13cbb4: 0x245182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 5)));
    // 0x13cbb8: 0x8ce2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x13cbbc: 0x243280b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 18));
    // 0x13cbc0: 0xc83021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x13cbc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13cbcc);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13cbcc
// Address: 0x13cbcc - 0x13cc00

void entry_13cbcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13cbcc) {
        switch (ctx->pc) {
            case 0x13cbd8: ctx->pc = 0; goto label_13cbd8;
            case 0x13cbdc: ctx->pc = 0; goto label_13cbdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13cbcc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13cbd0: 0x5600ffd5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x13CB28; return;
    }
label_13cbd8:
    // 0x13cbd8: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_13cbdc:
    // 0x13cbdc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13cbe0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13cbe4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13cbe8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13cbec: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13cbf0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13cbf4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13cbf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CbFill__10CByteQueueiPUc
// Address: 0x13cc00 - 0x13cc3c

void entry_13cc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cc3c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13cc40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreeDrain__10CByteQueuei
// Address: 0x13cc48 - 0x13cc80

void entry_13ccb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ccb8: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x13ccbc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13ccc0: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x13ccc4: 0x902021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x13ccc8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13cccc: 0x701823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x13ccd0: 0xae24000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 4));
    // 0x13ccd4: 0xae230010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 3));
    // 0x13ccd8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ccdc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13cce0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CbRead__15CQueueInputFileiPv
// Address: 0x13cce8 - 0x13ccf0

void entry_13cd0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cd0c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x13cd10: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x13cd14: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13cd18: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x13cd1c: 0x3c013f99
    SET_GPR_U32(ctx, 1, ((uint32_t)16281 << 16));
    // 0x13cd20: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x13cd24: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13cd28: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13cd2c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13cd30: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x13cd34: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13cd38: 0xe6000628
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1576), *(uint32_t*)&val); }
    // 0x13cd3c: 0x24841420
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    // 0x13cd40: 0xe601062c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1580), *(uint32_t*)&val); }
    // 0x13cd44: 0xae03068c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1676), GPR_U32(ctx, 3));
    // 0x13cd48: 0xe6020624
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 1572), *(uint32_t*)&val); }
    // 0x13cd4c: 0xa20202b0
    WRITE8(ADD32(GPR_U32(ctx, 16), 688), (uint8_t)GPR_U32(ctx, 2));
    // 0x13cd50: 0xa20202b4
    WRITE8(ADD32(GPR_U32(ctx, 16), 692), (uint8_t)GPR_U32(ctx, 2));
    // 0x13cd54: 0xa20202b3
    WRITE8(ADD32(GPR_U32(ctx, 16), 691), (uint8_t)GPR_U32(ctx, 2));
    // 0x13cd58: 0xa20202b2
    WRITE8(ADD32(GPR_U32(ctx, 16), 690), (uint8_t)GPR_U32(ctx, 2));
    // 0x13cd5c: 0xc0503fe
    SET_GPR_U32(ctx, 31, 0x13cd64);
    WRITE8(ADD32(GPR_U32(ctx, 16), 689), (uint8_t)GPR_U32(ctx, 2));
    IchkAllocChkmgr__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_13cd64
// Address: 0x13cd64 - 0x13cd80

void entry_13cd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cd64: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x13cd68: 0xae020688
    WRITE32(ADD32(GPR_U32(ctx, 16), 1672), GPR_U32(ctx, 2));
    // 0x13cd6c: 0xae030614
    WRITE32(ADD32(GPR_U32(ctx, 16), 1556), GPR_U32(ctx, 3));
    // 0x13cd70: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13cd74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13cd78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadBrkFromBrx__FP3BRKP18CBinaryInputStream
// Address: 0x13cd80 - 0x13cd94

void entry_13cd94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cd94: 0x8e060614
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x13cd98: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x13cd9c: 0x54c20006
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x13CDB8; return;
    }
    // 0x13cda4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13cda8: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x13cdb0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1560));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13cdb0
// Address: 0x13cdb0 - 0x13cdc4

void entry_13cdb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13cdb0) {
        switch (ctx->pc) {
            case 0x13cdb8: ctx->pc = 0; goto label_13cdb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13cdb0: 0x10000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13CDD8; return;
    }
label_13cdb8:
    // 0x13cdb8: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x13cdbc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x13cdc4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13cdc4
// Address: 0x13cdc4 - 0x13cdd4

void entry_13cdc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cdc4: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 16), 1560), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13cdd4(rdram, ctx, runtime); return;
    }
    // 0x13cdcc: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x13cdd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13cdd4
// Address: 0x13cdd4 - 0x13cde8

void entry_13cdd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13cdd4) {
        switch (ctx->pc) {
            case 0x13cdd8: ctx->pc = 0; goto label_13cdd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13cdd4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13cdd8:
    // 0x13cdd8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13cddc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13cde4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13cde8; return;
}


// Function: CloneBrk__FP3BRKT0
// Address: 0x13cde8 - 0x13ce0c

void entry_13ce0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ce0c: 0xae510688
    WRITE32(ADD32(GPR_U32(ctx, 18), 1672), GPR_U32(ctx, 17));
    // 0x13ce10: 0x8e0506b4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1716)));
    // 0x13ce14: 0x10a00005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13CE2C; return;
    }
    // 0x13ce1c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x13ce24);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 36));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_13ce24
// Address: 0x13ce24 - 0x13ce40

void entry_13ce24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ce24) {
        switch (ctx->pc) {
            case 0x13ce2c: ctx->pc = 0; goto label_13ce2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ce24: 0xae4206b4
    WRITE32(ADD32(GPR_U32(ctx, 18), 1716), GPR_U32(ctx, 2));
    // 0x13ce28: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_13ce2c:
    // 0x13ce2c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13ce30: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ce34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ce38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostBrkLoad__FP3BRK
// Address: 0x13ce40 - 0x13ce54

void entry_13ce54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ce54: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x13ce58: 0x3c050014
    SET_GPR_U32(ctx, 5, ((uint32_t)20 << 16));
    // 0x13ce5c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13ce60: 0x24a5ce80
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954624));
    // 0x13ce64: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13ce68: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x13ce70);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_13ce70
// Address: 0x13ce70 - 0x13ce80

void entry_13ce70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ce70: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ce74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ce78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostBrkLoadCallbackHookup__FP3BRK5MSGIDPv
// Address: 0x13ce80 - 0x13ceb0

void entry_13ceb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ceb0) {
        switch (ctx->pc) {
            case 0x13cebc: ctx->pc = 0; goto label_13cebc;
            case 0x13cef8: ctx->pc = 0; goto label_13cef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ceb0: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13cebc;
    }
    // 0x13ceb8: 0xae620678
    WRITE32(ADD32(GPR_U32(ctx, 19), 1656), GPR_U32(ctx, 2));
label_13cebc:
    // 0x13cebc: 0x26630034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 52));
    // 0x13cec0: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x13cec4: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x13cec8: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13cecc: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x13ced0: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x13ced4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13ced8: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x13cedc: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x13cee0: 0x8e630034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 52)));
    // 0x13cee4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x13cee8: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13ceec: 0x60882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13cef0: 0x12200053
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D040; return;
    }
label_13cef8:
    // 0x13cef8: 0x8e620678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1656)));
    // 0x13cefc: 0x1040000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13CF28; return;
    }
    // 0x13cf04: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13cf0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 46));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13cf0c
// Address: 0x13cf0c - 0x13cf1c

void entry_13cf0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cf0c: 0x10400045
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13d024(rdram, ctx, runtime); return;
    }
    // 0x13cf14: 0xc066704
    SET_GPR_U32(ctx, 31, 0x13cf1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    FUN_00199c10(rdram, ctx, runtime); return;
}


// Function: entry_13cf1c
// Address: 0x13cf1c - 0x13cf34

void entry_13cf1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13cf1c) {
        switch (ctx->pc) {
            case 0x13cf28: ctx->pc = 0; goto label_13cf28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13cf1c: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13cf20: 0x14400041
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D028; return;
    }
label_13cf28:
    // 0x13cf28: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13cf2c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13cf34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 117));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13cf34
// Address: 0x13cf34 - 0x13cf48

void entry_13cf34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cf34: 0x1440003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D028; return;
    }
    // 0x13cf3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13cf40: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13cf48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 122));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13cf48
// Address: 0x13cf48 - 0x13cf5c

void entry_13cf48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cf48: 0x14400037
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D028; return;
    }
    // 0x13cf50: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13cf54: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13cf5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 83));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13cf5c
// Address: 0x13cf5c - 0x13cf70

void entry_13cf5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13cf5c: 0x14400032
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D028; return;
    }
    // 0x13cf64: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13cf68: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13cf70);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 39));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13cf70
// Address: 0x13cf70 - 0x13cfac

void entry_13cf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13cf70) {
        switch (ctx->pc) {
            case 0x13cf78: ctx->pc = 0; goto label_13cf78;
            case 0x13cf80: ctx->pc = 0; goto label_13cf80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13cf70: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1376), GPR_U32(ctx, 19));
        goto label_13cf78;
    }
label_13cf78:
    // 0x13cf78: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13cf7c: 0x0
    // NOP
label_13cf80:
    // 0x13cf80: 0x8e620550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1360)));
    // 0x13cf84: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13cf88: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13cf8c: 0x10400018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13CFF0; return;
    }
    // 0x13cf94: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13cf98: 0x2421018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13cf9c: 0x24420554
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1364));
    // 0x13cfa0: 0x2628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x13cfa4: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x13cfac);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_13cfac
// Address: 0x13cfac - 0x13d024

void entry_13cfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13cfac) {
        switch (ctx->pc) {
            case 0x13cfe0: ctx->pc = 0; goto label_13cfe0;
            case 0x13cff0: ctx->pc = 0; goto label_13cff0;
            case 0x13d014: ctx->pc = 0; goto label_13d014;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13cfac: 0x5040fff4
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x13CF80; return;
    }
    // 0x13cfb4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13cfb8: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x13cfbc: 0x10400008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13cfe0;
    }
    // 0x13cfc4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13cfc8: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x13cfcc: 0x24429db0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942128));
    // 0x13cfd0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13cfd4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13cfd8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
label_13cfe0:
    // 0x13cfe0: 0x8e620550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1360)));
    // 0x13cfe4: 0x242182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13cfe8: 0x1460000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_13d014;
    }
label_13cff0:
    // 0x13cff0: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x13cff4: 0x24830001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 1));
    // 0x13cff8: 0x821018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13cffc: 0xae630550
    WRITE32(ADD32(GPR_U32(ctx, 19), 1360), GPR_U32(ctx, 3));
    // 0x13d000: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13d004: 0x24420554
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1364));
    // 0x13d008: 0x2628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x13d00c: 0xae040000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 4));
    // 0x13d010: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
label_13d014:
    // 0x13d014: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13d018: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x13d01c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d024);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d024
// Address: 0x13d024 - 0x13d068

void entry_13d024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d024) {
        switch (ctx->pc) {
            case 0x13d028: ctx->pc = 0; goto label_13d028;
            case 0x13d040: ctx->pc = 0; goto label_13d040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d024: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_13d028:
    // 0x13d028: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x13d02c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13d030: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13d034: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13d038: 0x1620ffaf
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13CEF8; return;
    }
label_13d040:
    // 0x13d040: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x13d044: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13d048: 0xae82b314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    // 0x13d04c: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13d050: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13d054: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13d058: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13d05c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13d060: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateBrk__FP3BRKf
// Address: 0x13d068 - 0x13d07c

void entry_13d07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d07c: 0x8e020678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1656)));
    // 0x13d080: 0x10400007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D0A0; return;
    }
    // 0x13d088: 0xae000678
    WRITE32(ADD32(GPR_U32(ctx, 16), 1656), GPR_U32(ctx, 0));
    // 0x13d08c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d090: 0x8c430130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 304)));
    // 0x13d094: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13d09c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13d09c
// Address: 0x13d09c - 0x13d0b0

void entry_13d09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d09c) {
        switch (ctx->pc) {
            case 0x13d0a0: ctx->pc = 0; goto label_13d0a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d09c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13d0a0:
    // 0x13d0a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13d0a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13d0ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13d0b0; return;
}


// Function: FAbsorbBrkWkr__FP3BRKP3WKR
// Address: 0x13d0b0 - 0x13d130

void entry_13d130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d130) {
        switch (ctx->pc) {
            case 0x13d14c: ctx->pc = 0; goto label_13d14c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d130: 0x5040fff7
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
        ctx->pc = 0x13D110; return;
    }
    // 0x13d138: 0x8e220668
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1640)));
    // 0x13d13c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13d140: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 12)));
        ctx->pc = 0x13D164; return;
    }
    // 0x13d148: 0x8e650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_13d14c:
    // 0x13d14c: 0xc04f6ca
    SET_GPR_U32(ctx, 31, 0x13d154);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCheckBrkTouchObject__FP3BRKP2SO(rdram, ctx, runtime); return;
}


// Function: entry_13d154
// Address: 0x13d154 - 0x13d1a8

void entry_13d154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d154) {
        switch (ctx->pc) {
            case 0x13d15c: ctx->pc = 0; goto label_13d15c;
            case 0x13d164: ctx->pc = 0; goto label_13d164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d154: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 12)));
        goto label_13d164;
    }
label_13d15c:
    // 0x13d15c: 0x1000003f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D25C; return;
    }
label_13d164:
    // 0x13d164: 0x30620004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4));
    // 0x13d168: 0x1440003c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D25C; return;
    }
    // 0x13d170: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x13d174: 0x10400011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13d1bc(rdram, ctx, runtime); return;
    }
    // 0x13d17c: 0x8e220624
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1572)));
    // 0x13d180: 0xda610030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 48)));
    // 0x13d184: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13d188: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13d18c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d190: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d194: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13d198: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13d19c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d1a0: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x13d1a8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_13d1a8
// Address: 0x13d1a8 - 0x13d1bc

void entry_13d1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d1a8: 0xc66c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[12] = *(float*)&val; }
    // 0x13d1ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13d1b0: 0x26650020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 32));
    // 0x13d1b4: 0xc06f038
    SET_GPR_U32(ctx, 31, 0x13d1bc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ApplySoImpulse__FP2SOP6VECTORT1f(rdram, ctx, runtime); return;
}


// Function: entry_13d1bc
// Address: 0x13d1bc - 0x13d1d4

void entry_13d1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d1bc: 0x8e62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x13d1c0: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x13d1c4: 0x10400025
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D25C; return;
    }
    // 0x13d1cc: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x13d1d4);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13d1d4
// Address: 0x13d1d4 - 0x13d20c

void entry_13d1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d1d4: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x13d1d8: 0x5462000d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
        ctx->pc = 0x13D210; return;
    }
    // 0x13d1e0: 0x8e620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x13d1e4: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x13d1e8: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
        ctx->pc = 0x13D210; return;
    }
    // 0x13d1f0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13d1f4: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x13d1f8: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x13d1fc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13d200: 0x24842c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    // 0x13d204: 0xc05bb0e
    SET_GPR_U32(ctx, 31, 0x13d20c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    TriggerJoyRumbleRumk__FP3JOY4RUMKf(rdram, ctx, runtime); return;
}


// Function: entry_13d20c
// Address: 0x13d20c - 0x13d234

void entry_13d20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d20c) {
        switch (ctx->pc) {
            case 0x13d210: ctx->pc = 0; goto label_13d210;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d20c: 0x8e230690
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
label_13d210:
    // 0x13d210: 0x26220690
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1680));
    // 0x13d214: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x13d218: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13d21c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x13d220: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x13d224: 0xae230690
    WRITE32(ADD32(GPR_U32(ctx, 17), 1680), GPR_U32(ctx, 3));
    // 0x13d228: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13d22c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x13d234);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_13d234
// Address: 0x13d234 - 0x13d258

void entry_13d234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d234: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    // 0x13d238: 0x8e23068c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1676)));
    // 0x13d23c: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x13d240: 0x14400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D25C; return;
    }
    // 0x13d248: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13d24c: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x13d250: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d258);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d258
// Address: 0x13d258 - 0x13d278

void entry_13d258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d258) {
        switch (ctx->pc) {
            case 0x13d25c: ctx->pc = 0; goto label_13d25c;
            case 0x13d260: ctx->pc = 0; goto label_13d260;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d258: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_13d25c:
    // 0x13d25c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_13d260:
    // 0x13d260: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13d264: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13d268: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13d26c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13d270: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BreakBrk__FP3BRK
// Address: 0x13d278 - 0x13d2d4

void entry_13d2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d2d4) {
        switch (ctx->pc) {
            case 0x13d300: ctx->pc = 0; goto label_13d300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d2d4: 0x2b82b
    SET_GPR_U32(ctx, 23, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x13d2d8: 0x8e220684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1668)));
    // 0x13d2dc: 0x1440012b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D78C; return;
    }
    // 0x13d2e4: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x13d2e8: 0x184000d4
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13D63C; return;
    }
    // 0x13d2f0: 0x3c160025
    SET_GPR_U32(ctx, 22, ((uint32_t)37 << 16));
    // 0x13d2f4: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13d2f8: 0x26d58d30
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 22), 4294937904));
    // 0x13d2fc: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
label_13d300:
    // 0x13d300: 0x2621018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13d304: 0x24420554
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1364));
    // 0x13d308: 0x2229021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x13d30c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13d310: 0x506000c6
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
        ctx->pc = 0x13D62C; return;
    }
    // 0x13d318: 0x8e500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x13d31c: 0x520000c3
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
        ctx->pc = 0x13D62C; return;
    }
    // 0x13d324: 0x8e250638
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1592)));
    // 0x13d328: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x13d330);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_13d330
// Address: 0x13d330 - 0x13d340

void entry_13d330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d330: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x13d334: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13d338: 0xc076ec8
    SET_GPR_U32(ctx, 31, 0x13d340);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FOverflowSwLo__FP2SWP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_13d340
// Address: 0x13d340 - 0x13d37c

void entry_13d340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d340: 0x544000ba
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
        ctx->pc = 0x13D62C; return;
    }
    // 0x13d348: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d34c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13d350: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x13d354: 0x5040004d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x13D48C; return;
    }
    // 0x13d35c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13d360: 0x2442fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x13d364: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x13d368: 0x54400048
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x13D48C; return;
    }
    // 0x13d370: 0xc62d0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[13] = *(float*)&val; }
    // 0x13d374: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13d37c);
    ctx->f[12] = FPU_NEG_S(ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13d37c
// Address: 0x13d37c - 0x13d38c

void entry_13d37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d37c: 0xc62d0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[13] = *(float*)&val; }
    // 0x13d380: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x13d384: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13d38c);
    ctx->f[12] = FPU_NEG_S(ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13d38c
// Address: 0x13d38c - 0x13d39c

void entry_13d38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d38c: 0xc62d0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[13] = *(float*)&val; }
    // 0x13d390: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x13d394: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13d39c);
    ctx->f[12] = FPU_NEG_S(ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13d39c
// Address: 0x13d39c - 0x13d3cc

void entry_13d39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d39c: 0x4403a800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[21]);
    // 0x13d3a0: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x13d3a4: 0x70431c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13d3a8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13d3ac: 0x70431b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13d3b0: 0xc62c0628
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1576)); ctx->f[12] = *(float*)&val; }
    // 0x13d3b4: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13d3b8: 0xc62d062c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1580)); ctx->f[13] = *(float*)&val; }
    // 0x13d3bc: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13d3c0: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13d3c4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13d3cc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13d3cc
// Address: 0x13d3cc - 0x13d404

void entry_13d3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d3cc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13d3d0: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13d3d4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13d3d8: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13d3dc: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13d3e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d3e4: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x13d3e8: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13d3ec: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13d3f0: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13d3f4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d3f8: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x13d3fc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13d404);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13d404
// Address: 0x13d404 - 0x13d410

void entry_13d404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d404: 0xc62d0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[13] = *(float*)&val; }
    // 0x13d408: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13d410);
    ctx->f[12] = FPU_NEG_S(ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13d410
// Address: 0x13d410 - 0x13d420

void entry_13d410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d410: 0xc62d0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[13] = *(float*)&val; }
    // 0x13d414: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x13d418: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13d420);
    ctx->f[12] = FPU_NEG_S(ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13d420
// Address: 0x13d420 - 0x13d430

void entry_13d420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d420: 0xc62d0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[13] = *(float*)&val; }
    // 0x13d424: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x13d428: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x13d430);
    ctx->f[12] = FPU_NEG_S(ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_13d430
// Address: 0x13d430 - 0x13d460

void entry_13d430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d430: 0x4403a800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[21]);
    // 0x13d434: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x13d438: 0x70431c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13d43c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13d440: 0x70431b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x13d444: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d448: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x13d44c: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    // 0x13d450: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d454: 0x8c430094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 148)));
    // 0x13d458: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13d460);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13d460
// Address: 0x13d460 - 0x13d488

void entry_13d460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d460: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d464: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x13d468: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x13d46c: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13d488(rdram, ctx, runtime); return;
    }
    // 0x13d474: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d478: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d47c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d480: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x13d488);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_13d488
// Address: 0x13d488 - 0x13d4b0

void entry_13d488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d488) {
        switch (ctx->pc) {
            case 0x13d48c: ctx->pc = 0; goto label_13d48c;
            case 0x13d4a0: ctx->pc = 0; goto label_13d4a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d488: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_13d48c:
    // 0x13d48c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13d490: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_13d4a0;
    }
    // 0x13d498: 0x54620006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x13D4B4; return;
    }
label_13d4a0:
    // 0x13d4a0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d4a4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x13d4a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d4b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d4b0
// Address: 0x13d4b0 - 0x13d4e0

void entry_13d4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d4b0) {
        switch (ctx->pc) {
            case 0x13d4b4: ctx->pc = 0; goto label_13d4b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d4b0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_13d4b4:
    // 0x13d4b4: 0x2442fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x13d4b8: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x13d4bc: 0x1440000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D4E8; return;
    }
    // 0x13d4c4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13d4c8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x13d4cc: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D4E8; return;
    }
    // 0x13d4d4: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x13d4d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d4e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d4e0
// Address: 0x13d4e0 - 0x13d4f8

void entry_13d4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d4e0) {
        switch (ctx->pc) {
            case 0x13d4e8: ctx->pc = 0; goto label_13d4e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d4e0: 0x10000006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D4FC; return;
    }
label_13d4e8:
    // 0x13d4e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d4ec: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x13d4f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d4f8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d4f8
// Address: 0x13d4f8 - 0x13d52c

void entry_13d4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d4f8) {
        switch (ctx->pc) {
            case 0x13d4fc: ctx->pc = 0; goto label_13d4fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d4f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_13d4fc:
    // 0x13d4fc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13d500: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x13d504: 0x50400041
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
        ctx->pc = 0x13D60C; return;
    }
    // 0x13d50c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13d510: 0x2442fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x13d514: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x13d518: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D548; return;
    }
    // 0x13d520: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x13d524: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d52c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d52c
// Address: 0x13d52c - 0x13d540

void entry_13d52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d52c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d530: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d534: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x13d538: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d540);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d540
// Address: 0x13d540 - 0x13d550

void entry_13d540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d540) {
        switch (ctx->pc) {
            case 0x13d548: ctx->pc = 0; goto label_13d548;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d540: 0x10000032
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D60C; return;
    }
label_13d548:
    // 0x13d548: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13d550);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 46));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13d550
// Address: 0x13d550 - 0x13d564

void entry_13d550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d550: 0x14400006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D56C; return;
    }
    // 0x13d558: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d55c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13d564);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 85));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13d564
// Address: 0x13d564 - 0x13d578

void entry_13d564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d564) {
        switch (ctx->pc) {
            case 0x13d56c: ctx->pc = 0; goto label_13d56c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d564: 0x10400028
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13d608(rdram, ctx, runtime); return;
    }
label_13d56c:
    // 0x13d56c: 0x260400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
    // 0x13d570: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x13d578);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_13d578
// Address: 0x13d578 - 0x13d58c

void entry_13d578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d578: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d57c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d580: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x13d584: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d58c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d58c
// Address: 0x13d58c - 0x13d5a0

void entry_13d58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d58c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d590: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d594: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x13d598: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d5a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 4294937904));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d5a0
// Address: 0x13d5a0 - 0x13d5ac

void entry_13d5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d5a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d5a4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13d5ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 46));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13d5ac
// Address: 0x13d5ac - 0x13d5c8

void entry_13d5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d5ac: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D5D0; return;
    }
    // 0x13d5b4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d5b8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d5bc: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x13d5c0: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x13d5c8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_13d5c8
// Address: 0x13d5c8 - 0x13d5d8

void entry_13d5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d5c8) {
        switch (ctx->pc) {
            case 0x13d5d0: ctx->pc = 0; goto label_13d5d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d5c8: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D60C; return;
    }
label_13d5d0:
    // 0x13d5d0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13d5d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 89));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13d5d8
// Address: 0x13d5d8 - 0x13d5f0

void entry_13d5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d5d8: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D5F8; return;
    }
    // 0x13d5e0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d5e4: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x13d5e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d5f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d5f0
// Address: 0x13d5f0 - 0x13d608

void entry_13d5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d5f0) {
        switch (ctx->pc) {
            case 0x13d5f8: ctx->pc = 0; goto label_13d5f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d5f0: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D60C; return;
    }
label_13d5f8:
    // 0x13d5f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d5fc: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x13d600: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d608);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d608
// Address: 0x13d608 - 0x13d628

void entry_13d608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d608) {
        switch (ctx->pc) {
            case 0x13d60c: ctx->pc = 0; goto label_13d60c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d608: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
label_13d60c:
    // 0x13d60c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13d610: 0xafb00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 16));
    // 0x13d614: 0x2405000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    // 0x13d618: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13d61c: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x13d620: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13d628);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13d628
// Address: 0x13d628 - 0x13d6ac

void entry_13d628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d628) {
        switch (ctx->pc) {
            case 0x13d62c: ctx->pc = 0; goto label_13d62c;
            case 0x13d63c: ctx->pc = 0; goto label_13d63c;
            case 0x13d660: ctx->pc = 0; goto label_13d660;
            case 0x13d66c: ctx->pc = 0; goto label_13d66c;
            case 0x13d670: ctx->pc = 0; goto label_13d670;
            case 0x13d678: ctx->pc = 0; goto label_13d678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d628: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
label_13d62c:
    // 0x13d62c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x13d630: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x13d634: 0x1440ff32
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D300; return;
    }
label_13d63c:
    // 0x13d63c: 0x56e0004c
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
        ctx->pc = 0x13D770; return;
    }
    // 0x13d644: 0x8e23061c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1564)));
    // 0x13d648: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_13d660;
    }
    // 0x13d650: 0x50620006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 680)); ctx->f[1] = *(float*)&val; }
        goto label_13d66c;
    }
    // 0x13d658: 0x10000007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1560)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13d678;
    }
label_13d660:
    // 0x13d660: 0xc62102a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 676)); ctx->f[1] = *(float*)&val; }
    // 0x13d664: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13d670;
    }
label_13d66c:
    // 0x13d66c: 0xc62003d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 976)); ctx->f[0] = *(float*)&val; }
label_13d670:
    // 0x13d670: 0x460105a8
    ctx->f[22] = std::max(ctx->f[0], ctx->f[1]);
    // 0x13d674: 0x8e230618
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1560)));
label_13d678:
    // 0x13d678: 0x1060000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D6B4; return;
    }
    // 0x13d680: 0xc6200620
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1568)); ctx->f[0] = *(float*)&val; }
    // 0x13d684: 0xafa20040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    // 0x13d688: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13d68c: 0xe7a00070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x13d690: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x13d694: 0xe7b60074
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 116), *(uint32_t*)&val); }
    // 0x13d698: 0xafb10044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 17));
    // 0x13d69c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13d6a0: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x13d6a4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x13d6ac);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 320));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_13d6ac
// Address: 0x13d6ac - 0x13d6c4

void entry_13d6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d6ac) {
        switch (ctx->pc) {
            case 0x13d6b4: ctx->pc = 0; goto label_13d6b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d6ac: 0x10000006
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D6C8; return;
    }
label_13d6b4:
    // 0x13d6b4: 0x26300140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 320));
    // 0x13d6b8: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x13d6bc: 0xc0559b2
    SET_GPR_U32(ctx, 31, 0x13d6c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StandardSmokeCloud__FP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_13d6c4
// Address: 0x13d6c4 - 0x13d6d8

void entry_13d6c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d6c4) {
        switch (ctx->pc) {
            case 0x13d6c8: ctx->pc = 0; goto label_13d6c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d6c4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_13d6c8:
    // 0x13d6c8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13d6cc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d6d0: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x13d6d8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1696));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_13d6d8
// Address: 0x13d6d8 - 0x13d6f0

void entry_13d6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d6d8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13d6dc: 0x8e260698
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1688)));
    // 0x13d6e0: 0x8e2706b0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1712)));
    // 0x13d6e4: 0x24841ef0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    // 0x13d6e8: 0xc054804
    SET_GPR_U32(ctx, 31, 0x13d6f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    OnDifficultyBreak(rdram, ctx, runtime); return;
}


// Function: entry_13d6f0
// Address: 0x13d6f0 - 0x13d728

void entry_13d6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d6f0: 0x8e2206b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1716)));
    // 0x13d6f4: 0x1040000e
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D730; return;
    }
    // 0x13d6fc: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x13d700: 0xc44e000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[14] = *(float*)&val; }
    // 0x13d704: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d708: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13d70c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d710: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x13d714: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x13d718: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x13d71c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d720: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x13d728);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_13d728
// Address: 0x13d728 - 0x13d76c

void entry_13d728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d728) {
        switch (ctx->pc) {
            case 0x13d730: ctx->pc = 0; goto label_13d730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d728: 0x10000011
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D770; return;
    }
label_13d730:
    // 0x13d730: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x13d734: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x13d738: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x13d73c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13d740: 0x2404002a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 42));
    // 0x13d744: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x13d748: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x13d74c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d750: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13d754: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x13d758: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d75c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x13d760: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d764: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x13d76c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_13d76c
// Address: 0x13d76c - 0x13d788

void entry_13d76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d76c) {
        switch (ctx->pc) {
            case 0x13d770: ctx->pc = 0; goto label_13d770;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d76c: 0x8e22067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
label_13d770:
    // 0x13d770: 0x14400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D78C; return;
    }
    // 0x13d778: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13d77c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x13d780: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d788);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d788
// Address: 0x13d788 - 0x13d79c

void entry_13d788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d788) {
        switch (ctx->pc) {
            case 0x13d78c: ctx->pc = 0; goto label_13d78c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d788: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_13d78c:
    // 0x13d78c: 0x8e250688
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1672)));
    // 0x13d790: 0x27c41420
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 5152));
    // 0x13d794: 0xc050410
    SET_GPR_U32(ctx, 31, 0x13d79c);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1664), GPR_U32(ctx, 2));
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_13d79c
// Address: 0x13d79c - 0x13d7b4

void entry_13d79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d79c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13d7a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13d7a4: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x13d7a8: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x13d7ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13d7b4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13d7b4
// Address: 0x13d7b4 - 0x13d7cc

void entry_13d7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13d7b4: 0x12e00007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D7D4; return;
    }
    // 0x13d7bc: 0x24050016
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 22));
    // 0x13d7c0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d7c4: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x13d7cc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_13d7cc
// Address: 0x13d7cc - 0x13d7e4

void entry_13d7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d7cc) {
        switch (ctx->pc) {
            case 0x13d7d4: ctx->pc = 0; goto label_13d7d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d7cc: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D7E8; return;
    }
label_13d7d4:
    // 0x13d7d4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x13d7d8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13d7dc: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x13d7e4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_13d7e4
// Address: 0x13d7e4 - 0x13d820

void entry_13d7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d7e4) {
        switch (ctx->pc) {
            case 0x13d7e8: ctx->pc = 0; goto label_13d7e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d7e4: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
label_13d7e8:
    // 0x13d7e8: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x13d7ec: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x13d7f0: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x13d7f4: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x13d7f8: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x13d7fc: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13d800: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13d804: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13d808: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13d80c: 0xc7b60150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[22] = *(float*)&val; }
    // 0x13d810: 0xc7b50148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[21] = *(float*)&val; }
    // 0x13d814: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x13d818: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBrkBroken__FP3BRKi
// Address: 0x13d820 - 0x13d840

void entry_13d840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d840) {
        switch (ctx->pc) {
            case 0x13d848: ctx->pc = 0; goto label_13d848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d840: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13D85C; return;
    }
label_13d848:
    // 0x13d848: 0x8c850688
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1672)));
    // 0x13d84c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x13d850: 0xc050428
    SET_GPR_U32(ctx, 31, 0x13d858);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    ClearChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_13d858
// Address: 0x13d858 - 0x13d868

void entry_13d858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13d858) {
        switch (ctx->pc) {
            case 0x13d85c: ctx->pc = 0; goto label_13d85c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13d858: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_13d85c:
    // 0x13d85c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13d864: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13d868; return;
}


// Function: SetBrkExclude__FP3BRK3OID
// Address: 0x13d868 - 0x13d8b0

void FUN_0013DAB8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dab8) {
        switch (ctx->pc) {
            case 0x13dae4: ctx->pc = 0; goto label_13dae4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dab8: 0x8c830668
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1640)));
    // 0x13dabc: 0x2c620003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 3));
    // 0x13dac0: 0x10400008
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13dae4;
    }
    // 0x13dac8: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x13dacc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x13dad0: 0xac45066c
    WRITE32(ADD32(GPR_U32(ctx, 2), 1644), GPR_U32(ctx, 5));
    // 0x13dad4: 0xac830668
    WRITE32(ADD32(GPR_U32(ctx, 4), 1640), GPR_U32(ctx, 3));
    // 0x13dad8: 0x8c82063c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1596)));
    // 0x13dadc: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x13dae0: 0xac82063c
    WRITE32(ADD32(GPR_U32(ctx, 4), 1596), GPR_U32(ctx, 2));
label_13dae4:
    // 0x13dae4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13daec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13daf0; return;
}


// Function: PsfxEnsureBrk__FP3BRK4ENSK
// Address: 0x13daf0 - 0x13db14

void entry_13db14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13db14) {
        switch (ctx->pc) {
            case 0x13db1c: ctx->pc = 0; goto label_13db1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13db14: 0x8e0206b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1716)));
    // 0x13db18: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13db1c:
    // 0x13db1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13db20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCheckBrkTouchObject__FP3BRKP2SO
// Address: 0x13db28 - 0x13db64

void entry_13db64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13db64) {
        switch (ctx->pc) {
            case 0x13db6c: ctx->pc = 0; goto label_13db6c;
            case 0x13db74: ctx->pc = 0; goto label_13db74;
            case 0x13db9c: ctx->pc = 0; goto label_13db9c;
            case 0x13dbb8: ctx->pc = 0; goto label_13dbb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13db64: 0x56620003
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1596)));
        goto label_13db74;
    }
label_13db6c:
    // 0x13db6c: 0x1000002a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DC18; return;
    }
label_13db74:
    // 0x13db74: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13db78: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x13db7c: 0x10400007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13db9c;
    }
    // 0x13db84: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x13db88: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13db8c: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x13db90: 0x14400021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DC18; return;
    }
    // 0x13db98: 0x30820002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 2));
label_13db9c:
    // 0x13db9c: 0x1040001e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DC18; return;
    }
    // 0x13dba4: 0x8e420640
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1600)));
    // 0x13dba8: 0x1840000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13DBDC; return;
    }
    // 0x13dbb0: 0x26500644
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1604));
    // 0x13dbb4: 0x0
    // NOP
label_13dbb8:
    // 0x13dbb8: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13dbbc: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x13dbc4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_13dbc4
// Address: 0x13dbc4 - 0x13dbfc

void entry_13dbc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dbc4) {
        switch (ctx->pc) {
            case 0x13dbdc: ctx->pc = 0; goto label_13dbdc;
            case 0x13dbf0: ctx->pc = 0; goto label_13dbf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dbc4: 0x1440ffe9
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DB6C; return;
    }
    // 0x13dbcc: 0x8e420640
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1600)));
    // 0x13dbd0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x13dbd4: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DBB8; return;
    }
label_13dbdc:
    // 0x13dbdc: 0x8e420654
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1620)));
    // 0x13dbe0: 0x1840000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13DC14; return;
    }
    // 0x13dbe8: 0x26500658
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1624));
    // 0x13dbec: 0x0
    // NOP
label_13dbf0:
    // 0x13dbf0: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13dbf4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13dbfc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13dbfc
// Address: 0x13dbfc - 0x13dc38

void entry_13dbfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dbfc) {
        switch (ctx->pc) {
            case 0x13dc14: ctx->pc = 0; goto label_13dc14;
            case 0x13dc18: ctx->pc = 0; goto label_13dc18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dbfc: 0x1440ffdb
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DB6C; return;
    }
    // 0x13dc04: 0x8e420654
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1620)));
    // 0x13dc08: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x13dc0c: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DBF0; return;
    }
label_13dc14:
    // 0x13dc14: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13dc18:
    // 0x13dc18: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13dc1c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13dc20: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13dc24: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13dc28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13dc2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13dc34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13dc38; return;
}


// Function: UpdateBrkp__FP4BRKPf
// Address: 0x13dc38 - 0x13dc4c

void entry_13dc4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dc4c) {
        switch (ctx->pc) {
            case 0x13dc8c: ctx->pc = 0; goto label_13dc8c;
            case 0x13dc90: ctx->pc = 0; goto label_13dc90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dc4c: 0x8e050550
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x13dc50: 0x10a0000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_13dc90;
    }
    // 0x13dc58: 0x14a2000d
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_13dc90;
    }
    // 0x13dc60: 0x8e020228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 552)));
    // 0x13dc64: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x13dc68: 0x10400008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13dc8c;
    }
    // 0x13dc70: 0xc6020554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1364)); ctx->f[2] = *(float*)&val; }
    // 0x13dc74: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x13dc78: 0xc6010558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x13dc7c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x13dc80: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13dc84: 0x45000002
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13dc90;
    }
label_13dc8c:
    // 0x13dc8c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
label_13dc90:
    // 0x13dc90: 0xc04f75e
    SET_GPR_U32(ctx, 31, 0x13dc98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBrkpBrkps__FP4BRKP5BRKPS(rdram, ctx, runtime); return;
}


// Function: entry_13dc98
// Address: 0x13dc98 - 0x13dca8

void entry_13dc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13dc98: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13dc9c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13dca0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleBrkpMessage__FP4BRKP5MSGIDPv
// Address: 0x13dca8 - 0x13dccc

void entry_13dccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13dccc: 0x2402000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 15));
    // 0x13dcd0: 0x16020007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x13DCF0; return;
    }
    // 0x13dcd8: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x13dcdc: 0x14920005
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x13DCF4; return;
    }
    // 0x13dce4: 0xc04f75e
    SET_GPR_U32(ctx, 31, 0x13dcec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetBrkpBrkps__FP4BRKP5BRKPS(rdram, ctx, runtime); return;
}


// Function: entry_13dcec
// Address: 0x13dcec - 0x13dd08

void entry_13dcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dcec) {
        switch (ctx->pc) {
            case 0x13dcf0: ctx->pc = 0; goto label_13dcf0;
            case 0x13dcf4: ctx->pc = 0; goto label_13dcf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dcec: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_13dcf0:
    // 0x13dcf0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_13dcf4:
    // 0x13dcf4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13dcf8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13dcfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13dd04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13dd08; return;
}


// Function: FIgnoreBrkpIntersection__FP4BRKPP2SO
// Address: 0x13dd08 - 0x13dd58

void entry_13dd58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dd58) {
        switch (ctx->pc) {
            case 0x13dd68: ctx->pc = 0; goto label_13dd68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dd58: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13dd5c: 0x14600002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_13dd68;
    }
    // 0x13dd64: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_13dd68:
    // 0x13dd68: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13dd6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13dd74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13dd78; return;
}


// Function: SetBrkpBrkps__FP4BRKP5BRKPS
// Address: 0x13dd78 - 0x13dda8

void entry_13dda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13dda8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ddac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13ddb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13ddb8; return;
}


// Function: InitBreak__FP5BREAK
// Address: 0x13ddb8 - 0x13ddcc

void entry_13ddcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ddcc: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x13ddd0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x13ddd4: 0xae020698
    WRITE32(ADD32(GPR_U32(ctx, 16), 1688), GPR_U32(ctx, 2));
    // 0x13ddd8: 0xae03063c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1596), GPR_U32(ctx, 3));
    // 0x13dddc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13dde0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13dde4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13ddec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13ddf0; return;
}


// Function: InitFragile__FP7FRAGILE
// Address: 0x13ddf0 - 0x13de04

void entry_13de04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13de04: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13de08: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13de0c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x13de10: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13de14: 0xae0306c8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1736), GPR_U32(ctx, 3));
    // 0x13de18: 0xae02063c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1596), GPR_U32(ctx, 2));
    // 0x13de1c: 0xe60006c0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1728), *(uint32_t*)&val); }
    // 0x13de20: 0xae0306c4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1732), GPR_U32(ctx, 3));
    // 0x13de24: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13de28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13de2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13de34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13de38; return;
}


// Function: AdjustFragileNewXp__FP7FRAGILEP2XPi
// Address: 0x13de38 - 0x13de84

void entry_13de84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13de84: 0x10400011
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DECC; return;
    }
    // 0x13de8c: 0x8e0506c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1732)));
    // 0x13de90: 0x50b10004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
        ctx->pc = 0x13DEA4; return;
    }
    // 0x13de98: 0xc06ec16
    SET_GPR_U32(ctx, 31, 0x13dea0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSoCnstrForce__FP2SO5CNSTR(rdram, ctx, runtime); return;
}


// Function: entry_13dea0
// Address: 0x13dea0 - 0x13deb4

void entry_13dea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dea0) {
        switch (ctx->pc) {
            case 0x13dea4: ctx->pc = 0; goto label_13dea4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dea0: 0x8e0506c8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
label_13dea4:
    // 0x13dea4: 0x50b10004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 17)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 872)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x13DEB8; return;
    }
    // 0x13deac: 0xc06ec32
    SET_GPR_U32(ctx, 31, 0x13deb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSoCnstrTorque__FP2SO5CNSTR(rdram, ctx, runtime); return;
}


// Function: entry_13deb4
// Address: 0x13deb4 - 0x13dee8

void entry_13deb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13deb4) {
        switch (ctx->pc) {
            case 0x13deb8: ctx->pc = 0; goto label_13deb8;
            case 0x13decc: ctx->pc = 0; goto label_13decc;
            case 0x13ded0: ctx->pc = 0; goto label_13ded0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13deb4: 0xc6000368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 872)); ctx->f[0] = *(float*)&val; }
label_13deb8:
    // 0x13deb8: 0xc60106c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1728)); ctx->f[1] = *(float*)&val; }
    // 0x13debc: 0xae130678
    WRITE32(ADD32(GPR_U32(ctx, 16), 1656), GPR_U32(ctx, 19));
    // 0x13dec0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x13dec4: 0xae1206cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1740), GPR_U32(ctx, 18));
    // 0x13dec8: 0xe6000368
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 872), *(uint32_t*)&val); }
label_13decc:
    // 0x13decc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_13ded0:
    // 0x13ded0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13ded4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13ded8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13dedc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13dee0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustZapbreakNewXp__FP8ZAPBREAKP2XPi
// Address: 0x13dee8 - 0x13df0c

void entry_13df0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13df0c: 0x8e220680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1664)));
    // 0x13df10: 0x14400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DF54; return;
    }
    // 0x13df18: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13df1c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x13df20: 0x501023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x13df24: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x13df28: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x13df2c: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13df30: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13df38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13df38
// Address: 0x13df38 - 0x13df48

void entry_13df38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13df38: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DF50; return;
    }
    // 0x13df40: 0xc04f6ca
    SET_GPR_U32(ctx, 31, 0x13df48);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FCheckBrkTouchObject__FP3BRKP2SO(rdram, ctx, runtime); return;
}


// Function: entry_13df48
// Address: 0x13df48 - 0x13df68

void entry_13df48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13df48) {
        switch (ctx->pc) {
            case 0x13df50: ctx->pc = 0; goto label_13df50;
            case 0x13df54: ctx->pc = 0; goto label_13df54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13df48: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1748), GPR_U32(ctx, 16));
        goto label_13df50;
    }
label_13df50:
    // 0x13df50: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_13df54:
    // 0x13df54: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13df58: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13df5c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13df60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateZapbreak__FP8ZAPBREAKf
// Address: 0x13df68 - 0x13df7c

void entry_13df7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13df7c: 0x8e0206d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1748)));
    // 0x13df80: 0x10400011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13DFC8; return;
    }
    // 0x13df88: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x13df90);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_13df90
// Address: 0x13df90 - 0x13dfac

void entry_13df90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13df90: 0x8e0306d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1748)));
    // 0x13df94: 0x5462000b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1748), GPR_U32(ctx, 0));
        ctx->pc = 0x13DFC4; return;
    }
    // 0x13df9c: 0x8e0506d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1744)));
    // 0x13dfa0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13dfa4: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x13dfac);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13dfac
// Address: 0x13dfac - 0x13dfc0

void entry_13dfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13dfac: 0x8e0406d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1748)));
    // 0x13dfb0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13dfb4: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x13dfb8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13dfc0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13dfc0
// Address: 0x13dfc0 - 0x13dfd8

void entry_13dfc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13dfc0) {
        switch (ctx->pc) {
            case 0x13dfc4: ctx->pc = 0; goto label_13dfc4;
            case 0x13dfc8: ctx->pc = 0; goto label_13dfc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13dfc0: 0xae0006d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1748), GPR_U32(ctx, 0));
label_13dfc4:
    // 0x13dfc4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_13dfc8:
    // 0x13dfc8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13dfcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13dfd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13dfd8; return;
}


// Function: ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG
// Address: 0x13dfd8 - 0x13e158

void entry_13e158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13e158) {
        switch (ctx->pc) {
            case 0x13e1ec: ctx->pc = 0; goto label_13e1ec;
            case 0x13e204: ctx->pc = 0; goto label_13e204;
            case 0x13e238: ctx->pc = 0; goto label_13e238;
            case 0x13e23c: ctx->pc = 0; goto label_13e23c;
            case 0x13e274: ctx->pc = 0; goto label_13e274;
            case 0x13e2e4: ctx->pc = 0; goto label_13e2e4;
            case 0x13e30c: ctx->pc = 0; goto label_13e30c;
            case 0x13e380: ctx->pc = 0; goto label_13e380;
            case 0x13e394: ctx->pc = 0; goto label_13e394;
            case 0x13e398: ctx->pc = 0; goto label_13e398;
            case 0x13e3c8: ctx->pc = 0; goto label_13e3c8;
            case 0x13e3cc: ctx->pc = 0; goto label_13e3cc;
            case 0x13e3d8: ctx->pc = 0; goto label_13e3d8;
            case 0x13e3dc: ctx->pc = 0; goto label_13e3dc;
            case 0x13e3e8: ctx->pc = 0; goto label_13e3e8;
            case 0x13e3f0: ctx->pc = 0; goto label_13e3f0;
            case 0x13e3f4: ctx->pc = 0; goto label_13e3f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13e158: 0x26730070
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 112));
    // 0x13e15c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x13e160: 0xdac40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x13e164: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x13e168: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x13e16c: 0xdaa20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x13e170: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x13e174: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x13e178: 0x48a60800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 6));
    // 0x13e17c: 0xfba10210
    WRITE128(ADD32(GPR_U32(ctx, 29), 528), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13e180: 0xfba30210
    WRITE128(ADD32(GPR_U32(ctx, 29), 528), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13e184: 0x4be121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x13e188: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13e18c: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13e190: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x13e194: 0xdac40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x13e198: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13e19c: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x13e1a0: 0xdaa20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x13e1a4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13e1a8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x13e1ac: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13e1b0: 0xfba10210
    WRITE128(ADD32(GPR_U32(ctx, 29), 528), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13e1b4: 0xfba30210
    WRITE128(ADD32(GPR_U32(ctx, 29), 528), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13e1b8: 0x4be121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x13e1bc: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13e1c0: 0xfa210010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13e1c4: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x13e1c8: 0xae220050
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 2));
    // 0x13e1cc: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x13e1d0: 0xae230054
    WRITE32(ADD32(GPR_U32(ctx, 17), 84), GPR_U32(ctx, 3));
    // 0x13e1d4: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x13e1d8: 0x7ba70220
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x13e1dc: 0x10400003
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13e1ec;
    }
    // 0x13e1e4: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13e1e8: 0x7e220020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 2));
label_13e1ec:
    // 0x13e1ec: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x13e1f0: 0x10400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13e204;
    }
    // 0x13e1f8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13e1fc: 0x7e220030
    WRITE128(ADD32(GPR_U32(ctx, 17), 48), GPR_VEC(ctx, 2));
    // 0x13e200: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
label_13e204:
    // 0x13e204: 0x2692823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 9)));
    // 0x13e208: 0xe6210040
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x13e20c: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x13e210: 0x12800009
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_13e238;
    }
    // 0x13e218: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x13e21c: 0x5e1023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 30)));
    // 0x13e220: 0x521018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13e224: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x13e228: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x13e22c: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x13e230: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13e234: 0xae23004c
    WRITE32(ADD32(GPR_U32(ctx, 17), 76), GPR_U32(ctx, 3));
label_13e238:
    // 0x13e238: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
label_13e23c:
    // 0x13e23c: 0x90102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x13e240: 0x10400069
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13e3e8;
    }
    // 0x13e248: 0x6a060007
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x13e24c: 0x6e060000
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x13e250: 0x6a02000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x13e254: 0x6e020008
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x13e258: 0xb3a60007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13e25c: 0xb7a60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13e260: 0xb3a2000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13e264: 0xb7a20008
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x13e268: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e26c: 0x1040ff84
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967280));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E080; return;
    }
label_13e274:
    // 0x13e274: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e278: 0xdac20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x13e27c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13e280: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x13e284: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13e288: 0x4bc310aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13e28c: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13e290: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13e294: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13e298: 0xc4410010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[1] = *(float*)&val; }
    // 0x13e29c: 0x48261000
    SET_GPR_VEC(ctx, 6, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13e2a0: 0x44860000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 6);
    // 0x13e2a4: 0xdaa10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x13e2a8: 0x46010141
    ctx->f[5] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x13e2ac: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13e2b0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13e2b4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13e2b8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13e2bc: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13e2c0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x13e2c4: 0x46022836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[5], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e2c8: 0x0
    // NOP
    // 0x13e2cc: 0x45000005
    ctx->f[7] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13e2e4;
    }
    // 0x13e2d4: 0x46023836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[7], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e2d8: 0x0
    // NOP
    // 0x13e2dc: 0x4503003b
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
        goto label_13e3cc;
    }
label_13e2e4:
    // 0x13e2e4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x13e2e8: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e2ec: 0x0
    // NOP
    // 0x13e2f0: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_SUB_S(ctx->f[5], ctx->f[7]);
        goto label_13e30c;
    }
    // 0x13e2f8: 0x46070034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[7])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e2fc: 0x0
    // NOP
    // 0x13e300: 0x45030035
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
        goto label_13e3d8;
    }
    // 0x13e308: 0x460728c1
    ctx->f[3] = FPU_SUB_S(ctx->f[5], ctx->f[7]);
label_13e30c:
    // 0x13e30c: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x13e310: 0xc6060004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[6] = *(float*)&val; }
    // 0x13e314: 0x4601a881
    ctx->f[2] = FPU_SUB_S(ctx->f[21], ctx->f[1]);
    // 0x13e318: 0x46032a03
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[8] = copysignf(INFINITY, ctx->f[5] * 0.0f); } else ctx->f[8] = ctx->f[5] / ctx->f[3];
    // 0x13e31c: 0x4606a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[6]);
    // 0x13e320: 0x46051082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[5]);
    // 0x13e324: 0x46063902
    ctx->f[4] = FPU_MUL_S(ctx->f[7], ctx->f[6]);
    // 0x13e328: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x13e32c: 0x460138c2
    ctx->f[3] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x13e330: 0x46080834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[8])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e334: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x13e338: 0x45000016
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13e394;
    }
    // 0x13e340: 0x46064034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[8], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e344: 0x45000013
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13e394;
    }
    // 0x13e34c: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x13e350: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x13e354: 0xe6080004
    { float val = ctx->f[8]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x13e358: 0x46001836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e35c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e360: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13e364: 0x45000006
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13e380;
    }
    // 0x13e36c: 0xae000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
    // 0x13e370: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e374: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x13e378: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e398;
    }
label_13e380:
    // 0x13e380: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e384: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x13e388: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e38c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x13e390: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
label_13e394:
    // 0x13e394: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
label_13e398:
    // 0x13e398: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e39c: 0x0
    // NOP
    // 0x13e3a0: 0x45010009
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_13e3c8;
    }
    // 0x13e3a8: 0x46001832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e3ac: 0x0
    // NOP
    // 0x13e3b0: 0x4502000a
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
        goto label_13e3dc;
    }
    // 0x13e3b8: 0x46002036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e3bc: 0x0
    // NOP
    // 0x13e3c0: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
        goto label_13e3dc;
    }
label_13e3c8:
    // 0x13e3c8: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
label_13e3cc:
    // 0x13e3cc: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x13e3d0: 0x1000ff23
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E060; return;
    }
label_13e3d8:
    // 0x13e3d8: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
label_13e3dc:
    // 0x13e3dc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x13e3e0: 0x1000ff1f
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E060; return;
    }
label_13e3e8:
    // 0x13e3e8: 0x10000002
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e3f4;
    }
label_13e3f0:
    // 0x13e3f0: 0xe0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
label_13e3f4:
    // 0x13e3f4: 0x7bbf02d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 720)));
    // 0x13e3f8: 0x7bbe02c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 704)));
    // 0x13e3fc: 0x7bb702b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 688)));
    // 0x13e400: 0x7bb602a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 672)));
    // 0x13e404: 0x7bb50290
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 656)));
    // 0x13e408: 0x7bb40280
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 640)));
    // 0x13e40c: 0x7bb30270
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x13e410: 0x7bb20260
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x13e414: 0x7bb10250
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x13e418: 0x7bb00240
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x13e41c: 0xc7b502e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 744)); ctx->f[21] = *(float*)&val; }
    // 0x13e420: 0xc7b402e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 736)); ctx->f[20] = *(float*)&val; }
    // 0x13e424: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 752));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13e42c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13e430; return;
}


// Function: PruneBsp__FP3BSPP6VECTORfPP3BSP
// Address: 0x13e430 - 0x13e4f4

void entry_13e4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13e4f4) {
        switch (ctx->pc) {
            case 0x13e504: ctx->pc = 0; goto label_13e504;
            case 0x13e508: ctx->pc = 0; goto label_13e508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13e4f4: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13e4f8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13e4fc: 0x10000002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 3), 4294967284));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e508;
    }
label_13e504:
    // 0x13e504: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13e508:
    // 0x13e508: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x13e50c: 0x10800008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E530; return;
    }
    // 0x13e514: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x13e518: 0xc04f90c
    SET_GPR_U32(ctx, 31, 0x13e520);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_13e520
// Address: 0x13e520 - 0x13e658

void entry_13e520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13e520) {
        switch (ctx->pc) {
            case 0x13e530: ctx->pc = 0; goto label_13e530;
            case 0x13e534: ctx->pc = 0; goto label_13e534;
            case 0x13e548: ctx->pc = 0; goto label_13e548;
            case 0x13e570: ctx->pc = 0; goto label_13e570;
            case 0x13e580: ctx->pc = 0; goto label_13e580;
            case 0x13e588: ctx->pc = 0; goto label_13e588;
            case 0x13e594: ctx->pc = 0; goto label_13e594;
            case 0x13e598: ctx->pc = 0; goto label_13e598;
            case 0x13e5b8: ctx->pc = 0; goto label_13e5b8;
            case 0x13e5c8: ctx->pc = 0; goto label_13e5c8;
            case 0x13e5d8: ctx->pc = 0; goto label_13e5d8;
            case 0x13e5e4: ctx->pc = 0; goto label_13e5e4;
            case 0x13e5e8: ctx->pc = 0; goto label_13e5e8;
            case 0x13e5f0: ctx->pc = 0; goto label_13e5f0;
            case 0x13e5fc: ctx->pc = 0; goto label_13e5fc;
            case 0x13e604: ctx->pc = 0; goto label_13e604;
            case 0x13e618: ctx->pc = 0; goto label_13e618;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13e520: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13e524: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13e528: 0x10000002
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 3), 4294967284));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e534;
    }
label_13e530:
    // 0x13e530: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
label_13e534:
    // 0x13e534: 0x56040004
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_13e548;
    }
    // 0x13e53c: 0x14960036
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 22)) {
        goto label_13e618;
    }
    // 0x13e544: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_13e548:
    // 0x13e548: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13e54c: 0x1217000e
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 23)) {
        goto label_13e588;
    }
    // 0x13e554: 0x2a020002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    // 0x13e558: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13e570;
    }
    // 0x13e560: 0x52000007
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_13e580;
    }
    // 0x13e568: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e598;
    }
label_13e570:
    // 0x13e570: 0x52160008
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 22)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_13e594;
    }
    // 0x13e578: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e598;
    }
label_13e580:
    // 0x13e580: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e598;
    }
label_13e588:
    // 0x13e588: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13e58c: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 30));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e598;
    }
label_13e594:
    // 0x13e594: 0xac540004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 20));
label_13e598:
    // 0x13e598: 0x1097000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 23)) {
        goto label_13e5d8;
    }
    // 0x13e5a0: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13e5b8;
    }
    // 0x13e5a8: 0x10800007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_13e5c8;
    }
    // 0x13e5b0: 0x1000000f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e5f0;
    }
label_13e5b8:
    // 0x13e5b8: 0x1096000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 22)) {
        goto label_13e5e4;
    }
    // 0x13e5c0: 0x1000000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e5f0;
    }
label_13e5c8:
    // 0x13e5c8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x13e5cc: 0x246313e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 5088));
    // 0x13e5d0: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e5e8;
    }
label_13e5d8:
    // 0x13e5d8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13e5dc: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e5e8;
    }
label_13e5e4:
    // 0x13e5e4: 0xac550008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 21));
label_13e5e8:
    // 0x13e5e8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13e5ec: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
label_13e5f0:
    // 0x13e5f0: 0x2442000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 12));
    // 0x13e5f4: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13e618;
    }
label_13e5fc:
    // 0x13e5fc: 0x5620ffa2
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x13E488; return;
    }
label_13e604:
    // 0x13e604: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13e608: 0x0
    // NOP
    // 0x13e60c: 0x45010002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_13e618;
    }
    // 0x13e614: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13e618:
    // 0x13e618: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13e61c: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13e620: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13e624: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13e628: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13e62c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13e630: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13e634: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13e638: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13e63c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13e640: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e644: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x13e648: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13e650: 0x0
    // NOP
    // 0x13e654: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13e658; return;
}


// Function: PbspPointInBspQuick__FP6VECTORP3BSP
// Address: 0x13e658 - 0x13e6c8

void entry_13e710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13e710) {
        switch (ctx->pc) {
            case 0x13e728: ctx->pc = 0; goto label_13e728;
            case 0x13e76c: ctx->pc = 0; goto label_13e76c;
            case 0x13e78c: ctx->pc = 0; goto label_13e78c;
            case 0x13e7a4: ctx->pc = 0; goto label_13e7a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13e710: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13e714: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13e718: 0x18600022
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_13e7a4;
    }
    // 0x13e720: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13e724: 0x0
    // NOP
label_13e728:
    // 0x13e728: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x13e72c: 0x8e650010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x13e730: 0x473021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x13e734: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x13e738: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x13e73c: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x13e740: 0x872021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 7)));
    // 0x13e744: 0x651823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x13e748: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13e74c: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x13e750: 0x8cc50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x13e754: 0x50a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_13e76c;
    }
    // 0x13e75c: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x13e760: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x13e764: 0xa21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x13e768: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_13e76c:
    // 0x13e76c: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
    // 0x13e770: 0x8cc50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x13e774: 0x50a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_13e78c;
    }
    // 0x13e77c: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x13e780: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x13e784: 0xa21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x13e788: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_13e78c:
    // 0x13e78c: 0xac820008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 2));
    // 0x13e790: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x13e794: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13e798: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x13e79c: 0x1440ffe2
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_13e728;
    }
label_13e7a4:
    // 0x13e7a4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13e7a8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13e7ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13e7b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13e7b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e7b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostAshLoad__FP2SWP3ASHP3ALO
// Address: 0x13e7c0 - 0x13e814

void entry_13e814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13e814: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13e818: 0x52000007
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        ctx->pc = 0x13E838; return;
    }
    // 0x13e820: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13e824: 0xc04fa36
    SET_GPR_U32(ctx, 31, 0x13e82c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FAddAshAseg__FP3ASHP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_13e82c
// Address: 0x13e82c - 0x13e834

void entry_13e82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13e82c: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x13e834);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13e834
// Address: 0x13e834 - 0x13e868

void entry_13e834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13e834) {
        switch (ctx->pc) {
            case 0x13e838: ctx->pc = 0; goto label_13e838;
            case 0x13e840: ctx->pc = 0; goto label_13e840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13e834: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_13e838:
    // 0x13e838: 0x1620fff1
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E800; return;
    }
label_13e840:
    // 0x13e840: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13e844: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13e848: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13e84c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13e850: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13e854: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13e858: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e85c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13e864: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13e868; return;
}


// Function: FFoundAshAseg__FP3ASHP4ASEG
// Address: 0x13e868 - 0x13e8a4

void entry_13e8a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13e8a4) {
        switch (ctx->pc) {
            case 0x13e8b8: ctx->pc = 0; goto label_13e8b8;
            case 0x13e8bc: ctx->pc = 0; goto label_13e8bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13e8a4: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_13e8bc;
    }
    // 0x13e8ac: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x13e8b0: 0x601fff9
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967292));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x13E898; return;
    }
label_13e8b8:
    // 0x13e8b8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13e8bc:
    // 0x13e8bc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13e8c0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13e8c4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13e8c8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e8cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13e8d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13e8d8; return;
}


// Function: FAddAshAseg__FP3ASHP4ASEG
// Address: 0x13e8d8 - 0x13e8f8

void entry_13e934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13e934: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x13e938: 0xae020120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 2));
    // 0x13e93c: 0xae030140
    WRITE32(ADD32(GPR_U32(ctx, 16), 320), GPR_U32(ctx, 3));
    // 0x13e940: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13e944: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13e948: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadBtn__FP3BTNP3ALO
// Address: 0x13e950 - 0x13e9cc

void entry_13e9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13e9cc: 0x1440000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E9FC; return;
    }
    // 0x13e9d4: 0x26510008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 8));
    // 0x13e9d8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13e9dc: 0xc04fa1a
    SET_GPR_U32(ctx, 31, 0x13e9e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FFoundAshAseg__FP3ASHP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_13e9e4
// Address: 0x13e9e4 - 0x13e9f8

void entry_13e9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13e9e4: 0x14400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E9FC; return;
    }
    // 0x13e9ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13e9f0: 0xc04fa36
    SET_GPR_U32(ctx, 31, 0x13e9f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FAddAshAseg__FP3ASHP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_13e9f8
// Address: 0x13e9f8 - 0x13ea38

void entry_13e9f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13e9f8) {
        switch (ctx->pc) {
            case 0x13e9fc: ctx->pc = 0; goto label_13e9fc;
            case 0x13ea14: ctx->pc = 0; goto label_13ea14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13e9f8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_13e9fc:
    // 0x13e9fc: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x13ea00: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13ea04: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13ea08: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13ea0c: 0x1600ffe8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13E9B0; return;
    }
label_13ea14:
    // 0x13ea14: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x13ea18: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13ea1c: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x13ea20: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13ea24: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13ea28: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13ea2c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ea30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostBtnLoad__FP3BTN
// Address: 0x13ea38 - 0x13ea80

void entry_13ea80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ea80: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x13ea84: 0x643fffa
    if (GPR_S32(ctx, 18) >= 0) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x13EA70; return;
    }
    // 0x13ea8c: 0x8e22011c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 284)));
    // 0x13ea90: 0x1040000c
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13eac4(rdram, ctx, runtime); return;
    }
    // 0x13ea98: 0x8e250120
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x13ea9c: 0xc050402
    SET_GPR_U32(ctx, 31, 0x13eaa4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_13eaa4
// Address: 0x13eaa4 - 0x13eac4

void entry_13eaa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13eaa4: 0x10400007
    SET_GPR_U32(ctx, 5, ((uint32_t)20 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13eac4(rdram, ctx, runtime); return;
    }
    // 0x13eaac: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13eab0: 0x24a5eae0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294961888));
    // 0x13eab4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13eab8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13eabc: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x13eac4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_13eac4
// Address: 0x13eac4 - 0x13eae0

void entry_13eac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13eac4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13eac8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13eacc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13ead0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ead4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ead8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RestoreBtnFromCheckpointCallback__FP3BTN5MSGIDPv
// Address: 0x13eae0 - 0x13eb0c

void entry_13eb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13eb0c) {
        switch (ctx->pc) {
            case 0x13eb14: ctx->pc = 0; goto label_13eb14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13eb0c: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EB24; return;
    }
label_13eb14:
    // 0x13eb14: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13eb18: 0xc04fbd4
    SET_GPR_U32(ctx, 31, 0x13eb20);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    TriggerBtn__FP3BTNii(rdram, ctx, runtime); return;
}


// Function: entry_13eb20
// Address: 0x13eb20 - 0x13eb30

void entry_13eb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13eb20) {
        switch (ctx->pc) {
            case 0x13eb24: ctx->pc = 0; goto label_13eb24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13eb20: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_13eb24:
    // 0x13eb24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13eb2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13eb30; return;
}


// Function: SetBtnRsmg__FP3BTNi3OIDN22
// Address: 0x13eb30 - 0x13eb5c

void entry_13eb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13eb5c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13eb60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBtnButtons__FP3BTN7BUTTONS
// Address: 0x13eb68 - 0x13ebc4

void entry_13ebc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ebc4: 0x12200004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_13ebd8(rdram, ctx, runtime); return;
    }
    // 0x13ebcc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13ebd0: 0xc04fbd4
    SET_GPR_U32(ctx, 31, 0x13ebd8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TriggerBtn__FP3BTNii(rdram, ctx, runtime); return;
}


// Function: entry_13ebd8
// Address: 0x13ebd8 - 0x13ebe8

void entry_13ebd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ebd8: 0x12400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_13ebe8(rdram, ctx, runtime); return;
    }
    // 0x13ebe0: 0xc04fc1c
    SET_GPR_U32(ctx, 31, 0x13ebe8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UntriggerBtn__FP3BTNi(rdram, ctx, runtime); return;
}


// Function: entry_13ebe8
// Address: 0x13ebe8 - 0x13ec00

void entry_13ebe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ebe8) {
        switch (ctx->pc) {
            case 0x13ebec: ctx->pc = 0; goto label_13ebec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ebe8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_13ebec:
    // 0x13ebec: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13ebf0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ebf4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ebf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FAddRsmg__FP4RSMGiPii3OIDN24
// Address: 0x13ec00 - 0x13ecb0

void entry_13ed1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13ed1c: 0x14570012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 23)) {
        ctx->pc = 0x13ED68; return;
    }
    // 0x13ed24: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ed28: 0xc04a708
    SET_GPR_U32(ctx, 31, 0x13ed30);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    PsmaFindAlo__FP3ALO3OID(rdram, ctx, runtime); return;
}


// Function: entry_13ed30
// Address: 0x13ed30 - 0x13ed54

void entry_13ed30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ed30) {
        switch (ctx->pc) {
            case 0x13ed44: ctx->pc = 0; goto label_13ed44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ed30: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        ctx->pc = 0x13ED58; return;
    }
    // 0x13ed38: 0x52600002
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_13ed44;
    }
    // 0x13ed40: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_13ed44:
    // 0x13ed44: 0x50b60004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 22)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        ctx->pc = 0x13ED58; return;
    }
    // 0x13ed4c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x13ed54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_13ed54
// Address: 0x13ed54 - 0x13ed90

void entry_13ed54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ed54) {
        switch (ctx->pc) {
            case 0x13ed58: ctx->pc = 0; goto label_13ed58;
            case 0x13ed64: ctx->pc = 0; goto label_13ed64;
            case 0x13ed68: ctx->pc = 0; goto label_13ed68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ed54: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_13ed58:
    // 0x13ed58: 0x232102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 18)));
    // 0x13ed5c: 0x1440ffe8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13ED00; return;
    }
label_13ed64:
    // 0x13ed64: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_13ed68:
    // 0x13ed68: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13ed6c: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13ed70: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13ed74: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13ed78: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13ed7c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13ed80: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13ed84: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ed88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RunBtnAsegs__FP3BTN4IASHi
// Address: 0x13ed90 - 0x13ee0c

void entry_13ee0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ee0c) {
        switch (ctx->pc) {
            case 0x13ee1c: ctx->pc = 0; goto label_13ee1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ee0c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 64)));
        goto label_13ee1c;
    }
    // 0x13ee14: 0x10000007
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EE34; return;
    }
label_13ee1c:
    // 0x13ee1c: 0x50b70005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 23)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x13EE34; return;
    }
    // 0x13ee24: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x13ee28: 0xc056912
    SET_GPR_U32(ctx, 31, 0x13ee30);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 20)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13ee30
// Address: 0x13ee30 - 0x13ee84

void entry_13ee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ee30) {
        switch (ctx->pc) {
            case 0x13ee34: ctx->pc = 0; goto label_13ee34;
            case 0x13ee58: ctx->pc = 0; goto label_13ee58;
            case 0x13ee6c: ctx->pc = 0; goto label_13ee6c;
            case 0x13ee74: ctx->pc = 0; goto label_13ee74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ee30: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_13ee34:
    // 0x13ee34: 0x52a00008
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 312)));
        goto label_13ee58;
    }
    // 0x13ee3c: 0x8e020044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x13ee40: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 312)));
        goto label_13ee58;
    }
    // 0x13ee48: 0xc62d0118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 280)); ctx->f[13] = *(float*)&val; }
    // 0x13ee4c: 0x460da036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13ee50: 0x10000006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13ee6c;
    }
label_13ee58:
    // 0x13ee58: 0x1040000c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EE8C; return;
    }
    // 0x13ee60: 0xc62d0118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 280)); ctx->f[13] = *(float*)&val; }
    // 0x13ee64: 0x46146834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13ee68: 0x0
    // NOP
label_13ee6c:
    // 0x13ee6c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
        goto label_13ee74;
    }
label_13ee74:
    // 0x13ee74: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x13ee78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13ee7c: 0xc04b23e
    SET_GPR_U32(ctx, 31, 0x13ee84);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PasegaEnsureAseg__FP4ASEGP3ALO4SEEKffi(rdram, ctx, runtime); return;
}


// Function: entry_13ee84
// Address: 0x13ee84 - 0x13eea4

void entry_13ee84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ee84) {
        switch (ctx->pc) {
            case 0x13ee8c: ctx->pc = 0; goto label_13ee8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ee84: 0x10000008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EEA8; return;
    }
label_13ee8c:
    // 0x13ee8c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x13ee90: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13ee94: 0xc62d0118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 280)); ctx->f[13] = *(float*)&val; }
    // 0x13ee98: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13ee9c: 0xc04b23e
    SET_GPR_U32(ctx, 31, 0x13eea4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PasegaEnsureAseg__FP4ASEGP3ALO4SEEKffi(rdram, ctx, runtime); return;
}


// Function: entry_13eea4
// Address: 0x13eea4 - 0x13eecc

void entry_13eea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13eea4) {
        switch (ctx->pc) {
            case 0x13eea8: ctx->pc = 0; goto label_13eea8;
            case 0x13eeb4: ctx->pc = 0; goto label_13eeb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13eea4: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
label_13eea8:
    // 0x13eea8: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x13eeac: 0x5640ffd4
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x13EE00; return;
    }
label_13eeb4:
    // 0x13eeb4: 0x8e270004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x13eeb8: 0x2626014c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 332));
    // 0x13eebc: 0x8e250148
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 328)));
    // 0x13eec0: 0x2e880001
    SET_GPR_U32(ctx, 8, SLTU32(GPR_U32(ctx, 20), 1));
    // 0x13eec4: 0xc04fb2c
    SET_GPR_U32(ctx, 31, 0x13eecc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 20)));
    TriggerRsmg__FP2SWiP4RSMGP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_13eecc
// Address: 0x13eecc - 0x13eef0

void entry_13eecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13eecc: 0x8e250140
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x13eed0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x13eed4: 0x10a20012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x13EF20; return;
    }
    // 0x13eedc: 0x56c00011
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
        ctx->pc = 0x13EF24; return;
    }
    // 0x13eee4: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x13eee8: 0xc056912
    SET_GPR_U32(ctx, 31, 0x13eef0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 20)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_13eef0
// Address: 0x13eef0 - 0x13ef0c

void entry_13eef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13eef0: 0x12800008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EF14; return;
    }
    // 0x13eef8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13eefc: 0x16820008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x13EF20; return;
    }
    // 0x13ef04: 0xc05466a
    SET_GPR_U32(ctx, 31, 0x13ef0c);
    UntriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_13ef0c
// Address: 0x13ef0c - 0x13ef1c

void entry_13ef0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ef0c) {
        switch (ctx->pc) {
            case 0x13ef14: ctx->pc = 0; goto label_13ef14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ef0c: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EF20; return;
    }
label_13ef14:
    // 0x13ef14: 0xc05462e
    SET_GPR_U32(ctx, 31, 0x13ef1c);
    TriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_13ef1c
// Address: 0x13ef1c - 0x13ef50

void entry_13ef1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ef1c) {
        switch (ctx->pc) {
            case 0x13ef20: ctx->pc = 0; goto label_13ef20;
            case 0x13ef24: ctx->pc = 0; goto label_13ef24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ef1c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_13ef20:
    // 0x13ef20: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_13ef24:
    // 0x13ef24: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13ef28: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13ef2c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13ef30: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13ef34: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13ef38: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13ef3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13ef40: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x13ef44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13ef4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13ef50; return;
}


// Function: TriggerBtn__FP3BTNii
// Address: 0x13ef50 - 0x13ef88

void entry_13ef88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ef88) {
        switch (ctx->pc) {
            case 0x13ef90: ctx->pc = 0; goto label_13ef90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ef88: 0x10000007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 308)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EFA8; return;
    }
label_13ef90:
    // 0x13ef90: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x13ef94: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x13ef98: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13ef9c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x13efa4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_13efa4
// Address: 0x13efa4 - 0x13eff8

void entry_13efa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13efa4) {
        switch (ctx->pc) {
            case 0x13efa8: ctx->pc = 0; goto label_13efa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13efa4: 0x8e020134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 308)));
label_13efa8:
    // 0x13efa8: 0x14400014
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13EFFC; return;
    }
    // 0x13efb0: 0x16200013
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F000; return;
    }
    // 0x13efb8: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x13efbc: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x13efc0: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x13efc4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13efc8: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x13efcc: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x13efd0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x13efd4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13efd8: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x13efdc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x13efe0: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x13efe4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x13efe8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x13efec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13eff0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x13eff8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_13eff8
// Address: 0x13eff8 - 0x13f00c

void entry_13eff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13eff8) {
        switch (ctx->pc) {
            case 0x13effc: ctx->pc = 0; goto label_13effc;
            case 0x13f000: ctx->pc = 0; goto label_13f000;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13eff8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_13effc:
    // 0x13effc: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_13f000:
    // 0x13f000: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f004: 0xc04fb64
    SET_GPR_U32(ctx, 31, 0x13f00c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RunBtnAsegs__FP3BTN4IASHi(rdram, ctx, runtime); return;
}


// Function: entry_13f00c
// Address: 0x13f00c - 0x13f024

void entry_13f00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f00c: 0x8e02013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 316)));
    // 0x13f010: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 284)));
        ctx->pc = 0x13F028; return;
    }
    // 0x13f018: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f01c: 0xc04fada
    SET_GPR_U32(ctx, 31, 0x13f024);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetBtnButtons__FP3BTN7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_13f024
// Address: 0x13f024 - 0x13f03c

void entry_13f024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f024) {
        switch (ctx->pc) {
            case 0x13f028: ctx->pc = 0; goto label_13f028;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f024: 0x8e02011c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 284)));
label_13f028:
    // 0x13f028: 0x10400004
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13f03c(rdram, ctx, runtime); return;
    }
    // 0x13f030: 0x8e050120
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x13f034: 0xc050410
    SET_GPR_U32(ctx, 31, 0x13f03c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_13f03c
// Address: 0x13f03c - 0x13f054

void entry_13f03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f03c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x13f040: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f044: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13f048: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x13f04c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13f054);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13f054
// Address: 0x13f054 - 0x13f070

void entry_13f054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f054: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13f058: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13f05c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f060: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f064: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13f06c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13f070; return;
}


// Function: UntriggerBtn__FP3BTNi
// Address: 0x13f070 - 0x13f09c

void entry_13f09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f09c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13f0a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f0a4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13f0a8: 0xc04fb64
    SET_GPR_U32(ctx, 31, 0x13f0b0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RunBtnAsegs__FP3BTN4IASHi(rdram, ctx, runtime); return;
}


// Function: entry_13f0b0
// Address: 0x13f0b0 - 0x13f0c8

void entry_13f0b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f0b0: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x13f0b4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f0b8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13f0bc: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x13f0c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13f0c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13f0c8
// Address: 0x13f0c8 - 0x13f0e0

void entry_13f0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f0c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13f0cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f0d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f0d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13f0dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13f0e0; return;
}


// Function: InitButton__FP6BUTTON
// Address: 0x13f0e0 - 0x13f0f4

void entry_13f0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f0f4: 0xc04fa46
    SET_GPR_U32(ctx, 31, 0x13f0fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1364));
    InitBtn__FP3BTN(rdram, ctx, runtime); return;
}


// Function: entry_13f0fc
// Address: 0x13f0fc - 0x13f110

void entry_13f0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f0fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f100: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f104: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13f10c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13f110; return;
}


// Function: LoadButtonFromBrx__FP6BUTTONP18CBinaryInputStream
// Address: 0x13f110 - 0x13f124

void entry_13f124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f124: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f128: 0xc04fa54
    SET_GPR_U32(ctx, 31, 0x13f130);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1364));
    LoadBtn__FP3BTNP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13f130
// Address: 0x13f130 - 0x13f140

void entry_13f130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f130: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f134: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f138: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InsertButtonPos__FP6BUTTONP3PNTP6VECTOR
// Address: 0x13f140 - 0x13f170

void entry_13f170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f170: 0x1040000a
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F19C; return;
    }
    // 0x13f178: 0x1a000008
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        ctx->pc = 0x13F19C; return;
    }
    // 0x13f180: 0x103100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 16), 4));
    // 0x13f184: 0x262507c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1984));
    // 0x13f188: 0xd12021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 17)));
    // 0x13f18c: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x13f194);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1984));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_13f194
// Address: 0x13f194 - 0x13f1d8

void entry_13f194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f194) {
        switch (ctx->pc) {
            case 0x13f19c: ctx->pc = 0; goto label_13f19c;
            case 0x13f1a0: ctx->pc = 0; goto label_13f1a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f194: 0x10000002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f1a0;
    }
label_13f19c:
    // 0x13f19c: 0x7a620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
label_13f1a0:
    // 0x13f1a0: 0x121900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 4));
    // 0x13f1a4: 0x711821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x13f1a8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13f1ac: 0x7c6207c0
    WRITE128(ADD32(GPR_U32(ctx, 3), 1984), GPR_VEC(ctx, 2));
    // 0x13f1b0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13f1b4: 0x8e2407b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1972)));
    // 0x13f1b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13f1bc: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x13f1c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f1c4: 0xae2407b4
    WRITE32(ADD32(GPR_U32(ctx, 17), 1972), GPR_U32(ctx, 4));
    // 0x13f1c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f1cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13f1d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13f1d8; return;
}


// Function: InsertButtonMat__FP6BUTTONP3XFMP7MATRIX3
// Address: 0x13f1d8 - 0x13f208

void entry_13f208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f208: 0x1040000d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F240; return;
    }
    // 0x13f210: 0x1a00000b
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        ctx->pc = 0x13F240; return;
    }
    // 0x13f218: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x13f21c: 0x262507f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 2032));
    // 0x13f220: 0x2061018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13f224: 0x2060018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13f228: 0x512021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x13f22c: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x13f230: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x13f238);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2032));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_13f238
// Address: 0x13f238 - 0x13f290

void entry_13f238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f238) {
        switch (ctx->pc) {
            case 0x13f240: ctx->pc = 0; goto label_13f240;
            case 0x13f244: ctx->pc = 0; goto label_13f244;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f238: 0x10000002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f244;
    }
label_13f240:
    // 0x13f240: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
label_13f244:
    // 0x13f244: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13f248: 0x2641818
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13f24c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13f250: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13f254: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f258: 0x712021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x13f25c: 0x7c8207f0
    WRITE128(ADD32(GPR_U32(ctx, 4), 2032), GPR_VEC(ctx, 2));
    // 0x13f260: 0x248407f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2032));
    // 0x13f264: 0x7a420010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x13f268: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x13f26c: 0x7a430020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x13f270: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13f274: 0x7c830020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
    // 0x13f278: 0x8e2207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2016)));
    // 0x13f27c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x13f280: 0xae2207e0
    WRITE32(ADD32(GPR_U32(ctx, 17), 2016), GPR_U32(ctx, 2));
    // 0x13f284: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f288: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostButtonLoad__FP6BUTTON
// Address: 0x13f290 - 0x13f2e4

void entry_13f2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f2e4: 0xc04fa8e
    SET_GPR_U32(ctx, 31, 0x13f2ec);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1364));
    PostBtnLoad__FP3BTN(rdram, ctx, runtime); return;
}


// Function: entry_13f2ec
// Address: 0x13f2ec - 0x13f2f8

void entry_13f2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f2ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13f2f0: 0xc04fdbe
    SET_GPR_U32(ctx, 31, 0x13f2f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetButtonButtons__FP6BUTTON7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_13f2f8
// Address: 0x13f2f8 - 0x13f338

void entry_13f2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f2f8) {
        switch (ctx->pc) {
            case 0x13f328: ctx->pc = 0; goto label_13f328;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f2f8: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x13f2fc: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x13f300: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x13f304: 0x8e320550
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x13f308: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13f30c: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x13f310: 0x12000038
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F3F4; return;
    }
    // 0x13f318: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13f31c: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13f320: 0x27b30020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 32));
    // 0x13f324: 0x0
    // NOP
label_13f328:
    // 0x13f328: 0x1640000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F368; return;
    }
    // 0x13f330: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13f338);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13f338
// Address: 0x13f338 - 0x13f350

void entry_13f338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f338: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F368; return;
    }
    // 0x13f340: 0x8e250018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x13f344: 0x26060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 64));
    // 0x13f348: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x13f350);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_13f350
// Address: 0x13f350 - 0x13f360

void entry_13f350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f350: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13f354: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f358: 0xc04fc50
    SET_GPR_U32(ctx, 31, 0x13f360);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    InsertButtonPos__FP6BUTTONP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_13f360
// Address: 0x13f360 - 0x13f378

void entry_13f360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f360) {
        switch (ctx->pc) {
            case 0x13f368: ctx->pc = 0; goto label_13f368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f360: 0x10000019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F3C8; return;
    }
label_13f368:
    // 0x13f368: 0x16550017
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x13F3C8; return;
    }
    // 0x13f370: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13f378);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 115));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13f378
// Address: 0x13f378 - 0x13f388

void entry_13f378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f378: 0x10400012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13f3c4(rdram, ctx, runtime); return;
    }
    // 0x13f380: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13f388);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 117));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13f388
// Address: 0x13f388 - 0x13f3a4

void entry_13f388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f388: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x13F3C8; return;
    }
    // 0x13f390: 0x8e250018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x13f394: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13f398: 0x26060050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 80));
    // 0x13f39c: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x13f3a4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_13f3a4
// Address: 0x13f3a4 - 0x13f3b4

void entry_13f3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f3a4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13f3a8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f3ac: 0xc04fc76
    SET_GPR_U32(ctx, 31, 0x13f3b4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    InsertButtonMat__FP6BUTTONP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_13f3b4
// Address: 0x13f3b4 - 0x13f3c4

void entry_13f3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f3b4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13f3b8: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x13f3bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x13f3c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_13f3c4
// Address: 0x13f3c4 - 0x13f3d0

void entry_13f3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f3c4) {
        switch (ctx->pc) {
            case 0x13f3c8: ctx->pc = 0; goto label_13f3c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f3c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_13f3c8:
    // 0x13f3c8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13f3d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13f3d0
// Address: 0x13f3d0 - 0x13f454

void entry_13f3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f3d0) {
        switch (ctx->pc) {
            case 0x13f3d8: ctx->pc = 0; goto label_13f3d8;
            case 0x13f3f4: ctx->pc = 0; goto label_13f3f4;
            case 0x13f428: ctx->pc = 0; goto label_13f428;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f3d0: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 2176), GPR_U32(ctx, 16));
        goto label_13f3d8;
    }
label_13f3d8:
    // 0x13f3d8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x13f3dc: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x13f3e0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13f3e4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x13f3e8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x13f3ec: 0x1600ffce
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F328; return;
    }
label_13f3f4:
    // 0x13f3f4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13f3f8: 0x12420038
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x13F4DC; return;
    }
    // 0x13f400: 0x104000a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F694; return;
    }
    // 0x13f408: 0x164000a3
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F698; return;
    }
    // 0x13f410: 0x8e2207b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1972)));
    // 0x13f414: 0x18400018
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13F478; return;
    }
    // 0x13f41c: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    // 0x13f420: 0x263007c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1984));
    // 0x13f424: 0x0
    // NOP
label_13f428:
    // 0x13f428: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13f42c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13f430: 0xda220100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x13f434: 0x26250440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1088));
    // 0x13f438: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13f43c: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13f440: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13f444: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13f448: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13f44c: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x13f454);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_13f454
// Address: 0x13f454 - 0x13f4f8

void entry_13f454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f454) {
        switch (ctx->pc) {
            case 0x13f478: ctx->pc = 0; goto label_13f478;
            case 0x13f4dc: ctx->pc = 0; goto label_13f4dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f454: 0xda210100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x13f458: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f45c: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13f460: 0xfa010000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13f464: 0x8e2207b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1972)));
    // 0x13f468: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13f46c: 0x1440ffee
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F428; return;
    }
    // 0x13f474: 0x8e2207b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1972)));
label_13f478:
    // 0x13f478: 0xda2207c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1984)));
    // 0x13f47c: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x13f480: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x13f484: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13f488: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x13f48c: 0xd84107b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 1968)));
    // 0x13f490: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13f494: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x13f498: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13f49c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13f4a0: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13f4a4: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13f4a8: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13f4ac: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13f4b0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13f4b4: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x13f4b8: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13f4bc: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x13f4c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x13f4c4: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x13f4c8: 0xfa210860
    WRITE128(ADD32(GPR_U32(ctx, 17), 2144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13f4cc: 0x4be310d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13f4d0: 0xfa220860
    WRITE128(ADD32(GPR_U32(ctx, 17), 2144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13f4d4: 0x1000006e
    WRITE128(ADD32(GPR_U32(ctx, 17), 2160), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F690; return;
    }
label_13f4dc:
    // 0x13f4dc: 0x8e2207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2016)));
    // 0x13f4e0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13f4e4: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x13f4e8: 0x26260460
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1120));
    // 0x13f4ec: 0x2450ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x13f4f0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x13f4f8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 112));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_13f4f8
// Address: 0x13f4f8 - 0x13f5d4

void entry_13f4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f4f8) {
        switch (ctx->pc) {
            case 0x13f544: ctx->pc = 0; goto label_13f544;
            case 0x13f580: ctx->pc = 0; goto label_13f580;
            case 0x13f5ac: ctx->pc = 0; goto label_13f5ac;
            case 0x13f5c0: ctx->pc = 0; goto label_13f5c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f4f8: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x13f4fc: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x13f500: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13f504: 0xc7a00070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[0] = *(float*)&val; }
    // 0x13f508: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13f50c: 0x0
    // NOP
    // 0x13f510: 0x4500000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13f544;
    }
    // 0x13f518: 0x7a230810
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 2064)));
    // 0x13f51c: 0x2041018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13f520: 0x26320800
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 2048));
    // 0x13f524: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x13f528: 0x512821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x13f52c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13f530: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x13f534: 0x24538d10
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 4294937872));
    // 0x13f538: 0x24900800
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 2048));
    // 0x13f53c: 0x1000001b
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 2064)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f5ac;
    }
label_13f544:
    // 0x13f544: 0xc7a00074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 116)); ctx->f[0] = *(float*)&val; }
    // 0x13f548: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13f54c: 0x0
    // NOP
    // 0x13f550: 0x4500000b
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13f580;
    }
    // 0x13f558: 0x7a2307f0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 2032)));
    // 0x13f55c: 0x26320810
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 2064));
    // 0x13f560: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x13f564: 0x512821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x13f568: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13f56c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x13f570: 0x24538d20
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x13f574: 0x24900810
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 2064));
    // 0x13f578: 0x1000000c
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 2032)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f5ac;
    }
label_13f580:
    // 0x13f580: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x13f584: 0x7a230800
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 2048)));
    // 0x13f588: 0x2041018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13f58c: 0x263207f0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 2032));
    // 0x13f590: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x13f594: 0x512821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x13f598: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13f59c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x13f5a0: 0x24538d00
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x13f5a4: 0x249007f0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 2032));
    // 0x13f5a8: 0x78a20800
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 2048)));
label_13f5ac:
    // 0x13f5ac: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x13f5b0: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x13f5b4: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 320)));
        goto label_13f5c0;
    }
    // 0x13f5bc: 0x7a220100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 256)));
label_13f5c0:
    // 0x13f5c0: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x13f5c4: 0x26240860
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 2144));
    // 0x13f5c8: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x13f5cc: 0xc063600
    SET_GPR_U32(ctx, 31, 0x13f5d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_13f5d4
// Address: 0x13f5d4 - 0x13f6c0

void entry_13f5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f5d4) {
        switch (ctx->pc) {
            case 0x13f674: ctx->pc = 0; goto label_13f674;
            case 0x13f690: ctx->pc = 0; goto label_13f690;
            case 0x13f694: ctx->pc = 0; goto label_13f694;
            case 0x13f698: ctx->pc = 0; goto label_13f698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f5d4: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x13f5d8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13f5dc: 0xda250870
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 2160)));
    // 0x13f5e0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x13f5e4: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13f5e8: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13f5ec: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13f5f0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x13f5f4: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x13f5f8: 0x4be31098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13f5fc: 0xfa220850
    WRITE128(ADD32(GPR_U32(ctx, 17), 2128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13f600: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x13f604: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x13f608: 0x4be30848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13f60c: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13f610: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13f614: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x13f618: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x13f61c: 0x4be31108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13f620: 0x4be1206c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13f624: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x13f628: 0x4bc128aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x13f62c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13f630: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13f634: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13f638: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13f63c: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13f640: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x13f644: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13f648: 0x0
    // NOP
    // 0x13f64c: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 2144)));
        goto label_13f674;
    }
    // 0x13f654: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x13f658: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13f65c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x13f660: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x13f664: 0x4be12898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x13f668: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13f66c: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 17), 2160), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f690;
    }
label_13f674:
    // 0x13f674: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x13f678: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13f67c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x13f680: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x13f684: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13f688: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13f68c: 0xfa210860
    WRITE128(ADD32(GPR_U32(ctx, 17), 2144), _mm_castps_si128(ctx->vu0_vf[1]));
label_13f690:
    // 0x13f690: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_13f694:
    // 0x13f694: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_13f698:
    // 0x13f698: 0xaec2b314
    WRITE32(ADD32(GPR_U32(ctx, 22), 4294947604), GPR_U32(ctx, 2));
    // 0x13f69c: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x13f6a0: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x13f6a4: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x13f6a8: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x13f6ac: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13f6b0: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13f6b4: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13f6b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneButton__FP6BUTTONT0
// Address: 0x13f6c0 - 0x13f6dc

void entry_13f6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f6dc: 0xae110674
    WRITE32(ADD32(GPR_U32(ctx, 16), 1652), GPR_U32(ctx, 17));
    // 0x13f6e0: 0xae100558
    WRITE32(ADD32(GPR_U32(ctx, 16), 1368), GPR_U32(ctx, 16));
    // 0x13f6e4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13f6e8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f6ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f6f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetButtonButtons__FP6BUTTON7BUTTONS
// Address: 0x13f6f8 - 0x13f708

void entry_13f708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f708: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f70c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13f714: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x13f718; return;
}


// Function: FCheckButtonObject__FP6BUTTONP2SO
// Address: 0x13f718 - 0x13f770

void entry_13f770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f770) {
        switch (ctx->pc) {
            case 0x13f790: ctx->pc = 0; goto label_13f790;
            case 0x13f7a8: ctx->pc = 0; goto label_13f7a8;
            case 0x13f7b0: ctx->pc = 0; goto label_13f7b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f770: 0x5040fff7
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
        ctx->pc = 0x13F750; return;
    }
    // 0x13f778: 0x8e020720
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1824)));
    // 0x13f77c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13f780: 0x54400019
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1896)));
        ctx->pc = 0x13F7E8; return;
    }
    // 0x13f788: 0x1000003e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F884; return;
    }
label_13f790:
    // 0x13f790: 0x8e020744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1860)));
    // 0x13f794: 0x18400013
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13F7E4; return;
    }
    // 0x13f79c: 0x10000004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1864));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f7b0;
    }
    // 0x13f7a4: 0x0
    // NOP
label_13f7a8:
    // 0x13f7a8: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x13f7ac: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_13f7b0:
    // 0x13f7b0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13f7b4: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1896)));
        ctx->pc = 0x13F7E8; return;
    }
    // 0x13f7bc: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13f7c0: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x13f7c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_13f7c8
// Address: 0x13f7c8 - 0x13f818

void entry_13f7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f7c8) {
        switch (ctx->pc) {
            case 0x13f7e4: ctx->pc = 0; goto label_13f7e4;
            case 0x13f7e8: ctx->pc = 0; goto label_13f7e8;
            case 0x13f7f8: ctx->pc = 0; goto label_13f7f8;
            case 0x13f800: ctx->pc = 0; goto label_13f800;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f7c8: 0x1040fff7
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1860)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F7A8; return;
    }
    // 0x13f7d0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13f7d4: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1896)));
        goto label_13f7e8;
    }
    // 0x13f7dc: 0x10000029
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F884; return;
    }
label_13f7e4:
    // 0x13f7e4: 0x8e020768
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1896)));
label_13f7e8:
    // 0x13f7e8: 0x18400012
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13F834; return;
    }
    // 0x13f7f0: 0x10000003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1900));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f800;
    }
label_13f7f8:
    // 0x13f7f8: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x13f7fc: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_13f800:
    // 0x13f800: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13f804: 0x1040001f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F884; return;
    }
    // 0x13f80c: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13f810: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13f818);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13f818
// Address: 0x13f818 - 0x13f868

void entry_13f818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f818) {
        switch (ctx->pc) {
            case 0x13f834: ctx->pc = 0; goto label_13f834;
            case 0x13f848: ctx->pc = 0; goto label_13f848;
            case 0x13f850: ctx->pc = 0; goto label_13f850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f818: 0x1040fff7
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1896)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F7F8; return;
    }
    // 0x13f820: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13f824: 0x14400017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F884; return;
    }
    // 0x13f82c: 0x10000015
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F884; return;
    }
label_13f834:
    // 0x13f834: 0x8e02078c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1932)));
    // 0x13f838: 0x18400011
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1936));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x13F880; return;
    }
    // 0x13f840: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13f850;
    }
label_13f848:
    // 0x13f848: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x13f84c: 0x8e02078c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1932)));
label_13f850:
    // 0x13f850: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x13f854: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1932)));
        ctx->pc = 0x13F874; return;
    }
    // 0x13f85c: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x13f860: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x13f868);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_13f868
// Address: 0x13f868 - 0x13f8a0

void entry_13f868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f868) {
        switch (ctx->pc) {
            case 0x13f874: ctx->pc = 0; goto label_13f874;
            case 0x13f880: ctx->pc = 0; goto label_13f880;
            case 0x13f884: ctx->pc = 0; goto label_13f884;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f868: 0x1040fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F848; return;
    }
    // 0x13f870: 0x8e03078c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1932)));
label_13f874:
    // 0x13f874: 0x243182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x13f878: 0x14600002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_13f884;
    }
label_13f880:
    // 0x13f880: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_13f884:
    // 0x13f884: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13f888: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13f88c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13f890: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13f894: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13f898: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IposFindButtonClosest__FP6BUTTONPf
// Address: 0x13f8a0 - 0x13f940

void entry_13f9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13f9a8: 0xc062338
    SET_GPR_U32(ctx, 31, 0x13f9b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CosRotateMatrixMagnitude__FP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_13f9b0
// Address: 0x13f9b0 - 0x13f9e4

void entry_13f9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f9b0) {
        switch (ctx->pc) {
            case 0x13f9cc: ctx->pc = 0; goto label_13f9cc;
            case 0x13f9d4: ctx->pc = 0; goto label_13f9d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f9b0: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13f9b4: 0x0
    // NOP
    // 0x13f9b8: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        goto label_13f9cc;
    }
    // 0x13f9c0: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x13f9c4: 0x200a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13f9c8: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
label_13f9cc:
    // 0x13f9cc: 0x601fff2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967248));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x13F998; return;
    }
label_13f9d4:
    // 0x13f9d4: 0x12600005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13F9EC; return;
    }
    // 0x13f9dc: 0xc08155e
    SET_GPR_U32(ctx, 31, 0x13f9e4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    acosf(rdram, ctx, runtime); return;
}


// Function: entry_13f9e4
// Address: 0x13f9e4 - 0x13fa10

void entry_13f9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13f9e4) {
        switch (ctx->pc) {
            case 0x13f9ec: ctx->pc = 0; goto label_13f9ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13f9e4: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
    // 0x13f9e8: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_13f9ec:
    // 0x13f9ec: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13f9f0: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13f9f4: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13f9f8: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13f9fc: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13fa00: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13fa04: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x13fa08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetButtonAccel__FP6BUTTONf
// Address: 0x13fa10 - 0x13fa2c

void entry_13fa2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fa2c) {
        switch (ctx->pc) {
            case 0x13fa48: ctx->pc = 0; goto label_13fa48;
            case 0x13fa6c: ctx->pc = 0; goto label_13fa6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fa2c: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x13fa30: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_13fa48;
    }
    // 0x13fa38: 0x10620015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x13FA90; return;
    }
    // 0x13fa40: 0x10000026
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FADC; return;
    }
label_13fa48:
    // 0x13fa48: 0x8e0207b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1972)));
    // 0x13fa4c: 0x10400021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13fad4(rdram, ctx, runtime); return;
    }
    // 0x13fa54: 0x8e030680
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x13fa58: 0x10620004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1984));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_13fa6c;
    }
    // 0x13fa60: 0x8e0207b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1968)));
    // 0x13fa64: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x13fa68: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
label_13fa6c:
    // 0x13fa6c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13fa70: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x13fa74: 0x8c86020c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 524)));
    // 0x13fa78: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x13fa7c: 0x8c880210
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 528)));
    // 0x13fa80: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x13fa88);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_13fa88
// Address: 0x13fa88 - 0x13fad4

void entry_13fa88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fa88) {
        switch (ctx->pc) {
            case 0x13fa90: ctx->pc = 0; goto label_13fa90;
            case 0x13fab8: ctx->pc = 0; goto label_13fab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fa88: 0x10000013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FAD8; return;
    }
label_13fa90:
    // 0x13fa90: 0x8e0207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x13fa94: 0x1040000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13fad4(rdram, ctx, runtime); return;
    }
    // 0x13fa9c: 0x8e030680
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x13faa0: 0x10620005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 2032));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_13fab8;
    }
    // 0x13faa8: 0x8e0307b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1968)));
    // 0x13faac: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x13fab0: 0x622018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x13fab4: 0x852821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
label_13fab8:
    // 0x13fab8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13fabc: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x13fac0: 0x8c860214
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 532)));
    // 0x13fac4: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x13fac8: 0x8c880218
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 536)));
    // 0x13facc: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x13fad4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_13fad4
// Address: 0x13fad4 - 0x13fae8

void entry_13fad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fad4) {
        switch (ctx->pc) {
            case 0x13fad8: ctx->pc = 0; goto label_13fad8;
            case 0x13fadc: ctx->pc = 0; goto label_13fadc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fad4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_13fad8:
    // 0x13fad8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_13fadc:
    // 0x13fadc: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x13fae0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateButtonInternalXps__FP6BUTTON
// Address: 0x13fae8 - 0x13fb3c

void entry_13fb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fb3c) {
        switch (ctx->pc) {
            case 0x13fb44: ctx->pc = 0; goto label_13fb44;
            case 0x13fb58: ctx->pc = 0; goto label_13fb58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fb3c: 0xae2004b4
    WRITE32(ADD32(GPR_U32(ctx, 17), 1204), GPR_U32(ctx, 0));
    // 0x13fb40: 0x27b60020
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 32));
label_13fb44:
    // 0x13fb44: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13fb48: 0x2c0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x13fb4c: 0x26330860
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 2144));
    // 0x13fb50: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x13fb54: 0x263007c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1984));
label_13fb58:
    // 0x13fb58: 0x8e2207b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1972)));
    // 0x13fb5c: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x13fb60: 0x10400005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_13fb78(rdram, ctx, runtime); return;
    }
    // 0x13fb68: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x13fb6c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13fb70: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x13fb78);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_13fb78
// Address: 0x13fb78 - 0x13fb8c

void entry_13fb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13fb78: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x13fb7c: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x13fb80: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x13fb84: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x13fb8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_13fb8c
// Address: 0x13fb8c - 0x13fc28

void entry_13fb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fb8c) {
        switch (ctx->pc) {
            case 0x13fc14: ctx->pc = 0; goto label_13fc14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fb8c: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x13fb90: 0x26b50010
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
    // 0x13fb94: 0x26730010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 16));
    // 0x13fb98: 0x26520010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 16));
    // 0x13fb9c: 0x2a820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 2));
    // 0x13fba0: 0x1440ffed
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FB58; return;
    }
    // 0x13fba8: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x13fbac: 0x14400019
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_13fc14;
    }
    // 0x13fbb4: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13fbb8: 0x26260140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 320));
    // 0x13fbbc: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x13fbc0: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13fbc4: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13fbc8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x13fbcc: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13fbd0: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x13fbd4: 0x4bc118ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13fbd8: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13fbdc: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13fbe0: 0x4b0330ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13fbe4: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x13fbe8: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x13fbec: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x13fbf0: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13fbf4: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13fbf8: 0x4bc5212a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13fbfc: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13fc00: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13fc04: 0x4b04090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13fc08: 0x46006007
    ctx->f[0] = FPU_NEG_S(ctx->f[12]);
    // 0x13fc0c: 0x10000021
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FC94; return;
    }
label_13fc14:
    // 0x13fc14: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x13fc18: 0x26260850
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 2128));
    // 0x13fc1c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13fc20: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x13fc28);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_13fc28
// Address: 0x13fc28 - 0x13fcf4

void entry_13fc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fc28) {
        switch (ctx->pc) {
            case 0x13fc94: ctx->pc = 0; goto label_13fc94;
            case 0x13fcc4: ctx->pc = 0; goto label_13fcc4;
            case 0x13fce0: ctx->pc = 0; goto label_13fce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fc28: 0xda240140
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x13fc2c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x13fc30: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x13fc34: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x13fc38: 0x4bc2216a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13fc3c: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13fc40: 0x4b05283d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x13fc44: 0x4b05314a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13fc48: 0x4bc3212a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13fc4c: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13fc50: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x13fc54: 0x4b04310a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13fc58: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x13fc5c: 0x4bc308ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13fc60: 0x4b0001c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13fc64: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x13fc68: 0x4b0338ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13fc6c: 0x48222800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x13fc70: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13fc74: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x13fc78: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x13fc7c: 0x4b01304a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x13fc80: 0x48232000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x13fc84: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x13fc88: 0x44846000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 4);
    // 0x13fc8c: 0x48241800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x13fc90: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
label_13fc94:
    // 0x13fc94: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x13fc98: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x13fc9c: 0x3c01b8d1
    SET_GPR_U32(ctx, 1, ((uint32_t)47313 << 16));
    // 0x13fca0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x13fca4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x13fca8: 0x46016034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13fcac: 0x0
    // NOP
    // 0x13fcb0: 0x45000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_13fcc4;
    }
    // 0x13fcb8: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x13fcbc: 0x10000008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13fce0;
    }
label_13fcc4:
    // 0x13fcc4: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x13fcc8: 0x46020301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x13fccc: 0x46016034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13fcd0: 0x0
    // NOP
    // 0x13fcd4: 0x45000008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x13FCF8; return;
    }
    // 0x13fcdc: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
label_13fce0:
    // 0x13fce0: 0x2408000a
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 10));
    // 0x13fce4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13fce8: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x13fcec: 0xc061748
    SET_GPR_U32(ctx, 31, 0x13fcf4);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 4), 1204));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_13fcf4
// Address: 0x13fcf4 - 0x13fd20

void entry_13fcf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fcf4) {
        switch (ctx->pc) {
            case 0x13fcf8: ctx->pc = 0; goto label_13fcf8;
            case 0x13fcfc: ctx->pc = 0; goto label_13fcfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fcf4: 0xac400098
    WRITE32(ADD32(GPR_U32(ctx, 2), 152), GPR_U32(ctx, 0));
label_13fcf8:
    // 0x13fcf8: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_13fcfc:
    // 0x13fcfc: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x13fd00: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x13fd04: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x13fd08: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x13fd0c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x13fd10: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x13fd14: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x13fd18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateButton__FP6BUTTONf
// Address: 0x13fd20 - 0x13fd48

void entry_13fd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fd48) {
        switch (ctx->pc) {
            case 0x13fda8: ctx->pc = 0; goto label_13fda8;
            case 0x13fdac: ctx->pc = 0; goto label_13fdac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fd48: 0x8e430680
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1664)));
    // 0x13fd4c: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x13fd50: 0x104000ac
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_140004(rdram, ctx, runtime); return;
    }
    // 0x13fd58: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x13fd5c: 0x24429de0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942176));
    // 0x13fd60: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13fd64: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13fd68: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x13fd70: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13fd74: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x13fd78: 0x1080000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_13fda8;
    }
    // 0x13fd80: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x13fd84: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1660)); ctx->f[2] = *(float*)&val; }
        goto label_13fdac;
    }
    // 0x13fd8c: 0x8c832204
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8708)));
    // 0x13fd90: 0x8e420880
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2176)));
    // 0x13fd94: 0x54620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1660)); ctx->f[2] = *(float*)&val; }
        goto label_13fdac;
    }
    // 0x13fd9c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13fda0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x13fda4: 0xe6400678
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1656), *(uint32_t*)&val); }
label_13fda8:
    // 0x13fda8: 0xc642067c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1660)); ctx->f[2] = *(float*)&val; }
label_13fdac:
    // 0x13fdac: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x13fdb0: 0x46020036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13fdb4: 0x0
    // NOP
    // 0x13fdb8: 0x45000092
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_140004(rdram, ctx, runtime); return;
    }
    // 0x13fdc0: 0xc6410678
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1656)); ctx->f[1] = *(float*)&val; }
    // 0x13fdc4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x13fdc8: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x13fdcc: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13fdd0: 0x0
    // NOP
    // 0x13fdd4: 0x4500008b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_140004(rdram, ctx, runtime); return;
    }
    // 0x13fddc: 0xc04fdbe
    SET_GPR_U32(ctx, 31, 0x13fde4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetButtonButtons__FP6BUTTON7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_13fde4
// Address: 0x13fde4 - 0x13fe24

void entry_13fde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13fde4: 0x10000088
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140008; return;
    }
    // 0x13fdec: 0x8e430550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x13fdf0: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x13fdf4: 0x10400016
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FE50; return;
    }
    // 0x13fdfc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x13fe00: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x13fe04: 0x24429e00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942208));
    // 0x13fe08: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x13fe0c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x13fe10: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x13fe18: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13fe1c: 0xc04fe28
    SET_GPR_U32(ctx, 31, 0x13fe24);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime); return;
}


// Function: entry_13fe24
// Address: 0x13fe24 - 0x13fe38

void entry_13fe24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x13fe24: 0x10000005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FE3C; return;
    }
    // 0x13fe2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13fe30: 0xc04fe50
    SET_GPR_U32(ctx, 31, 0x13fe38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ImatFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime); return;
}


// Function: entry_13fe38
// Address: 0x13fe38 - 0x13fe64

void entry_13fe38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fe38) {
        switch (ctx->pc) {
            case 0x13fe3c: ctx->pc = 0; goto label_13fe3c;
            case 0x13fe50: ctx->pc = 0; goto label_13fe50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fe38: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
label_13fe3c:
    // 0x13fe3c: 0x10000004
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13fe50;
    }
    // 0x13fe44: 0x10000002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13fe50;
    }
    // 0x13fe4c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13fe50:
    // 0x13fe50: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x13fe54: 0x1202006b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        entry_140004(rdram, ctx, runtime); return;
    }
    // 0x13fe5c: 0xc04fdbe
    SET_GPR_U32(ctx, 31, 0x13fe64);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetButtonButtons__FP6BUTTON7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_13fe64
// Address: 0x13fe64 - 0x13ff34

void entry_13fe64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fe64) {
        switch (ctx->pc) {
            case 0x13fe9c: ctx->pc = 0; goto label_13fe9c;
            case 0x13fed8: ctx->pc = 0; goto label_13fed8;
            case 0x13fef0: ctx->pc = 0; goto label_13fef0;
            case 0x13ff00: ctx->pc = 0; goto label_13ff00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fe64: 0x10000068
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140008; return;
    }
    // 0x13fe6c: 0x8e530680
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 1664)));
    // 0x13fe70: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x13fe74: 0x8e430550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x13fe78: 0x1064005f
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x13FFF8; return;
    }
    // 0x13fe80: 0x28620004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    // 0x13fe84: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13fe9c;
    }
    // 0x13fe8c: 0x10620012
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_13fed8;
    }
    // 0x13fe94: 0x10000031
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FF5C; return;
    }
label_13fe9c:
    // 0x13fe9c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x13fea0: 0x1462002e
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x13FF5C; return;
    }
    // 0x13fea8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x13feac: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x13feb0: 0x10600051
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FFF8; return;
    }
    // 0x13feb8: 0x8c622220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8736)));
    // 0x13febc: 0x1444004f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x13FFFC; return;
    }
    // 0x13fec4: 0x8c622204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8708)));
    // 0x13fec8: 0x8e430880
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2176)));
    // 0x13fecc: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x13fed0: 0x1000004a
    SET_GPR_U32(ctx, 19, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FFFC; return;
    }
label_13fed8:
    // 0x13fed8: 0x8e540050
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x13fedc: 0x8e820480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1152)));
    // 0x13fee0: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x13fee4: 0x12200044
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FFF8; return;
    }
    // 0x13feec: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_13fef0:
    // 0x13fef0: 0x52000016
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x13FF4C; return;
    }
    // 0x13fef8: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13fefc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_13ff00:
    // 0x13ff00: 0x541026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x13ff04: 0x2202b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x13ff08: 0x41980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 6));
    // 0x13ff0c: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x13ff10: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x13ff14: 0x5452000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x13FF40; return;
    }
    // 0x13ff1c: 0x2a41023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 4)));
    // 0x13ff20: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x13ff24: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x13ff28: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x13ff2c: 0xc04fdc6
    SET_GPR_U32(ctx, 31, 0x13ff34);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    FCheckButtonObject__FP6BUTTONP2SO(rdram, ctx, runtime); return;
}


// Function: entry_13ff34
// Address: 0x13ff34 - 0x13ff6c

void entry_13ff34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ff34) {
        switch (ctx->pc) {
            case 0x13ff40: ctx->pc = 0; goto label_13ff40;
            case 0x13ff4c: ctx->pc = 0; goto label_13ff4c;
            case 0x13ff5c: ctx->pc = 0; goto label_13ff5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ff34: 0x54400030
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x13FFF8; return;
    }
    // 0x13ff3c: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
label_13ff40:
    // 0x13ff40: 0x5600ffef
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x13FF00; return;
    }
    // 0x13ff48: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_13ff4c:
    // 0x13ff4c: 0x5620ffe8
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x13FEF0; return;
    }
    // 0x13ff54: 0x10000029
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FFFC; return;
    }
label_13ff5c:
    // 0x13ff5c: 0x14600008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FF80; return;
    }
    // 0x13ff64: 0xc04fe28
    SET_GPR_U32(ctx, 31, 0x13ff6c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime); return;
}


// Function: entry_13ff6c
// Address: 0x13ff6c - 0x13ff88

void entry_13ff6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ff6c) {
        switch (ctx->pc) {
            case 0x13ff80: ctx->pc = 0; goto label_13ff80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ff6c: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x13ff70: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x13ff74: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x13ff78: 0x10000008
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x13FF9C; return;
    }
label_13ff80:
    // 0x13ff80: 0xc04fe50
    SET_GPR_U32(ctx, 31, 0x13ff88);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    ImatFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime); return;
}


// Function: entry_13ff88
// Address: 0x13ff88 - 0x13fff4

void entry_13ff88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13ff88) {
        switch (ctx->pc) {
            case 0x13ff9c: ctx->pc = 0; goto label_13ff9c;
            case 0x13ffb0: ctx->pc = 0; goto label_13ffb0;
            case 0x13ffd4: ctx->pc = 0; goto label_13ffd4;
            case 0x13ffe0: ctx->pc = 0; goto label_13ffe0;
            case 0x13ffe4: ctx->pc = 0; goto label_13ffe4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13ff88: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x13ff8c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x13ff90: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x13ff94: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x13ff98: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_13ff9c:
    // 0x13ff9c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x13ffa0: 0x0
    // NOP
    // 0x13ffa4: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_13ffb0;
    }
    // 0x13ffac: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_13ffb0:
    // 0x13ffb0: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1968)));
        goto label_13ffe4;
    }
    // 0x13ffb8: 0x16000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_13ffd4;
    }
    // 0x13ffc0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x13ffc4: 0x16220003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_13ffd4;
    }
    // 0x13ffcc: 0x10000004
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_13ffe0;
    }
label_13ffd4:
    // 0x13ffd4: 0x3a030001
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 16), 1));
    // 0x13ffd8: 0x231100b
    if (GPR_U32(ctx, 17) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 17));
    // 0x13ffdc: 0x43980a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 2));
label_13ffe0:
    // 0x13ffe0: 0x8e4207b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1968)));
label_13ffe4:
    // 0x13ffe4: 0x10500005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x13FFFC; return;
    }
    // 0x13ffec: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x13fff4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_13fff4
// Address: 0x13fff4 - 0x140004

void entry_13fff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x13fff4) {
        switch (ctx->pc) {
            case 0x13fff8: ctx->pc = 0; goto label_13fff8;
            case 0x13fffc: ctx->pc = 0; goto label_13fffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x13fff4: 0xae5007b0
    WRITE32(ADD32(GPR_U32(ctx, 18), 1968), GPR_U32(ctx, 16));
label_13fff8:
    // 0x13fff8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_13fffc:
    // 0x13fffc: 0xc04fdbe
    SET_GPR_U32(ctx, 31, 0x140004);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetButtonButtons__FP6BUTTON7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_140004
// Address: 0x140004 - 0x140028

void entry_130038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130038 inside entry_12fffc (0x12fffc - 0x130070)
    ctx->pc = 0x130038;
    entry_12fffc(rdram, ctx, runtime);
}

void entry_13005c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13005c inside entry_12fffc (0x12fffc - 0x130070)
    ctx->pc = 0x13005c;
    entry_12fffc(rdram, ctx, runtime);
}

void entry_13009c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13009c inside Spool__18CBinaryAsyncStream (0x130070 - 0x1300a4)
    ctx->pc = 0x13009c;
    Spool__18CBinaryAsyncStream(rdram, ctx, runtime);
}

void entry_1300b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1300b4 inside entry_1300ac (0x1300ac - 0x1300bc)
    ctx->pc = 0x1300b4;
    entry_1300ac(rdram, ctx, runtime);
}

void entry_1300c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1300c8 inside entry_1300c4 (0x1300c4 - 0x1300d8)
    ctx->pc = 0x1300c8;
    entry_1300c4(rdram, ctx, runtime);
}

void entry_1300cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1300cc inside entry_1300c4 (0x1300c4 - 0x1300d8)
    ctx->pc = 0x1300cc;
    entry_1300c4(rdram, ctx, runtime);
}

void entry_1300ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1300ec inside FIsBasicDerivedFrom__FP5BASIC3CID (0x1300e8 - 0x130110)
    ctx->pc = 0x1300ec;
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime);
}

void entry_130108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130108 inside FIsBasicDerivedFrom__FP5BASIC3CID (0x1300e8 - 0x130110)
    ctx->pc = 0x130108;
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime);
}

void entry_13014c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13014c inside entry_130148 (0x130148 - 0x130158)
    ctx->pc = 0x13014c;
    entry_130148(rdram, ctx, runtime);
}

void entry_130198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130198 inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x130198;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_1301bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1301bc inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x1301bc;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_130220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130220 inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x130220;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_130264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130264 inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x130264;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_130278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130278 inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x130278;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_130288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130288 inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x130288;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_130294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130294 inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x130294;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_13030c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13030c inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x13030c;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_1303e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1303e4 inside EvaluateBezierWeightedFloat__FfffffffffPfN29 (0x130168 - 0x1303f0)
    ctx->pc = 0x1303e4;
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime);
}

void entry_130464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130464 inside EvaluateBezierFloat__FfffffffPfN27 (0x1303f0 - 0x130540)
    ctx->pc = 0x130464;
    EvaluateBezierFloat__FfffffffPfN27(rdram, ctx, runtime);
}

void entry_1304cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1304cc inside EvaluateBezierFloat__FfffffffPfN27 (0x1303f0 - 0x130540)
    ctx->pc = 0x1304cc;
    EvaluateBezierFloat__FfffffffPfN27(rdram, ctx, runtime);
}

void entry_130538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130538 inside EvaluateBezierFloat__FfffffffPfN27 (0x1303f0 - 0x130540)
    ctx->pc = 0x130538;
    EvaluateBezierFloat__FfffffffPfN27(rdram, ctx, runtime);
}

void entry_1305ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1305ec inside EvaluateBezierPos__FfffP6VECTORN63 (0x130540 - 0x130748)
    ctx->pc = 0x1305ec;
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime);
}

void entry_130698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130698 inside EvaluateBezierPos__FfffP6VECTORN63 (0x130540 - 0x130748)
    ctx->pc = 0x130698;
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime);
}

void entry_13073c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13073c inside EvaluateBezierPos__FfffP6VECTORN63 (0x130540 - 0x130748)
    ctx->pc = 0x13073c;
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime);
}

void entry_130824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130824 inside EvaluateBezierMat__FfffP7MATRIX3P6VECTORT3T4T3T4T4 (0x130748 - 0x130854)
    ctx->pc = 0x130824;
    EvaluateBezierMat__FfffP7MATRIX3P6VECTORT3T4T3T4T4(rdram, ctx, runtime);
}

void entry_130834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130834 inside EvaluateBezierMat__FfffP7MATRIX3P6VECTORT3T4T3T4T4 (0x130748 - 0x130854)
    ctx->pc = 0x130834;
    EvaluateBezierMat__FfffP7MATRIX3P6VECTORT3T4T3T4T4(rdram, ctx, runtime);
}

void entry_130904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130904 inside entry_130854 (0x130854 - 0x130934)
    ctx->pc = 0x130904;
    entry_130854(rdram, ctx, runtime);
}

void entry_130914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130914 inside entry_130854 (0x130854 - 0x130934)
    ctx->pc = 0x130914;
    entry_130854(rdram, ctx, runtime);
}

void entry_130a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130a3c inside entry_1309dc (0x1309dc - 0x130a50)
    ctx->pc = 0x130a3c;
    entry_1309dc(rdram, ctx, runtime);
}

void entry_130b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130b08 inside entry_130a60 (0x130a60 - 0x130b48)
    ctx->pc = 0x130b08;
    entry_130a60(rdram, ctx, runtime);
}

void entry_130bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130bb0 inside TesselateBezier__FfffP6VECTORN33iT3 (0x130b48 - 0x130be0)
    ctx->pc = 0x130bb0;
    TesselateBezier__FfffP6VECTORN33iT3(rdram, ctx, runtime);
}

void entry_130bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130bf0 inside entry_130be0 (0x130be0 - 0x130c20)
    ctx->pc = 0x130bf0;
    entry_130be0(rdram, ctx, runtime);
}

void entry_130d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130d08 inside LimitBezierMulti__Fie (0x130c58 - 0x130d20)
    ctx->pc = 0x130d08;
    LimitBezierMulti__Fie(rdram, ctx, runtime);
}

void entry_130d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130d28 inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130d28;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130d48 inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130d48;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130d60 inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130d60;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130d90 inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130d90;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130dc4 inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130dc4;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130dcc inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130dcc;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130dd0 inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130dd0;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130df8 inside entry_130d20 (0x130d20 - 0x130e00)
    ctx->pc = 0x130df8;
    entry_130d20(rdram, ctx, runtime);
}

void entry_130e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e04 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e04;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e30 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e30;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e34 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e34;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e50 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e50;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e68 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e68;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e6c inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e6c;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e88 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e88;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130e8c inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130e8c;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130eb8 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130eb8;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130ee8 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130ee8;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130ef4 inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130ef4;
    entry_130e00(rdram, ctx, runtime);
}

void entry_130efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x130efc inside entry_130e00 (0x130e00 - 0x130f48)
    ctx->pc = 0x130efc;
    entry_130e00(rdram, ctx, runtime);
}

void entry_131020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131020 inside GEvaluateBei (0x131000 - 0x1310f0)
    ctx->pc = 0x131020;
    GEvaluateBei(rdram, ctx, runtime);
}

void entry_131050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131050 inside GEvaluateBei (0x131000 - 0x1310f0)
    ctx->pc = 0x131050;
    GEvaluateBei(rdram, ctx, runtime);
}

void entry_131060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131060 inside GEvaluateBei (0x131000 - 0x1310f0)
    ctx->pc = 0x131060;
    GEvaluateBei(rdram, ctx, runtime);
}

void entry_131068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131068 inside GEvaluateBei (0x131000 - 0x1310f0)
    ctx->pc = 0x131068;
    GEvaluateBei(rdram, ctx, runtime);
}

void entry_1310ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1310ac inside GEvaluateBei (0x131000 - 0x1310f0)
    ctx->pc = 0x1310ac;
    GEvaluateBei(rdram, ctx, runtime);
}

void entry_1310bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1310bc inside GEvaluateBei (0x131000 - 0x1310f0)
    ctx->pc = 0x1310bc;
    GEvaluateBei(rdram, ctx, runtime);
}

void entry_131290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131290 inside entry_131288 (0x131288 - 0x1312ac)
    ctx->pc = 0x131290;
    entry_131288(rdram, ctx, runtime);
}

void entry_1312c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1312c8 inside entry_1312ac (0x1312ac - 0x1312dc)
    ctx->pc = 0x1312c8;
    entry_1312ac(rdram, ctx, runtime);
}

void entry_131490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131490 inside entry_13148c (0x13148c - 0x1314a0)
    ctx->pc = 0x131490;
    entry_13148c(rdram, ctx, runtime);
}

void entry_1315c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1315c0 inside entry_1315a0 (0x1315a0 - 0x1315d0)
    ctx->pc = 0x1315c0;
    entry_1315a0(rdram, ctx, runtime);
}

void entry_131910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131910 inside entry_13190c (0x13190c - 0x13195c)
    ctx->pc = 0x131910;
    entry_13190c(rdram, ctx, runtime);
}

void entry_131c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131c6c inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131c6c;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131cac inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131cac;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131cc4 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131cc4;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131d08 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131d08;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131d48 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131d48;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131d60 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131d60;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131da4 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131da4;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131de4 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131de4;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131dfc inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131dfc;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131e40 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131e40;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_131e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x131e80 inside entry_131bc4 (0x131bc4 - 0x131ed4)
    ctx->pc = 0x131e80;
    entry_131bc4(rdram, ctx, runtime);
}

void entry_132068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132068 inside entry_132054 (0x132054 - 0x132118)
    ctx->pc = 0x132068;
    entry_132054(rdram, ctx, runtime);
}

void entry_1320f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1320f8 inside entry_132054 (0x132054 - 0x132118)
    ctx->pc = 0x1320f8;
    entry_132054(rdram, ctx, runtime);
}

void entry_132280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132280 inside entry_132264 (0x132264 - 0x132294)
    ctx->pc = 0x132280;
    entry_132264(rdram, ctx, runtime);
}

void entry_132288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132288 inside entry_132264 (0x132264 - 0x132294)
    ctx->pc = 0x132288;
    entry_132264(rdram, ctx, runtime);
}

void entry_13230c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13230c inside entry_1322bc (0x1322bc - 0x132318)
    ctx->pc = 0x13230c;
    entry_1322bc(rdram, ctx, runtime);
}

void entry_132310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132310 inside entry_1322bc (0x1322bc - 0x132318)
    ctx->pc = 0x132310;
    entry_1322bc(rdram, ctx, runtime);
}

void entry_132394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132394 inside entry_13235c (0x13235c - 0x13239c)
    ctx->pc = 0x132394;
    entry_13235c(rdram, ctx, runtime);
}

void entry_1324a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1324a0 inside entry_13249c (0x13249c - 0x132500)
    ctx->pc = 0x1324a0;
    entry_13249c(rdram, ctx, runtime);
}

void entry_1325c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1325c8 inside entry_1325ac (0x1325ac - 0x13262c)
    ctx->pc = 0x1325c8;
    entry_1325ac(rdram, ctx, runtime);
}

void entry_1325d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1325d0 inside entry_1325ac (0x1325ac - 0x13262c)
    ctx->pc = 0x1325d0;
    entry_1325ac(rdram, ctx, runtime);
}

void entry_132600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132600 inside entry_1325ac (0x1325ac - 0x13262c)
    ctx->pc = 0x132600;
    entry_1325ac(rdram, ctx, runtime);
}

void entry_13261c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13261c inside entry_1325ac (0x1325ac - 0x13262c)
    ctx->pc = 0x13261c;
    entry_1325ac(rdram, ctx, runtime);
}

void entry_132688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132688 inside entry_13262c (0x13262c - 0x1327f8)
    ctx->pc = 0x132688;
    entry_13262c(rdram, ctx, runtime);
}

void entry_132698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132698 inside entry_13262c (0x13262c - 0x1327f8)
    ctx->pc = 0x132698;
    entry_13262c(rdram, ctx, runtime);
}

void entry_1326f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1326f4 inside entry_13262c (0x13262c - 0x1327f8)
    ctx->pc = 0x1326f4;
    entry_13262c(rdram, ctx, runtime);
}

void entry_13273c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13273c inside entry_13262c (0x13262c - 0x1327f8)
    ctx->pc = 0x13273c;
    entry_13262c(rdram, ctx, runtime);
}

void entry_132788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132788 inside entry_13262c (0x13262c - 0x1327f8)
    ctx->pc = 0x132788;
    entry_13262c(rdram, ctx, runtime);
}

void entry_1327d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1327d0 inside entry_13262c (0x13262c - 0x1327f8)
    ctx->pc = 0x1327d0;
    entry_13262c(rdram, ctx, runtime);
}

void entry_1327e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1327e8 inside entry_13262c (0x13262c - 0x1327f8)
    ctx->pc = 0x1327e8;
    entry_13262c(rdram, ctx, runtime);
}

void entry_132860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132860 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x132860;
    entry_13281c(rdram, ctx, runtime);
}

void entry_1328a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1328a4 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x1328a4;
    entry_13281c(rdram, ctx, runtime);
}

void entry_1328d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1328d8 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x1328d8;
    entry_13281c(rdram, ctx, runtime);
}

void entry_1328f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1328f0 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x1328f0;
    entry_13281c(rdram, ctx, runtime);
}

void entry_132934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132934 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x132934;
    entry_13281c(rdram, ctx, runtime);
}

void entry_132974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132974 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x132974;
    entry_13281c(rdram, ctx, runtime);
}

void entry_13298c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13298c inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x13298c;
    entry_13281c(rdram, ctx, runtime);
}

void entry_1329d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1329d0 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x1329d0;
    entry_13281c(rdram, ctx, runtime);
}

void entry_132a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132a10 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x132a10;
    entry_13281c(rdram, ctx, runtime);
}

void entry_132a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132a28 inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x132a28;
    entry_13281c(rdram, ctx, runtime);
}

void entry_132a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132a6c inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x132a6c;
    entry_13281c(rdram, ctx, runtime);
}

void entry_132aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132aac inside entry_13281c (0x13281c - 0x132af4)
    ctx->pc = 0x132aac;
    entry_13281c(rdram, ctx, runtime);
}

void entry_132b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132b38 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132b38;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132b7c inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132b7c;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132bbc inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132bbc;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132bd4 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132bd4;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132c18 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132c18;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132c58 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132c58;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132c70 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132c70;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132cb4 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132cb4;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132cf4 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132cf4;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132d0c inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132d0c;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132d50 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132d50;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132d90 inside entry_132af4 (0x132af4 - 0x132e28)
    ctx->pc = 0x132d90;
    entry_132af4(rdram, ctx, runtime);
}

void entry_132ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x132ed8 inside entry_132ed0 (0x132ed0 - 0x132f08)
    ctx->pc = 0x132ed8;
    entry_132ed0(rdram, ctx, runtime);
}

void entry_133128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133128 inside entry_133120 (0x133120 - 0x133158)
    ctx->pc = 0x133128;
    entry_133120(rdram, ctx, runtime);
}

void entry_133330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133330 inside entry_13331c (0x13331c - 0x133360)
    ctx->pc = 0x133330;
    entry_13331c(rdram, ctx, runtime);
}

void entry_1333c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1333c4 inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x1333c4;
    entry_133360(rdram, ctx, runtime);
}

void entry_1333fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1333fc inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x1333fc;
    entry_133360(rdram, ctx, runtime);
}

void entry_133424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133424 inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x133424;
    entry_133360(rdram, ctx, runtime);
}

void entry_13343c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13343c inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x13343c;
    entry_133360(rdram, ctx, runtime);
}

void entry_133474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133474 inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x133474;
    entry_133360(rdram, ctx, runtime);
}

void entry_13349c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13349c inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x13349c;
    entry_133360(rdram, ctx, runtime);
}

void entry_1334b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1334b4 inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x1334b4;
    entry_133360(rdram, ctx, runtime);
}

void entry_1334ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1334ec inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x1334ec;
    entry_133360(rdram, ctx, runtime);
}

void entry_133514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133514 inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x133514;
    entry_133360(rdram, ctx, runtime);
}

void entry_13352c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13352c inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x13352c;
    entry_133360(rdram, ctx, runtime);
}

void entry_133564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133564 inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x133564;
    entry_133360(rdram, ctx, runtime);
}

void entry_13358c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13358c inside entry_133360 (0x133360 - 0x1335b0)
    ctx->pc = 0x13358c;
    entry_133360(rdram, ctx, runtime);
}

void entry_133730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133730 inside entry_1336bc (0x1336bc - 0x133760)
    ctx->pc = 0x133730;
    entry_1336bc(rdram, ctx, runtime);
}

void entry_1337cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1337cc inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x1337cc;
    entry_133760(rdram, ctx, runtime);
}

void entry_133804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133804 inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x133804;
    entry_133760(rdram, ctx, runtime);
}

void entry_13382c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13382c inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x13382c;
    entry_133760(rdram, ctx, runtime);
}

void entry_133844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133844 inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x133844;
    entry_133760(rdram, ctx, runtime);
}

void entry_13387c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13387c inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x13387c;
    entry_133760(rdram, ctx, runtime);
}

void entry_1338a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1338a4 inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x1338a4;
    entry_133760(rdram, ctx, runtime);
}

void entry_1338bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1338bc inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x1338bc;
    entry_133760(rdram, ctx, runtime);
}

void entry_1338f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1338f4 inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x1338f4;
    entry_133760(rdram, ctx, runtime);
}

void entry_13391c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13391c inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x13391c;
    entry_133760(rdram, ctx, runtime);
}

void entry_133934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133934 inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x133934;
    entry_133760(rdram, ctx, runtime);
}

void entry_13396c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13396c inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x13396c;
    entry_133760(rdram, ctx, runtime);
}

void entry_133994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133994 inside entry_133760 (0x133760 - 0x1339b8)
    ctx->pc = 0x133994;
    entry_133760(rdram, ctx, runtime);
}

void entry_133ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133ad4 inside entry_133abc (0x133abc - 0x133ae8)
    ctx->pc = 0x133ad4;
    entry_133abc(rdram, ctx, runtime);
}

void entry_133c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133c18 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133c18;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133c5c inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133c5c;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133c9c inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133c9c;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133cb4 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133cb4;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133cf8 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133cf8;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133d38 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133d38;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133d50 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133d50;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133d94 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133d94;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133dd4 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133dd4;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133dec inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133dec;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133e30 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133e30;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133e70 inside entry_133bbc (0x133bbc - 0x133eac)
    ctx->pc = 0x133e70;
    entry_133bbc(rdram, ctx, runtime);
}

void entry_133ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133ef8 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x133ef8;
    entry_133eac(rdram, ctx, runtime);
}

void entry_133f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133f3c inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x133f3c;
    entry_133eac(rdram, ctx, runtime);
}

void entry_133f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133f7c inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x133f7c;
    entry_133eac(rdram, ctx, runtime);
}

void entry_133f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133f94 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x133f94;
    entry_133eac(rdram, ctx, runtime);
}

void entry_133fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x133fd8 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x133fd8;
    entry_133eac(rdram, ctx, runtime);
}

void entry_134018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134018 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x134018;
    entry_133eac(rdram, ctx, runtime);
}

void entry_134030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134030 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x134030;
    entry_133eac(rdram, ctx, runtime);
}

void entry_134074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134074 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x134074;
    entry_133eac(rdram, ctx, runtime);
}

void entry_1340b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1340b4 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x1340b4;
    entry_133eac(rdram, ctx, runtime);
}

void entry_1340cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1340cc inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x1340cc;
    entry_133eac(rdram, ctx, runtime);
}

void entry_134110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134110 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x134110;
    entry_133eac(rdram, ctx, runtime);
}

void entry_134150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134150 inside entry_133eac (0x133eac - 0x13418c)
    ctx->pc = 0x134150;
    entry_133eac(rdram, ctx, runtime);
}

void entry_1341d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1341d8 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x1341d8;
    entry_13418c(rdram, ctx, runtime);
}

void entry_13421c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13421c inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x13421c;
    entry_13418c(rdram, ctx, runtime);
}

void entry_13425c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13425c inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x13425c;
    entry_13418c(rdram, ctx, runtime);
}

void entry_134274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134274 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x134274;
    entry_13418c(rdram, ctx, runtime);
}

void entry_1342b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1342b8 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x1342b8;
    entry_13418c(rdram, ctx, runtime);
}

void entry_1342f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1342f8 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x1342f8;
    entry_13418c(rdram, ctx, runtime);
}

void entry_134310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134310 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x134310;
    entry_13418c(rdram, ctx, runtime);
}

void entry_134354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134354 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x134354;
    entry_13418c(rdram, ctx, runtime);
}

void entry_134394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134394 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x134394;
    entry_13418c(rdram, ctx, runtime);
}

void entry_1343ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1343ac inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x1343ac;
    entry_13418c(rdram, ctx, runtime);
}

void entry_1343f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1343f0 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x1343f0;
    entry_13418c(rdram, ctx, runtime);
}

void entry_134430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134430 inside entry_13418c (0x13418c - 0x13446c)
    ctx->pc = 0x134430;
    entry_13418c(rdram, ctx, runtime);
}

void entry_134500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134500 inside entry_1344fc (0x1344fc - 0x134508)
    ctx->pc = 0x134500;
    entry_1344fc(rdram, ctx, runtime);
}

void entry_134678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134678 inside entry_134674 (0x134674 - 0x134680)
    ctx->pc = 0x134678;
    entry_134674(rdram, ctx, runtime);
}

void entry_1347f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1347f0 inside entry_1347ec (0x1347ec - 0x1347f8)
    ctx->pc = 0x1347f0;
    entry_1347ec(rdram, ctx, runtime);
}

void entry_134968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134968 inside entry_134964 (0x134964 - 0x134970)
    ctx->pc = 0x134968;
    entry_134964(rdram, ctx, runtime);
}

void entry_134b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134b28 inside entry_134ac8 (0x134ac8 - 0x134b48)
    ctx->pc = 0x134b28;
    entry_134ac8(rdram, ctx, runtime);
}

void entry_134c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134c20 inside entry_134bec (0x134bec - 0x134c2c)
    ctx->pc = 0x134c20;
    entry_134bec(rdram, ctx, runtime);
}

void entry_134cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134cd8 inside entry_134cd0 (0x134cd0 - 0x134ce8)
    ctx->pc = 0x134cd8;
    entry_134cd0(rdram, ctx, runtime);
}

void entry_134d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134d2c inside entry_134ce8 (0x134ce8 - 0x134dbc)
    ctx->pc = 0x134d2c;
    entry_134ce8(rdram, ctx, runtime);
}

void entry_134d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134d38 inside entry_134ce8 (0x134ce8 - 0x134dbc)
    ctx->pc = 0x134d38;
    entry_134ce8(rdram, ctx, runtime);
}

void entry_134da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134da8 inside entry_134ce8 (0x134ce8 - 0x134dbc)
    ctx->pc = 0x134da8;
    entry_134ce8(rdram, ctx, runtime);
}

void entry_134dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134dc8 inside entry_134dbc (0x134dbc - 0x134e14)
    ctx->pc = 0x134dc8;
    entry_134dbc(rdram, ctx, runtime);
}

void entry_134de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134de8 inside entry_134dbc (0x134dbc - 0x134e14)
    ctx->pc = 0x134de8;
    entry_134dbc(rdram, ctx, runtime);
}

void entry_134dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134dfc inside entry_134dbc (0x134dbc - 0x134e14)
    ctx->pc = 0x134dfc;
    entry_134dbc(rdram, ctx, runtime);
}

void entry_134e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134e7c inside entry_134e14 (0x134e14 - 0x134ec4)
    ctx->pc = 0x134e7c;
    entry_134e14(rdram, ctx, runtime);
}

void entry_134e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134e90 inside entry_134e14 (0x134e14 - 0x134ec4)
    ctx->pc = 0x134e90;
    entry_134e14(rdram, ctx, runtime);
}

void entry_134ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134ea8 inside entry_134e14 (0x134e14 - 0x134ec4)
    ctx->pc = 0x134ea8;
    entry_134e14(rdram, ctx, runtime);
}

void entry_134ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134ee0 inside entry_134ec4 (0x134ec4 - 0x134f08)
    ctx->pc = 0x134ee0;
    entry_134ec4(rdram, ctx, runtime);
}

void entry_134ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x134ee4 inside entry_134ec4 (0x134ec4 - 0x134f08)
    ctx->pc = 0x134ee4;
    entry_134ec4(rdram, ctx, runtime);
}

void entry_1351c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1351c8 inside entry_1351bc (0x1351bc - 0x135228)
    ctx->pc = 0x1351c8;
    entry_1351bc(rdram, ctx, runtime);
}

void entry_135338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135338 inside entry_135310 (0x135310 - 0x135380)
    ctx->pc = 0x135338;
    entry_135310(rdram, ctx, runtime);
}

void entry_13535c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13535c inside entry_135310 (0x135310 - 0x135380)
    ctx->pc = 0x13535c;
    entry_135310(rdram, ctx, runtime);
}

void entry_1353a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1353a8 inside entry_135380 (0x135380 - 0x135460)
    ctx->pc = 0x1353a8;
    entry_135380(rdram, ctx, runtime);
}

void entry_135498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135498 inside entry_13548c (0x13548c - 0x1354e4)
    ctx->pc = 0x135498;
    entry_13548c(rdram, ctx, runtime);
}

void entry_1354fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1354fc inside entry_1354e4 (0x1354e4 - 0x135550)
    ctx->pc = 0x1354fc;
    entry_1354e4(rdram, ctx, runtime);
}

void entry_1355d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1355d8 inside entry_135594 (0x135594 - 0x1355e4)
    ctx->pc = 0x1355d8;
    entry_135594(rdram, ctx, runtime);
}

void entry_135600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135600 inside entry_1355e4 (0x1355e4 - 0x135628)
    ctx->pc = 0x135600;
    entry_1355e4(rdram, ctx, runtime);
}

void entry_135608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135608 inside entry_1355e4 (0x1355e4 - 0x135628)
    ctx->pc = 0x135608;
    entry_1355e4(rdram, ctx, runtime);
}

void entry_135668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135668 inside entry_135628 (0x135628 - 0x135678)
    ctx->pc = 0x135668;
    entry_135628(rdram, ctx, runtime);
}

void entry_135694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135694 inside entry_135678 (0x135678 - 0x1356a8)
    ctx->pc = 0x135694;
    entry_135678(rdram, ctx, runtime);
}

void entry_13569c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13569c inside entry_135678 (0x135678 - 0x1356a8)
    ctx->pc = 0x13569c;
    entry_135678(rdram, ctx, runtime);
}

void entry_1356a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1356a0 inside entry_135678 (0x135678 - 0x1356a8)
    ctx->pc = 0x1356a0;
    entry_135678(rdram, ctx, runtime);
}

void entry_1356ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1356ac inside entry_1356a8 (0x1356a8 - 0x1356c0)
    ctx->pc = 0x1356ac;
    entry_1356a8(rdram, ctx, runtime);
}

void entry_13570c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13570c inside entry_135704 (0x135704 - 0x13574c)
    ctx->pc = 0x13570c;
    entry_135704(rdram, ctx, runtime);
}

void entry_135750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135750 inside entry_13574c (0x13574c - 0x1357a8)
    ctx->pc = 0x135750;
    entry_13574c(rdram, ctx, runtime);
}

void entry_135768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135768 inside entry_13574c (0x13574c - 0x1357a8)
    ctx->pc = 0x135768;
    entry_13574c(rdram, ctx, runtime);
}

void entry_1357b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1357b0 inside entry_1357a8 (0x1357a8 - 0x1357cc)
    ctx->pc = 0x1357b0;
    entry_1357a8(rdram, ctx, runtime);
}

void entry_1357d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1357d0 inside entry_1357cc (0x1357cc - 0x1357f0)
    ctx->pc = 0x1357d0;
    entry_1357cc(rdram, ctx, runtime);
}

void entry_1357dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1357dc inside entry_1357cc (0x1357cc - 0x1357f0)
    ctx->pc = 0x1357dc;
    entry_1357cc(rdram, ctx, runtime);
}

void entry_135844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135844 inside entry_135820 (0x135820 - 0x135858)
    ctx->pc = 0x135844;
    entry_135820(rdram, ctx, runtime);
}

void entry_135848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135848 inside entry_135820 (0x135820 - 0x135858)
    ctx->pc = 0x135848;
    entry_135820(rdram, ctx, runtime);
}

void entry_1358bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1358bc inside entry_135894 (0x135894 - 0x1358d0)
    ctx->pc = 0x1358bc;
    entry_135894(rdram, ctx, runtime);
}

void entry_1358c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1358c0 inside entry_135894 (0x135894 - 0x1358d0)
    ctx->pc = 0x1358c0;
    entry_135894(rdram, ctx, runtime);
}

void entry_135968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135968 inside entry_13594c (0x13594c - 0x135984)
    ctx->pc = 0x135968;
    entry_13594c(rdram, ctx, runtime);
}

void entry_1359e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1359e0 inside entry_135984 (0x135984 - 0x135a10)
    ctx->pc = 0x1359e0;
    entry_135984(rdram, ctx, runtime);
}

void entry_1359fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1359fc inside entry_135984 (0x135984 - 0x135a10)
    ctx->pc = 0x1359fc;
    entry_135984(rdram, ctx, runtime);
}

void entry_135a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135a00 inside entry_135984 (0x135984 - 0x135a10)
    ctx->pc = 0x135a00;
    entry_135984(rdram, ctx, runtime);
}

void entry_135a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135a54 inside entry_135a28 (0x135a28 - 0x135a98)
    ctx->pc = 0x135a54;
    entry_135a28(rdram, ctx, runtime);
}

void entry_135a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135a78 inside entry_135a28 (0x135a28 - 0x135a98)
    ctx->pc = 0x135a78;
    entry_135a28(rdram, ctx, runtime);
}

void entry_135ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135ad4 inside entry_135a98 (0x135a98 - 0x135aec)
    ctx->pc = 0x135ad4;
    entry_135a98(rdram, ctx, runtime);
}

void entry_135adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135adc inside entry_135a98 (0x135a98 - 0x135aec)
    ctx->pc = 0x135adc;
    entry_135a98(rdram, ctx, runtime);
}

void entry_135b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135b14 inside entry_135aec (0x135aec - 0x135b94)
    ctx->pc = 0x135b14;
    entry_135aec(rdram, ctx, runtime);
}

void entry_135b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135b18 inside entry_135aec (0x135aec - 0x135b94)
    ctx->pc = 0x135b18;
    entry_135aec(rdram, ctx, runtime);
}

void entry_135c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135c24 inside entry_135bec (0x135bec - 0x135cec)
    ctx->pc = 0x135c24;
    entry_135bec(rdram, ctx, runtime);
}

void entry_135c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135c50 inside entry_135bec (0x135bec - 0x135cec)
    ctx->pc = 0x135c50;
    entry_135bec(rdram, ctx, runtime);
}

void entry_135c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135c68 inside entry_135bec (0x135bec - 0x135cec)
    ctx->pc = 0x135c68;
    entry_135bec(rdram, ctx, runtime);
}

void entry_135c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135c78 inside entry_135bec (0x135bec - 0x135cec)
    ctx->pc = 0x135c78;
    entry_135bec(rdram, ctx, runtime);
}

void entry_135c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135c7c inside entry_135bec (0x135bec - 0x135cec)
    ctx->pc = 0x135c7c;
    entry_135bec(rdram, ctx, runtime);
}

void entry_135cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135cb0 inside entry_135bec (0x135bec - 0x135cec)
    ctx->pc = 0x135cb0;
    entry_135bec(rdram, ctx, runtime);
}

void entry_135cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135cd4 inside entry_135bec (0x135bec - 0x135cec)
    ctx->pc = 0x135cd4;
    entry_135bec(rdram, ctx, runtime);
}

void entry_135d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135d24 inside entry_135d14 (0x135d14 - 0x135d44)
    ctx->pc = 0x135d24;
    entry_135d14(rdram, ctx, runtime);
}

void entry_135dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135dd4 inside entry_135d94 (0x135d94 - 0x135e20)
    ctx->pc = 0x135dd4;
    entry_135d94(rdram, ctx, runtime);
}

void entry_135dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135dd8 inside entry_135d94 (0x135d94 - 0x135e20)
    ctx->pc = 0x135dd8;
    entry_135d94(rdram, ctx, runtime);
}

void entry_135de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135de4 inside entry_135d94 (0x135d94 - 0x135e20)
    ctx->pc = 0x135de4;
    entry_135d94(rdram, ctx, runtime);
}

void entry_135ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135ec0 inside SetBinocBfk (0x135e78 - 0x135ed0)
    ctx->pc = 0x135ec0;
    SetBinocBfk(rdram, ctx, runtime);
}

void entry_135ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135ee8 inside entry_135ee0 (0x135ee0 - 0x135ef0)
    ctx->pc = 0x135ee8;
    entry_135ee0(rdram, ctx, runtime);
}

void entry_135ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135ef4 inside entry_135ef0 (0x135ef0 - 0x135f1c)
    ctx->pc = 0x135ef4;
    entry_135ef0(rdram, ctx, runtime);
}

void entry_135f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135f04 inside entry_135ef0 (0x135ef0 - 0x135f1c)
    ctx->pc = 0x135f04;
    entry_135ef0(rdram, ctx, runtime);
}

void entry_135f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135f20 inside entry_135f1c (0x135f1c - 0x135f48)
    ctx->pc = 0x135f20;
    entry_135f1c(rdram, ctx, runtime);
}

void entry_135f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x135f9c inside entry_135f94 (0x135f94 - 0x135fa8)
    ctx->pc = 0x135f9c;
    entry_135f94(rdram, ctx, runtime);
}

void entry_136020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136020 inside entry_13601c (0x13601c - 0x136040)
    ctx->pc = 0x136020;
    entry_13601c(rdram, ctx, runtime);
}

void entry_13607c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13607c inside FUN_00136040 (0x136040 - 0x1361c0)
    ctx->pc = 0x13607c;
    FUN_00136040(rdram, ctx, runtime);
}

void entry_1360fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1360fc inside FUN_00136040 (0x136040 - 0x1361c0)
    ctx->pc = 0x1360fc;
    FUN_00136040(rdram, ctx, runtime);
}

void entry_136124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136124 inside FUN_00136040 (0x136040 - 0x1361c0)
    ctx->pc = 0x136124;
    FUN_00136040(rdram, ctx, runtime);
}

void entry_136134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136134 inside FUN_00136040 (0x136040 - 0x1361c0)
    ctx->pc = 0x136134;
    FUN_00136040(rdram, ctx, runtime);
}

void entry_13614c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13614c inside FUN_00136040 (0x136040 - 0x1361c0)
    ctx->pc = 0x13614c;
    FUN_00136040(rdram, ctx, runtime);
}

void entry_1361b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1361b4 inside FUN_00136040 (0x136040 - 0x1361c0)
    ctx->pc = 0x1361b4;
    FUN_00136040(rdram, ctx, runtime);
}

void entry_136208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136208 inside entry_136200 (0x136200 - 0x136220)
    ctx->pc = 0x136208;
    entry_136200(rdram, ctx, runtime);
}

void entry_136214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136214 inside entry_136200 (0x136200 - 0x136220)
    ctx->pc = 0x136214;
    entry_136200(rdram, ctx, runtime);
}

void entry_136218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136218 inside entry_136200 (0x136200 - 0x136220)
    ctx->pc = 0x136218;
    entry_136200(rdram, ctx, runtime);
}

void entry_136298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136298 inside entry_136290 (0x136290 - 0x1362a0)
    ctx->pc = 0x136298;
    entry_136290(rdram, ctx, runtime);
}

void entry_1362a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1362a4 inside entry_1362a0 (0x1362a0 - 0x1362c0)
    ctx->pc = 0x1362a4;
    entry_1362a0(rdram, ctx, runtime);
}

void entry_136370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136370 inside entry_136348 (0x136348 - 0x13637c)
    ctx->pc = 0x136370;
    entry_136348(rdram, ctx, runtime);
}

void entry_13638c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13638c inside entry_13637c (0x13637c - 0x1363a0)
    ctx->pc = 0x13638c;
    entry_13637c(rdram, ctx, runtime);
}

void entry_1363bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1363bc inside entry_1363b8 (0x1363b8 - 0x1363d0)
    ctx->pc = 0x1363bc;
    entry_1363b8(rdram, ctx, runtime);
}

void entry_1363fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1363fc inside entry_1363f8 (0x1363f8 - 0x136408)
    ctx->pc = 0x1363fc;
    entry_1363f8(rdram, ctx, runtime);
}

void entry_13646c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13646c inside entry_13644c (0x13644c - 0x136474)
    ctx->pc = 0x13646c;
    entry_13644c(rdram, ctx, runtime);
}

void entry_1364a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1364a0 inside entry_136484 (0x136484 - 0x1364a8)
    ctx->pc = 0x1364a0;
    entry_136484(rdram, ctx, runtime);
}

void entry_1364c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1364c0 inside entry_1364b8 (0x1364b8 - 0x1364ec)
    ctx->pc = 0x1364c0;
    entry_1364b8(rdram, ctx, runtime);
}

void entry_1364e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1364e4 inside entry_1364b8 (0x1364b8 - 0x1364ec)
    ctx->pc = 0x1364e4;
    entry_1364b8(rdram, ctx, runtime);
}

void entry_136500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136500 inside entry_1364ec (0x1364ec - 0x136530)
    ctx->pc = 0x136500;
    entry_1364ec(rdram, ctx, runtime);
}

void entry_13650c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13650c inside entry_1364ec (0x1364ec - 0x136530)
    ctx->pc = 0x13650c;
    entry_1364ec(rdram, ctx, runtime);
}

void entry_13658c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13658c inside entry_136560 (0x136560 - 0x1365a0)
    ctx->pc = 0x13658c;
    entry_136560(rdram, ctx, runtime);
}

void entry_136590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136590 inside entry_136560 (0x136560 - 0x1365a0)
    ctx->pc = 0x136590;
    entry_136560(rdram, ctx, runtime);
}

void entry_1365d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1365d8 inside SetBinocZoom__FP5BINOCf (0x1365a8 - 0x1365f0)
    ctx->pc = 0x1365d8;
    SetBinocZoom__FP5BINOCf(rdram, ctx, runtime);
}

void entry_1365e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1365e8 inside SetBinocZoom__FP5BINOCf (0x1365a8 - 0x1365f0)
    ctx->pc = 0x1365e8;
    SetBinocZoom__FP5BINOCf(rdram, ctx, runtime);
}

void entry_136634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136634 inside FUN_001365f0 (0x1365f0 - 0x13663c)
    ctx->pc = 0x136634;
    FUN_001365f0(rdram, ctx, runtime);
}

void entry_136640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136640 inside entry_13663c (0x13663c - 0x136648)
    ctx->pc = 0x136640;
    entry_13663c(rdram, ctx, runtime);
}

void entry_13668c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13668c inside FUN_00136648 (0x136648 - 0x136694)
    ctx->pc = 0x13668c;
    FUN_00136648(rdram, ctx, runtime);
}

void entry_136698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136698 inside entry_136694 (0x136694 - 0x1366a0)
    ctx->pc = 0x136698;
    entry_136694(rdram, ctx, runtime);
}

void entry_13671c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13671c inside entry_1366ec (0x1366ec - 0x13673c)
    ctx->pc = 0x13671c;
    entry_1366ec(rdram, ctx, runtime);
}

void entry_136784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136784 inside entry_13677c (0x13677c - 0x136794)
    ctx->pc = 0x136784;
    entry_13677c(rdram, ctx, runtime);
}

void entry_136798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136798 inside entry_136794 (0x136794 - 0x1367d8)
    ctx->pc = 0x136798;
    entry_136794(rdram, ctx, runtime);
}

void entry_13679c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13679c inside entry_136794 (0x136794 - 0x1367d8)
    ctx->pc = 0x13679c;
    entry_136794(rdram, ctx, runtime);
}

void entry_1367b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1367b8 inside entry_136794 (0x136794 - 0x1367d8)
    ctx->pc = 0x1367b8;
    entry_136794(rdram, ctx, runtime);
}

void entry_1367d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1367d0 inside entry_136794 (0x136794 - 0x1367d8)
    ctx->pc = 0x1367d0;
    entry_136794(rdram, ctx, runtime);
}

void entry_13680c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13680c inside entry_1367d8 (0x1367d8 - 0x1368b0)
    ctx->pc = 0x13680c;
    entry_1367d8(rdram, ctx, runtime);
}

void entry_136810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136810 inside entry_1367d8 (0x1367d8 - 0x1368b0)
    ctx->pc = 0x136810;
    entry_1367d8(rdram, ctx, runtime);
}

void entry_13685c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13685c inside entry_1367d8 (0x1367d8 - 0x1368b0)
    ctx->pc = 0x13685c;
    entry_1367d8(rdram, ctx, runtime);
}

void entry_13686c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13686c inside entry_1367d8 (0x1367d8 - 0x1368b0)
    ctx->pc = 0x13686c;
    entry_1367d8(rdram, ctx, runtime);
}

void entry_136884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136884 inside entry_1367d8 (0x1367d8 - 0x1368b0)
    ctx->pc = 0x136884;
    entry_1367d8(rdram, ctx, runtime);
}

void entry_13690c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13690c inside entry_1368e8 (0x1368e8 - 0x136ac4)
    ctx->pc = 0x13690c;
    entry_1368e8(rdram, ctx, runtime);
}

void entry_136924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136924 inside entry_1368e8 (0x1368e8 - 0x136ac4)
    ctx->pc = 0x136924;
    entry_1368e8(rdram, ctx, runtime);
}

void entry_136978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136978 inside entry_1368e8 (0x1368e8 - 0x136ac4)
    ctx->pc = 0x136978;
    entry_1368e8(rdram, ctx, runtime);
}

void entry_1369a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1369a0 inside entry_1368e8 (0x1368e8 - 0x136ac4)
    ctx->pc = 0x1369a0;
    entry_1368e8(rdram, ctx, runtime);
}

void entry_136a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136a04 inside entry_1368e8 (0x1368e8 - 0x136ac4)
    ctx->pc = 0x136a04;
    entry_1368e8(rdram, ctx, runtime);
}

void entry_136a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136a38 inside entry_1368e8 (0x1368e8 - 0x136ac4)
    ctx->pc = 0x136a38;
    entry_1368e8(rdram, ctx, runtime);
}

void entry_136a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136a5c inside entry_1368e8 (0x1368e8 - 0x136ac4)
    ctx->pc = 0x136a5c;
    entry_1368e8(rdram, ctx, runtime);
}

void entry_136adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136adc inside entry_136ac4 (0x136ac4 - 0x136afc)
    ctx->pc = 0x136adc;
    entry_136ac4(rdram, ctx, runtime);
}

void entry_136b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136b70 inside entry_136b04 (0x136b04 - 0x136c04)
    ctx->pc = 0x136b70;
    entry_136b04(rdram, ctx, runtime);
}

void entry_136b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136b8c inside entry_136b04 (0x136b04 - 0x136c04)
    ctx->pc = 0x136b8c;
    entry_136b04(rdram, ctx, runtime);
}

void entry_136bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136bf4 inside entry_136b04 (0x136b04 - 0x136c04)
    ctx->pc = 0x136bf4;
    entry_136b04(rdram, ctx, runtime);
}

void entry_136bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136bf8 inside entry_136b04 (0x136b04 - 0x136c04)
    ctx->pc = 0x136bf8;
    entry_136b04(rdram, ctx, runtime);
}

void entry_136c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136c4c inside entry_136c20 (0x136c20 - 0x136c64)
    ctx->pc = 0x136c4c;
    entry_136c20(rdram, ctx, runtime);
}

void entry_136c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136c68 inside entry_136c64 (0x136c64 - 0x136cc0)
    ctx->pc = 0x136c68;
    entry_136c64(rdram, ctx, runtime);
}

void entry_136dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136dd4 inside entry_136da4 (0x136da4 - 0x136e00)
    ctx->pc = 0x136dd4;
    entry_136da4(rdram, ctx, runtime);
}

void entry_136df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136df4 inside entry_136da4 (0x136da4 - 0x136e00)
    ctx->pc = 0x136df4;
    entry_136da4(rdram, ctx, runtime);
}

void entry_136e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136e84 inside entry_136e80 (0x136e80 - 0x136ec8)
    ctx->pc = 0x136e84;
    entry_136e80(rdram, ctx, runtime);
}

void entry_136f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136f3c inside FUN_00136ef8 (0x136ef8 - 0x136f54)
    ctx->pc = 0x136f3c;
    FUN_00136ef8(rdram, ctx, runtime);
}

void entry_136f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136f4c inside FUN_00136ef8 (0x136ef8 - 0x136f54)
    ctx->pc = 0x136f4c;
    FUN_00136ef8(rdram, ctx, runtime);
}

void entry_136f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136f5c inside entry_136f54 (0x136f54 - 0x136f68)
    ctx->pc = 0x136f5c;
    entry_136f54(rdram, ctx, runtime);
}

void entry_136f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136f70 inside entry_136f68 (0x136f68 - 0x136f78)
    ctx->pc = 0x136f70;
    entry_136f68(rdram, ctx, runtime);
}

void entry_136f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136f7c inside entry_136f78 (0x136f78 - 0x136f84)
    ctx->pc = 0x136f7c;
    entry_136f78(rdram, ctx, runtime);
}

void entry_136f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136f8c inside entry_136f84 (0x136f84 - 0x136f94)
    ctx->pc = 0x136f8c;
    entry_136f84(rdram, ctx, runtime);
}

void entry_136f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136f98 inside entry_136f94 (0x136f94 - 0x136fa8)
    ctx->pc = 0x136f98;
    entry_136f94(rdram, ctx, runtime);
}

void entry_136fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136fd0 inside entry_136fc8 (0x136fc8 - 0x136fd8)
    ctx->pc = 0x136fd0;
    entry_136fc8(rdram, ctx, runtime);
}

void entry_136fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x136fdc inside entry_136fd8 (0x136fd8 - 0x136fe8)
    ctx->pc = 0x136fdc;
    entry_136fd8(rdram, ctx, runtime);
}

void entry_1371f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1371f0 inside entry_1371c8 (0x1371c8 - 0x137228)
    ctx->pc = 0x1371f0;
    entry_1371c8(rdram, ctx, runtime);
}

void entry_1372e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1372e0 inside __18CBinaryInputStreamPvii (0x137290 - 0x1372fc)
    ctx->pc = 0x1372e0;
    fn___18CBinaryInputStreamPvii(rdram, ctx, runtime);
}

void entry_137314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137314 inside entry_137310 (0x137310 - 0x137328)
    ctx->pc = 0x137314;
    entry_137310(rdram, ctx, runtime);
}

void entry_13736c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13736c inside FOpenSector__18CBinaryInputStreamUiUi (0x137328 - 0x137398)
    ctx->pc = 0x13736c;
    FOpenSector__18CBinaryInputStreamUiUi(rdram, ctx, runtime);
}

void entry_1373fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1373fc inside Close__18CBinaryInputStream (0x1373d0 - 0x137410)
    ctx->pc = 0x1373fc;
    Close__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_137418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137418 inside entry_137410 (0x137410 - 0x13743c)
    ctx->pc = 0x137418;
    entry_137410(rdram, ctx, runtime);
}

void entry_137444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137444 inside entry_13743c (0x13743c - 0x13744c)
    ctx->pc = 0x137444;
    entry_13743c(rdram, ctx, runtime);
}

void entry_137450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137450 inside entry_13744c (0x13744c - 0x137480)
    ctx->pc = 0x137450;
    entry_13744c(rdram, ctx, runtime);
}

void entry_137454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137454 inside entry_13744c (0x13744c - 0x137480)
    ctx->pc = 0x137454;
    entry_13744c(rdram, ctx, runtime);
}

void entry_1374dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1374dc inside PumpCd__18CBinaryInputStream (0x137490 - 0x137570)
    ctx->pc = 0x1374dc;
    PumpCd__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_137514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137514 inside PumpCd__18CBinaryInputStream (0x137490 - 0x137570)
    ctx->pc = 0x137514;
    PumpCd__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_137530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137530 inside PumpCd__18CBinaryInputStream (0x137490 - 0x137570)
    ctx->pc = 0x137530;
    PumpCd__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_137534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137534 inside PumpCd__18CBinaryInputStream (0x137490 - 0x137570)
    ctx->pc = 0x137534;
    PumpCd__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_137540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137540 inside PumpCd__18CBinaryInputStream (0x137490 - 0x137570)
    ctx->pc = 0x137540;
    PumpCd__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_13754c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13754c inside PumpCd__18CBinaryInputStream (0x137490 - 0x137570)
    ctx->pc = 0x13754c;
    PumpCd__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_137578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137578 inside entry_137570 (0x137570 - 0x1375bc)
    ctx->pc = 0x137578;
    entry_137570(rdram, ctx, runtime);
}

void entry_13757c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13757c inside entry_137570 (0x137570 - 0x1375bc)
    ctx->pc = 0x13757c;
    entry_137570(rdram, ctx, runtime);
}

void entry_1375a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1375a8 inside entry_137570 (0x137570 - 0x1375bc)
    ctx->pc = 0x1375a8;
    entry_137570(rdram, ctx, runtime);
}

void entry_1375c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1375c4 inside entry_1375bc (0x1375bc - 0x1375cc)
    ctx->pc = 0x1375c4;
    entry_1375bc(rdram, ctx, runtime);
}

void entry_1375f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1375f4 inside entry_1375ec (0x1375ec - 0x1375fc)
    ctx->pc = 0x1375f4;
    entry_1375ec(rdram, ctx, runtime);
}

void entry_137640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137640 inside entry_1375fc (0x1375fc - 0x137698)
    ctx->pc = 0x137640;
    entry_1375fc(rdram, ctx, runtime);
}

void entry_1376a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1376a0 inside entry_137698 (0x137698 - 0x1376a8)
    ctx->pc = 0x1376a0;
    entry_137698(rdram, ctx, runtime);
}

void entry_1376ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1376ac inside entry_1376a8 (0x1376a8 - 0x137738)
    ctx->pc = 0x1376ac;
    entry_1376a8(rdram, ctx, runtime);
}

void entry_1376f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1376f4 inside entry_1376a8 (0x1376a8 - 0x137738)
    ctx->pc = 0x1376f4;
    entry_1376a8(rdram, ctx, runtime);
}

void entry_137740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137740 inside entry_137738 (0x137738 - 0x13774c)
    ctx->pc = 0x137740;
    entry_137738(rdram, ctx, runtime);
}

void entry_137750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137750 inside entry_13774c (0x13774c - 0x1377c0)
    ctx->pc = 0x137750;
    entry_13774c(rdram, ctx, runtime);
}

void entry_137760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137760 inside entry_13774c (0x13774c - 0x1377c0)
    ctx->pc = 0x137760;
    entry_13774c(rdram, ctx, runtime);
}

void entry_13776c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13776c inside entry_13774c (0x13774c - 0x1377c0)
    ctx->pc = 0x13776c;
    entry_13774c(rdram, ctx, runtime);
}

void entry_137798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137798 inside entry_13774c (0x13774c - 0x1377c0)
    ctx->pc = 0x137798;
    entry_13774c(rdram, ctx, runtime);
}

void entry_1377a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1377a8 inside entry_13774c (0x13774c - 0x1377c0)
    ctx->pc = 0x1377a8;
    entry_13774c(rdram, ctx, runtime);
}

void entry_1377f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1377f8 inside PumpHost__18CBinaryInputStream (0x1377c0 - 0x13780c)
    ctx->pc = 0x1377f8;
    PumpHost__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_1377fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1377fc inside PumpHost__18CBinaryInputStream (0x1377c0 - 0x13780c)
    ctx->pc = 0x1377fc;
    PumpHost__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_13784c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13784c inside Pump__18CBinaryInputStream (0x137820 - 0x137854)
    ctx->pc = 0x13784c;
    Pump__18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_13785c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13785c inside entry_137854 (0x137854 - 0x137864)
    ctx->pc = 0x13785c;
    entry_137854(rdram, ctx, runtime);
}

void entry_137868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137868 inside entry_137864 (0x137864 - 0x137890)
    ctx->pc = 0x137868;
    entry_137864(rdram, ctx, runtime);
}

void entry_1378fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1378fc inside entry_1378f8 (0x1378f8 - 0x137940)
    ctx->pc = 0x1378fc;
    entry_1378f8(rdram, ctx, runtime);
}

void entry_137908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137908 inside entry_1378f8 (0x1378f8 - 0x137940)
    ctx->pc = 0x137908;
    entry_1378f8(rdram, ctx, runtime);
}

void entry_137910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137910 inside entry_1378f8 (0x1378f8 - 0x137940)
    ctx->pc = 0x137910;
    entry_1378f8(rdram, ctx, runtime);
}

void entry_13792c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13792c inside entry_1378f8 (0x1378f8 - 0x137940)
    ctx->pc = 0x13792c;
    entry_1378f8(rdram, ctx, runtime);
}

void entry_137950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137950 inside entry_137940 (0x137940 - 0x1379c0)
    ctx->pc = 0x137950;
    entry_137940(rdram, ctx, runtime);
}

void entry_137970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137970 inside entry_137940 (0x137940 - 0x1379c0)
    ctx->pc = 0x137970;
    entry_137940(rdram, ctx, runtime);
}

void entry_137994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137994 inside entry_137940 (0x137940 - 0x1379c0)
    ctx->pc = 0x137994;
    entry_137940(rdram, ctx, runtime);
}

void entry_1379d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1379d8 inside entry_1379c0 (0x1379c0 - 0x1379f4)
    ctx->pc = 0x1379d8;
    entry_1379c0(rdram, ctx, runtime);
}

void entry_1379e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1379e4 inside entry_1379c0 (0x1379c0 - 0x1379f4)
    ctx->pc = 0x1379e4;
    entry_1379c0(rdram, ctx, runtime);
}

void entry_137a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137a00 inside entry_1379f4 (0x1379f4 - 0x137a60)
    ctx->pc = 0x137a00;
    entry_1379f4(rdram, ctx, runtime);
}

void entry_137a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137a1c inside entry_1379f4 (0x1379f4 - 0x137a60)
    ctx->pc = 0x137a1c;
    entry_1379f4(rdram, ctx, runtime);
}

void entry_137a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137a24 inside entry_1379f4 (0x1379f4 - 0x137a60)
    ctx->pc = 0x137a24;
    entry_1379f4(rdram, ctx, runtime);
}

void entry_137a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137a98 inside Read__18CBinaryInputStreamiPv (0x137a60 - 0x137abc)
    ctx->pc = 0x137a98;
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime);
}

void entry_137ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137ac4 inside entry_137abc (0x137abc - 0x137acc)
    ctx->pc = 0x137ac4;
    entry_137abc(rdram, ctx, runtime);
}

void entry_137aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137aec inside entry_137acc (0x137acc - 0x137b1c)
    ctx->pc = 0x137aec;
    entry_137acc(rdram, ctx, runtime);
}

void entry_137afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137afc inside entry_137acc (0x137acc - 0x137b1c)
    ctx->pc = 0x137afc;
    entry_137acc(rdram, ctx, runtime);
}

void entry_137b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137b3c inside entry_137b1c (0x137b1c - 0x137b60)
    ctx->pc = 0x137b3c;
    entry_137b1c(rdram, ctx, runtime);
}

void entry_137bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137bc0 inside entry_137bb8 (0x137bb8 - 0x137be0)
    ctx->pc = 0x137bc0;
    entry_137bb8(rdram, ctx, runtime);
}

void entry_137bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137bd4 inside entry_137bb8 (0x137bb8 - 0x137be0)
    ctx->pc = 0x137bd4;
    entry_137bb8(rdram, ctx, runtime);
}

void entry_137c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137c10 inside entry_137c08 (0x137c08 - 0x137c40)
    ctx->pc = 0x137c10;
    entry_137c08(rdram, ctx, runtime);
}

void entry_137c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137c34 inside entry_137c08 (0x137c08 - 0x137c40)
    ctx->pc = 0x137c34;
    entry_137c08(rdram, ctx, runtime);
}

void entry_137c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137c6c inside entry_137c64 (0x137c64 - 0x137cb8)
    ctx->pc = 0x137c6c;
    entry_137c64(rdram, ctx, runtime);
}

void entry_137ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137ca8 inside entry_137c64 (0x137c64 - 0x137cb8)
    ctx->pc = 0x137ca8;
    entry_137c64(rdram, ctx, runtime);
}

void entry_137cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137cf0 inside entry_137ce8 (0x137ce8 - 0x137d10)
    ctx->pc = 0x137cf0;
    entry_137ce8(rdram, ctx, runtime);
}

void entry_137d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137d04 inside entry_137ce8 (0x137ce8 - 0x137d10)
    ctx->pc = 0x137d04;
    entry_137ce8(rdram, ctx, runtime);
}

void entry_137d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137d40 inside entry_137d38 (0x137d38 - 0x137d78)
    ctx->pc = 0x137d40;
    entry_137d38(rdram, ctx, runtime);
}

void entry_137d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137d68 inside entry_137d38 (0x137d38 - 0x137d78)
    ctx->pc = 0x137d68;
    entry_137d38(rdram, ctx, runtime);
}

void entry_137da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137da4 inside entry_137d9c (0x137d9c - 0x137df0)
    ctx->pc = 0x137da4;
    entry_137d9c(rdram, ctx, runtime);
}

void entry_137de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137de0 inside entry_137d9c (0x137d9c - 0x137df0)
    ctx->pc = 0x137de0;
    entry_137d9c(rdram, ctx, runtime);
}

void entry_137e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137e24 inside entry_137e1c (0x137e1c - 0x137e70)
    ctx->pc = 0x137e24;
    entry_137e1c(rdram, ctx, runtime);
}

void entry_137e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x137e64 inside entry_137e1c (0x137e1c - 0x137e70)
    ctx->pc = 0x137e64;
    entry_137e1c(rdram, ctx, runtime);
}

void entry_138018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138018 inside entry_138004 (0x138004 - 0x13802c)
    ctx->pc = 0x138018;
    entry_138004(rdram, ctx, runtime);
}

void entry_13803c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13803c inside entry_13802c (0x13802c - 0x138048)
    ctx->pc = 0x13803c;
    entry_13802c(rdram, ctx, runtime);
}

void entry_1380a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1380a0 inside entry_13808c (0x13808c - 0x1380b8)
    ctx->pc = 0x1380a0;
    entry_13808c(rdram, ctx, runtime);
}

void entry_1381c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1381c8 inside entry_1381bc (0x1381bc - 0x1381d4)
    ctx->pc = 0x1381c8;
    entry_1381bc(rdram, ctx, runtime);
}

void entry_138204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138204 inside entry_1381f4 (0x1381f4 - 0x138278)
    ctx->pc = 0x138204;
    entry_1381f4(rdram, ctx, runtime);
}

void entry_138208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138208 inside entry_1381f4 (0x1381f4 - 0x138278)
    ctx->pc = 0x138208;
    entry_1381f4(rdram, ctx, runtime);
}

void entry_138234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138234 inside entry_1381f4 (0x1381f4 - 0x138278)
    ctx->pc = 0x138234;
    entry_1381f4(rdram, ctx, runtime);
}

void entry_138244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138244 inside entry_1381f4 (0x1381f4 - 0x138278)
    ctx->pc = 0x138244;
    entry_1381f4(rdram, ctx, runtime);
}

void entry_1382f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1382f0 inside entry_1382d4 (0x1382d4 - 0x138300)
    ctx->pc = 0x1382f0;
    entry_1382d4(rdram, ctx, runtime);
}

void entry_138334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138334 inside entry_138318 (0x138318 - 0x13833c)
    ctx->pc = 0x138334;
    entry_138318(rdram, ctx, runtime);
}

void entry_138358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138358 inside entry_13833c (0x13833c - 0x138398)
    ctx->pc = 0x138358;
    entry_13833c(rdram, ctx, runtime);
}

void entry_13836c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13836c inside entry_13833c (0x13833c - 0x138398)
    ctx->pc = 0x13836c;
    entry_13833c(rdram, ctx, runtime);
}

void entry_1383f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1383f0 inside entry_1383d8 (0x1383d8 - 0x138404)
    ctx->pc = 0x1383f0;
    entry_1383d8(rdram, ctx, runtime);
}

void entry_138430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138430 inside entry_138418 (0x138418 - 0x138444)
    ctx->pc = 0x138430;
    entry_138418(rdram, ctx, runtime);
}

void entry_13843c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13843c inside entry_138418 (0x138418 - 0x138444)
    ctx->pc = 0x13843c;
    entry_138418(rdram, ctx, runtime);
}

void entry_13845c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13845c inside entry_138444 (0x138444 - 0x1384a0)
    ctx->pc = 0x13845c;
    entry_138444(rdram, ctx, runtime);
}

void entry_138468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138468 inside entry_138444 (0x138444 - 0x1384a0)
    ctx->pc = 0x138468;
    entry_138444(rdram, ctx, runtime);
}

void entry_138480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138480 inside entry_138444 (0x138444 - 0x1384a0)
    ctx->pc = 0x138480;
    entry_138444(rdram, ctx, runtime);
}

void entry_13858c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13858c inside entry_138584 (0x138584 - 0x1385a0)
    ctx->pc = 0x13858c;
    entry_138584(rdram, ctx, runtime);
}

void entry_138590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138590 inside entry_138584 (0x138584 - 0x1385a0)
    ctx->pc = 0x138590;
    entry_138584(rdram, ctx, runtime);
}

void entry_13862c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13862c inside UpdateSwPox__FP2SWP3OXAT1UcUc (0x1385a0 - 0x138654)
    ctx->pc = 0x13862c;
    UpdateSwPox__FP2SWP3OXAT1UcUc(rdram, ctx, runtime);
}

void entry_138678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138678 inside entry_138668 (0x138668 - 0x138698)
    ctx->pc = 0x138678;
    entry_138668(rdram, ctx, runtime);
}

void entry_1386e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1386e8 inside entry_1386e4 (0x1386e4 - 0x138700)
    ctx->pc = 0x1386e8;
    entry_1386e4(rdram, ctx, runtime);
}

void entry_138704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138704 inside entry_138700 (0x138700 - 0x138710)
    ctx->pc = 0x138704;
    entry_138700(rdram, ctx, runtime);
}

void entry_138720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138720 inside entry_13871c (0x13871c - 0x138738)
    ctx->pc = 0x138720;
    entry_13871c(rdram, ctx, runtime);
}

void entry_138798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138798 inside PoxRemoveSw__FP2SWP3OXAT1 (0x138788 - 0x1387c0)
    ctx->pc = 0x138798;
    PoxRemoveSw__FP2SWP3OXAT1(rdram, ctx, runtime);
}

void entry_13879c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13879c inside PoxRemoveSw__FP2SWP3OXAT1 (0x138788 - 0x1387c0)
    ctx->pc = 0x13879c;
    PoxRemoveSw__FP2SWP3OXAT1(rdram, ctx, runtime);
}

void entry_1387b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1387b8 inside PoxRemoveSw__FP2SWP3OXAT1 (0x138788 - 0x1387c0)
    ctx->pc = 0x1387b8;
    PoxRemoveSw__FP2SWP3OXAT1(rdram, ctx, runtime);
}

void entry_1387d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1387d8 inside PoxFromSoSo__FP2SOT0 (0x1387c0 - 0x1387f8)
    ctx->pc = 0x1387d8;
    PoxFromSoSo__FP2SOT0(rdram, ctx, runtime);
}

void entry_1387e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1387e8 inside PoxFromSoSo__FP2SOT0 (0x1387c0 - 0x1387f8)
    ctx->pc = 0x1387e8;
    PoxFromSoSo__FP2SOT0(rdram, ctx, runtime);
}

void entry_1387f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1387f0 inside PoxFromSoSo__FP2SOT0 (0x1387c0 - 0x1387f8)
    ctx->pc = 0x1387f0;
    PoxFromSoSo__FP2SOT0(rdram, ctx, runtime);
}

void entry_138814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138814 inside entry_138808 (0x138808 - 0x138828)
    ctx->pc = 0x138814;
    entry_138808(rdram, ctx, runtime);
}

void entry_138848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138848 inside AddSwAaobrObject__FP2SWP2SO (0x138828 - 0x138894)
    ctx->pc = 0x138848;
    AddSwAaobrObject__FP2SWP2SO(rdram, ctx, runtime);
}

void entry_1388f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1388f0 inside RemoveSwAaobrObject__FP2SWP2SO (0x1388a0 - 0x138958)
    ctx->pc = 0x1388f0;
    RemoveSwAaobrObject__FP2SWP2SO(rdram, ctx, runtime);
}

void entry_138908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138908 inside RemoveSwAaobrObject__FP2SWP2SO (0x1388a0 - 0x138958)
    ctx->pc = 0x138908;
    RemoveSwAaobrObject__FP2SWP2SO(rdram, ctx, runtime);
}

void entry_13890c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13890c inside RemoveSwAaobrObject__FP2SWP2SO (0x1388a0 - 0x138958)
    ctx->pc = 0x13890c;
    RemoveSwAaobrObject__FP2SWP2SO(rdram, ctx, runtime);
}

void entry_13893c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13893c inside RemoveSwAaobrObject__FP2SWP2SO (0x1388a0 - 0x138958)
    ctx->pc = 0x13893c;
    RemoveSwAaobrObject__FP2SWP2SO(rdram, ctx, runtime);
}

void entry_138a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138a28 inside UpdateSwAaox__FP2SW (0x1389d0 - 0x138ad8)
    ctx->pc = 0x138a28;
    UpdateSwAaox__FP2SW(rdram, ctx, runtime);
}

void entry_138a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138a70 inside UpdateSwAaox__FP2SW (0x1389d0 - 0x138ad8)
    ctx->pc = 0x138a70;
    UpdateSwAaox__FP2SW(rdram, ctx, runtime);
}

void entry_138a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138a94 inside UpdateSwAaox__FP2SW (0x1389d0 - 0x138ad8)
    ctx->pc = 0x138a94;
    UpdateSwAaox__FP2SW(rdram, ctx, runtime);
}

void entry_138aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138aa8 inside UpdateSwAaox__FP2SW (0x1389d0 - 0x138ad8)
    ctx->pc = 0x138aa8;
    UpdateSwAaox__FP2SW(rdram, ctx, runtime);
}

void entry_138ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138ae0 inside entry_138ad8 (0x138ad8 - 0x138afc)
    ctx->pc = 0x138ae0;
    entry_138ad8(rdram, ctx, runtime);
}

void entry_138b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138b00 inside entry_138afc (0x138afc - 0x138b64)
    ctx->pc = 0x138b00;
    entry_138afc(rdram, ctx, runtime);
}

void entry_138b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138b04 inside entry_138afc (0x138afc - 0x138b64)
    ctx->pc = 0x138b04;
    entry_138afc(rdram, ctx, runtime);
}

void entry_138b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138b28 inside entry_138afc (0x138afc - 0x138b64)
    ctx->pc = 0x138b28;
    entry_138afc(rdram, ctx, runtime);
}

void entry_138b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138b7c inside entry_138b64 (0x138b64 - 0x138be0)
    ctx->pc = 0x138b7c;
    entry_138b64(rdram, ctx, runtime);
}

void entry_138b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138b88 inside entry_138b64 (0x138b64 - 0x138be0)
    ctx->pc = 0x138b88;
    entry_138b64(rdram, ctx, runtime);
}

void entry_138ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138ba8 inside entry_138b64 (0x138b64 - 0x138be0)
    ctx->pc = 0x138ba8;
    entry_138b64(rdram, ctx, runtime);
}

void entry_138bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138bac inside entry_138b64 (0x138b64 - 0x138be0)
    ctx->pc = 0x138bac;
    entry_138b64(rdram, ctx, runtime);
}

void entry_138bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138bf8 inside InvalidateSwXpForObject__FP2SWP2SOi (0x138be0 - 0x138c00)
    ctx->pc = 0x138bf8;
    InvalidateSwXpForObject__FP2SWP2SOi(rdram, ctx, runtime);
}

void entry_138c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138c48 inside entry_138c38 (0x138c38 - 0x138d44)
    ctx->pc = 0x138c48;
    entry_138c38(rdram, ctx, runtime);
}

void entry_138cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138cb8 inside entry_138c38 (0x138c38 - 0x138d44)
    ctx->pc = 0x138cb8;
    entry_138c38(rdram, ctx, runtime);
}

void entry_138ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138ce4 inside entry_138c38 (0x138c38 - 0x138d44)
    ctx->pc = 0x138ce4;
    entry_138c38(rdram, ctx, runtime);
}

void entry_138ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138ce8 inside entry_138c38 (0x138c38 - 0x138d44)
    ctx->pc = 0x138ce8;
    entry_138c38(rdram, ctx, runtime);
}

void entry_138d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138d34 inside entry_138c38 (0x138c38 - 0x138d44)
    ctx->pc = 0x138d34;
    entry_138c38(rdram, ctx, runtime);
}

void entry_138d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138d98 inside entry_138d94 (0x138d94 - 0x138db0)
    ctx->pc = 0x138d98;
    entry_138d94(rdram, ctx, runtime);
}

void entry_138db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138db8 inside entry_138db0 (0x138db0 - 0x138dd0)
    ctx->pc = 0x138db8;
    entry_138db0(rdram, ctx, runtime);
}

void entry_138dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138dc0 inside entry_138db0 (0x138db0 - 0x138dd0)
    ctx->pc = 0x138dc0;
    entry_138db0(rdram, ctx, runtime);
}

void entry_138de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138de0 inside entry_138dd0 (0x138dd0 - 0x138e44)
    ctx->pc = 0x138de0;
    entry_138dd0(rdram, ctx, runtime);
}

void entry_138de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138de4 inside entry_138dd0 (0x138dd0 - 0x138e44)
    ctx->pc = 0x138de4;
    entry_138dd0(rdram, ctx, runtime);
}

void entry_138df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138df0 inside entry_138dd0 (0x138dd0 - 0x138e44)
    ctx->pc = 0x138df0;
    entry_138dd0(rdram, ctx, runtime);
}

void entry_138e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138e10 inside entry_138dd0 (0x138dd0 - 0x138e44)
    ctx->pc = 0x138e10;
    entry_138dd0(rdram, ctx, runtime);
}

void entry_138e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138e30 inside entry_138dd0 (0x138dd0 - 0x138e44)
    ctx->pc = 0x138e30;
    entry_138dd0(rdram, ctx, runtime);
}

void entry_138e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138e48 inside entry_138e44 (0x138e44 - 0x138ecc)
    ctx->pc = 0x138e48;
    entry_138e44(rdram, ctx, runtime);
}

void entry_138e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138e54 inside entry_138e44 (0x138e44 - 0x138ecc)
    ctx->pc = 0x138e54;
    entry_138e44(rdram, ctx, runtime);
}

void entry_138e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138e60 inside entry_138e44 (0x138e44 - 0x138ecc)
    ctx->pc = 0x138e60;
    entry_138e44(rdram, ctx, runtime);
}

void entry_138e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138e6c inside entry_138e44 (0x138e44 - 0x138ecc)
    ctx->pc = 0x138e6c;
    entry_138e44(rdram, ctx, runtime);
}

void entry_138e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138e98 inside entry_138e44 (0x138e44 - 0x138ecc)
    ctx->pc = 0x138e98;
    entry_138e44(rdram, ctx, runtime);
}

void entry_138eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138eb8 inside entry_138e44 (0x138e44 - 0x138ecc)
    ctx->pc = 0x138eb8;
    entry_138e44(rdram, ctx, runtime);
}

void entry_138ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138ed0 inside entry_138ecc (0x138ecc - 0x138f28)
    ctx->pc = 0x138ed0;
    entry_138ecc(rdram, ctx, runtime);
}

void entry_138edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138edc inside entry_138ecc (0x138ecc - 0x138f28)
    ctx->pc = 0x138edc;
    entry_138ecc(rdram, ctx, runtime);
}

void entry_138ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138ee8 inside entry_138ecc (0x138ecc - 0x138f28)
    ctx->pc = 0x138ee8;
    entry_138ecc(rdram, ctx, runtime);
}

void entry_138ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138ef4 inside entry_138ecc (0x138ecc - 0x138f28)
    ctx->pc = 0x138ef4;
    entry_138ecc(rdram, ctx, runtime);
}

void entry_138f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138f60 inside RecalcSwOxfFilterForObject__FP2SWP2SO (0x138f28 - 0x138f7c)
    ctx->pc = 0x138f60;
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime);
}

void entry_138fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138fa4 inside entry_138f98 (0x138f98 - 0x138fc4)
    ctx->pc = 0x138fa4;
    entry_138f98(rdram, ctx, runtime);
}

void entry_138fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138fa8 inside entry_138f98 (0x138f98 - 0x138fc4)
    ctx->pc = 0x138fa8;
    entry_138f98(rdram, ctx, runtime);
}

void entry_138fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138fc8 inside entry_138fc4 (0x138fc4 - 0x138ff0)
    ctx->pc = 0x138fc8;
    entry_138fc4(rdram, ctx, runtime);
}

void entry_138fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x138fd0 inside entry_138fc4 (0x138fc4 - 0x138ff0)
    ctx->pc = 0x138fd0;
    entry_138fc4(rdram, ctx, runtime);
}

void entry_139010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139010 inside VerifyAeaEquivalence__FiP2EAiT1 (0x138ff0 - 0x139038)
    ctx->pc = 0x139010;
    VerifyAeaEquivalence__FiP2EAiT1(rdram, ctx, runtime);
}

void entry_13902c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13902c inside VerifyAeaEquivalence__FiP2EAiT1 (0x138ff0 - 0x139038)
    ctx->pc = 0x13902c;
    VerifyAeaEquivalence__FiP2EAiT1(rdram, ctx, runtime);
}

void entry_139098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139098 inside EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL (0x139038 - 0x1390e8)
    ctx->pc = 0x139098;
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime);
}

void entry_1390b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1390b4 inside EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL (0x139038 - 0x1390e8)
    ctx->pc = 0x1390b4;
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime);
}

void entry_1390d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1390d4 inside EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL (0x139038 - 0x1390e8)
    ctx->pc = 0x1390d4;
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime);
}

void entry_139160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139160 inside entry_139144 (0x139144 - 0x139190)
    ctx->pc = 0x139160;
    entry_139144(rdram, ctx, runtime);
}

void entry_13919c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13919c inside entry_139190 (0x139190 - 0x1391ec)
    ctx->pc = 0x13919c;
    entry_139190(rdram, ctx, runtime);
}

void entry_1391b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1391b0 inside entry_139190 (0x139190 - 0x1391ec)
    ctx->pc = 0x1391b0;
    entry_139190(rdram, ctx, runtime);
}

void entry_1391c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1391c4 inside entry_139190 (0x139190 - 0x1391ec)
    ctx->pc = 0x1391c4;
    entry_139190(rdram, ctx, runtime);
}

void entry_1391d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1391d8 inside entry_139190 (0x139190 - 0x1391ec)
    ctx->pc = 0x1391d8;
    entry_139190(rdram, ctx, runtime);
}

void entry_139200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139200 inside entry_1391ec (0x1391ec - 0x139314)
    ctx->pc = 0x139200;
    entry_1391ec(rdram, ctx, runtime);
}

void entry_139258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139258 inside entry_1391ec (0x1391ec - 0x139314)
    ctx->pc = 0x139258;
    entry_1391ec(rdram, ctx, runtime);
}

void entry_13929c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13929c inside entry_1391ec (0x1391ec - 0x139314)
    ctx->pc = 0x13929c;
    entry_1391ec(rdram, ctx, runtime);
}

void entry_1392b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1392b8 inside entry_1391ec (0x1391ec - 0x139314)
    ctx->pc = 0x1392b8;
    entry_1391ec(rdram, ctx, runtime);
}

void entry_1392d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1392d8 inside entry_1391ec (0x1391ec - 0x139314)
    ctx->pc = 0x1392d8;
    entry_1391ec(rdram, ctx, runtime);
}

void entry_1392f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1392f4 inside entry_1391ec (0x1391ec - 0x139314)
    ctx->pc = 0x1392f4;
    entry_1391ec(rdram, ctx, runtime);
}

void entry_139344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139344 inside entry_139330 (0x139330 - 0x13938c)
    ctx->pc = 0x139344;
    entry_139330(rdram, ctx, runtime);
}

void entry_139358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139358 inside entry_139330 (0x139330 - 0x13938c)
    ctx->pc = 0x139358;
    entry_139330(rdram, ctx, runtime);
}

void entry_139370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139370 inside entry_139330 (0x139330 - 0x13938c)
    ctx->pc = 0x139370;
    entry_139330(rdram, ctx, runtime);
}

void entry_1393bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1393bc inside entry_1393a8 (0x1393a8 - 0x139404)
    ctx->pc = 0x1393bc;
    entry_1393a8(rdram, ctx, runtime);
}

void entry_1393d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1393d0 inside entry_1393a8 (0x1393a8 - 0x139404)
    ctx->pc = 0x1393d0;
    entry_1393a8(rdram, ctx, runtime);
}

void entry_1393e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1393e8 inside entry_1393a8 (0x1393a8 - 0x139404)
    ctx->pc = 0x1393e8;
    entry_1393a8(rdram, ctx, runtime);
}

void entry_139430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139430 inside entry_139420 (0x139420 - 0x139468)
    ctx->pc = 0x139430;
    entry_139420(rdram, ctx, runtime);
}

void entry_139444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139444 inside entry_139420 (0x139420 - 0x139468)
    ctx->pc = 0x139444;
    entry_139420(rdram, ctx, runtime);
}

void entry_139470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139470 inside entry_139468 (0x139468 - 0x1394b8)
    ctx->pc = 0x139470;
    entry_139468(rdram, ctx, runtime);
}

void entry_139488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139488 inside entry_139468 (0x139468 - 0x1394b8)
    ctx->pc = 0x139488;
    entry_139468(rdram, ctx, runtime);
}

void entry_1394f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1394f0 inside entry_1394d4 (0x1394d4 - 0x139554)
    ctx->pc = 0x1394f0;
    entry_1394d4(rdram, ctx, runtime);
}

void entry_1394fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1394fc inside entry_1394d4 (0x1394d4 - 0x139554)
    ctx->pc = 0x1394fc;
    entry_1394d4(rdram, ctx, runtime);
}

void entry_13950c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13950c inside entry_1394d4 (0x1394d4 - 0x139554)
    ctx->pc = 0x13950c;
    entry_1394d4(rdram, ctx, runtime);
}

void entry_139510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139510 inside entry_1394d4 (0x1394d4 - 0x139554)
    ctx->pc = 0x139510;
    entry_1394d4(rdram, ctx, runtime);
}

void entry_139528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139528 inside entry_1394d4 (0x1394d4 - 0x139554)
    ctx->pc = 0x139528;
    entry_1394d4(rdram, ctx, runtime);
}

void entry_13952c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13952c inside entry_1394d4 (0x1394d4 - 0x139554)
    ctx->pc = 0x13952c;
    entry_1394d4(rdram, ctx, runtime);
}

void entry_139544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139544 inside entry_1394d4 (0x1394d4 - 0x139554)
    ctx->pc = 0x139544;
    entry_1394d4(rdram, ctx, runtime);
}

void entry_1395c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1395c8 inside entry_1395c4 (0x1395c4 - 0x1395d0)
    ctx->pc = 0x1395c8;
    entry_1395c4(rdram, ctx, runtime);
}

void entry_139650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139650 inside FillBlAmrsg__FiiPviiP3OID (0x139600 - 0x13969c)
    ctx->pc = 0x139650;
    FillBlAmrsg__FiiPviiP3OID(rdram, ctx, runtime);
}

void entry_139688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139688 inside FillBlAmrsg__FiiPviiP3OID (0x139600 - 0x13969c)
    ctx->pc = 0x139688;
    FillBlAmrsg__FiiPviiP3OID(rdram, ctx, runtime);
}

void entry_1396a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1396a8 inside entry_13969c (0x13969c - 0x139740)
    ctx->pc = 0x1396a8;
    entry_13969c(rdram, ctx, runtime);
}

void entry_1396c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1396c0 inside entry_13969c (0x13969c - 0x139740)
    ctx->pc = 0x1396c0;
    entry_13969c(rdram, ctx, runtime);
}

void entry_1396ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1396ec inside entry_13969c (0x13969c - 0x139740)
    ctx->pc = 0x1396ec;
    entry_13969c(rdram, ctx, runtime);
}

void entry_1396fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1396fc inside entry_13969c (0x13969c - 0x139740)
    ctx->pc = 0x1396fc;
    entry_13969c(rdram, ctx, runtime);
}

void entry_13970c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13970c inside entry_13969c (0x13969c - 0x139740)
    ctx->pc = 0x13970c;
    entry_13969c(rdram, ctx, runtime);
}

void entry_139780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139780 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x139780;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1397a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1397a4 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1397a4;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1397b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1397b4 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1397b4;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1397c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1397c8 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1397c8;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1397f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1397f0 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1397f0;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_139818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139818 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x139818;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_139824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139824 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x139824;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_13983c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13983c inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x13983c;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_139868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139868 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x139868;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_13989c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13989c inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x13989c;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1398c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1398c0 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1398c0;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1398d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1398d0 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1398d0;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1398dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1398dc inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1398dc;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1398e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1398e0 inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1398e0;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1398ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1398ec inside CalculateBlendAmrsg__FiiPviiP4MRSGPf (0x139740 - 0x1398fc)
    ctx->pc = 0x1398ec;
    CalculateBlendAmrsg__FiiPviiP4MRSGPf(rdram, ctx, runtime);
}

void entry_139918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139918 inside entry_1398fc (0x1398fc - 0x139970)
    ctx->pc = 0x139918;
    entry_1398fc(rdram, ctx, runtime);
}

void entry_13993c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13993c inside entry_1398fc (0x1398fc - 0x139970)
    ctx->pc = 0x13993c;
    entry_1398fc(rdram, ctx, runtime);
}

void entry_139948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139948 inside entry_1398fc (0x1398fc - 0x139970)
    ctx->pc = 0x139948;
    entry_1398fc(rdram, ctx, runtime);
}

void entry_139950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139950 inside entry_1398fc (0x1398fc - 0x139970)
    ctx->pc = 0x139950;
    entry_1398fc(rdram, ctx, runtime);
}

void entry_139954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139954 inside entry_1398fc (0x1398fc - 0x139970)
    ctx->pc = 0x139954;
    entry_1398fc(rdram, ctx, runtime);
}

void entry_139958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139958 inside entry_1398fc (0x1398fc - 0x139970)
    ctx->pc = 0x139958;
    entry_1398fc(rdram, ctx, runtime);
}

void entry_139988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139988 inside ImrsgLookUp__FffiP4MRSGPf (0x139970 - 0x1399f0)
    ctx->pc = 0x139988;
    ImrsgLookUp__FffiP4MRSGPf(rdram, ctx, runtime);
}

void entry_13998c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13998c inside ImrsgLookUp__FffiP4MRSGPf (0x139970 - 0x1399f0)
    ctx->pc = 0x13998c;
    ImrsgLookUp__FffiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1399c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1399c8 inside ImrsgLookUp__FffiP4MRSGPf (0x139970 - 0x1399f0)
    ctx->pc = 0x1399c8;
    ImrsgLookUp__FffiP4MRSGPf(rdram, ctx, runtime);
}

void entry_1399e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1399e4 inside ImrsgLookUp__FffiP4MRSGPf (0x139970 - 0x1399f0)
    ctx->pc = 0x1399e4;
    ImrsgLookUp__FffiP4MRSGPf(rdram, ctx, runtime);
}

void entry_139a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139a38 inside ReblendAsegbl__FP6ASEGBLiiPv (0x1399f8 - 0x139a64)
    ctx->pc = 0x139a38;
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime);
}

void entry_139a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139a50 inside ReblendAsegbl__FP6ASEGBLiiPv (0x1399f8 - 0x139a64)
    ctx->pc = 0x139a50;
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime);
}

void entry_139a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139a94 inside entry_139a8c (0x139a8c - 0x139ad4)
    ctx->pc = 0x139a94;
    entry_139a8c(rdram, ctx, runtime);
}

void entry_139aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139aa8 inside entry_139a8c (0x139a8c - 0x139ad4)
    ctx->pc = 0x139aa8;
    entry_139a8c(rdram, ctx, runtime);
}

void entry_139adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139adc inside entry_139ad4 (0x139ad4 - 0x139b04)
    ctx->pc = 0x139adc;
    entry_139ad4(rdram, ctx, runtime);
}

void entry_139ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139ae0 inside entry_139ad4 (0x139ad4 - 0x139b04)
    ctx->pc = 0x139ae0;
    entry_139ad4(rdram, ctx, runtime);
}

void entry_139af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139af0 inside entry_139ad4 (0x139ad4 - 0x139b04)
    ctx->pc = 0x139af0;
    entry_139ad4(rdram, ctx, runtime);
}

void entry_139b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139b14 inside entry_139b04 (0x139b04 - 0x139b38)
    ctx->pc = 0x139b14;
    entry_139b04(rdram, ctx, runtime);
}

void entry_139b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139b64 inside entry_139b48 (0x139b48 - 0x139b70)
    ctx->pc = 0x139b64;
    entry_139b48(rdram, ctx, runtime);
}

void entry_139ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139ca4 inside entry_139c90 (0x139c90 - 0x139cb0)
    ctx->pc = 0x139ca4;
    entry_139c90(rdram, ctx, runtime);
}

void entry_139cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139cec inside entry_139ce4 (0x139ce4 - 0x139cfc)
    ctx->pc = 0x139cec;
    entry_139ce4(rdram, ctx, runtime);
}

void entry_139d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139d00 inside entry_139cfc (0x139cfc - 0x139d0c)
    ctx->pc = 0x139d00;
    entry_139cfc(rdram, ctx, runtime);
}

void entry_139d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139d10 inside entry_139d0c (0x139d0c - 0x139d28)
    ctx->pc = 0x139d10;
    entry_139d0c(rdram, ctx, runtime);
}

void entry_139f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139f18 inside OnBlipgRemove__FP5BLIPG (0x139ec8 - 0x139f20)
    ctx->pc = 0x139f18;
    OnBlipgRemove__FP5BLIPG(rdram, ctx, runtime);
}

void entry_139f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139f3c inside entry_139f20 (0x139f20 - 0x139f4c)
    ctx->pc = 0x139f3c;
    entry_139f20(rdram, ctx, runtime);
}

void entry_139fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139fac inside entry_139f98 (0x139f98 - 0x139ff8)
    ctx->pc = 0x139fac;
    entry_139f98(rdram, ctx, runtime);
}

void entry_139fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139fc8 inside entry_139f98 (0x139f98 - 0x139ff8)
    ctx->pc = 0x139fc8;
    entry_139f98(rdram, ctx, runtime);
}

void entry_139ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x139ff0 inside entry_139f98 (0x139f98 - 0x139ff8)
    ctx->pc = 0x139ff0;
    entry_139f98(rdram, ctx, runtime);
}

void entry_13a048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a048 inside PropagateBlipgShader__FP5BLIPG (0x13a008 - 0x13a0d8)
    ctx->pc = 0x13a048;
    PropagateBlipgShader__FP5BLIPG(rdram, ctx, runtime);
}

void entry_13a064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a064 inside PropagateBlipgShader__FP5BLIPG (0x13a008 - 0x13a0d8)
    ctx->pc = 0x13a064;
    PropagateBlipgShader__FP5BLIPG(rdram, ctx, runtime);
}

void entry_13a088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a088 inside PropagateBlipgShader__FP5BLIPG (0x13a008 - 0x13a0d8)
    ctx->pc = 0x13a088;
    PropagateBlipgShader__FP5BLIPG(rdram, ctx, runtime);
}

void entry_13a0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a0a4 inside PropagateBlipgShader__FP5BLIPG (0x13a008 - 0x13a0d8)
    ctx->pc = 0x13a0a4;
    PropagateBlipgShader__FP5BLIPG(rdram, ctx, runtime);
}

void entry_13a0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a0c8 inside PropagateBlipgShader__FP5BLIPG (0x13a008 - 0x13a0d8)
    ctx->pc = 0x13a0c8;
    PropagateBlipgShader__FP5BLIPG(rdram, ctx, runtime);
}

void entry_13a0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a0f4 inside entry_13a0d8 (0x13a0d8 - 0x13a128)
    ctx->pc = 0x13a0f4;
    entry_13a0d8(rdram, ctx, runtime);
}

void entry_13a104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a104 inside entry_13a0d8 (0x13a0d8 - 0x13a128)
    ctx->pc = 0x13a104;
    entry_13a0d8(rdram, ctx, runtime);
}

void entry_13a178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a178 inside SetBlipgEmitb__FP5BLIPGP5EMITB (0x13a128 - 0x13a1ec)
    ctx->pc = 0x13a178;
    SetBlipgEmitb__FP5BLIPGP5EMITB(rdram, ctx, runtime);
}

void entry_13a198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a198 inside SetBlipgEmitb__FP5BLIPGP5EMITB (0x13a128 - 0x13a1ec)
    ctx->pc = 0x13a198;
    SetBlipgEmitb__FP5BLIPGP5EMITB(rdram, ctx, runtime);
}

void entry_13a1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a1d8 inside SetBlipgEmitb__FP5BLIPGP5EMITB (0x13a128 - 0x13a1ec)
    ctx->pc = 0x13a1d8;
    SetBlipgEmitb__FP5BLIPGP5EMITB(rdram, ctx, runtime);
}

void entry_13a234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a234 inside entry_13a1fc (0x13a1fc - 0x13a27c)
    ctx->pc = 0x13a234;
    entry_13a1fc(rdram, ctx, runtime);
}

void entry_13a24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a24c inside entry_13a1fc (0x13a1fc - 0x13a27c)
    ctx->pc = 0x13a24c;
    entry_13a1fc(rdram, ctx, runtime);
}

void entry_13a254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a254 inside entry_13a1fc (0x13a1fc - 0x13a27c)
    ctx->pc = 0x13a254;
    entry_13a1fc(rdram, ctx, runtime);
}

void entry_13a258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a258 inside entry_13a1fc (0x13a1fc - 0x13a27c)
    ctx->pc = 0x13a258;
    entry_13a1fc(rdram, ctx, runtime);
}

void entry_13a318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a318 inside entry_13a2ac (0x13a2ac - 0x13a368)
    ctx->pc = 0x13a318;
    entry_13a2ac(rdram, ctx, runtime);
}

void entry_13a348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a348 inside entry_13a2ac (0x13a2ac - 0x13a368)
    ctx->pc = 0x13a348;
    entry_13a2ac(rdram, ctx, runtime);
}

void entry_13a354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a354 inside entry_13a2ac (0x13a2ac - 0x13a368)
    ctx->pc = 0x13a354;
    entry_13a2ac(rdram, ctx, runtime);
}

void entry_13a384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a384 inside entry_13a380 (0x13a380 - 0x13a3a0)
    ctx->pc = 0x13a384;
    entry_13a380(rdram, ctx, runtime);
}

void entry_13a3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a3ec inside entry_13a3bc (0x13a3bc - 0x13a408)
    ctx->pc = 0x13a3ec;
    entry_13a3bc(rdram, ctx, runtime);
}

void entry_13a3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a3f0 inside entry_13a3bc (0x13a3bc - 0x13a408)
    ctx->pc = 0x13a3f0;
    entry_13a3bc(rdram, ctx, runtime);
}

void entry_13a40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a40c inside entry_13a408 (0x13a408 - 0x13a418)
    ctx->pc = 0x13a40c;
    entry_13a408(rdram, ctx, runtime);
}

void entry_13a480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a480 inside entry_13a458 (0x13a458 - 0x13a498)
    ctx->pc = 0x13a480;
    entry_13a458(rdram, ctx, runtime);
}

void entry_13a484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a484 inside entry_13a458 (0x13a458 - 0x13a498)
    ctx->pc = 0x13a484;
    entry_13a458(rdram, ctx, runtime);
}

void entry_13a538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a538 inside CblipeProjectBlipTransformAccel__FP7MATRIX4G8VU_FLOATP5BLIPPP5BLIPVP5BLIPXi6BLIPOKP6VECTORT7 (0x13a498 - 0x13a590)
    ctx->pc = 0x13a538;
    CblipeProjectBlipTransformAccel__FP7MATRIX4G8VU_FLOATP5BLIPPP5BLIPVP5BLIPXi6BLIPOKP6VECTORT7(rdram, ctx, runtime);
}

void entry_13a55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a55c inside CblipeProjectBlipTransformAccel__FP7MATRIX4G8VU_FLOATP5BLIPPP5BLIPVP5BLIPXi6BLIPOKP6VECTORT7 (0x13a498 - 0x13a590)
    ctx->pc = 0x13a55c;
    CblipeProjectBlipTransformAccel__FP7MATRIX4G8VU_FLOATP5BLIPPP5BLIPVP5BLIPXi6BLIPOKP6VECTORT7(rdram, ctx, runtime);
}

void entry_13a598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a598 inside entry_13a590 (0x13a590 - 0x13a618)
    ctx->pc = 0x13a598;
    entry_13a590(rdram, ctx, runtime);
}

void entry_13a5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a5b0 inside entry_13a590 (0x13a590 - 0x13a618)
    ctx->pc = 0x13a5b0;
    entry_13a590(rdram, ctx, runtime);
}

void entry_13a5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a5cc inside entry_13a590 (0x13a590 - 0x13a618)
    ctx->pc = 0x13a5cc;
    entry_13a590(rdram, ctx, runtime);
}

void entry_13a728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a728 inside entry_13a704 (0x13a704 - 0x13a738)
    ctx->pc = 0x13a728;
    entry_13a704(rdram, ctx, runtime);
}

void entry_13a858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a858 inside entry_13a850 (0x13a850 - 0x13a880)
    ctx->pc = 0x13a858;
    entry_13a850(rdram, ctx, runtime);
}

void entry_13a85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a85c inside entry_13a850 (0x13a850 - 0x13a880)
    ctx->pc = 0x13a85c;
    entry_13a850(rdram, ctx, runtime);
}

void entry_13a864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a864 inside entry_13a850 (0x13a850 - 0x13a880)
    ctx->pc = 0x13a864;
    entry_13a850(rdram, ctx, runtime);
}

void entry_13a888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a888 inside entry_13a880 (0x13a880 - 0x13a8c4)
    ctx->pc = 0x13a888;
    entry_13a880(rdram, ctx, runtime);
}

void entry_13a900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a900 inside entry_13a8c4 (0x13a8c4 - 0x13a940)
    ctx->pc = 0x13a900;
    entry_13a8c4(rdram, ctx, runtime);
}

void entry_13a990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13a990 inside entry_13a988 (0x13a988 - 0x13ab04)
    ctx->pc = 0x13a990;
    entry_13a988(rdram, ctx, runtime);
}

void entry_13aa00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aa00 inside entry_13a988 (0x13a988 - 0x13ab04)
    ctx->pc = 0x13aa00;
    entry_13a988(rdram, ctx, runtime);
}

void entry_13aa58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aa58 inside entry_13a988 (0x13a988 - 0x13ab04)
    ctx->pc = 0x13aa58;
    entry_13a988(rdram, ctx, runtime);
}

void entry_13aa80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aa80 inside entry_13a988 (0x13a988 - 0x13ab04)
    ctx->pc = 0x13aa80;
    entry_13a988(rdram, ctx, runtime);
}

void entry_13aa9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aa9c inside entry_13a988 (0x13a988 - 0x13ab04)
    ctx->pc = 0x13aa9c;
    entry_13a988(rdram, ctx, runtime);
}

void entry_13aac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aac4 inside entry_13a988 (0x13a988 - 0x13ab04)
    ctx->pc = 0x13aac4;
    entry_13a988(rdram, ctx, runtime);
}

void entry_13ab34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ab34 inside entry_13ab04 (0x13ab04 - 0x13ab7c)
    ctx->pc = 0x13ab34;
    entry_13ab04(rdram, ctx, runtime);
}

void entry_13ab3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ab3c inside entry_13ab04 (0x13ab04 - 0x13ab7c)
    ctx->pc = 0x13ab3c;
    entry_13ab04(rdram, ctx, runtime);
}

void entry_13ab90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ab90 inside entry_13ab7c (0x13ab7c - 0x13ac04)
    ctx->pc = 0x13ab90;
    entry_13ab7c(rdram, ctx, runtime);
}

void entry_13abbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13abbc inside entry_13ab7c (0x13ab7c - 0x13ac04)
    ctx->pc = 0x13abbc;
    entry_13ab7c(rdram, ctx, runtime);
}

void entry_13abdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13abdc inside entry_13ab7c (0x13ab7c - 0x13ac04)
    ctx->pc = 0x13abdc;
    entry_13ab7c(rdram, ctx, runtime);
}

void entry_13ac0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ac0c inside entry_13ac04 (0x13ac04 - 0x13ac48)
    ctx->pc = 0x13ac0c;
    entry_13ac04(rdram, ctx, runtime);
}

void entry_13ac14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ac14 inside entry_13ac04 (0x13ac04 - 0x13ac48)
    ctx->pc = 0x13ac14;
    entry_13ac04(rdram, ctx, runtime);
}

void entry_13ac2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ac2c inside entry_13ac04 (0x13ac04 - 0x13ac48)
    ctx->pc = 0x13ac2c;
    entry_13ac04(rdram, ctx, runtime);
}

void entry_13ac50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ac50 inside entry_13ac48 (0x13ac48 - 0x13ac8c)
    ctx->pc = 0x13ac50;
    entry_13ac48(rdram, ctx, runtime);
}

void entry_13acc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13acc8 inside entry_13ac8c (0x13ac8c - 0x13ad08)
    ctx->pc = 0x13acc8;
    entry_13ac8c(rdram, ctx, runtime);
}

void entry_13acd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13acd4 inside entry_13ac8c (0x13ac8c - 0x13ad08)
    ctx->pc = 0x13acd4;
    entry_13ac8c(rdram, ctx, runtime);
}

void entry_13ad58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ad58 inside entry_13ad30 (0x13ad30 - 0x13ad68)
    ctx->pc = 0x13ad58;
    entry_13ad30(rdram, ctx, runtime);
}

void entry_13ae58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ae58 inside entry_13ae20 (0x13ae20 - 0x13ae78)
    ctx->pc = 0x13ae58;
    entry_13ae20(rdram, ctx, runtime);
}

void entry_13aea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aea4 inside entry_13ae78 (0x13ae78 - 0x13af74)
    ctx->pc = 0x13aea4;
    entry_13ae78(rdram, ctx, runtime);
}

void entry_13aeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aeb4 inside entry_13ae78 (0x13ae78 - 0x13af74)
    ctx->pc = 0x13aeb4;
    entry_13ae78(rdram, ctx, runtime);
}

void entry_13aed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aed0 inside entry_13ae78 (0x13ae78 - 0x13af74)
    ctx->pc = 0x13aed0;
    entry_13ae78(rdram, ctx, runtime);
}

void entry_13aee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13aee4 inside entry_13ae78 (0x13ae78 - 0x13af74)
    ctx->pc = 0x13aee4;
    entry_13ae78(rdram, ctx, runtime);
}

void entry_13af98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13af98 inside entry_13af8c (0x13af8c - 0x13b01c)
    ctx->pc = 0x13af98;
    entry_13af8c(rdram, ctx, runtime);
}

void entry_13af9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13af9c inside entry_13af8c (0x13af8c - 0x13b01c)
    ctx->pc = 0x13af9c;
    entry_13af8c(rdram, ctx, runtime);
}

void entry_13afb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13afb4 inside entry_13af8c (0x13af8c - 0x13b01c)
    ctx->pc = 0x13afb4;
    entry_13af8c(rdram, ctx, runtime);
}

void entry_13afcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13afcc inside entry_13af8c (0x13af8c - 0x13b01c)
    ctx->pc = 0x13afcc;
    entry_13af8c(rdram, ctx, runtime);
}

void entry_13b008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b008 inside entry_13af8c (0x13af8c - 0x13b01c)
    ctx->pc = 0x13b008;
    entry_13af8c(rdram, ctx, runtime);
}

void entry_13b058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b058 inside entry_13b01c (0x13b01c - 0x13b060)
    ctx->pc = 0x13b058;
    entry_13b01c(rdram, ctx, runtime);
}

void entry_13b114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b114 inside entry_13b0f4 (0x13b0f4 - 0x13b154)
    ctx->pc = 0x13b114;
    entry_13b0f4(rdram, ctx, runtime);
}

void entry_13b1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b1d4 inside entry_13b1b4 (0x13b1b4 - 0x13b1f0)
    ctx->pc = 0x13b1d4;
    entry_13b1b4(rdram, ctx, runtime);
}

void entry_13b1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b1dc inside entry_13b1b4 (0x13b1b4 - 0x13b1f0)
    ctx->pc = 0x13b1dc;
    entry_13b1b4(rdram, ctx, runtime);
}

void entry_13b278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b278 inside entry_13b25c (0x13b25c - 0x13b290)
    ctx->pc = 0x13b278;
    entry_13b25c(rdram, ctx, runtime);
}

void entry_13b2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b2ec inside entry_13b2e8 (0x13b2e8 - 0x13b308)
    ctx->pc = 0x13b2ec;
    entry_13b2e8(rdram, ctx, runtime);
}

void entry_13b35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b35c inside entry_13b338 (0x13b338 - 0x13b37c)
    ctx->pc = 0x13b35c;
    entry_13b338(rdram, ctx, runtime);
}

void entry_13b36c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b36c inside entry_13b338 (0x13b338 - 0x13b37c)
    ctx->pc = 0x13b36c;
    entry_13b338(rdram, ctx, runtime);
}

void entry_13b384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b384 inside entry_13b37c (0x13b37c - 0x13b394)
    ctx->pc = 0x13b384;
    entry_13b37c(rdram, ctx, runtime);
}

void entry_13b39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b39c inside entry_13b394 (0x13b394 - 0x13b3a8)
    ctx->pc = 0x13b39c;
    entry_13b394(rdram, ctx, runtime);
}

void entry_13b3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b3ac inside entry_13b3a8 (0x13b3a8 - 0x13b3b4)
    ctx->pc = 0x13b3ac;
    entry_13b3a8(rdram, ctx, runtime);
}

void entry_13b3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b3c4 inside entry_13b3b4 (0x13b3b4 - 0x13b3e8)
    ctx->pc = 0x13b3c4;
    entry_13b3b4(rdram, ctx, runtime);
}

void entry_13b3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b3e0 inside entry_13b3b4 (0x13b3b4 - 0x13b3e8)
    ctx->pc = 0x13b3e0;
    entry_13b3b4(rdram, ctx, runtime);
}

void entry_13b468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b468 inside PropagateBlipgShaders__Fi (0x13b430 - 0x13b498)
    ctx->pc = 0x13b468;
    PropagateBlipgShaders__Fi(rdram, ctx, runtime);
}

void entry_13b484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b484 inside PropagateBlipgShaders__Fi (0x13b430 - 0x13b498)
    ctx->pc = 0x13b484;
    PropagateBlipgShaders__Fi(rdram, ctx, runtime);
}

void entry_13b488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b488 inside PropagateBlipgShaders__Fi (0x13b430 - 0x13b498)
    ctx->pc = 0x13b488;
    PropagateBlipgShaders__Fi(rdram, ctx, runtime);
}

void entry_13b49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b49c inside entry_13b498 (0x13b498 - 0x13b4c0)
    ctx->pc = 0x13b49c;
    entry_13b498(rdram, ctx, runtime);
}

void entry_13b4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b4a4 inside entry_13b498 (0x13b498 - 0x13b4c0)
    ctx->pc = 0x13b4a4;
    entry_13b498(rdram, ctx, runtime);
}

void entry_13b600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b600 inside entry_13b5f8 (0x13b5f8 - 0x13b610)
    ctx->pc = 0x13b600;
    entry_13b5f8(rdram, ctx, runtime);
}

void entry_13b670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b670 inside entry_13b630 (0x13b630 - 0x13b67c)
    ctx->pc = 0x13b670;
    entry_13b630(rdram, ctx, runtime);
}

void entry_13b6b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b6b0 inside entry_13b6ac (0x13b6ac - 0x13b6dc)
    ctx->pc = 0x13b6b0;
    entry_13b6ac(rdram, ctx, runtime);
}

void entry_13b6c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b6c8 inside entry_13b6ac (0x13b6ac - 0x13b6dc)
    ctx->pc = 0x13b6c8;
    entry_13b6ac(rdram, ctx, runtime);
}

void entry_13b6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b6e4 inside entry_13b6dc (0x13b6dc - 0x13b708)
    ctx->pc = 0x13b6e4;
    entry_13b6dc(rdram, ctx, runtime);
}

void entry_13b760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b760 inside entry_13b75c (0x13b75c - 0x13b778)
    ctx->pc = 0x13b760;
    entry_13b75c(rdram, ctx, runtime);
}

void entry_13b764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b764 inside entry_13b75c (0x13b75c - 0x13b778)
    ctx->pc = 0x13b764;
    entry_13b75c(rdram, ctx, runtime);
}

void entry_13b768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b768 inside entry_13b75c (0x13b75c - 0x13b778)
    ctx->pc = 0x13b768;
    entry_13b75c(rdram, ctx, runtime);
}

void entry_13b7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b7e0 inside UpdateBomb__FP4BOMBf (0x13b778 - 0x13b7f0)
    ctx->pc = 0x13b7e0;
    UpdateBomb__FP4BOMBf(rdram, ctx, runtime);
}

void entry_13b7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b7e8 inside UpdateBomb__FP4BOMBf (0x13b778 - 0x13b7f0)
    ctx->pc = 0x13b7e8;
    UpdateBomb__FP4BOMBf(rdram, ctx, runtime);
}

void entry_13b7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b7f8 inside entry_13b7f0 (0x13b7f0 - 0x13b800)
    ctx->pc = 0x13b7f8;
    entry_13b7f0(rdram, ctx, runtime);
}

void entry_13b818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b818 inside entry_13b814 (0x13b814 - 0x13b828)
    ctx->pc = 0x13b818;
    entry_13b814(rdram, ctx, runtime);
}

void entry_13b858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b858 inside FUN_0013b828 (0x13b828 - 0x13b884)
    ctx->pc = 0x13b858;
    FUN_0013b828(rdram, ctx, runtime);
}

void entry_13b898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b898 inside entry_13b884 (0x13b884 - 0x13b90c)
    ctx->pc = 0x13b898;
    entry_13b884(rdram, ctx, runtime);
}

void entry_13b8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b8b8 inside entry_13b884 (0x13b884 - 0x13b90c)
    ctx->pc = 0x13b8b8;
    entry_13b884(rdram, ctx, runtime);
}

void entry_13b8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b8e0 inside entry_13b884 (0x13b884 - 0x13b90c)
    ctx->pc = 0x13b8e0;
    entry_13b884(rdram, ctx, runtime);
}

void entry_13b8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b8ec inside entry_13b884 (0x13b884 - 0x13b90c)
    ctx->pc = 0x13b8ec;
    entry_13b884(rdram, ctx, runtime);
}

void entry_13b9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b9ac inside entry_13b958 (0x13b958 - 0x13b9d8)
    ctx->pc = 0x13b9ac;
    entry_13b958(rdram, ctx, runtime);
}

void entry_13b9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b9b0 inside entry_13b958 (0x13b958 - 0x13b9d8)
    ctx->pc = 0x13b9b0;
    entry_13b958(rdram, ctx, runtime);
}

void entry_13b9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b9b8 inside entry_13b958 (0x13b958 - 0x13b9d8)
    ctx->pc = 0x13b9b8;
    entry_13b958(rdram, ctx, runtime);
}

void entry_13b9bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13b9bc inside entry_13b958 (0x13b958 - 0x13b9d8)
    ctx->pc = 0x13b9bc;
    entry_13b958(rdram, ctx, runtime);
}

void entry_13ba18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ba18 inside FUN_0013b9d8 (0x13b9d8 - 0x13ba60)
    ctx->pc = 0x13ba18;
    FUN_0013b9d8(rdram, ctx, runtime);
}

void entry_13ba30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ba30 inside FUN_0013b9d8 (0x13b9d8 - 0x13ba60)
    ctx->pc = 0x13ba30;
    FUN_0013b9d8(rdram, ctx, runtime);
}

void entry_13ba64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ba64 inside entry_13ba60 (0x13ba60 - 0x13ba70)
    ctx->pc = 0x13ba64;
    entry_13ba60(rdram, ctx, runtime);
}

void entry_13badc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13badc inside FUN_0013ba70 (0x13ba70 - 0x13baec)
    ctx->pc = 0x13badc;
    FUN_0013ba70(rdram, ctx, runtime);
}

void entry_13bb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bb0c inside entry_13bafc (0x13bafc - 0x13bb28)
    ctx->pc = 0x13bb0c;
    entry_13bafc(rdram, ctx, runtime);
}

void entry_13bb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bb34 inside entry_13bb28 (0x13bb28 - 0x13bb74)
    ctx->pc = 0x13bb34;
    entry_13bb28(rdram, ctx, runtime);
}

void entry_13bb44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bb44 inside entry_13bb28 (0x13bb28 - 0x13bb74)
    ctx->pc = 0x13bb44;
    entry_13bb28(rdram, ctx, runtime);
}

void entry_13bb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bb5c inside entry_13bb28 (0x13bb28 - 0x13bb74)
    ctx->pc = 0x13bb5c;
    entry_13bb28(rdram, ctx, runtime);
}

void entry_13bb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bb84 inside entry_13bb80 (0x13bb80 - 0x13bba0)
    ctx->pc = 0x13bb84;
    entry_13bb80(rdram, ctx, runtime);
}

void entry_13bb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bb88 inside entry_13bb80 (0x13bb80 - 0x13bba0)
    ctx->pc = 0x13bb88;
    entry_13bb80(rdram, ctx, runtime);
}

void entry_13bc30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bc30 inside entry_13bbc0 (0x13bbc0 - 0x13bc54)
    ctx->pc = 0x13bc30;
    entry_13bbc0(rdram, ctx, runtime);
}

void entry_13bc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bc3c inside entry_13bbc0 (0x13bbc0 - 0x13bc54)
    ctx->pc = 0x13bc3c;
    entry_13bbc0(rdram, ctx, runtime);
}

void entry_13bc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bc64 inside entry_13bc60 (0x13bc60 - 0x13bc80)
    ctx->pc = 0x13bc64;
    entry_13bc60(rdram, ctx, runtime);
}

void entry_13bcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bcb4 inside FUN_0013bc80 (0x13bc80 - 0x13bd20)
    ctx->pc = 0x13bcb4;
    FUN_0013bc80(rdram, ctx, runtime);
}

void entry_13bcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bcb8 inside FUN_0013bc80 (0x13bc80 - 0x13bd20)
    ctx->pc = 0x13bcb8;
    FUN_0013bc80(rdram, ctx, runtime);
}

void entry_13bcf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bcf4 inside FUN_0013bc80 (0x13bc80 - 0x13bd20)
    ctx->pc = 0x13bcf4;
    FUN_0013bc80(rdram, ctx, runtime);
}

void entry_13bd04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bd04 inside FUN_0013bc80 (0x13bc80 - 0x13bd20)
    ctx->pc = 0x13bd04;
    FUN_0013bc80(rdram, ctx, runtime);
}

void entry_13bd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bd18 inside FUN_0013bc80 (0x13bc80 - 0x13bd20)
    ctx->pc = 0x13bd18;
    FUN_0013bc80(rdram, ctx, runtime);
}

void entry_13bda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bda4 inside entry_13bd20 (0x13bd20 - 0x13bdb8)
    ctx->pc = 0x13bda4;
    entry_13bd20(rdram, ctx, runtime);
}

void entry_13bda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bda8 inside entry_13bd20 (0x13bd20 - 0x13bdb8)
    ctx->pc = 0x13bda8;
    entry_13bd20(rdram, ctx, runtime);
}

void entry_13bdc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bdc0 inside entry_13bdb8 (0x13bdb8 - 0x13bdd4)
    ctx->pc = 0x13bdc0;
    entry_13bdb8(rdram, ctx, runtime);
}

void entry_13bddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bddc inside entry_13bdd4 (0x13bdd4 - 0x13be00)
    ctx->pc = 0x13bddc;
    entry_13bdd4(rdram, ctx, runtime);
}

void entry_13bdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bdf4 inside entry_13bdd4 (0x13bdd4 - 0x13be00)
    ctx->pc = 0x13bdf4;
    entry_13bdd4(rdram, ctx, runtime);
}

void entry_13bdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bdf8 inside entry_13bdd4 (0x13bdd4 - 0x13be00)
    ctx->pc = 0x13bdf8;
    entry_13bdd4(rdram, ctx, runtime);
}

void entry_13be4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13be4c inside entry_13be38 (0x13be38 - 0x13bf1c)
    ctx->pc = 0x13be4c;
    entry_13be38(rdram, ctx, runtime);
}

void entry_13be58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13be58 inside entry_13be38 (0x13be38 - 0x13bf1c)
    ctx->pc = 0x13be58;
    entry_13be38(rdram, ctx, runtime);
}

void entry_13beb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13beb4 inside entry_13be38 (0x13be38 - 0x13bf1c)
    ctx->pc = 0x13beb4;
    entry_13be38(rdram, ctx, runtime);
}

void entry_13bec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13bec0 inside entry_13be38 (0x13be38 - 0x13bf1c)
    ctx->pc = 0x13bec0;
    entry_13be38(rdram, ctx, runtime);
}

void entry_13c038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c038 inside entry_13bfec (0x13bfec - 0x13c070)
    ctx->pc = 0x13c038;
    entry_13bfec(rdram, ctx, runtime);
}

void entry_13c058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c058 inside entry_13bfec (0x13bfec - 0x13c070)
    ctx->pc = 0x13c058;
    entry_13bfec(rdram, ctx, runtime);
}

void entry_13c060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c060 inside entry_13bfec (0x13bfec - 0x13c070)
    ctx->pc = 0x13c060;
    entry_13bfec(rdram, ctx, runtime);
}

void entry_13c098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c098 inside entry_13c090 (0x13c090 - 0x13c0c8)
    ctx->pc = 0x13c098;
    entry_13c090(rdram, ctx, runtime);
}

void entry_13c0e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c0e4 inside entry_13c0c8 (0x13c0c8 - 0x13c174)
    ctx->pc = 0x13c0e4;
    entry_13c0c8(rdram, ctx, runtime);
}

void entry_13c0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c0e8 inside entry_13c0c8 (0x13c0c8 - 0x13c174)
    ctx->pc = 0x13c0e8;
    entry_13c0c8(rdram, ctx, runtime);
}

void entry_13c118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c118 inside entry_13c0c8 (0x13c0c8 - 0x13c174)
    ctx->pc = 0x13c118;
    entry_13c0c8(rdram, ctx, runtime);
}

void entry_13c17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c17c inside entry_13c174 (0x13c174 - 0x13c1c0)
    ctx->pc = 0x13c17c;
    entry_13c174(rdram, ctx, runtime);
}

void entry_13c1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c1a0 inside entry_13c174 (0x13c174 - 0x13c1c0)
    ctx->pc = 0x13c1a0;
    entry_13c174(rdram, ctx, runtime);
}

void entry_13c1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c1c8 inside entry_13c1c0 (0x13c1c0 - 0x13c1d4)
    ctx->pc = 0x13c1c8;
    entry_13c1c0(rdram, ctx, runtime);
}

void entry_13c1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c1cc inside entry_13c1c0 (0x13c1c0 - 0x13c1d4)
    ctx->pc = 0x13c1cc;
    entry_13c1c0(rdram, ctx, runtime);
}

void entry_13c210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c210 inside entry_13c208 (0x13c208 - 0x13c2c4)
    ctx->pc = 0x13c210;
    entry_13c208(rdram, ctx, runtime);
}

void entry_13c2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c2a8 inside entry_13c208 (0x13c208 - 0x13c2c4)
    ctx->pc = 0x13c2a8;
    entry_13c208(rdram, ctx, runtime);
}

void entry_13c2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c2b4 inside entry_13c208 (0x13c208 - 0x13c2c4)
    ctx->pc = 0x13c2b4;
    entry_13c208(rdram, ctx, runtime);
}

void entry_13c348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c348 inside entry_13c2c4 (0x13c2c4 - 0x13c434)
    ctx->pc = 0x13c348;
    entry_13c2c4(rdram, ctx, runtime);
}

void entry_13c35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c35c inside entry_13c2c4 (0x13c2c4 - 0x13c434)
    ctx->pc = 0x13c35c;
    entry_13c2c4(rdram, ctx, runtime);
}

void entry_13c3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c3e0 inside entry_13c2c4 (0x13c2c4 - 0x13c434)
    ctx->pc = 0x13c3e0;
    entry_13c2c4(rdram, ctx, runtime);
}

void entry_13c3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c3f4 inside entry_13c2c4 (0x13c2c4 - 0x13c434)
    ctx->pc = 0x13c3f4;
    entry_13c2c4(rdram, ctx, runtime);
}

void entry_13c50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c50c inside entry_13c508 (0x13c508 - 0x13c518)
    ctx->pc = 0x13c50c;
    entry_13c508(rdram, ctx, runtime);
}

void entry_13c510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c510 inside entry_13c508 (0x13c508 - 0x13c518)
    ctx->pc = 0x13c510;
    entry_13c508(rdram, ctx, runtime);
}

void entry_13c54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c54c inside entry_13c548 (0x13c548 - 0x13c564)
    ctx->pc = 0x13c54c;
    entry_13c548(rdram, ctx, runtime);
}

void entry_13c55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c55c inside entry_13c548 (0x13c548 - 0x13c564)
    ctx->pc = 0x13c55c;
    entry_13c548(rdram, ctx, runtime);
}

void entry_13c584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c584 inside entry_13c564 (0x13c564 - 0x13c594)
    ctx->pc = 0x13c584;
    entry_13c564(rdram, ctx, runtime);
}

void entry_13c630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c630 inside entry_13c628 (0x13c628 - 0x13c640)
    ctx->pc = 0x13c630;
    entry_13c628(rdram, ctx, runtime);
}

void entry_13c644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c644 inside entry_13c640 (0x13c640 - 0x13c678)
    ctx->pc = 0x13c644;
    entry_13c640(rdram, ctx, runtime);
}

void entry_13c680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c680 inside entry_13c678 (0x13c678 - 0x13c6b8)
    ctx->pc = 0x13c680;
    entry_13c678(rdram, ctx, runtime);
}

void entry_13c6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c6bc inside entry_13c6b8 (0x13c6b8 - 0x13c784)
    ctx->pc = 0x13c6bc;
    entry_13c6b8(rdram, ctx, runtime);
}

void entry_13c704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c704 inside entry_13c6b8 (0x13c6b8 - 0x13c784)
    ctx->pc = 0x13c704;
    entry_13c6b8(rdram, ctx, runtime);
}

void entry_13c718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c718 inside entry_13c6b8 (0x13c6b8 - 0x13c784)
    ctx->pc = 0x13c718;
    entry_13c6b8(rdram, ctx, runtime);
}

void entry_13c754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c754 inside entry_13c6b8 (0x13c6b8 - 0x13c784)
    ctx->pc = 0x13c754;
    entry_13c6b8(rdram, ctx, runtime);
}

void entry_13c768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c768 inside entry_13c6b8 (0x13c6b8 - 0x13c784)
    ctx->pc = 0x13c768;
    entry_13c6b8(rdram, ctx, runtime);
}

void entry_13c778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c778 inside entry_13c6b8 (0x13c6b8 - 0x13c784)
    ctx->pc = 0x13c778;
    entry_13c6b8(rdram, ctx, runtime);
}

void entry_13c8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c8c0 inside entry_13c8bc (0x13c8bc - 0x13c8e0)
    ctx->pc = 0x13c8c0;
    entry_13c8bc(rdram, ctx, runtime);
}

void entry_13c8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c8d0 inside entry_13c8bc (0x13c8bc - 0x13c8e0)
    ctx->pc = 0x13c8d0;
    entry_13c8bc(rdram, ctx, runtime);
}

void entry_13c97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13c97c inside entry_13c974 (0x13c974 - 0x13c988)
    ctx->pc = 0x13c97c;
    entry_13c974(rdram, ctx, runtime);
}

void entry_13ca14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ca14 inside CbFill__10CByteQueueiP11CQueueInput (0x13c9d0 - 0x13caa8)
    ctx->pc = 0x13ca14;
    CbFill__10CByteQueueiP11CQueueInput(rdram, ctx, runtime);
}

void entry_13ca20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ca20 inside CbFill__10CByteQueueiP11CQueueInput (0x13c9d0 - 0x13caa8)
    ctx->pc = 0x13ca20;
    CbFill__10CByteQueueiP11CQueueInput(rdram, ctx, runtime);
}

void entry_13ca40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ca40 inside CbFill__10CByteQueueiP11CQueueInput (0x13c9d0 - 0x13caa8)
    ctx->pc = 0x13ca40;
    CbFill__10CByteQueueiP11CQueueInput(rdram, ctx, runtime);
}

void entry_13ca70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ca70 inside CbFill__10CByteQueueiP11CQueueInput (0x13c9d0 - 0x13caa8)
    ctx->pc = 0x13ca70;
    CbFill__10CByteQueueiP11CQueueInput(rdram, ctx, runtime);
}

void entry_13cab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cab4 inside entry_13caa8 (0x13caa8 - 0x13cad8)
    ctx->pc = 0x13cab4;
    entry_13caa8(rdram, ctx, runtime);
}

void entry_13cab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cab8 inside entry_13caa8 (0x13caa8 - 0x13cad8)
    ctx->pc = 0x13cab8;
    entry_13caa8(rdram, ctx, runtime);
}

void entry_13cb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cb20 inside CbDrain__10CByteQueueiP12CQueueOutput (0x13cad8 - 0x13cb68)
    ctx->pc = 0x13cb20;
    CbDrain__10CByteQueueiP12CQueueOutput(rdram, ctx, runtime);
}

void entry_13cb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cb28 inside CbDrain__10CByteQueueiP12CQueueOutput (0x13cad8 - 0x13cb68)
    ctx->pc = 0x13cb28;
    CbDrain__10CByteQueueiP12CQueueOutput(rdram, ctx, runtime);
}

void entry_13cb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cb40 inside CbDrain__10CByteQueueiP12CQueueOutput (0x13cad8 - 0x13cb68)
    ctx->pc = 0x13cb40;
    CbDrain__10CByteQueueiP12CQueueOutput(rdram, ctx, runtime);
}

void entry_13cb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cb80 inside entry_13cb68 (0x13cb68 - 0x13cbcc)
    ctx->pc = 0x13cb80;
    entry_13cb68(rdram, ctx, runtime);
}

void entry_13cb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cb88 inside entry_13cb68 (0x13cb68 - 0x13cbcc)
    ctx->pc = 0x13cb88;
    entry_13cb68(rdram, ctx, runtime);
}

void entry_13cb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cb94 inside entry_13cb68 (0x13cb68 - 0x13cbcc)
    ctx->pc = 0x13cb94;
    entry_13cb68(rdram, ctx, runtime);
}

void entry_13cbd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cbd8 inside entry_13cbcc (0x13cbcc - 0x13cc00)
    ctx->pc = 0x13cbd8;
    entry_13cbcc(rdram, ctx, runtime);
}

void entry_13cbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cbdc inside entry_13cbcc (0x13cbcc - 0x13cc00)
    ctx->pc = 0x13cbdc;
    entry_13cbcc(rdram, ctx, runtime);
}

void entry_13cc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cc60 inside FreeDrain__10CByteQueuei (0x13cc48 - 0x13cc80)
    ctx->pc = 0x13cc60;
    FreeDrain__10CByteQueuei(rdram, ctx, runtime);
}

void entry_13cc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cc74 inside FreeDrain__10CByteQueuei (0x13cc48 - 0x13cc80)
    ctx->pc = 0x13cc74;
    FreeDrain__10CByteQueuei(rdram, ctx, runtime);
}

void entry_13cdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cdb8 inside entry_13cdb0 (0x13cdb0 - 0x13cdc4)
    ctx->pc = 0x13cdb8;
    entry_13cdb0(rdram, ctx, runtime);
}

void entry_13cdd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cdd8 inside entry_13cdd4 (0x13cdd4 - 0x13cde8)
    ctx->pc = 0x13cdd8;
    entry_13cdd4(rdram, ctx, runtime);
}

void entry_13ce2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ce2c inside entry_13ce24 (0x13ce24 - 0x13ce40)
    ctx->pc = 0x13ce2c;
    entry_13ce24(rdram, ctx, runtime);
}

void entry_13cebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cebc inside entry_13ceb0 (0x13ceb0 - 0x13cf0c)
    ctx->pc = 0x13cebc;
    entry_13ceb0(rdram, ctx, runtime);
}

void entry_13cef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cef8 inside entry_13ceb0 (0x13ceb0 - 0x13cf0c)
    ctx->pc = 0x13cef8;
    entry_13ceb0(rdram, ctx, runtime);
}

void entry_13cf28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cf28 inside entry_13cf1c (0x13cf1c - 0x13cf34)
    ctx->pc = 0x13cf28;
    entry_13cf1c(rdram, ctx, runtime);
}

void entry_13cf78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cf78 inside entry_13cf70 (0x13cf70 - 0x13cfac)
    ctx->pc = 0x13cf78;
    entry_13cf70(rdram, ctx, runtime);
}

void entry_13cf80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cf80 inside entry_13cf70 (0x13cf70 - 0x13cfac)
    ctx->pc = 0x13cf80;
    entry_13cf70(rdram, ctx, runtime);
}

void entry_13cfe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cfe0 inside entry_13cfac (0x13cfac - 0x13d024)
    ctx->pc = 0x13cfe0;
    entry_13cfac(rdram, ctx, runtime);
}

void entry_13cff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13cff0 inside entry_13cfac (0x13cfac - 0x13d024)
    ctx->pc = 0x13cff0;
    entry_13cfac(rdram, ctx, runtime);
}

void entry_13d014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d014 inside entry_13cfac (0x13cfac - 0x13d024)
    ctx->pc = 0x13d014;
    entry_13cfac(rdram, ctx, runtime);
}

void entry_13d028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d028 inside entry_13d024 (0x13d024 - 0x13d068)
    ctx->pc = 0x13d028;
    entry_13d024(rdram, ctx, runtime);
}

void entry_13d040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d040 inside entry_13d024 (0x13d024 - 0x13d068)
    ctx->pc = 0x13d040;
    entry_13d024(rdram, ctx, runtime);
}

void entry_13d0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d0a0 inside entry_13d09c (0x13d09c - 0x13d0b0)
    ctx->pc = 0x13d0a0;
    entry_13d09c(rdram, ctx, runtime);
}

void entry_13d110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d110 inside FAbsorbBrkWkr__FP3BRKP3WKR (0x13d0b0 - 0x13d130)
    ctx->pc = 0x13d110;
    FAbsorbBrkWkr__FP3BRKP3WKR(rdram, ctx, runtime);
}

void entry_13d114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d114 inside FAbsorbBrkWkr__FP3BRKP3WKR (0x13d0b0 - 0x13d130)
    ctx->pc = 0x13d114;
    FAbsorbBrkWkr__FP3BRKP3WKR(rdram, ctx, runtime);
}

void entry_13d14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d14c inside entry_13d130 (0x13d130 - 0x13d154)
    ctx->pc = 0x13d14c;
    entry_13d130(rdram, ctx, runtime);
}

void entry_13d15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d15c inside entry_13d154 (0x13d154 - 0x13d1a8)
    ctx->pc = 0x13d15c;
    entry_13d154(rdram, ctx, runtime);
}

void entry_13d164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d164 inside entry_13d154 (0x13d154 - 0x13d1a8)
    ctx->pc = 0x13d164;
    entry_13d154(rdram, ctx, runtime);
}

void entry_13d210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d210 inside entry_13d20c (0x13d20c - 0x13d234)
    ctx->pc = 0x13d210;
    entry_13d20c(rdram, ctx, runtime);
}

void entry_13d25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d25c inside entry_13d258 (0x13d258 - 0x13d278)
    ctx->pc = 0x13d25c;
    entry_13d258(rdram, ctx, runtime);
}

void entry_13d260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d260 inside entry_13d258 (0x13d258 - 0x13d278)
    ctx->pc = 0x13d260;
    entry_13d258(rdram, ctx, runtime);
}

void entry_13d300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d300 inside entry_13d2d4 (0x13d2d4 - 0x13d330)
    ctx->pc = 0x13d300;
    entry_13d2d4(rdram, ctx, runtime);
}

void entry_13d48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d48c inside entry_13d488 (0x13d488 - 0x13d4b0)
    ctx->pc = 0x13d48c;
    entry_13d488(rdram, ctx, runtime);
}

void entry_13d4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d4a0 inside entry_13d488 (0x13d488 - 0x13d4b0)
    ctx->pc = 0x13d4a0;
    entry_13d488(rdram, ctx, runtime);
}

void entry_13d4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d4b4 inside entry_13d4b0 (0x13d4b0 - 0x13d4e0)
    ctx->pc = 0x13d4b4;
    entry_13d4b0(rdram, ctx, runtime);
}

void entry_13d4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d4e8 inside entry_13d4e0 (0x13d4e0 - 0x13d4f8)
    ctx->pc = 0x13d4e8;
    entry_13d4e0(rdram, ctx, runtime);
}

void entry_13d4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d4fc inside entry_13d4f8 (0x13d4f8 - 0x13d52c)
    ctx->pc = 0x13d4fc;
    entry_13d4f8(rdram, ctx, runtime);
}

void entry_13d548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d548 inside entry_13d540 (0x13d540 - 0x13d550)
    ctx->pc = 0x13d548;
    entry_13d540(rdram, ctx, runtime);
}

void entry_13d56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d56c inside entry_13d564 (0x13d564 - 0x13d578)
    ctx->pc = 0x13d56c;
    entry_13d564(rdram, ctx, runtime);
}

void entry_13d5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d5d0 inside entry_13d5c8 (0x13d5c8 - 0x13d5d8)
    ctx->pc = 0x13d5d0;
    entry_13d5c8(rdram, ctx, runtime);
}

void entry_13d5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d5f8 inside entry_13d5f0 (0x13d5f0 - 0x13d608)
    ctx->pc = 0x13d5f8;
    entry_13d5f0(rdram, ctx, runtime);
}

void entry_13d60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d60c inside entry_13d608 (0x13d608 - 0x13d628)
    ctx->pc = 0x13d60c;
    entry_13d608(rdram, ctx, runtime);
}

void entry_13d62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d62c inside entry_13d628 (0x13d628 - 0x13d6ac)
    ctx->pc = 0x13d62c;
    entry_13d628(rdram, ctx, runtime);
}

void entry_13d63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d63c inside entry_13d628 (0x13d628 - 0x13d6ac)
    ctx->pc = 0x13d63c;
    entry_13d628(rdram, ctx, runtime);
}

void entry_13d660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d660 inside entry_13d628 (0x13d628 - 0x13d6ac)
    ctx->pc = 0x13d660;
    entry_13d628(rdram, ctx, runtime);
}

void entry_13d66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d66c inside entry_13d628 (0x13d628 - 0x13d6ac)
    ctx->pc = 0x13d66c;
    entry_13d628(rdram, ctx, runtime);
}

void entry_13d670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d670 inside entry_13d628 (0x13d628 - 0x13d6ac)
    ctx->pc = 0x13d670;
    entry_13d628(rdram, ctx, runtime);
}

void entry_13d678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d678 inside entry_13d628 (0x13d628 - 0x13d6ac)
    ctx->pc = 0x13d678;
    entry_13d628(rdram, ctx, runtime);
}

void entry_13d6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d6b4 inside entry_13d6ac (0x13d6ac - 0x13d6c4)
    ctx->pc = 0x13d6b4;
    entry_13d6ac(rdram, ctx, runtime);
}

void entry_13d6c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d6c8 inside entry_13d6c4 (0x13d6c4 - 0x13d6d8)
    ctx->pc = 0x13d6c8;
    entry_13d6c4(rdram, ctx, runtime);
}

void entry_13d730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d730 inside entry_13d728 (0x13d728 - 0x13d76c)
    ctx->pc = 0x13d730;
    entry_13d728(rdram, ctx, runtime);
}

void entry_13d770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d770 inside entry_13d76c (0x13d76c - 0x13d788)
    ctx->pc = 0x13d770;
    entry_13d76c(rdram, ctx, runtime);
}

void entry_13d78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d78c inside entry_13d788 (0x13d788 - 0x13d79c)
    ctx->pc = 0x13d78c;
    entry_13d788(rdram, ctx, runtime);
}

void entry_13d7d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d7d4 inside entry_13d7cc (0x13d7cc - 0x13d7e4)
    ctx->pc = 0x13d7d4;
    entry_13d7cc(rdram, ctx, runtime);
}

void entry_13d7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d7e8 inside entry_13d7e4 (0x13d7e4 - 0x13d820)
    ctx->pc = 0x13d7e8;
    entry_13d7e4(rdram, ctx, runtime);
}

void entry_13d848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d848 inside entry_13d840 (0x13d840 - 0x13d858)
    ctx->pc = 0x13d848;
    entry_13d840(rdram, ctx, runtime);
}

void entry_13d85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d85c inside entry_13d858 (0x13d858 - 0x13d868)
    ctx->pc = 0x13d85c;
    entry_13d858(rdram, ctx, runtime);
}

void entry_13d8a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d8a4 inside SetBrkExclude__FP3BRK3OID (0x13d868 - 0x13d8b0)
    ctx->pc = 0x13d8a4;
    SetBrkExclude__FP3BRK3OID(rdram, ctx, runtime);
}

void entry_13d8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d8f4 inside SetBrkRemain__FP3BRK3OID (0x13d8b0 - 0x13d900)
    ctx->pc = 0x13d8f4;
    SetBrkRemain__FP3BRK3OID(rdram, ctx, runtime);
}

void entry_13d944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d944 inside SetBrkFixed__FP3BRK3OID (0x13d900 - 0x13d950)
    ctx->pc = 0x13d944;
    SetBrkFixed__FP3BRK3OID(rdram, ctx, runtime);
}

void entry_13d994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d994 inside SetBrkRemainFixed__FP3BRK3OID (0x13d950 - 0x13d9a0)
    ctx->pc = 0x13d994;
    SetBrkRemainFixed__FP3BRK3OID(rdram, ctx, runtime);
}

void entry_13d9bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d9bc inside SetBrkOnPlayer__FP3BRKi (0x13d9a0 - 0x13d9e0)
    ctx->pc = 0x13d9bc;
    SetBrkOnPlayer__FP3BRKi(rdram, ctx, runtime);
}

void entry_13d9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13d9d4 inside SetBrkOnPlayer__FP3BRKi (0x13d9a0 - 0x13d9e0)
    ctx->pc = 0x13d9d4;
    SetBrkOnPlayer__FP3BRKi(rdram, ctx, runtime);
}

void entry_13da0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13da0c inside SetBrkOnBomb__FP3BRKi (0x13d9f0 - 0x13da30)
    ctx->pc = 0x13da0c;
    SetBrkOnBomb__FP3BRKi(rdram, ctx, runtime);
}

void entry_13da24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13da24 inside SetBrkOnBomb__FP3BRKi (0x13d9f0 - 0x13da30)
    ctx->pc = 0x13da24;
    SetBrkOnBomb__FP3BRKi(rdram, ctx, runtime);
}

void entry_13da74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13da74 inside AddBrkTouchObject__FP3BRK3OID (0x13da48 - 0x13da80)
    ctx->pc = 0x13da74;
    AddBrkTouchObject__FP3BRK3OID(rdram, ctx, runtime);
}

void entry_13daac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13daac inside AddBrkTouchClass__FP3BRK3CID (0x13da80 - 0x13dab8)
    ctx->pc = 0x13daac;
    AddBrkTouchClass__FP3BRK3CID(rdram, ctx, runtime);
}

void entry_13dae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dae4 inside FUN_0013DAB8 (0x13dab8 - 0x13daf0)
    ctx->pc = 0x13dae4;
    FUN_0013DAB8(rdram, ctx, runtime);
}

void entry_13db1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13db1c inside entry_13db14 (0x13db14 - 0x13db28)
    ctx->pc = 0x13db1c;
    entry_13db14(rdram, ctx, runtime);
}

void entry_13db6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13db6c inside entry_13db64 (0x13db64 - 0x13dbc4)
    ctx->pc = 0x13db6c;
    entry_13db64(rdram, ctx, runtime);
}

void entry_13db74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13db74 inside entry_13db64 (0x13db64 - 0x13dbc4)
    ctx->pc = 0x13db74;
    entry_13db64(rdram, ctx, runtime);
}

void entry_13db9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13db9c inside entry_13db64 (0x13db64 - 0x13dbc4)
    ctx->pc = 0x13db9c;
    entry_13db64(rdram, ctx, runtime);
}

void entry_13dbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dbb8 inside entry_13db64 (0x13db64 - 0x13dbc4)
    ctx->pc = 0x13dbb8;
    entry_13db64(rdram, ctx, runtime);
}

void entry_13dbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dbdc inside entry_13dbc4 (0x13dbc4 - 0x13dbfc)
    ctx->pc = 0x13dbdc;
    entry_13dbc4(rdram, ctx, runtime);
}

void entry_13dbf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dbf0 inside entry_13dbc4 (0x13dbc4 - 0x13dbfc)
    ctx->pc = 0x13dbf0;
    entry_13dbc4(rdram, ctx, runtime);
}

void entry_13dc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dc14 inside entry_13dbfc (0x13dbfc - 0x13dc38)
    ctx->pc = 0x13dc14;
    entry_13dbfc(rdram, ctx, runtime);
}

void entry_13dc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dc18 inside entry_13dbfc (0x13dbfc - 0x13dc38)
    ctx->pc = 0x13dc18;
    entry_13dbfc(rdram, ctx, runtime);
}

void entry_13dc8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dc8c inside entry_13dc4c (0x13dc4c - 0x13dc98)
    ctx->pc = 0x13dc8c;
    entry_13dc4c(rdram, ctx, runtime);
}

void entry_13dc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dc90 inside entry_13dc4c (0x13dc4c - 0x13dc98)
    ctx->pc = 0x13dc90;
    entry_13dc4c(rdram, ctx, runtime);
}

void entry_13dcf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dcf0 inside entry_13dcec (0x13dcec - 0x13dd08)
    ctx->pc = 0x13dcf0;
    entry_13dcec(rdram, ctx, runtime);
}

void entry_13dcf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dcf4 inside entry_13dcec (0x13dcec - 0x13dd08)
    ctx->pc = 0x13dcf4;
    entry_13dcec(rdram, ctx, runtime);
}

void entry_13dd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dd50 inside FIgnoreBrkpIntersection__FP4BRKPP2SO (0x13dd08 - 0x13dd58)
    ctx->pc = 0x13dd50;
    FIgnoreBrkpIntersection__FP4BRKPP2SO(rdram, ctx, runtime);
}

void entry_13dd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dd68 inside entry_13dd58 (0x13dd58 - 0x13dd78)
    ctx->pc = 0x13dd68;
    entry_13dd58(rdram, ctx, runtime);
}

void entry_13dea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dea4 inside entry_13dea0 (0x13dea0 - 0x13deb4)
    ctx->pc = 0x13dea4;
    entry_13dea0(rdram, ctx, runtime);
}

void entry_13deb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13deb8 inside entry_13deb4 (0x13deb4 - 0x13dee8)
    ctx->pc = 0x13deb8;
    entry_13deb4(rdram, ctx, runtime);
}

void entry_13decc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13decc inside entry_13deb4 (0x13deb4 - 0x13dee8)
    ctx->pc = 0x13decc;
    entry_13deb4(rdram, ctx, runtime);
}

void entry_13ded0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ded0 inside entry_13deb4 (0x13deb4 - 0x13dee8)
    ctx->pc = 0x13ded0;
    entry_13deb4(rdram, ctx, runtime);
}

void entry_13df50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13df50 inside entry_13df48 (0x13df48 - 0x13df68)
    ctx->pc = 0x13df50;
    entry_13df48(rdram, ctx, runtime);
}

void entry_13df54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13df54 inside entry_13df48 (0x13df48 - 0x13df68)
    ctx->pc = 0x13df54;
    entry_13df48(rdram, ctx, runtime);
}

void entry_13dfc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dfc4 inside entry_13dfc0 (0x13dfc0 - 0x13dfd8)
    ctx->pc = 0x13dfc4;
    entry_13dfc0(rdram, ctx, runtime);
}

void entry_13dfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13dfc8 inside entry_13dfc0 (0x13dfc0 - 0x13dfd8)
    ctx->pc = 0x13dfc8;
    entry_13dfc0(rdram, ctx, runtime);
}

void entry_13e060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e060 inside ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG (0x13dfd8 - 0x13e158)
    ctx->pc = 0x13e060;
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime);
}

void entry_13e080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e080 inside ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG (0x13dfd8 - 0x13e158)
    ctx->pc = 0x13e080;
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime);
}

void entry_13e0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e0c8 inside ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG (0x13dfd8 - 0x13e158)
    ctx->pc = 0x13e0c8;
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime);
}

void entry_13e11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e11c inside ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG (0x13dfd8 - 0x13e158)
    ctx->pc = 0x13e11c;
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime);
}

void entry_13e12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e12c inside ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG (0x13dfd8 - 0x13e158)
    ctx->pc = 0x13e12c;
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime);
}

void entry_13e130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e130 inside ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG (0x13dfd8 - 0x13e158)
    ctx->pc = 0x13e130;
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime);
}

void entry_13e1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e1ec inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e1ec;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e204 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e204;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e238 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e238;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e23c inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e23c;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e274 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e274;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e2e4 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e2e4;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e30c inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e30c;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e380 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e380;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e394 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e394;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e398 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e398;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e3c8 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e3c8;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e3cc inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e3cc;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e3d8 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e3d8;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e3dc inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e3dc;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e3e8 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e3e8;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e3f0 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e3f0;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e3f4 inside entry_13e158 (0x13e158 - 0x13e430)
    ctx->pc = 0x13e3f4;
    entry_13e158(rdram, ctx, runtime);
}

void entry_13e488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e488 inside PruneBsp__FP3BSPP6VECTORfPP3BSP (0x13e430 - 0x13e4f4)
    ctx->pc = 0x13e488;
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime);
}

void entry_13e4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e4c8 inside PruneBsp__FP3BSPP6VECTORfPP3BSP (0x13e430 - 0x13e4f4)
    ctx->pc = 0x13e4c8;
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime);
}

void entry_13e4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e4e0 inside PruneBsp__FP3BSPP6VECTORfPP3BSP (0x13e430 - 0x13e4f4)
    ctx->pc = 0x13e4e0;
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime);
}

void entry_13e504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e504 inside entry_13e4f4 (0x13e4f4 - 0x13e520)
    ctx->pc = 0x13e504;
    entry_13e4f4(rdram, ctx, runtime);
}

void entry_13e508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e508 inside entry_13e4f4 (0x13e4f4 - 0x13e520)
    ctx->pc = 0x13e508;
    entry_13e4f4(rdram, ctx, runtime);
}

void entry_13e530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e530 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e530;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e534 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e534;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e548 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e548;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e570 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e570;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e580 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e580;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e588 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e588;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e594 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e594;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e598 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e598;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e5b8 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e5b8;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e5c8 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e5c8;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e5d8 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e5d8;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e5e4 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e5e4;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e5e8 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e5e8;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e5f0 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e5f0;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e5fc inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e5fc;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e604 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e604;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e618 inside entry_13e520 (0x13e520 - 0x13e658)
    ctx->pc = 0x13e618;
    entry_13e520(rdram, ctx, runtime);
}

void entry_13e668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e668 inside PbspPointInBspQuick__FP6VECTORP3BSP (0x13e658 - 0x13e6c8)
    ctx->pc = 0x13e668;
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime);
}

void entry_13e66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e66c inside PbspPointInBspQuick__FP6VECTORP3BSP (0x13e658 - 0x13e6c8)
    ctx->pc = 0x13e66c;
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime);
}

void entry_13e6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e6b4 inside PbspPointInBspQuick__FP6VECTORP3BSP (0x13e658 - 0x13e6c8)
    ctx->pc = 0x13e6b4;
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime);
}

void entry_13e728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e728 inside entry_13e710 (0x13e710 - 0x13e7c0)
    ctx->pc = 0x13e728;
    entry_13e710(rdram, ctx, runtime);
}

void entry_13e76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e76c inside entry_13e710 (0x13e710 - 0x13e7c0)
    ctx->pc = 0x13e76c;
    entry_13e710(rdram, ctx, runtime);
}

void entry_13e78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e78c inside entry_13e710 (0x13e710 - 0x13e7c0)
    ctx->pc = 0x13e78c;
    entry_13e710(rdram, ctx, runtime);
}

void entry_13e7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e7a4 inside entry_13e710 (0x13e710 - 0x13e7c0)
    ctx->pc = 0x13e7a4;
    entry_13e710(rdram, ctx, runtime);
}

void entry_13e800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e800 inside PostAshLoad__FP2SWP3ASHP3ALO (0x13e7c0 - 0x13e814)
    ctx->pc = 0x13e800;
    PostAshLoad__FP2SWP3ASHP3ALO(rdram, ctx, runtime);
}

void entry_13e838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e838 inside entry_13e834 (0x13e834 - 0x13e868)
    ctx->pc = 0x13e838;
    entry_13e834(rdram, ctx, runtime);
}

void entry_13e840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e840 inside entry_13e834 (0x13e834 - 0x13e868)
    ctx->pc = 0x13e840;
    entry_13e834(rdram, ctx, runtime);
}

void entry_13e898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e898 inside FFoundAshAseg__FP3ASHP4ASEG (0x13e868 - 0x13e8a4)
    ctx->pc = 0x13e898;
    FFoundAshAseg__FP3ASHP4ASEG(rdram, ctx, runtime);
}

void entry_13e8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e8b8 inside entry_13e8a4 (0x13e8a4 - 0x13e8d8)
    ctx->pc = 0x13e8b8;
    entry_13e8a4(rdram, ctx, runtime);
}

void entry_13e8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e8bc inside entry_13e8a4 (0x13e8a4 - 0x13e8d8)
    ctx->pc = 0x13e8bc;
    entry_13e8a4(rdram, ctx, runtime);
}

void entry_13e9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e9b0 inside LoadBtn__FP3BTNP3ALO (0x13e950 - 0x13e9cc)
    ctx->pc = 0x13e9b0;
    LoadBtn__FP3BTNP3ALO(rdram, ctx, runtime);
}

void entry_13e9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13e9fc inside entry_13e9f8 (0x13e9f8 - 0x13ea38)
    ctx->pc = 0x13e9fc;
    entry_13e9f8(rdram, ctx, runtime);
}

void entry_13ea14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ea14 inside entry_13e9f8 (0x13e9f8 - 0x13ea38)
    ctx->pc = 0x13ea14;
    entry_13e9f8(rdram, ctx, runtime);
}

void entry_13ea70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ea70 inside PostBtnLoad__FP3BTN (0x13ea38 - 0x13ea80)
    ctx->pc = 0x13ea70;
    PostBtnLoad__FP3BTN(rdram, ctx, runtime);
}

void entry_13eb14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13eb14 inside entry_13eb0c (0x13eb0c - 0x13eb20)
    ctx->pc = 0x13eb14;
    entry_13eb0c(rdram, ctx, runtime);
}

void entry_13eb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13eb24 inside entry_13eb20 (0x13eb20 - 0x13eb30)
    ctx->pc = 0x13eb24;
    entry_13eb20(rdram, ctx, runtime);
}

void entry_13eb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13eb9c inside SetBtnButtons__FP3BTN7BUTTONS (0x13eb68 - 0x13ebc4)
    ctx->pc = 0x13eb9c;
    SetBtnButtons__FP3BTN7BUTTONS(rdram, ctx, runtime);
}

void entry_13ebac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ebac inside SetBtnButtons__FP3BTN7BUTTONS (0x13eb68 - 0x13ebc4)
    ctx->pc = 0x13ebac;
    SetBtnButtons__FP3BTN7BUTTONS(rdram, ctx, runtime);
}

void entry_13ebec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ebec inside entry_13ebe8 (0x13ebe8 - 0x13ec00)
    ctx->pc = 0x13ebec;
    entry_13ebe8(rdram, ctx, runtime);
}

void entry_13ec18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ec18 inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13ec18;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13ec38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ec38 inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13ec38;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13ec44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ec44 inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13ec44;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13ec4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ec4c inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13ec4c;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13ec5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ec5c inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13ec5c;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13ec78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ec78 inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13ec78;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13ec9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ec9c inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13ec9c;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13eca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13eca8 inside FAddRsmg__FP4RSMGiPii3OIDN24 (0x13ec00 - 0x13ecb0)
    ctx->pc = 0x13eca8;
    FAddRsmg__FP4RSMGiPii3OIDN24(rdram, ctx, runtime);
}

void entry_13ed00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ed00 inside TriggerRsmg__FP2SWiP4RSMGP2LOi (0x13ecb0 - 0x13ed1c)
    ctx->pc = 0x13ed00;
    TriggerRsmg__FP2SWiP4RSMGP2LOi(rdram, ctx, runtime);
}

void entry_13ed44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ed44 inside entry_13ed30 (0x13ed30 - 0x13ed54)
    ctx->pc = 0x13ed44;
    entry_13ed30(rdram, ctx, runtime);
}

void entry_13ed58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ed58 inside entry_13ed54 (0x13ed54 - 0x13ed90)
    ctx->pc = 0x13ed58;
    entry_13ed54(rdram, ctx, runtime);
}

void entry_13ed64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ed64 inside entry_13ed54 (0x13ed54 - 0x13ed90)
    ctx->pc = 0x13ed64;
    entry_13ed54(rdram, ctx, runtime);
}

void entry_13ed68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ed68 inside entry_13ed54 (0x13ed54 - 0x13ed90)
    ctx->pc = 0x13ed68;
    entry_13ed54(rdram, ctx, runtime);
}

void entry_13ee00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ee00 inside RunBtnAsegs__FP3BTN4IASHi (0x13ed90 - 0x13ee0c)
    ctx->pc = 0x13ee00;
    RunBtnAsegs__FP3BTN4IASHi(rdram, ctx, runtime);
}

void entry_13ee1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ee1c inside entry_13ee0c (0x13ee0c - 0x13ee30)
    ctx->pc = 0x13ee1c;
    entry_13ee0c(rdram, ctx, runtime);
}

void entry_13ee34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ee34 inside entry_13ee30 (0x13ee30 - 0x13ee84)
    ctx->pc = 0x13ee34;
    entry_13ee30(rdram, ctx, runtime);
}

void entry_13ee58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ee58 inside entry_13ee30 (0x13ee30 - 0x13ee84)
    ctx->pc = 0x13ee58;
    entry_13ee30(rdram, ctx, runtime);
}

void entry_13ee6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ee6c inside entry_13ee30 (0x13ee30 - 0x13ee84)
    ctx->pc = 0x13ee6c;
    entry_13ee30(rdram, ctx, runtime);
}

void entry_13ee74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ee74 inside entry_13ee30 (0x13ee30 - 0x13ee84)
    ctx->pc = 0x13ee74;
    entry_13ee30(rdram, ctx, runtime);
}

void entry_13ee8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ee8c inside entry_13ee84 (0x13ee84 - 0x13eea4)
    ctx->pc = 0x13ee8c;
    entry_13ee84(rdram, ctx, runtime);
}

void entry_13eea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13eea8 inside entry_13eea4 (0x13eea4 - 0x13eecc)
    ctx->pc = 0x13eea8;
    entry_13eea4(rdram, ctx, runtime);
}

void entry_13eeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13eeb4 inside entry_13eea4 (0x13eea4 - 0x13eecc)
    ctx->pc = 0x13eeb4;
    entry_13eea4(rdram, ctx, runtime);
}

void entry_13ef14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ef14 inside entry_13ef0c (0x13ef0c - 0x13ef1c)
    ctx->pc = 0x13ef14;
    entry_13ef0c(rdram, ctx, runtime);
}

void entry_13ef20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ef20 inside entry_13ef1c (0x13ef1c - 0x13ef50)
    ctx->pc = 0x13ef20;
    entry_13ef1c(rdram, ctx, runtime);
}

void entry_13ef24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ef24 inside entry_13ef1c (0x13ef1c - 0x13ef50)
    ctx->pc = 0x13ef24;
    entry_13ef1c(rdram, ctx, runtime);
}

void entry_13ef90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ef90 inside entry_13ef88 (0x13ef88 - 0x13efa4)
    ctx->pc = 0x13ef90;
    entry_13ef88(rdram, ctx, runtime);
}

void entry_13efa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13efa8 inside entry_13efa4 (0x13efa4 - 0x13eff8)
    ctx->pc = 0x13efa8;
    entry_13efa4(rdram, ctx, runtime);
}

void entry_13effc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13effc inside entry_13eff8 (0x13eff8 - 0x13f00c)
    ctx->pc = 0x13effc;
    entry_13eff8(rdram, ctx, runtime);
}

void entry_13f000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f000 inside entry_13eff8 (0x13eff8 - 0x13f00c)
    ctx->pc = 0x13f000;
    entry_13eff8(rdram, ctx, runtime);
}

void entry_13f028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f028 inside entry_13f024 (0x13f024 - 0x13f03c)
    ctx->pc = 0x13f028;
    entry_13f024(rdram, ctx, runtime);
}

void entry_13f19c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f19c inside entry_13f194 (0x13f194 - 0x13f1d8)
    ctx->pc = 0x13f19c;
    entry_13f194(rdram, ctx, runtime);
}

void entry_13f1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f1a0 inside entry_13f194 (0x13f194 - 0x13f1d8)
    ctx->pc = 0x13f1a0;
    entry_13f194(rdram, ctx, runtime);
}

void entry_13f240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f240 inside entry_13f238 (0x13f238 - 0x13f290)
    ctx->pc = 0x13f240;
    entry_13f238(rdram, ctx, runtime);
}

void entry_13f244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f244 inside entry_13f238 (0x13f238 - 0x13f290)
    ctx->pc = 0x13f244;
    entry_13f238(rdram, ctx, runtime);
}

void entry_13f328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f328 inside entry_13f2f8 (0x13f2f8 - 0x13f338)
    ctx->pc = 0x13f328;
    entry_13f2f8(rdram, ctx, runtime);
}

void entry_13f368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f368 inside entry_13f360 (0x13f360 - 0x13f378)
    ctx->pc = 0x13f368;
    entry_13f360(rdram, ctx, runtime);
}

void entry_13f3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f3c8 inside entry_13f3c4 (0x13f3c4 - 0x13f3d0)
    ctx->pc = 0x13f3c8;
    entry_13f3c4(rdram, ctx, runtime);
}

void entry_13f3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f3d8 inside entry_13f3d0 (0x13f3d0 - 0x13f454)
    ctx->pc = 0x13f3d8;
    entry_13f3d0(rdram, ctx, runtime);
}

void entry_13f3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f3f4 inside entry_13f3d0 (0x13f3d0 - 0x13f454)
    ctx->pc = 0x13f3f4;
    entry_13f3d0(rdram, ctx, runtime);
}

void entry_13f428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f428 inside entry_13f3d0 (0x13f3d0 - 0x13f454)
    ctx->pc = 0x13f428;
    entry_13f3d0(rdram, ctx, runtime);
}

void entry_13f478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f478 inside entry_13f454 (0x13f454 - 0x13f4f8)
    ctx->pc = 0x13f478;
    entry_13f454(rdram, ctx, runtime);
}

void entry_13f4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f4dc inside entry_13f454 (0x13f454 - 0x13f4f8)
    ctx->pc = 0x13f4dc;
    entry_13f454(rdram, ctx, runtime);
}

void entry_13f544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f544 inside entry_13f4f8 (0x13f4f8 - 0x13f5d4)
    ctx->pc = 0x13f544;
    entry_13f4f8(rdram, ctx, runtime);
}

void entry_13f580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f580 inside entry_13f4f8 (0x13f4f8 - 0x13f5d4)
    ctx->pc = 0x13f580;
    entry_13f4f8(rdram, ctx, runtime);
}

void entry_13f5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f5ac inside entry_13f4f8 (0x13f4f8 - 0x13f5d4)
    ctx->pc = 0x13f5ac;
    entry_13f4f8(rdram, ctx, runtime);
}

void entry_13f5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f5c0 inside entry_13f4f8 (0x13f4f8 - 0x13f5d4)
    ctx->pc = 0x13f5c0;
    entry_13f4f8(rdram, ctx, runtime);
}

void entry_13f674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f674 inside entry_13f5d4 (0x13f5d4 - 0x13f6c0)
    ctx->pc = 0x13f674;
    entry_13f5d4(rdram, ctx, runtime);
}

void entry_13f690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f690 inside entry_13f5d4 (0x13f5d4 - 0x13f6c0)
    ctx->pc = 0x13f690;
    entry_13f5d4(rdram, ctx, runtime);
}

void entry_13f694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f694 inside entry_13f5d4 (0x13f5d4 - 0x13f6c0)
    ctx->pc = 0x13f694;
    entry_13f5d4(rdram, ctx, runtime);
}

void entry_13f698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f698 inside entry_13f5d4 (0x13f5d4 - 0x13f6c0)
    ctx->pc = 0x13f698;
    entry_13f5d4(rdram, ctx, runtime);
}

void entry_13f750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f750 inside FCheckButtonObject__FP6BUTTONP2SO (0x13f718 - 0x13f770)
    ctx->pc = 0x13f750;
    FCheckButtonObject__FP6BUTTONP2SO(rdram, ctx, runtime);
}

void entry_13f758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f758 inside FCheckButtonObject__FP6BUTTONP2SO (0x13f718 - 0x13f770)
    ctx->pc = 0x13f758;
    FCheckButtonObject__FP6BUTTONP2SO(rdram, ctx, runtime);
}

void entry_13f790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f790 inside entry_13f770 (0x13f770 - 0x13f7c8)
    ctx->pc = 0x13f790;
    entry_13f770(rdram, ctx, runtime);
}

void entry_13f7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f7a8 inside entry_13f770 (0x13f770 - 0x13f7c8)
    ctx->pc = 0x13f7a8;
    entry_13f770(rdram, ctx, runtime);
}

void entry_13f7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f7b0 inside entry_13f770 (0x13f770 - 0x13f7c8)
    ctx->pc = 0x13f7b0;
    entry_13f770(rdram, ctx, runtime);
}

void entry_13f7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f7e4 inside entry_13f7c8 (0x13f7c8 - 0x13f818)
    ctx->pc = 0x13f7e4;
    entry_13f7c8(rdram, ctx, runtime);
}

void entry_13f7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f7e8 inside entry_13f7c8 (0x13f7c8 - 0x13f818)
    ctx->pc = 0x13f7e8;
    entry_13f7c8(rdram, ctx, runtime);
}

void entry_13f7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f7f8 inside entry_13f7c8 (0x13f7c8 - 0x13f818)
    ctx->pc = 0x13f7f8;
    entry_13f7c8(rdram, ctx, runtime);
}

void entry_13f800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f800 inside entry_13f7c8 (0x13f7c8 - 0x13f818)
    ctx->pc = 0x13f800;
    entry_13f7c8(rdram, ctx, runtime);
}

void entry_13f834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f834 inside entry_13f818 (0x13f818 - 0x13f868)
    ctx->pc = 0x13f834;
    entry_13f818(rdram, ctx, runtime);
}

void entry_13f848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f848 inside entry_13f818 (0x13f818 - 0x13f868)
    ctx->pc = 0x13f848;
    entry_13f818(rdram, ctx, runtime);
}

void entry_13f850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f850 inside entry_13f818 (0x13f818 - 0x13f868)
    ctx->pc = 0x13f850;
    entry_13f818(rdram, ctx, runtime);
}

void entry_13f874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f874 inside entry_13f868 (0x13f868 - 0x13f8a0)
    ctx->pc = 0x13f874;
    entry_13f868(rdram, ctx, runtime);
}

void entry_13f880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f880 inside entry_13f868 (0x13f868 - 0x13f8a0)
    ctx->pc = 0x13f880;
    entry_13f868(rdram, ctx, runtime);
}

void entry_13f884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f884 inside entry_13f868 (0x13f868 - 0x13f8a0)
    ctx->pc = 0x13f884;
    entry_13f868(rdram, ctx, runtime);
}

void entry_13f8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f8b8 inside IposFindButtonClosest__FP6BUTTONPf (0x13f8a0 - 0x13f940)
    ctx->pc = 0x13f8b8;
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f8d0 inside IposFindButtonClosest__FP6BUTTONPf (0x13f8a0 - 0x13f940)
    ctx->pc = 0x13f8d0;
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f910 inside IposFindButtonClosest__FP6BUTTONPf (0x13f8a0 - 0x13f940)
    ctx->pc = 0x13f910;
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f924 inside IposFindButtonClosest__FP6BUTTONPf (0x13f8a0 - 0x13f940)
    ctx->pc = 0x13f924;
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f92c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f92c inside IposFindButtonClosest__FP6BUTTONPf (0x13f8a0 - 0x13f940)
    ctx->pc = 0x13f92c;
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f934 inside IposFindButtonClosest__FP6BUTTONPf (0x13f8a0 - 0x13f940)
    ctx->pc = 0x13f934;
    IposFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f97c inside ImatFindButtonClosest__FP6BUTTONPf (0x13f940 - 0x13f9a8)
    ctx->pc = 0x13f97c;
    ImatFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f998 inside ImatFindButtonClosest__FP6BUTTONPf (0x13f940 - 0x13f9a8)
    ctx->pc = 0x13f998;
    ImatFindButtonClosest__FP6BUTTONPf(rdram, ctx, runtime);
}

void entry_13f9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f9cc inside entry_13f9b0 (0x13f9b0 - 0x13f9e4)
    ctx->pc = 0x13f9cc;
    entry_13f9b0(rdram, ctx, runtime);
}

void entry_13f9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f9d4 inside entry_13f9b0 (0x13f9b0 - 0x13f9e4)
    ctx->pc = 0x13f9d4;
    entry_13f9b0(rdram, ctx, runtime);
}

void entry_13f9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13f9ec inside entry_13f9e4 (0x13f9e4 - 0x13fa10)
    ctx->pc = 0x13f9ec;
    entry_13f9e4(rdram, ctx, runtime);
}

void entry_13fa48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fa48 inside entry_13fa2c (0x13fa2c - 0x13fa88)
    ctx->pc = 0x13fa48;
    entry_13fa2c(rdram, ctx, runtime);
}

void entry_13fa6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fa6c inside entry_13fa2c (0x13fa2c - 0x13fa88)
    ctx->pc = 0x13fa6c;
    entry_13fa2c(rdram, ctx, runtime);
}

void entry_13fa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fa90 inside entry_13fa88 (0x13fa88 - 0x13fad4)
    ctx->pc = 0x13fa90;
    entry_13fa88(rdram, ctx, runtime);
}

void entry_13fab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fab8 inside entry_13fa88 (0x13fa88 - 0x13fad4)
    ctx->pc = 0x13fab8;
    entry_13fa88(rdram, ctx, runtime);
}

void entry_13fad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fad8 inside entry_13fad4 (0x13fad4 - 0x13fae8)
    ctx->pc = 0x13fad8;
    entry_13fad4(rdram, ctx, runtime);
}

void entry_13fadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fadc inside entry_13fad4 (0x13fad4 - 0x13fae8)
    ctx->pc = 0x13fadc;
    entry_13fad4(rdram, ctx, runtime);
}

void entry_13fb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fb2c inside UpdateButtonInternalXps__FP6BUTTON (0x13fae8 - 0x13fb3c)
    ctx->pc = 0x13fb2c;
    UpdateButtonInternalXps__FP6BUTTON(rdram, ctx, runtime);
}

void entry_13fb44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fb44 inside entry_13fb3c (0x13fb3c - 0x13fb78)
    ctx->pc = 0x13fb44;
    entry_13fb3c(rdram, ctx, runtime);
}

void entry_13fb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fb58 inside entry_13fb3c (0x13fb3c - 0x13fb78)
    ctx->pc = 0x13fb58;
    entry_13fb3c(rdram, ctx, runtime);
}

void entry_13fc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fc14 inside entry_13fb8c (0x13fb8c - 0x13fc28)
    ctx->pc = 0x13fc14;
    entry_13fb8c(rdram, ctx, runtime);
}

void entry_13fc94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fc94 inside entry_13fc28 (0x13fc28 - 0x13fcf4)
    ctx->pc = 0x13fc94;
    entry_13fc28(rdram, ctx, runtime);
}

void entry_13fcc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fcc4 inside entry_13fc28 (0x13fc28 - 0x13fcf4)
    ctx->pc = 0x13fcc4;
    entry_13fc28(rdram, ctx, runtime);
}

void entry_13fce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fce0 inside entry_13fc28 (0x13fc28 - 0x13fcf4)
    ctx->pc = 0x13fce0;
    entry_13fc28(rdram, ctx, runtime);
}

void entry_13fcf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fcf8 inside entry_13fcf4 (0x13fcf4 - 0x13fd20)
    ctx->pc = 0x13fcf8;
    entry_13fcf4(rdram, ctx, runtime);
}

void entry_13fcfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fcfc inside entry_13fcf4 (0x13fcf4 - 0x13fd20)
    ctx->pc = 0x13fcfc;
    entry_13fcf4(rdram, ctx, runtime);
}

void entry_13fda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fda8 inside entry_13fd48 (0x13fd48 - 0x13fde4)
    ctx->pc = 0x13fda8;
    entry_13fd48(rdram, ctx, runtime);
}

void entry_13fdac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fdac inside entry_13fd48 (0x13fd48 - 0x13fde4)
    ctx->pc = 0x13fdac;
    entry_13fd48(rdram, ctx, runtime);
}

void entry_13fe3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fe3c inside entry_13fe38 (0x13fe38 - 0x13fe64)
    ctx->pc = 0x13fe3c;
    entry_13fe38(rdram, ctx, runtime);
}

void entry_13fe50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fe50 inside entry_13fe38 (0x13fe38 - 0x13fe64)
    ctx->pc = 0x13fe50;
    entry_13fe38(rdram, ctx, runtime);
}

void entry_13fe9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fe9c inside entry_13fe64 (0x13fe64 - 0x13ff34)
    ctx->pc = 0x13fe9c;
    entry_13fe64(rdram, ctx, runtime);
}

void entry_13fed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fed8 inside entry_13fe64 (0x13fe64 - 0x13ff34)
    ctx->pc = 0x13fed8;
    entry_13fe64(rdram, ctx, runtime);
}

void entry_13fef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fef0 inside entry_13fe64 (0x13fe64 - 0x13ff34)
    ctx->pc = 0x13fef0;
    entry_13fe64(rdram, ctx, runtime);
}

void entry_13ff00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ff00 inside entry_13fe64 (0x13fe64 - 0x13ff34)
    ctx->pc = 0x13ff00;
    entry_13fe64(rdram, ctx, runtime);
}

void entry_13ff40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ff40 inside entry_13ff34 (0x13ff34 - 0x13ff6c)
    ctx->pc = 0x13ff40;
    entry_13ff34(rdram, ctx, runtime);
}

void entry_13ff4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ff4c inside entry_13ff34 (0x13ff34 - 0x13ff6c)
    ctx->pc = 0x13ff4c;
    entry_13ff34(rdram, ctx, runtime);
}

void entry_13ff5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ff5c inside entry_13ff34 (0x13ff34 - 0x13ff6c)
    ctx->pc = 0x13ff5c;
    entry_13ff34(rdram, ctx, runtime);
}

void entry_13ff80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ff80 inside entry_13ff6c (0x13ff6c - 0x13ff88)
    ctx->pc = 0x13ff80;
    entry_13ff6c(rdram, ctx, runtime);
}

void entry_13ff9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ff9c inside entry_13ff88 (0x13ff88 - 0x13fff4)
    ctx->pc = 0x13ff9c;
    entry_13ff88(rdram, ctx, runtime);
}

void entry_13ffb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ffb0 inside entry_13ff88 (0x13ff88 - 0x13fff4)
    ctx->pc = 0x13ffb0;
    entry_13ff88(rdram, ctx, runtime);
}

void entry_13ffd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ffd4 inside entry_13ff88 (0x13ff88 - 0x13fff4)
    ctx->pc = 0x13ffd4;
    entry_13ff88(rdram, ctx, runtime);
}

void entry_13ffe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ffe0 inside entry_13ff88 (0x13ff88 - 0x13fff4)
    ctx->pc = 0x13ffe0;
    entry_13ff88(rdram, ctx, runtime);
}

void entry_13ffe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13ffe4 inside entry_13ff88 (0x13ff88 - 0x13fff4)
    ctx->pc = 0x13ffe4;
    entry_13ff88(rdram, ctx, runtime);
}

void entry_13fff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fff8 inside entry_13fff4 (0x13fff4 - 0x140004)
    ctx->pc = 0x13fff8;
    entry_13fff4(rdram, ctx, runtime);
}

void entry_13fffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x13fffc inside entry_13fff4 (0x13fff4 - 0x140004)
    ctx->pc = 0x13fffc;
    entry_13fff4(rdram, ctx, runtime);
}

