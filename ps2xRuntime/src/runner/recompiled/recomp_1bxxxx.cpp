// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1b002c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b002c: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b0030: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b0034: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b0038: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b003c: 0x7c430060
    WRITE128(ADD32(GPR_U32(ctx, 2), 96), GPR_VEC(ctx, 3));
    // 0x1b0040: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1b0048);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1b0048
// Address: 0x1b0048 - 0x1b005c

void entry_1b0048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0048: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b004c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b0050: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1b0054: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b005c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b005c
// Address: 0x1b005c - 0x1b0064

void entry_1b005c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b005c: 0xc0557e8
    SET_GPR_U32(ctx, 31, 0x1b0064);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    UnpauseEmitter__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1b0064
// Address: 0x1b0064 - 0x1b0074

void entry_1b0064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0064) {
        switch (ctx->pc) {
            case 0x1b006c: ctx->pc = 0; goto label_1b006c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0064: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0078; return;
    }
label_1b006c:
    // 0x1b006c: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x1b0074);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1b0074
// Address: 0x1b0074 - 0x1b00a4

void entry_1b0074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0074) {
        switch (ctx->pc) {
            case 0x1b0078: ctx->pc = 0; goto label_1b0078;
            case 0x1b0088: ctx->pc = 0; goto label_1b0088;
            case 0x1b009c: ctx->pc = 0; goto label_1b009c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0074: 0x8e820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
label_1b0078:
    // 0x1b0078: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b007c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b0080: 0x1440ffdb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFFF0; return;
    }
label_1b0088:
    // 0x1b0088: 0x8e6205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1492)));
    // 0x1b008c: 0x8fb000bc
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    // 0x1b0090: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1b0094: 0x1440feec
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFC48; return;
    }
label_1b009c:
    // 0x1b009c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1b00a4);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b00a4
// Address: 0x1b00a4 - 0x1b00e8

void entry_1b00a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b00a4: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1b00a8: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1b00ac: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1b00b0: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1b00b4: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1b00b8: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1b00bc: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1b00c0: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b00c4: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b00c8: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b00cc: 0xc7b70178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[23] = *(float*)&val; }
    // 0x1b00d0: 0xc7b60170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[22] = *(float*)&val; }
    // 0x1b00d4: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x1b00d8: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x1b00dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b00e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b00e8; return;
}


// Function: EnableLasen__FP5LASEN5SENSM
// Address: 0x1b00e8 - 0x1b0114

void entry_1b0114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0114: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0118: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DisableLasen__FP5LASEN
// Address: 0x1b0120 - 0x1b0150

void entry_1b0150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0150: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0154: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b015c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b0160; return;
}


// Function: OnLasenAlarmTriggered__FP5LASEN
// Address: 0x1b0160 - 0x1b0198

void entry_1b0198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0198) {
        switch (ctx->pc) {
            case 0x1b019c: ctx->pc = 0; goto label_1b019c;
            case 0x1b01a0: ctx->pc = 0; goto label_1b01a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0198: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1b019c:
    // 0x1b019c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b01a0:
    // 0x1b01a0: 0xae020554
    WRITE32(ADD32(GPR_U32(ctx, 16), 1364), GPR_U32(ctx, 2));
    // 0x1b01a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b01a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLasenSensors__FP5LASEN7SENSORS
// Address: 0x1b01b0 - 0x1b0238

void entry_1b0238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0238) {
        switch (ctx->pc) {
            case 0x1b023c: ctx->pc = 0; goto label_1b023c;
            case 0x1b025c: ctx->pc = 0; goto label_1b025c;
            case 0x1b0270: ctx->pc = 0; goto label_1b0270;
            case 0x1b0288: ctx->pc = 0; goto label_1b0288;
            case 0x1b02a8: ctx->pc = 0; goto label_1b02a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0238: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
label_1b023c:
    // 0x1b023c: 0x12a2000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), 8));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        goto label_1b0270;
    }
    // 0x1b0244: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b025c;
    }
    // 0x1b024c: 0x12a20008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        goto label_1b0270;
    }
    // 0x1b0254: 0x10000035
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B032C; return;
    }
label_1b025c:
    // 0x1b025c: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1b0260: 0x12a2001f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B02E0; return;
    }
    // 0x1b0268: 0x10000030
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B032C; return;
    }
label_1b0270:
    // 0x1b0270: 0x8e6205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1492)));
    // 0x1b0274: 0x1840002c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B0328; return;
    }
    // 0x1b027c: 0x24160050
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1b0280: 0x961818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b0284: 0x0
    // NOP
label_1b0288:
    // 0x1b0288: 0x24940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1b028c: 0x246305e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1504));
    // 0x1b0290: 0x2639021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 3)));
    // 0x1b0294: 0x8e420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 36)));
    // 0x1b0298: 0x1840000a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B02C4; return;
    }
    // 0x1b02a0: 0x26500028
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 40));
    // 0x1b02a4: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b02a8:
    // 0x1b02a8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b02ac: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x1b02b4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1b02b4
// Address: 0x1b02b4 - 0x1b030c

void entry_1b02b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b02b4) {
        switch (ctx->pc) {
            case 0x1b02c4: ctx->pc = 0; goto label_1b02c4;
            case 0x1b02e0: ctx->pc = 0; goto label_1b02e0;
            case 0x1b02f0: ctx->pc = 0; goto label_1b02f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b02b4: 0x8e420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 36)));
    // 0x1b02b8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b02bc: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1B02A8; return;
    }
label_1b02c4:
    // 0x1b02c4: 0x8e6205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1492)));
    // 0x1b02c8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b02cc: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1b02d0: 0x1440ffed
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0288; return;
    }
    // 0x1b02d8: 0x10000014
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B032C; return;
    }
label_1b02e0:
    // 0x1b02e0: 0x8e620554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1364)));
    // 0x1b02e4: 0x54400002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 2796)); ctx->f[0] = *(float*)&val; }
        goto label_1b02f0;
    }
    // 0x1b02ec: 0xc66005bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1468)); ctx->f[0] = *(float*)&val; }
label_1b02f0:
    // 0x1b02f0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1b02f4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1b02f8: 0x240503e8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1000));
    // 0x1b02fc: 0x450018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b0300: 0x2812
    SET_GPR_U32(ctx, 5, ctx->lo);
    // 0x1b0304: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x1b030c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1476)));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_1b030c
// Address: 0x1b030c - 0x1b031c

void entry_1b030c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b030c: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1b0310: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1b0314: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b031c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b031c
// Address: 0x1b031c - 0x1b0334

void entry_1b031c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b031c) {
        switch (ctx->pc) {
            case 0x1b0328: ctx->pc = 0; goto label_1b0328;
            case 0x1b032c: ctx->pc = 0; goto label_1b032c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b031c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b0320: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b0324: 0xac6244d0
    WRITE32(ADD32(GPR_U32(ctx, 3), 17616), GPR_U32(ctx, 2));
label_1b0328:
    // 0x1b0328: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1b032c:
    // 0x1b032c: 0xc06bb3a
    SET_GPR_U32(ctx, 31, 0x1b0334);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SetSensorSensors__FP6SENSOR7SENSORS(rdram, ctx, runtime); return;
}


// Function: entry_1b0334
// Address: 0x1b0334 - 0x1b0360

void entry_1b0334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0334: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b0338: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b033c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b0340: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b0344: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b0348: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b034c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b0350: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0354: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b035c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b0360; return;
}


// Function: SCalcLasenShapeExtent__FP5LASENP5LBEAM
// Address: 0x1b0360 - 0x1b0470

void entry_1b04b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b04b4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b04b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b04bc: 0xae0205d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1496), GPR_U32(ctx, 2));
    // 0x1b04c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b04c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b04cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b04d0; return;
}


// Function: PostCamsenLoad__FP6CAMSEN
// Address: 0x1b04d0 - 0x1b04e4

void entry_1b04e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b04e4: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1b04e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b04ec: 0x24c644d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 17624));
    // 0x1b04f0: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1b04f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1b04f8
// Address: 0x1b04f8 - 0x1b0554

void entry_1b04f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b04f8) {
        switch (ctx->pc) {
            case 0x1b0504: ctx->pc = 0; goto label_1b0504;
            case 0x1b0520: ctx->pc = 0; goto label_1b0520;
            case 0x1b0528: ctx->pc = 0; goto label_1b0528;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b04f8: 0x8e0205d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1488)));
    // 0x1b04fc: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1488), GPR_U32(ctx, 16));
        goto label_1b0504;
    }
label_1b0504:
    // 0x1b0504: 0x8e0205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1492)));
    // 0x1b0508: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
        goto label_1b0520;
    }
    // 0x1b0510: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b0514: 0x8c431d14
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 7444)));
    // 0x1b0518: 0xae0305d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1492), GPR_U32(ctx, 3));
    // 0x1b051c: 0x8e020200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
label_1b0520:
    // 0x1b0520: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 68), GPR_U32(ctx, 0));
        goto label_1b0528;
    }
label_1b0528:
    // 0x1b0528: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1b052c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1b0530: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x1b0534: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b0538: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b053c: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b0540: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b0544: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x1b0548: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b054c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1b0554);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1b0554
// Address: 0x1b0554 - 0x1b0568

void entry_1b0554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0554: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b0558: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b055c: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1b0560: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b0568);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1376)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b0568
// Address: 0x1b0568 - 0x1b0578

void entry_1b0568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0568: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b056c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0570: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateCamsen__FP6CAMSENf
// Address: 0x1b0578 - 0x1b0594

void entry_1b0594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0594: 0x8e030558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1b0598: 0x2c620009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 9));
    // 0x1b059c: 0x1040009a
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b05a4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b05a8: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b05ac: 0x2442d040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955072));
    // 0x1b05b0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b05b4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b05b8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b05c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b05c4: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b05c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b05cc: 0xc60105b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1464)); ctx->f[1] = *(float*)&val; }
    // 0x1b05d0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b05d4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b05d8: 0x0
    // NOP
    // 0x1b05dc: 0x4500008a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b05e4: 0x10000088
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b05ec: 0x10000085
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0804; return;
    }
    // 0x1b05f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b05f8: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b05fc: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b0600: 0xc60105bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1468)); ctx->f[1] = *(float*)&val; }
    // 0x1b0604: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b0608: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b060c: 0x0
    // NOP
    // 0x1b0610: 0x4500007d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b0618: 0x1000007b
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b0620: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b0624: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b0628: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b062c: 0xc60105b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1464)); ctx->f[1] = *(float*)&val; }
    // 0x1b0630: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b0634: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0638: 0x0
    // NOP
    // 0x1b063c: 0x45000072
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b0644: 0x10000070
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b064c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b0650: 0x8c420130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 304)));
    // 0x1b0654: 0x1040006c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0808; return;
    }
    // 0x1b065c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b0664);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b0664
// Address: 0x1b0664 - 0x1b06c4

void entry_1b0664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0664) {
        switch (ctx->pc) {
            case 0x1b0694: ctx->pc = 0; goto label_1b0694;
            case 0x1b06a4: ctx->pc = 0; goto label_1b06a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0664: 0x10000069
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B080C; return;
    }
    // 0x1b066c: 0x8e1105d8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 1496)));
    // 0x1b0670: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b0674: 0x12220031
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B073C; return;
    }
    // 0x1b067c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b0694;
    }
    // 0x1b0684: 0x12200007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1b06a4;
    }
    // 0x1b068c: 0x10000042
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0798; return;
    }
label_1b0694:
    // 0x1b0694: 0x12220034
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B0768; return;
    }
    // 0x1b069c: 0x1000003e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0798; return;
    }
label_1b06a4:
    // 0x1b06a4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b06a8: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1b06ac: 0x10800007
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B06CC; return;
    }
    // 0x1b06b4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b06b8: 0x8c62013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 316)));
    // 0x1b06bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b06c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b06c4
// Address: 0x1b06c4 - 0x1b0704

void entry_1b06c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b06c4) {
        switch (ctx->pc) {
            case 0x1b06cc: ctx->pc = 0; goto label_1b06cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b06c4: 0x54400033
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
        ctx->pc = 0x1B0794; return;
    }
label_1b06cc:
    // 0x1b06cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b06d0: 0xc60205dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1500)); ctx->f[2] = *(float*)&val; }
    // 0x1b06d4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b06d8: 0xc60105e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1504)); ctx->f[1] = *(float*)&val; }
    // 0x1b06dc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b06e0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b06e4: 0x0
    // NOP
    // 0x1b06e8: 0x4500002a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0794; return;
    }
    // 0x1b06f0: 0x10400010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0734; return;
    }
    // 0x1b06f8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b06fc: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1b0704);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1b0704
// Address: 0x1b0704 - 0x1b0718

void entry_1b0704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0704: 0x8e442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    // 0x1b0708: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b070c: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1b0710: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b0718);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b0718
// Address: 0x1b0718 - 0x1b072c

void entry_1b0718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0718: 0x5040001f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1B0798; return;
    }
    // 0x1b0720: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b0724: 0xc06bbda
    SET_GPR_U32(ctx, 31, 0x1b072c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PauseSensor__FP6SENSOR(rdram, ctx, runtime); return;
}


// Function: entry_1b072c
// Address: 0x1b072c - 0x1b07a0

void entry_1b072c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b072c) {
        switch (ctx->pc) {
            case 0x1b0734: ctx->pc = 0; goto label_1b0734;
            case 0x1b073c: ctx->pc = 0; goto label_1b073c;
            case 0x1b0768: ctx->pc = 0; goto label_1b0768;
            case 0x1b0794: ctx->pc = 0; goto label_1b0794;
            case 0x1b0798: ctx->pc = 0; goto label_1b0798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b072c: 0x1000001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0798;
    }
label_1b0734:
    // 0x1b0734: 0x10000017
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0794;
    }
label_1b073c:
    // 0x1b073c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b0740: 0xc60205dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1500)); ctx->f[2] = *(float*)&val; }
    // 0x1b0744: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b0748: 0xc60105e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1508)); ctx->f[1] = *(float*)&val; }
    // 0x1b074c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b0750: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0754: 0x0
    // NOP
    // 0x1b0758: 0x4500000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b0798;
    }
    // 0x1b0760: 0x1000000c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0794;
    }
label_1b0768:
    // 0x1b0768: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b076c: 0xc60205dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1500)); ctx->f[2] = *(float*)&val; }
    // 0x1b0770: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b0774: 0xc60105e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1512)); ctx->f[1] = *(float*)&val; }
    // 0x1b0778: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b077c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0780: 0x0
    // NOP
    // 0x1b0784: 0x45000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b0794;
    }
    // 0x1b078c: 0x2411ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b0790: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
label_1b0794:
    // 0x1b0794: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1b0798:
    // 0x1b0798: 0xc06c41c
    SET_GPR_U32(ctx, 31, 0x1b07a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetCamsenCsdts__FP6CAMSEN5CSDTS(rdram, ctx, runtime); return;
}


// Function: entry_1b07a0
// Address: 0x1b07a0 - 0x1b081c

void entry_1b07a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b07a0) {
        switch (ctx->pc) {
            case 0x1b07fc: ctx->pc = 0; goto label_1b07fc;
            case 0x1b0804: ctx->pc = 0; goto label_1b0804;
            case 0x1b0808: ctx->pc = 0; goto label_1b0808;
            case 0x1b080c: ctx->pc = 0; goto label_1b080c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b07a0: 0x1000001a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b080c;
    }
    // 0x1b07a8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b07ac: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b07b0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b07b4: 0xc60105bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1468)); ctx->f[1] = *(float*)&val; }
    // 0x1b07b8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b07bc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b07c0: 0x0
    // NOP
    // 0x1b07c4: 0x45000010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b0808;
    }
    // 0x1b07cc: 0x1000000e
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0808;
    }
    // 0x1b07d4: 0x8e0205c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1472)));
    // 0x1b07d8: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1b080c;
    }
    // 0x1b07e0: 0x8e030554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x1b07e4: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1b07fc;
    }
    // 0x1b07ec: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b0804;
    }
    // 0x1b07f4: 0x10000005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b080c;
    }
label_1b07fc:
    // 0x1b07fc: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0808;
    }
label_1b0804:
    // 0x1b0804: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
label_1b0808:
    // 0x1b0808: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b080c:
    // 0x1b080c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b0810: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1b0814: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b081c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b081c
// Address: 0x1b081c - 0x1b0838

void entry_1b081c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b081c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b0820: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b0824: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b0828: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b082c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b0834: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b0838; return;
}


// Function: RenderCamsenSelf__FP6CAMSENP2CMP2RO
// Address: 0x1b0838 - 0x1b0874

void entry_1b0874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0874) {
        switch (ctx->pc) {
            case 0x1b08c4: ctx->pc = 0; goto label_1b08c4;
            case 0x1b0950: ctx->pc = 0; goto label_1b0950;
            case 0x1b0960: ctx->pc = 0; goto label_1b0960;
            case 0x1b09d0: ctx->pc = 0; goto label_1b09d0;
            case 0x1b09e0: ctx->pc = 0; goto label_1b09e0;
            case 0x1b0a28: ctx->pc = 0; goto label_1b0a28;
            case 0x1b0a94: ctx->pc = 0; goto label_1b0a94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0874: 0x8e030558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1b0878: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1b087c: 0x104000bb
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B6C; return;
    }
    // 0x1b0884: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b0888: 0x2442d070
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955120));
    // 0x1b088c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b0890: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b0894: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b089c: 0xc60305b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1464)); ctx->f[3] = *(float*)&val; }
    // 0x1b08a0: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1b08a4: 0x46021832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b08a8: 0x0
    // NOP
    // 0x1b08ac: 0x45000005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b08c4;
    }
    // 0x1b08b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b08b8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b08bc: 0x10000028
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0960;
    }
label_1b08c4:
    // 0x1b08c4: 0xc601055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x1b08c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b08cc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b08d0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1b08d4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b08d8: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1b08dc: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b08e0: 0x0
    // NOP
    // 0x1b08e4: 0x4503001e
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[2]);
        goto label_1b0960;
    }
    // 0x1b08ec: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b08f0: 0x0
    // NOP
    // 0x1b08f4: 0x4503001a
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[4]);
        goto label_1b0960;
    }
    // 0x1b08fc: 0x10000018
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0960;
    }
    // 0x1b0904: 0xc60405bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1468)); ctx->f[4] = *(float*)&val; }
    // 0x1b0908: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1b090c: 0x46032032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[4], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0910: 0x0
    // NOP
    // 0x1b0914: 0x45010012
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b0960;
    }
    // 0x1b091c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b0920: 0xc601055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x1b0924: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b0928: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b092c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b0930: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b0934: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x1b0938: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1b093c: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0940: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b0950;
    }
    // 0x1b0948: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0960;
    }
label_1b0950:
    // 0x1b0950: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0954: 0x0
    // NOP
    // 0x1b0958: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[2]);
        goto label_1b0960;
    }
label_1b0960:
    // 0x1b0960: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1b0964: 0x70631c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1b0968: 0x70631488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1b096c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b0970: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b0974: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1b0978: 0x1000007b
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B68; return;
    }
    // 0x1b0980: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b0984: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b0988: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1b098c: 0x70631c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1b0990: 0x70631488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1b0994: 0x10000074
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B68; return;
    }
    // 0x1b099c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b09a0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1b09a4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b09a8: 0x8e0305d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1496)));
    // 0x1b09ac: 0x1062001e
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b0a28;
    }
    // 0x1b09b4: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1b09b8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_1b09d0;
    }
    // 0x1b09c0: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1504)); ctx->f[2] = *(float*)&val; }
        goto label_1b09e0;
    }
    // 0x1b09c8: 0x10000068
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B6C; return;
    }
label_1b09d0:
    // 0x1b09d0: 0x50620049
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1512)); ctx->f[2] = *(float*)&val; }
        ctx->pc = 0x1B0AF8; return;
    }
    // 0x1b09d8: 0x10000064
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B6C; return;
    }
label_1b09e0:
    // 0x1b09e0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1b09e4: 0x46001032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b09e8: 0x0
    // NOP
    // 0x1b09ec: 0x45010052
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0B38; return;
    }
    // 0x1b09f4: 0xc60105dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1500)); ctx->f[1] = *(float*)&val; }
    // 0x1b09f8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b09fc: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1b0a00: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1b0a04: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1b0a08: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b0a0c: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1b0a10: 0x46002001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x1b0a14: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0a18: 0x45010047
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0B38; return;
    }
    // 0x1b0a20: 0x1000004a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B4C; return;
    }
label_1b0a28:
    // 0x1b0a28: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1b0a2c: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1b0a30: 0x10400041
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B38; return;
    }
    // 0x1b0a38: 0x8e0205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1492)));
    // 0x1b0a3c: 0x1040003e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0B38; return;
    }
    // 0x1b0a44: 0xc60305e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1508)); ctx->f[3] = *(float*)&val; }
    // 0x1b0a48: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1b0a4c: 0x46021832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0a50: 0x0
    // NOP
    // 0x1b0a54: 0x4501000f
    ctx->f[1] = FPU_MOV_S(ctx->f[4]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b0a94;
    }
    // 0x1b0a5c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b0a60: 0xc60105dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1500)); ctx->f[1] = *(float*)&val; }
    // 0x1b0a64: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b0a68: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b0a6c: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1b0a70: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0a74: 0x0
    // NOP
    // 0x1b0a78: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b0a94;
    }
    // 0x1b0a80: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0a84: 0x0
    // NOP
    // 0x1b0a88: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b0a94;
    }
    // 0x1b0a90: 0x46002046
    ctx->f[1] = FPU_MOV_S(ctx->f[4]);
label_1b0a94:
    // 0x1b0a94: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b0a98: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b0a9c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b0aa0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1b0aa4: 0x27a60060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1b0aa8: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b0aac: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b0ab0: 0x8c822e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 11792)));
    // 0x1b0ab4: 0xda040140
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1b0ab8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1b0abc: 0x24470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 320));
    // 0x1b0ac0: 0x8e0405d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1492)));
    // 0x1b0ac4: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1b0ac8: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b0acc: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b0ad0: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1b0ad4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1b0ad8: 0xc7ad0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[13] = *(float*)&val; }
    // 0x1b0adc: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1b0ae0: 0x4be221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1b0ae4: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b0ae8: 0xc049a2e
    SET_GPR_U32(ctx, 31, 0x1b0af0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime); return;
}


// Function: entry_1b0af0
// Address: 0x1b0af0 - 0x1b0ba0

void entry_1b0af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0af0) {
        switch (ctx->pc) {
            case 0x1b0af8: ctx->pc = 0; goto label_1b0af8;
            case 0x1b0b38: ctx->pc = 0; goto label_1b0b38;
            case 0x1b0b4c: ctx->pc = 0; goto label_1b0b4c;
            case 0x1b0b60: ctx->pc = 0; goto label_1b0b60;
            case 0x1b0b64: ctx->pc = 0; goto label_1b0b64;
            case 0x1b0b68: ctx->pc = 0; goto label_1b0b68;
            case 0x1b0b6c: ctx->pc = 0; goto label_1b0b6c;
            case 0x1b0b84: ctx->pc = 0; goto label_1b0b84;
            case 0x1b0b8c: ctx->pc = 0; goto label_1b0b8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0af0: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0b38;
    }
label_1b0af8:
    // 0x1b0af8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1b0afc: 0x46001032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0b00: 0x0
    // NOP
    // 0x1b0b04: 0x45010016
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b0b60;
    }
    // 0x1b0b0c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b0b10: 0xc60105dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1500)); ctx->f[1] = *(float*)&val; }
    // 0x1b0b14: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b0b18: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1b0b1c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1b0b20: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1b0b24: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b0b28: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1b0b2c: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0b30: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b0b4c;
    }
label_1b0b38:
    // 0x1b0b38: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1b0b3c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1b0b40: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b0b44: 0x10000007
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0b64;
    }
label_1b0b4c:
    // 0x1b0b4c: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0b50: 0x0
    // NOP
    // 0x1b0b54: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
        goto label_1b0b64;
    }
    // 0x1b0b5c: 0x46002006
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
label_1b0b60:
    // 0x1b0b60: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
label_1b0b64:
    // 0x1b0b64: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
label_1b0b68:
    // 0x1b0b68: 0x8e030558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
label_1b0b6c:
    // 0x1b0b6c: 0x4600007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_1b0b8c;
    }
    // 0x1b0b74: 0x10400003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b0b84;
    }
    // 0x1b0b7c: 0x10000003
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0b8c;
    }
label_1b0b84:
    // 0x1b0b84: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 1488)));
        goto label_1b0b8c;
    }
label_1b0b8c:
    // 0x1b0b8c: 0x26050110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1b0b90: 0x26040140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1b0b94: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b0b98: 0xc062304
    SET_GPR_U32(ctx, 31, 0x1b0ba0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1b0ba0
// Address: 0x1b0ba0 - 0x1b0bb8

void entry_1b0ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0ba0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b0ba4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b0ba8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b0bac: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x1b0bb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b0bb8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b0bb8
// Address: 0x1b0bb8 - 0x1b0bd8

void entry_1b0bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0bb8: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b0bbc: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b0bc0: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b0bc4: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b0bc8: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b0bcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b0bd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b0bd8; return;
}


// Function: FIgnoreCamsenIntersection__FP6CAMSENP2SO
// Address: 0x1b0bd8 - 0x1b0be0

void entry_1b0c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0c14: 0x8e030050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1b0c18: 0x1062000e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B0C54; return;
    }
    // 0x1b0c20: 0x8e220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1b0c24: 0x10620005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B0C3C; return;
    }
    // 0x1b0c2c: 0xc06bb94
    SET_GPR_U32(ctx, 31, 0x1b0c34);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIgnoreSensorObject__FP6SENSORP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b0c34
// Address: 0x1b0c34 - 0x1b0c68

void entry_1b0c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0c34) {
        switch (ctx->pc) {
            case 0x1b0c3c: ctx->pc = 0; goto label_1b0c3c;
            case 0x1b0c44: ctx->pc = 0; goto label_1b0c44;
            case 0x1b0c54: ctx->pc = 0; goto label_1b0c54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0c34: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 716)));
        goto label_1b0c44;
    }
label_1b0c3c:
    // 0x1b0c3c: 0x10000005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0c54;
    }
label_1b0c44:
    // 0x1b0c44: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1b0c48: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1b0c4c: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x1b0c50: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
label_1b0c54:
    // 0x1b0c54: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b0c58: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b0c5c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0c60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SenseCamsen__FP6CAMSENP7SENSORS
// Address: 0x1b0c68 - 0x1b0ca8

void entry_1b0ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0ca8: 0x14400079
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0E90; return;
    }
    // 0x1b0cb0: 0x8e502e10
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    // 0x1b0cb4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b0cb8: 0xc06f19c
    SET_GPR_U32(ctx, 31, 0x1b0cc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    FUN_001bc670(rdram, ctx, runtime); return;
}


// Function: entry_1b0cc0
// Address: 0x1b0cc0 - 0x1b0e24

void entry_1b0cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0cc0) {
        switch (ctx->pc) {
            case 0x1b0d44: ctx->pc = 0; goto label_1b0d44;
            case 0x1b0d50: ctx->pc = 0; goto label_1b0d50;
            case 0x1b0d80: ctx->pc = 0; goto label_1b0d80;
            case 0x1b0d98: ctx->pc = 0; goto label_1b0d98;
            case 0x1b0dd0: ctx->pc = 0; goto label_1b0dd0;
            case 0x1b0e0c: ctx->pc = 0; goto label_1b0e0c;
            case 0x1b0e1c: ctx->pc = 0; goto label_1b0e1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0cc0: 0x10400072
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b0e8c(rdram, ctx, runtime); return;
    }
    // 0x1b0cc8: 0x16020054
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1b0e1c;
    }
    // 0x1b0cd0: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1b0cd4: 0x14620051
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1b0e1c;
    }
    // 0x1b0cdc: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1b0ce0: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1b0ce4: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1b0ce8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b0cec: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b0cf0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b0cf4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b0cf8: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b0cfc: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b0d00: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1b0d04: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0d08: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b0d0c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b0d10: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b0d14: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b0d18: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b0d1c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b0d20: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b0d24: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1b0d28: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b0d2c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b0d30: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0d34: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b0d44;
    }
    // 0x1b0d3c: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0d50;
    }
label_1b0d44:
    // 0x1b0d44: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b0d48: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b0d4c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1b0d50:
    // 0x1b0d50: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b0d54: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b0d58: 0x8e442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    // 0x1b0d5c: 0x8c83239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9116)));
    // 0x1b0d60: 0x1062001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b0dd0;
    }
    // 0x1b0d68: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b0d80;
    }
    // 0x1b0d70: 0x50600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 272)));
        goto label_1b0d98;
    }
    // 0x1b0d78: 0x10000028
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0e1c;
    }
label_1b0d80:
    // 0x1b0d80: 0x10620022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b0e0c;
    }
    // 0x1b0d88: 0x14620024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1b0e1c;
    }
    // 0x1b0d90: 0x10000040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B0E94; return;
    }
label_1b0d98:
    // 0x1b0d98: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0d9c: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b0da0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b0da4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b0da8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b0dac: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1b0db0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b0db4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b0db8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0dbc: 0x0
    // NOP
    // 0x1b0dc0: 0x45010033
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0E90; return;
    }
    // 0x1b0dc8: 0x10000014
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0e1c;
    }
label_1b0dd0:
    // 0x1b0dd0: 0xd8820110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 272)));
    // 0x1b0dd4: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0dd8: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b0ddc: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b0de0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b0de4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b0de8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1b0dec: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b0df0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b0df4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0df8: 0x0
    // NOP
    // 0x1b0dfc: 0x45010024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B0E90; return;
    }
    // 0x1b0e04: 0x10000005
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b0e1c;
    }
label_1b0e0c:
    // 0x1b0e0c: 0x8c832228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8744)));
    // 0x1b0e10: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1b0e14: 0x1062001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B0E90; return;
    }
label_1b0e1c:
    // 0x1b0e1c: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1b0e24);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 320));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b0e24
// Address: 0x1b0e24 - 0x1b0e50

void entry_1b0e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0e24: 0x8e270050
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1b0e28: 0x3c08001b
    SET_GPR_U32(ctx, 8, ((uint32_t)27 << 16));
    // 0x1b0e2c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1b0e30: 0x25080be0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 3040));
    // 0x1b0e34: 0x24e70140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 320));
    // 0x1b0e38: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b0e3c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b0e40: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b0e44: 0x27aa0010
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b0e48: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1b0e50);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 20));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b0e50
// Address: 0x1b0e50 - 0x1b0e6c

void entry_1b0e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0e50: 0x8fa70010
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b0e54: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b0e58: 0x8fa80014
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1b0e5c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b0e60: 0x26250140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1b0e64: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1b0e6c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1b0e6c
// Address: 0x1b0e6c - 0x1b0e8c

void entry_1b0e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0e6c) {
        switch (ctx->pc) {
            case 0x1b0e84: ctx->pc = 0; goto label_1b0e84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0e6c: 0x14400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b0e84;
    }
    // 0x1b0e74: 0x8e220554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    // 0x1b0e78: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b0e7c: 0x82180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x1b0e80: 0xae630000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 3));
label_1b0e84:
    // 0x1b0e84: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1b0e8c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b0e8c
// Address: 0x1b0e8c - 0x1b0ea8

void entry_1b0e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0e8c) {
        switch (ctx->pc) {
            case 0x1b0e90: ctx->pc = 0; goto label_1b0e90;
            case 0x1b0e94: ctx->pc = 0; goto label_1b0e94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0e8c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1b0e90:
    // 0x1b0e90: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1b0e94:
    // 0x1b0e94: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b0e98: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b0e9c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b0ea0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnableCamsen__FP6CAMSEN5SENSM
// Address: 0x1b0ea8 - 0x1b0ed4

void entry_1b0ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b0ed4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0ed8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DisableCamsen__FP6CAMSEN
// Address: 0x1b0ee0 - 0x1b0f18

void entry_1b0f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0f18) {
        switch (ctx->pc) {
            case 0x1b0f60: ctx->pc = 0; goto label_1b0f60;
            case 0x1b0f64: ctx->pc = 0; goto label_1b0f64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0f18: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x1b0f1c: 0x10600010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1b0f60;
    }
    // 0x1b0f24: 0x8c640550
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 1360)));
    // 0x1b0f28: 0x1482000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1b0f64;
    }
    // 0x1b0f30: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b0f34: 0xc4610554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 1364)); ctx->f[1] = *(float*)&val; }
    // 0x1b0f38: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b0f3c: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1b0f40: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1b0f44: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b0f48: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b0f4c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b0f50: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b0f54: 0x0
    // NOP
    // 0x1b0f58: 0x45030002
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1472), GPR_U32(ctx, 4));
        goto label_1b0f64;
    }
label_1b0f60:
    // 0x1b0f60: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b0f64:
    // 0x1b0f64: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b0f68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnCamsenAlarmTriggered__FP6CAMSEN
// Address: 0x1b0f70 - 0x1b0fb0

void entry_1b0fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b0fb0) {
        switch (ctx->pc) {
            case 0x1b0fb4: ctx->pc = 0; goto label_1b0fb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b0fb0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b0fb4:
    // 0x1b0fb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b0fbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b0fc0; return;
}


// Function: SetCamsenSensors__FP6CAMSEN7SENSORS
// Address: 0x1b0fc0 - 0x1b1014

void entry_1b1014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1014) {
        switch (ctx->pc) {
            case 0x1b1020: ctx->pc = 0; goto label_1b1020;
            case 0x1b1024: ctx->pc = 0; goto label_1b1024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1014: 0x10000003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 9));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b1024;
    }
    // 0x1b101c: 0xae0005c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1472), GPR_U32(ctx, 0));
label_1b1020:
    // 0x1b1020: 0x2e220009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 9));
label_1b1024:
    // 0x1b1024: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b1050(rdram, ctx, runtime); return;
    }
    // 0x1b102c: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1b1030: 0x2442d0c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955200));
    // 0x1b1034: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b1038: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b103c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b1044: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b1048: 0xc06c41c
    SET_GPR_U32(ctx, 31, 0x1b1050);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCamsenCsdts__FP6CAMSEN5CSDTS(rdram, ctx, runtime); return;
}


// Function: entry_1b1050
// Address: 0x1b1050 - 0x1b105c

void entry_1b1050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1050: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b1054: 0xc06bb3a
    SET_GPR_U32(ctx, 31, 0x1b105c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetSensorSensors__FP6SENSOR7SENSORS(rdram, ctx, runtime); return;
}


// Function: entry_1b105c
// Address: 0x1b105c - 0x1b1070

void entry_1b105c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b105c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b1060: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1064: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1068: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCamsenCsdts__FP6CAMSEN5CSDTS
// Address: 0x1b1070 - 0x1b10a8

void entry_1b10a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b10a8) {
        switch (ctx->pc) {
            case 0x1b10d0: ctx->pc = 0; goto label_1b10d0;
            case 0x1b10e0: ctx->pc = 0; goto label_1b10e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b10a8: 0x52200009
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 512)));
        goto label_1b10d0;
    }
    // 0x1b10b0: 0x1a20001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x1B1130; return;
    }
    // 0x1b10b8: 0x12220009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_1b10e0;
    }
    // 0x1b10c0: 0x52220019
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
        ctx->pc = 0x1B1128; return;
    }
    // 0x1b10c8: 0x1000001a
    WRITE32(ADD32(GPR_U32(ctx, 16), 1496), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1134; return;
    }
label_1b10d0:
    // 0x1b10d0: 0x10600017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1130; return;
    }
    // 0x1b10d8: 0x10000015
    WRITE32(ADD32(GPR_U32(ctx, 3), 68), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1130; return;
    }
label_1b10e0:
    // 0x1b10e0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1b10e4: 0x2404001b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 27));
    // 0x1b10e8: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1b10ec: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1b10f0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1b10f4: 0x260505c4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1476));
    // 0x1b10f8: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1b10fc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1b1100: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b1104: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b1108: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b110c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b1110: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1b1114: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b1118: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1b1120);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1b1120
// Address: 0x1b1120 - 0x1b1158

void entry_1b1120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1120) {
        switch (ctx->pc) {
            case 0x1b1128: ctx->pc = 0; goto label_1b1128;
            case 0x1b1130: ctx->pc = 0; goto label_1b1130;
            case 0x1b1134: ctx->pc = 0; goto label_1b1134;
            case 0x1b1140: ctx->pc = 0; goto label_1b1140;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1120: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 1496), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b1134;
    }
label_1b1128:
    // 0x1b1128: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 68), GPR_U32(ctx, 0));
        goto label_1b1130;
    }
label_1b1130:
    // 0x1b1130: 0xae1105d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1496), GPR_U32(ctx, 17));
label_1b1134:
    // 0x1b1134: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b1138: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b113c: 0xe60005dc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1500), *(uint32_t*)&val); }
label_1b1140:
    // 0x1b1140: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b1144: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1148: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b114c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b1154: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b1158; return;
}


// Function: InitPrsen__FP5PRSEN
// Address: 0x1b1158 - 0x1b116c

void entry_1b116c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b116c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b1170: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1174: 0xae020600
    WRITE32(ADD32(GPR_U32(ctx, 16), 1536), GPR_U32(ctx, 2));
    // 0x1b1178: 0xae0205d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1488), GPR_U32(ctx, 2));
    // 0x1b117c: 0xae0205d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1492), GPR_U32(ctx, 2));
    // 0x1b1180: 0xae0205e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1504), GPR_U32(ctx, 2));
    // 0x1b1184: 0xae0205e4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1508), GPR_U32(ctx, 2));
    // 0x1b1188: 0xae0205f0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1520), GPR_U32(ctx, 2));
    // 0x1b118c: 0xae0205f4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1524), GPR_U32(ctx, 2));
    // 0x1b1190: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1194: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b119c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b11a0; return;
}


// Function: PostPrsenLoad__FP5PRSEN
// Address: 0x1b11a0 - 0x1b11b4

void entry_1b11b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b11b4) {
        switch (ctx->pc) {
            case 0x1b11d8: ctx->pc = 0; goto label_1b11d8;
            case 0x1b11f4: ctx->pc = 0; goto label_1b11f4;
            case 0x1b1210: ctx->pc = 0; goto label_1b1210;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b11b4: 0x8e02027c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1b11b8: 0x18400015
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1b1210;
    }
    // 0x1b11c0: 0x8e020280
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 640)));
    // 0x1b11c4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b11c8: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b11cc: 0x10000009
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b11f4;
    }
    // 0x1b11d4: 0x0
    // NOP
label_1b11d8:
    // 0x1b11d8: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1b11dc: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1b11e0: 0x1040000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b1210;
    }
    // 0x1b11e8: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b11ec: 0x471021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1b11f0: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_1b11f4:
    // 0x1b11f4: 0x8ca30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1b11f8: 0x5464fff7
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 636)));
        goto label_1b11d8;
    }
    // 0x1b1200: 0x8ca20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 20)));
    // 0x1b1204: 0x5040fff4
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 636)));
        goto label_1b11d8;
    }
    // 0x1b120c: 0xae050610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 5));
label_1b1210:
    // 0x1b1210: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b1214: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b1218: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1b121c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b1224);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1376)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b1224
// Address: 0x1b1224 - 0x1b1238

void entry_1b1224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1224: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1228: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b122c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b1234: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b1238; return;
}


// Function: UpdatePrsen__FP5PRSENf
// Address: 0x1b1238 - 0x1b124c

void entry_1b124c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b124c) {
        switch (ctx->pc) {
            case 0x1b1358: ctx->pc = 0; goto label_1b1358;
            case 0x1b1360: ctx->pc = 0; goto label_1b1360;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b124c: 0x8e030558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1b1250: 0x2c620009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 9));
    // 0x1b1254: 0x1040006c
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1408; return;
    }
    // 0x1b125c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b1260: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b1264: 0x2442d0f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955248));
    // 0x1b1268: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b126c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b1270: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b1278: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b127c: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b1280: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b1284: 0xc60105b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1464)); ctx->f[1] = *(float*)&val; }
    // 0x1b1288: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b128c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b1290: 0x0
    // NOP
    // 0x1b1294: 0x4500005c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B1408; return;
    }
    // 0x1b129c: 0x1000005a
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1408; return;
    }
    // 0x1b12a4: 0xc6020608
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1544)); ctx->f[2] = *(float*)&val; }
    // 0x1b12a8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1b12ac: 0x46020036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b12b0: 0x0
    // NOP
    // 0x1b12b4: 0x4500002a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b1360;
    }
    // 0x1b12bc: 0xc601055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x1b12c0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b12c4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b12c8: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b12cc: 0x10000022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b1358;
    }
    // 0x1b12d4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b12d8: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b12dc: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b12e0: 0xc60105bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1468)); ctx->f[1] = *(float*)&val; }
    // 0x1b12e4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b12e8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b12ec: 0x0
    // NOP
    // 0x1b12f0: 0x45000045
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B1408; return;
    }
    // 0x1b12f8: 0x10000043
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1408; return;
    }
    // 0x1b1300: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b1304: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b1308: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b130c: 0xc60105b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1464)); ctx->f[1] = *(float*)&val; }
    // 0x1b1310: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b1314: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b1318: 0x0
    // NOP
    // 0x1b131c: 0x4500003a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B1408; return;
    }
    // 0x1b1324: 0x10000038
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1408; return;
    }
    // 0x1b132c: 0xc6020608
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1544)); ctx->f[2] = *(float*)&val; }
    // 0x1b1330: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1b1334: 0x46020036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b1338: 0x0
    // NOP
    // 0x1b133c: 0x45000008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b1360;
    }
    // 0x1b1344: 0xc601055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x1b1348: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b134c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b1350: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b1354: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
label_1b1358:
    // 0x1b1358: 0x4503002b
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
        ctx->pc = 0x1B1408; return;
    }
label_1b1360:
    // 0x1b1360: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b1364: 0x8c420130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 304)));
    // 0x1b1368: 0x50400028
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1B140C; return;
    }
    // 0x1b1370: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b1374: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b137c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b137c
// Address: 0x1b137c - 0x1b141c

void entry_1b137c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b137c) {
        switch (ctx->pc) {
            case 0x1b13fc: ctx->pc = 0; goto label_1b13fc;
            case 0x1b1404: ctx->pc = 0; goto label_1b1404;
            case 0x1b1408: ctx->pc = 0; goto label_1b1408;
            case 0x1b140c: ctx->pc = 0; goto label_1b140c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b137c: 0x10000023
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b140c;
    }
    // 0x1b1384: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b1388: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b138c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b1390: 0xc60105bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1468)); ctx->f[1] = *(float*)&val; }
    // 0x1b1394: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b1398: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b139c: 0x0
    // NOP
    // 0x1b13a0: 0x45000019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b1408;
    }
    // 0x1b13a8: 0x10000017
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b1408;
    }
    // 0x1b13b0: 0x8e0205c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1472)));
    // 0x1b13b4: 0x54400015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1b140c;
    }
    // 0x1b13bc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b13c0: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1b13c4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b13c8: 0xc601060c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1548)); ctx->f[1] = *(float*)&val; }
    // 0x1b13cc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b13d0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b13d4: 0x0
    // NOP
    // 0x1b13d8: 0x4502000c
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1b140c;
    }
    // 0x1b13e0: 0x8e030554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x1b13e4: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1b13fc;
    }
    // 0x1b13ec: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b1404;
    }
    // 0x1b13f4: 0x10000005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b140c;
    }
label_1b13fc:
    // 0x1b13fc: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b1408;
    }
label_1b1404:
    // 0x1b1404: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
label_1b1408:
    // 0x1b1408: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b140c:
    // 0x1b140c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b1410: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1b1414: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b141c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b141c
// Address: 0x1b141c - 0x1b1424

void entry_1b141c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b141c: 0xc06c626
    SET_GPR_U32(ctx, 31, 0x1b1424);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime); return;
}


// Function: entry_1b1424
// Address: 0x1b1424 - 0x1b1438

void entry_1b1424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1424: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b1428: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b142c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b1434: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b1438; return;
}


// Function: SensePrsen__FP5PRSENP7SENSORS
// Address: 0x1b1438 - 0x1b14d0

void entry_1b14d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b14d0) {
        switch (ctx->pc) {
            case 0x1b14f8: ctx->pc = 0; goto label_1b14f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b14d0: 0x5040002d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x1B1588; return;
    }
    // 0x1b14d8: 0x8e620618
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1560)));
    // 0x1b14dc: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
        goto label_1b14f8;
    }
    // 0x1b14e4: 0x8e630554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1364)));
    // 0x1b14e8: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1b14ec: 0x3c3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 30));
    // 0x1b14f0: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    // 0x1b14f4: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
label_1b14f8:
    // 0x1b14f8: 0x2442fffb
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967291));
    // 0x1b14fc: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1b1500: 0x10400020
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b1584(rdram, ctx, runtime); return;
    }
    // 0x1b1508: 0x8e022e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1b150c: 0x16220010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B1550; return;
    }
    // 0x1b1514: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b1518: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b151c: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1b1524);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1b1524
// Address: 0x1b1524 - 0x1b1538

void entry_1b1524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1524: 0x8e042e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1b1528: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b152c: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1b1530: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b1538);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b1538
// Address: 0x1b1538 - 0x1b1548

void entry_1b1538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1538: 0x50400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x1B1588; return;
    }
    // 0x1b1540: 0xc06bbda
    SET_GPR_U32(ctx, 31, 0x1b1548);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PauseSensor__FP6SENSOR(rdram, ctx, runtime); return;
}


// Function: entry_1b1548
// Address: 0x1b1548 - 0x1b155c

void entry_1b1548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1548) {
        switch (ctx->pc) {
            case 0x1b1550: ctx->pc = 0; goto label_1b1550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1548: 0x1000000f
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1588; return;
    }
label_1b1550:
    // 0x1b1550: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b1554: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b155c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b155c
// Address: 0x1b155c - 0x1b1584

void entry_1b155c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b155c: 0xafb10014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 17));
    // 0x1b1560: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b1564: 0xafb30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 19));
    // 0x1b1568: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b156c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b1570: 0x7ae30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 23), 0)));
    // 0x1b1574: 0x7a220140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1b1578: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1b157c: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x1b1584);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1b1584
// Address: 0x1b1584 - 0x1b15d0

void entry_1b1584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1584) {
        switch (ctx->pc) {
            case 0x1b1588: ctx->pc = 0; goto label_1b1588;
            case 0x1b1590: ctx->pc = 0; goto label_1b1590;
            case 0x1b159c: ctx->pc = 0; goto label_1b159c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1584: 0x8e5200d0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
label_1b1588:
    // 0x1b1588: 0x5640ffc3
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1B1498; return;
    }
label_1b1590:
    // 0x1b1590: 0x8e940004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x1b1594: 0x5680ffba
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        ctx->pc = 0x1B1480; return;
    }
label_1b159c:
    // 0x1b159c: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b15a0: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b15a4: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b15a8: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b15ac: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b15b0: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b15b4: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b15b8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b15bc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b15c0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b15c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b15cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b15d0; return;
}


// Function: EnablePrsen__FP5PRSEN5SENSM
// Address: 0x1b15d0 - 0x1b15fc

void entry_1b15fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b15fc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1600: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DisablePrsen__FP5PRSEN
// Address: 0x1b1608 - 0x1b1640

void entry_1b1640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1640) {
        switch (ctx->pc) {
            case 0x1b1688: ctx->pc = 0; goto label_1b1688;
            case 0x1b168c: ctx->pc = 0; goto label_1b168c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1640: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x1b1644: 0x10600010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1b1688;
    }
    // 0x1b164c: 0x8c640550
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 1360)));
    // 0x1b1650: 0x1482000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1b168c;
    }
    // 0x1b1658: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b165c: 0xc4610554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 1364)); ctx->f[1] = *(float*)&val; }
    // 0x1b1660: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b1664: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1b1668: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1b166c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b1670: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b1674: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b1678: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b167c: 0x0
    // NOP
    // 0x1b1680: 0x45030002
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1472), GPR_U32(ctx, 4));
        goto label_1b168c;
    }
label_1b1688:
    // 0x1b1688: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b168c:
    // 0x1b168c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1690: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnPrsenAlarmTriggered__FP5PRSEN
// Address: 0x1b1698 - 0x1b16f0

void entry_1b16f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b16f0) {
        switch (ctx->pc) {
            case 0x1b16f8: ctx->pc = 0; goto label_1b16f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b16f0: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1708; return;
    }
label_1b16f8:
    // 0x1b16f8: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1b16fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b1704);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b1704
// Address: 0x1b1704 - 0x1b1710

void entry_1b1704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1704) {
        switch (ctx->pc) {
            case 0x1b1708: ctx->pc = 0; goto label_1b1708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1704: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b1708:
    // 0x1b1708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetPrsenSensors__FP5PRSEN7SENSORS
// Address: 0x1b1710 - 0x1b1774

void entry_1b1774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1774) {
        switch (ctx->pc) {
            case 0x1b1780: ctx->pc = 0; goto label_1b1780;
            case 0x1b1788: ctx->pc = 0; goto label_1b1788;
            case 0x1b1790: ctx->pc = 0; goto label_1b1790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1774: 0xc600055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[0] = *(float*)&val; }
    // 0x1b1778: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1556), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b1788;
    }
label_1b1780:
    // 0x1b1780: 0xae0005c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1472), GPR_U32(ctx, 0));
    // 0x1b1784: 0xae000618
    WRITE32(ADD32(GPR_U32(ctx, 16), 1560), GPR_U32(ctx, 0));
label_1b1788:
    // 0x1b1788: 0x2623ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1b178c: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
label_1b1790:
    // 0x1b1790: 0x1040002a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b183c(rdram, ctx, runtime); return;
    }
    // 0x1b1798: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b179c: 0x2442d120
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955296));
    // 0x1b17a0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b17a4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b17a8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b17b0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1b17b4: 0x2404000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 15));
    // 0x1b17b8: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x1b17bc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1b17c0: 0x260505c4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1476));
    // 0x1b17c4: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x1b17c8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1b17cc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b17d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b17d4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b17d8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b17dc: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1b17e0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b17e4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1b17ec);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1b17ec
// Address: 0x1b17ec - 0x1b183c

void entry_1b17ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b17ec: 0x10000014
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1840; return;
    }
    // 0x1b17f4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b17f8: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 1560), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1b183c(rdram, ctx, runtime); return;
    }
    // 0x1b1800: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1b1804: 0x2404001b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 27));
    // 0x1b1808: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x1b180c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1b1810: 0x260505c4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1476));
    // 0x1b1814: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x1b1818: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1b181c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b1820: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b1824: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b1828: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b182c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1b1830: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b1834: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1b183c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1b183c
// Address: 0x1b183c - 0x1b1848

void entry_1b183c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b183c) {
        switch (ctx->pc) {
            case 0x1b1840: ctx->pc = 0; goto label_1b1840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b183c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1b1840:
    // 0x1b1840: 0xc06bb3a
    SET_GPR_U32(ctx, 31, 0x1b1848);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetSensorSensors__FP6SENSOR7SENSORS(rdram, ctx, runtime); return;
}


// Function: entry_1b1848
// Address: 0x1b1848 - 0x1b1898

void entry_1b1848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1848) {
        switch (ctx->pc) {
            case 0x1b1864: ctx->pc = 0; goto label_1b1864;
            case 0x1b1880: ctx->pc = 0; goto label_1b1880;
            case 0x1b1884: ctx->pc = 0; goto label_1b1884;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1848: 0x8e020618
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1560)));
    // 0x1b184c: 0x1040000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b1880;
    }
    // 0x1b1854: 0x12220003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_1b1864;
    }
    // 0x1b185c: 0x16220009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_1b1884;
    }
label_1b1864:
    // 0x1b1864: 0x3a240002
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 17), 2));
    // 0x1b1868: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1b186c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b1870: 0xc6000614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1556)); ctx->f[0] = *(float*)&val; }
    // 0x1b1874: 0x64100a
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    // 0x1b1878: 0xe600055c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1372), *(uint32_t*)&val); }
    // 0x1b187c: 0xae020558
    WRITE32(ADD32(GPR_U32(ctx, 16), 1368), GPR_U32(ctx, 2));
label_1b1880:
    // 0x1b1880: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1b1884:
    // 0x1b1884: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1888: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b188c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b1894: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b1898; return;
}


// Function: UpdatePrsenLoopShader__FP5PRSEN
// Address: 0x1b1898 - 0x1b1ab8

void entry_1b1ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1ab8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1abc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b1ac4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b1ac8; return;
}


// Function: InitShadow__FP6SHADOW
// Address: 0x1b1ac8 - 0x1b1b38

void entry_1b1b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1b5c: 0xc06c74e
    SET_GPR_U32(ctx, 31, 0x1b1b64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FShadowRadiusSet__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b1b64
// Address: 0x1b1b64 - 0x1b1b7c

void entry_1b1b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1b64: 0x5440000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1B1B90; return;
    }
    // 0x1b1b6c: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1b1b70: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1b1b74: 0xc06c75c
    SET_GPR_U32(ctx, 31, 0x1b1b7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetShadowNearRadius__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_1b1b7c
// Address: 0x1b1b7c - 0x1b1b8c

void entry_1b1b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1b7c: 0x3c0143c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17352 << 16));
    // 0x1b1b80: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1b1b84: 0xc06c76a
    SET_GPR_U32(ctx, 31, 0x1b1b8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetShadowFarRadius__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_1b1b8c
// Address: 0x1b1b8c - 0x1b1bdc

void entry_1b1b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1b8c) {
        switch (ctx->pc) {
            case 0x1b1b90: ctx->pc = 0; goto label_1b1b90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1b8c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b1b90:
    // 0x1b1b90: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x1b1b94: 0x8c43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1b1b98: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1b1b9c: 0x14600010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1BE0; return;
    }
    // 0x1b1ba4: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1b1ba8: 0x8cc326d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 9936)));
    // 0x1b1bac: 0x28624000
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 16384));
    // 0x1b1bb0: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1BE0; return;
    }
    // 0x1b1bb8: 0x32100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1b1bbc: 0x2442dc20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294958112));
    // 0x1b1bc0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1b1bc4: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1b1bc8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b1bcc: 0xae0402d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 4));
    // 0x1b1bd0: 0xacc326d0
    WRITE32(ADD32(GPR_U32(ctx, 6), 9936), GPR_U32(ctx, 3));
    // 0x1b1bd4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b1bdc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b1bdc
// Address: 0x1b1bdc - 0x1b1bf0

void entry_1b1bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1bdc) {
        switch (ctx->pc) {
            case 0x1b1be0: ctx->pc = 0; goto label_1b1be0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1bdc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b1be0:
    // 0x1b1be0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1be4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b1bec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b1bf0; return;
}


// Function: InvalidateShadowVifs__FP6SHADOW
// Address: 0x1b1bf0 - 0x1b1bf8

void entry_1b1c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1c20) {
        switch (ctx->pc) {
            case 0x1b1c4c: ctx->pc = 0; goto label_1b1c4c;
            case 0x1b1cbc: ctx->pc = 0; goto label_1b1cbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1c20: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[6] = *(float*)&val; }
        goto label_1b1c4c;
    }
    // 0x1b1c28: 0xc6000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1b1c2c: 0xc6010044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[1] = *(float*)&val; }
    // 0x1b1c30: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1b1c34: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b1c38: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1b1c3c: 0x46000845
    ctx->f[1] = FPU_ABS_S(ctx->f[1]);
    // 0x1b1c40: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1b1c44: 0x1000001d
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b1cbc;
    }
label_1b1c4c:
    // 0x1b1c4c: 0xc6050008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[5] = *(float*)&val; }
    // 0x1b1c50: 0xc6030044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[3] = *(float*)&val; }
    // 0x1b1c54: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b1c58: 0x46053102
    ctx->f[4] = FPU_MUL_S(ctx->f[6], ctx->f[5]);
    // 0x1b1c5c: 0x460619c1
    ctx->f[7] = FPU_SUB_S(ctx->f[3], ctx->f[6]);
    // 0x1b1c60: 0x46001842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1b1c64: 0x46050001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[5]);
    // 0x1b1c68: 0x46052942
    ctx->f[5] = FPU_MUL_S(ctx->f[5], ctx->f[5]);
    // 0x1b1c6c: 0x46012101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x1b1c70: 0x46073882
    ctx->f[2] = FPU_MUL_S(ctx->f[7], ctx->f[7]);
    // 0x1b1c74: 0x46002103
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[4] = copysignf(INFINITY, ctx->f[4] * 0.0f); } else ctx->f[4] = ctx->f[4] / ctx->f[0];
    // 0x1b1c78: 0x46051080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[5]);
    // 0x1b1c7c: 0x46043180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[4]);
    // 0x1b1c80: 0x460418c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[4]);
    // 0x1b1c84: 0x46020044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x1b1c88: 0x46013002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x1b1c8c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1b1c90: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b1c94: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1b1c98: 0x46070003
    if (ctx->f[7] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[7];
    // 0x1b1c9c: 0x46010040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1b1ca0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1b1ca4: 0x46060003
    if (ctx->f[6] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[6];
    // 0x1b1ca8: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x1b1cac: 0x460318c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[3]);
    // 0x1b1cb0: 0x460518c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[5]);
    // 0x1b1cb4: 0x46030044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x1b1cb8: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
label_1b1cbc:
    // 0x1b1cbc: 0xe6010060
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 96), *(uint32_t*)&val); }
    // 0x1b1cc0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b1cc4: 0xda020020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1b1cc8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b1ccc: 0xda010010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1b1cd0: 0x4be31098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b1cd4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b1cd8: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b1cdc: 0xfa010050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b1ce0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b1ce4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b1ce8: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b1cec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b1cf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b1cf8; return;
}


// Function: SetShadowShader__FP6SHADOW3OID
// Address: 0x1b1cf8 - 0x1b1d18

void entry_1b1d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1d18: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b1d28(rdram, ctx, runtime); return;
    }
    // 0x1b1d20: 0xc06c6fc
    SET_GPR_U32(ctx, 31, 0x1b1d28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InvalidateShadowVifs__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b1d28
// Address: 0x1b1d28 - 0x1b1d38

void entry_1b1d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1d28: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1d2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1d30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FShadowRadiusSet__FP6SHADOW
// Address: 0x1b1d38 - 0x1b1d70

void entry_1b1d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1d9c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1da0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetShadowFarRadius__FP6SHADOWf
// Address: 0x1b1da8 - 0x1b1dd4

void entry_1b1dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1dd4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1dd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetShadowCastPosition__FP6SHADOWP6VECTOR
// Address: 0x1b1de0 - 0x1b1e2c

void entry_1b1e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1e2c: 0x10400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1E88; return;
    }
    // 0x1b1e34: 0x701117c9
    SET_GPR_VEC(ctx, 2, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b1e38: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b1e3c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b1e40: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b1e44: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1b1e48: 0x701017c9
    SET_GPR_VEC(ctx, 2, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b1e4c: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1b1e50: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1b1e58);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1b1e58
// Address: 0x1b1e58 - 0x1b1e84

void entry_1b1e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1e58: 0x1040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1E88; return;
    }
    // 0x1b1e60: 0x701114a8
    SET_GPR_VEC(ctx, 2, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    // 0x1b1e64: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b1e68: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b1e6c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b1e70: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1b1e74: 0x701014a8
    SET_GPR_VEC(ctx, 2, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    // 0x1b1e78: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1b1e7c: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1b1e84);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1b1e84
// Address: 0x1b1e84 - 0x1b1ea0

void entry_1b1e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1e84) {
        switch (ctx->pc) {
            case 0x1b1e88: ctx->pc = 0; goto label_1b1e88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1e84: 0x2a02b
    SET_GPR_U32(ctx, 20, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1b1e88:
    // 0x1b1e88: 0x16800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1EAC; return;
    }
    // 0x1b1e90: 0x7a620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1b1e94: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b1e98: 0xc06c6fe
    SET_GPR_U32(ctx, 31, 0x1b1ea0);
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 2));
    RebuildShadowRegion__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b1ea0
// Address: 0x1b1ea0 - 0x1b1ea8

void entry_1b1ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1ea0: 0xc06c6fc
    SET_GPR_U32(ctx, 31, 0x1b1ea8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    InvalidateShadowVifs__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b1ea8
// Address: 0x1b1ea8 - 0x1b1ec8

void entry_1b1ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1ea8) {
        switch (ctx->pc) {
            case 0x1b1eac: ctx->pc = 0; goto label_1b1eac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1ea8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1b1eac:
    // 0x1b1eac: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b1eb0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b1eb4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b1eb8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1ebc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1ec0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetShadowCastNormal__FP6SHADOWP6VECTOR
// Address: 0x1b1ec8 - 0x1b1f14

void entry_1b1f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1f14: 0x10400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1F70; return;
    }
    // 0x1b1f1c: 0x701117c9
    SET_GPR_VEC(ctx, 2, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b1f20: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b1f24: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b1f28: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b1f2c: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1b1f30: 0x701017c9
    SET_GPR_VEC(ctx, 2, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b1f34: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1b1f38: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1b1f40);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1b1f40
// Address: 0x1b1f40 - 0x1b1f6c

void entry_1b1f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1f40: 0x1040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1F70; return;
    }
    // 0x1b1f48: 0x701114a8
    SET_GPR_VEC(ctx, 2, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    // 0x1b1f4c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b1f50: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b1f54: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b1f58: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1b1f5c: 0x701014a8
    SET_GPR_VEC(ctx, 2, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    // 0x1b1f60: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1b1f64: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1b1f6c);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1b1f6c
// Address: 0x1b1f6c - 0x1b1f88

void entry_1b1f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1f6c) {
        switch (ctx->pc) {
            case 0x1b1f70: ctx->pc = 0; goto label_1b1f70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1f6c: 0x2a02b
    SET_GPR_U32(ctx, 20, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1b1f70:
    // 0x1b1f70: 0x16800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B1F94; return;
    }
    // 0x1b1f78: 0x7a620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1b1f7c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b1f80: 0xc06c6fe
    SET_GPR_U32(ctx, 31, 0x1b1f88);
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 2));
    RebuildShadowRegion__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b1f88
// Address: 0x1b1f88 - 0x1b1f90

void entry_1b1f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1f88: 0xc06c6fc
    SET_GPR_U32(ctx, 31, 0x1b1f90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    InvalidateShadowVifs__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b1f90
// Address: 0x1b1f90 - 0x1b1fb0

void entry_1b1f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b1f90) {
        switch (ctx->pc) {
            case 0x1b1f94: ctx->pc = 0; goto label_1b1f94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b1f90: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1b1f94:
    // 0x1b1f94: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b1f98: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b1f9c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b1fa0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1fa4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1fa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetShadowNearCast__FP6SHADOWf
// Address: 0x1b1fb0 - 0x1b1fc8

void entry_1b1fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1fc8: 0xc06c6fc
    SET_GPR_U32(ctx, 31, 0x1b1fd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InvalidateShadowVifs__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b1fd0
// Address: 0x1b1fd0 - 0x1b1fe0

void entry_1b1fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1fd0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b1fd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b1fd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetShadowFarCast__FP6SHADOWf
// Address: 0x1b1fe0 - 0x1b1ff8

void entry_1b1ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b1ff8: 0xc06c6fc
    SET_GPR_U32(ctx, 31, 0x1b2000);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InvalidateShadowVifs__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b2000
// Address: 0x1b2000 - 0x1b2010

void entry_1b2000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2000: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2004: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b2008: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetShadowConeAngle__FP6SHADOWf
// Address: 0x1b2010 - 0x1b2034

void entry_1b2034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2034: 0xc6010040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[1] = *(float*)&val; }
    // 0x1b2038: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b203c: 0xc6020044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[2] = *(float*)&val; }
    // 0x1b2040: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1b2044: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1b2048: 0xe6010004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1b204c: 0xc06c6fc
    SET_GPR_U32(ctx, 31, 0x1b2054);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    InvalidateShadowVifs__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1b2054
// Address: 0x1b2054 - 0x1b2068

void entry_1b2054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2054: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2058: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b205c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b2064: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b2068; return;
}


// Function: SetShadowFrustrumUp__FP6SHADOWP6VECTOR
// Address: 0x1b2068 - 0x1b2080

void entry_1b2080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2080: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b2084: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b208c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b2090; return;
}


// Function: FShadowValid__FP6SHADOWi
// Address: 0x1b2090 - 0x1b2118

void entry_1b2174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2174: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b2178: 0x3c07001b
    SET_GPR_U32(ctx, 7, ((uint32_t)27 << 16));
    // 0x1b217c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1b2180: 0x24e72118
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 8472));
    // 0x1b2184: 0xc66c0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 96)); ctx->f[12] = *(float*)&val; }
    // 0x1b2188: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b218c: 0x26660050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 80));
    // 0x1b2190: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2194: 0x27a900a0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1b2198: 0xc077134
    SET_GPR_U32(ctx, 31, 0x1b21a0);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 164));
    IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b21a0
// Address: 0x1b21a0 - 0x1b2218

void entry_1b21a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b21a0) {
        switch (ctx->pc) {
            case 0x1b21f0: ctx->pc = 0; goto label_1b21f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b21a0: 0x8fa200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b21a4: 0x1040005e
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2320; return;
    }
    // 0x1b21ac: 0x8e620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1b21b0: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b21b4: 0xda610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1b21b8: 0x8e620044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 68)));
    // 0x1b21bc: 0xda620020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1b21c0: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b21c4: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b21c8: 0x4be41148
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b21cc: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b21d0: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b21d4: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b21d8: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1b21dc: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b21e0: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b21e4: 0x8fa200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b21e8: 0x1840004d
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 164)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B2320; return;
    }
label_1b21f0:
    // 0x1b21f0: 0x141080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 20), 2));
    // 0x1b21f4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b21f8: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b21fc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b2200: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2204: 0x8c520000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b2208: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b220c: 0x27a90030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1b2210: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x1b2218);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1016)));
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1b2218
// Address: 0x1b2218 - 0x1b2290

void entry_1b2218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2218) {
        switch (ctx->pc) {
            case 0x1b2268: ctx->pc = 0; goto label_1b2268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2218: 0x1040003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B230C; return;
    }
    // 0x1b2220: 0x1080003b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2310; return;
    }
    // 0x1b2228: 0x8e4203b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 948)));
    // 0x1b222c: 0x8e430410
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1040)));
    // 0x1b2230: 0x821023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1b2234: 0x21143
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 5));
    // 0x1b2238: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b223c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b2240: 0x8c550004
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1b2244: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b2248: 0x235182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 21)));
    // 0x1b224c: 0x1060002f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B230C; return;
    }
    // 0x1b2254: 0x24070070
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 112));
    // 0x1b2258: 0x241e0028
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1b225c: 0x24170030
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1b2260: 0x24561858
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1b2264: 0x8e46040c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 1036)));
label_1b2268:
    // 0x1b2268: 0x1128c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 3));
    // 0x1b226c: 0x8e43023c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 572)));
    // 0x1b2270: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b2274: 0xc58021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x1b2278: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b227c: 0x471018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b2280: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b2284: 0x8c65002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 44)));
    // 0x1b2288: 0xc06c824
    SET_GPR_U32(ctx, 31, 0x1b2290);
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 7));
    FShadowValid__FP6SHADOWi(rdram, ctx, runtime); return;
}


// Function: entry_1b2290
// Address: 0x1b2290 - 0x1b2328

void entry_1b2290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2290) {
        switch (ctx->pc) {
            case 0x1b22dc: ctx->pc = 0; goto label_1b22dc;
            case 0x1b22fc: ctx->pc = 0; goto label_1b22fc;
            case 0x1b230c: ctx->pc = 0; goto label_1b230c;
            case 0x1b2310: ctx->pc = 0; goto label_1b2310;
            case 0x1b2320: ctx->pc = 0; goto label_1b2320;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2290: 0x1040001a
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b22fc;
    }
    // 0x1b2298: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b229c: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1b22a0: 0x9e2018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b22a4: 0x8e430240
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 576)));
    // 0x1b22a8: 0xb72818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b22ac: 0xc6c10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1b22b0: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1b22b4: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1b22b8: 0x452021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1b22bc: 0xc4800018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1b22c0: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b22c4: 0x0
    // NOP
    // 0x1b22c8: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 28)));
        goto label_1b22dc;
    }
    // 0x1b22d0: 0xe4810018
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 24), *(uint32_t*)&val); }
    // 0x1b22d4: 0xac80001c
    WRITE32(ADD32(GPR_U32(ctx, 4), 28), GPR_U32(ctx, 0));
    // 0x1b22d8: 0x8c83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 28)));
label_1b22dc:
    // 0x1b22dc: 0x2c620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 4));
    // 0x1b22e0: 0x1040000f
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b2320;
    }
    // 0x1b22e8: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1b22ec: 0xac530020
    WRITE32(ADD32(GPR_U32(ctx, 2), 32), GPR_U32(ctx, 19));
    // 0x1b22f0: 0x8c83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 28)));
    // 0x1b22f4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1b22f8: 0xac83001c
    WRITE32(ADD32(GPR_U32(ctx, 4), 28), GPR_U32(ctx, 3));
label_1b22fc:
    // 0x1b22fc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b2300: 0x235102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 21)));
    // 0x1b2304: 0x5440ffd8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 1036)));
        ctx->pc = 0x1B2268; return;
    }
label_1b230c:
    // 0x1b230c: 0x8fa200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
label_1b2310:
    // 0x1b2310: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1b2314: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x1b2318: 0x1440ffb5
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 164)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B21F0; return;
    }
label_1b2320:
    // 0x1b2320: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1b2328);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b2328
// Address: 0x1b2328 - 0x1b2358

void entry_1b2328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2328: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1b232c: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1b2330: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1b2334: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1b2338: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1b233c: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1b2340: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1b2344: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b2348: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b234c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b2350: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RebuildShadowVifs__FP6SHADOW
// Address: 0x1b2358 - 0x1b23c0

void entry_1b23c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b23c0: 0x8e5002d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    // 0x1b23c4: 0x27a20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1b23c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b23cc: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1b23d0: 0x50800a
    if (GPR_U32(ctx, 16) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
    // 0x1b23d4: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b23dc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 208));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b23dc
// Address: 0x1b23dc - 0x1b23f8

void entry_1b23dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b23dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b23e0: 0x27a900e0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1b23e4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1b23e8: 0x24060006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1b23ec: 0x24070016
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 22));
    // 0x1b23f0: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1b23f8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1b23f8
// Address: 0x1b23f8 - 0x1b241c

void entry_1b23f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b23f8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b23fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b2400: 0x2407001c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1b2404: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b2408: 0x8c51001c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1b240c: 0x26090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1b2410: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1b2414: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1b241c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1b241c
// Address: 0x1b241c - 0x1b2430

void entry_1b241c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b241c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b2420: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b2424: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x1b2428: 0xc05a528
    SET_GPR_U32(ctx, 31, 0x1b2430);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    PropagateSur__FP3SUR(rdram, ctx, runtime); return;
}


// Function: entry_1b2430
// Address: 0x1b2430 - 0x1b2440

void entry_1b2430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2430: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x1b2434: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b2438: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1b2440);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 944));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1b2440
// Address: 0x1b2440 - 0x1b2448

void entry_1b2440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2440: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x1b2448);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b2448
// Address: 0x1b2448 - 0x1b2458

void entry_1b2448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2448: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b244c: 0x264500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 192));
    // 0x1b2450: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x1b2458);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b2458
// Address: 0x1b2458 - 0x1b2474

void entry_1b2458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2458: 0x7a420020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1b245c: 0x27a60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1b2460: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1b2464: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1b2468: 0x7fa200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    // 0x1b246c: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1b2474);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 48));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1b2474
// Address: 0x1b2474 - 0x1b248c

void entry_1b2474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2474: 0xc64c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1b2478: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b247c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b2480: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b2484: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1b248c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[13] = *(float*)&val; }
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1b248c
// Address: 0x1b248c - 0x1b24a4

void entry_1b248c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b248c: 0x1040001d
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2504; return;
    }
    // 0x1b2494: 0x7a420010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1b2498: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b249c: 0xc062178
    SET_GPR_U32(ctx, 31, 0x1b24a4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    LoadIdentityMatrix4__FP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1b24a4
// Address: 0x1b24a4 - 0x1b257c

void entry_1b24a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b24a4) {
        switch (ctx->pc) {
            case 0x1b2504: ctx->pc = 0; goto label_1b2504;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b24a4: 0xc6410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1b24a8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b24ac: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1b24b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b24b4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b24b8: 0x8fa500e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b24bc: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1b24c0: 0x46010043
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[1];
    // 0x1b24c4: 0xc444d164
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294955364)); ctx->f[4] = *(float*)&val; }
    // 0x1b24c8: 0xe7a000b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
    // 0x1b24cc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b24d0: 0xe7a000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x1b24d4: 0xc46344f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 17648)); ctx->f[3] = *(float*)&val; }
    // 0x1b24d8: 0xc482d168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294955368)); ctx->f[2] = *(float*)&val; }
    // 0x1b24dc: 0xe7a10094
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 148), *(uint32_t*)&val); }
    // 0x1b24e0: 0xe7a10080
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x1b24e4: 0xe4a40050
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 5), 80), *(uint32_t*)&val); }
    // 0x1b24e8: 0x8fa200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b24ec: 0xe4420054
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 84), *(uint32_t*)&val); }
    // 0x1b24f0: 0xc6400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1b24f4: 0x8fa200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b24f8: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1b24fc: 0x10000032
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 92), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B25C8; return;
    }
label_1b2504:
    // 0x1b2504: 0xc6410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1b2508: 0xc6400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1b250c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b2510: 0xc6450040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 64)); ctx->f[5] = *(float*)&val; }
    // 0x1b2514: 0xc6440044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 68)); ctx->f[4] = *(float*)&val; }
    // 0x1b2518: 0x460100c1
    ctx->f[3] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b251c: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x1b2520: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1b2524: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1b2528: 0x46040882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x1b252c: 0xda420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1b2530: 0x46006386
    ctx->f[14] = FPU_MOV_S(ctx->f[12]);
    // 0x1b2534: 0xdba300c0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b2538: 0x460073c6
    ctx->f[15] = FPU_MOV_S(ctx->f[14]);
    // 0x1b253c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b2540: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1b2544: 0x46002d01
    ctx->f[20] = FPU_SUB_S(ctx->f[5], ctx->f[0]);
    // 0x1b2548: 0x46002541
    ctx->f[21] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x1b254c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b2550: 0x46140843
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[20];
    // 0x1b2554: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b2558: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1b255c: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b2560: 0xfba100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b2564: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b2568: 0x4600ac46
    ctx->f[17] = FPU_MOV_S(ctx->f[21]);
    // 0x1b256c: 0x4600a406
    ctx->f[16] = FPU_MOV_S(ctx->f[20]);
    // 0x1b2570: 0x46016303
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    // 0x1b2574: 0xc0627d6
    SET_GPR_U32(ctx, 31, 0x1b257c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    BuildSimpleProjectionMatrix__FffffffP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1b257c
// Address: 0x1b257c - 0x1b25dc

void entry_1b257c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b257c) {
        switch (ctx->pc) {
            case 0x1b25a0: ctx->pc = 0; goto label_1b25a0;
            case 0x1b25b0: ctx->pc = 0; goto label_1b25b0;
            case 0x1b25c8: ctx->pc = 0; goto label_1b25c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b257c: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b2580: 0x0
    // NOP
    // 0x1b2584: 0x45000006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b25a0;
    }
    // 0x1b258c: 0x8fa200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b2590: 0xe4540050
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 80), *(uint32_t*)&val); }
    // 0x1b2594: 0x8fa300e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b2598: 0x10000005
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 3), 84), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b25b0;
    }
label_1b25a0:
    // 0x1b25a0: 0x8fa200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b25a4: 0xe4550050
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 80), *(uint32_t*)&val); }
    // 0x1b25a8: 0x8fa300e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b25ac: 0xe4740054
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 3), 84), *(uint32_t*)&val); }
label_1b25b0:
    // 0x1b25b0: 0x8fa300e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b25b4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b25b8: 0xc44144f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 17648)); ctx->f[1] = *(float*)&val; }
    // 0x1b25bc: 0xc4600050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 80)); ctx->f[0] = *(float*)&val; }
    // 0x1b25c0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b25c4: 0xe460005c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 92), *(uint32_t*)&val); }
label_1b25c8:
    // 0x1b25c8: 0x26500070
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 112));
    // 0x1b25cc: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1b25d0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b25d4: 0xc0510b2
    SET_GPR_U32(ctx, 31, 0x1b25dc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CombineEyeLookAtProj(rdram, ctx, runtime); return;
}


// Function: entry_1b25dc
// Address: 0x1b25dc - 0x1b25ec

void entry_1b25dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b25dc: 0x8fa400e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b25e0: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1b25e4: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1b25ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1b25ec
// Address: 0x1b25ec - 0x1b2640

void entry_1b25ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b25ec) {
        switch (ctx->pc) {
            case 0x1b25f0: ctx->pc = 0; goto label_1b25f0;
            case 0x1b2620: ctx->pc = 0; goto label_1b2620;
            case 0x1b2624: ctx->pc = 0; goto label_1b2624;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b25ec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1b25f0:
    // 0x1b25f0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b25f4: 0x62880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1b25f8: 0x8fa400e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b25fc: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1b2600: 0x90430004
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1b2604: 0x852021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1b2608: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1b260c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1b2610: 0x28c20004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 4));
    // 0x1b2614: 0x31843
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 1));
    // 0x1b2618: 0x1440fff5
    WRITE32(ADD32(GPR_U32(ctx, 4), 64), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b25f0;
    }
label_1b2620:
    // 0x1b2620: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
label_1b2624:
    // 0x1b2624: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1b2628: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1b262c: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1b2630: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1b2634: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1b2638: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawShadow__FP6SHADOW
// Address: 0x1b2640 - 0x1b26a4

void entry_1b26a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b26a4) {
        switch (ctx->pc) {
            case 0x1b26b4: ctx->pc = 0; goto label_1b26b4;
            case 0x1b26e4: ctx->pc = 0; goto label_1b26e4;
            case 0x1b26e8: ctx->pc = 0; goto label_1b26e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b26a4: 0x8e0200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 192)));
    // 0x1b26a8: 0x1040000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b26e8;
    }
    // 0x1b26b0: 0x8e0300c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 192)));
label_1b26b4:
    // 0x1b26b4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1b26b8: 0x248422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8872));
    // 0x1b26bc: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1b26c0: 0x3c054000
    SET_GPR_U32(ctx, 5, ((uint32_t)16384 << 16));
    // 0x1b26c4: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1b26c8: 0x8c86000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1b26cc: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1b26d0: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b26d4: 0xfcc30000
    WRITE64(ADD32(GPR_U32(ctx, 6), 0), GPR_U64(ctx, 3));
    // 0x1b26d8: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1b26dc: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1b26e0: 0xac82000c
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 2));
label_1b26e4:
    // 0x1b26e4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b26e8:
    // 0x1b26e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b26ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b26f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b26f8; return;
}


// Function: FShadowIntersectsSphere__FP6SHADOWP6VECTORf
// Address: 0x1b26f8 - 0x1b2790

void entry_1b27f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b27f0) {
        switch (ctx->pc) {
            case 0x1b2810: ctx->pc = 0; goto label_1b2810;
            case 0x1b2814: ctx->pc = 0; goto label_1b2814;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b27f0: 0x1040fff9
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B27D8; return;
    }
    // 0x1b27f8: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 18));
        goto label_1b2814;
    }
    // 0x1b2800: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x1b2804: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1b2808: 0x1000fff3
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B27D8; return;
    }
label_1b2810:
    // 0x1b2810: 0xaeb20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 18));
label_1b2814:
    // 0x1b2814: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b2818: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b281c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b2820: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b2824: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b2828: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b282c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2830: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1b2834: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b283c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b2840; return;
}


// Function: LoadShapeFromBrx__FP5SHAPEP18CBinaryInputStream
// Address: 0x1b2840 - 0x1b2860

void entry_1b2860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2860: 0xc05366a
    SET_GPR_U32(ctx, 31, 0x1b2868);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PcrvNew__F4CRVK(rdram, ctx, runtime); return;
}


// Function: entry_1b2868
// Address: 0x1b2868 - 0x1b2888

void entry_1b2868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2868: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b286c: 0xae240034
    WRITE32(ADD32(GPR_U32(ctx, 17), 52), GPR_U32(ctx, 4));
    // 0x1b2870: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b2874: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b2878: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1B288C; return;
    }
    // 0x1b2880: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b2888);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b2888
// Address: 0x1b2888 - 0x1b2894

void entry_1b2888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2888) {
        switch (ctx->pc) {
            case 0x1b288c: ctx->pc = 0; goto label_1b288c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2888: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1b288c:
    // 0x1b288c: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1b2894);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b2894
// Address: 0x1b2894 - 0x1b28a8

void entry_1b2894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2894: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b2898: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b289c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b28a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetShapeParent__FP5SHAPEP3ALO
// Address: 0x1b28a8 - 0x1b28d8

void entry_1b28d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b28d8) {
        switch (ctx->pc) {
            case 0x1b28e0: ctx->pc = 0; goto label_1b28e0;
            case 0x1b2908: ctx->pc = 0; goto label_1b2908;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b28d8: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b2908;
    }
label_1b28e0:
    // 0x1b28e0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b28e4: 0x24428400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935552));
    // 0x1b28e8: 0x78460030
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1b28ec: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b28f0: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1b28f4: 0x78450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b28f8: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x1b28fc: 0x7fa40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 4));
    // 0x1b2900: 0x7fa50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 5));
    // 0x1b2904: 0x7fa60030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 6));
label_1b2908:
    // 0x1b2908: 0x12000006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 320));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2924; return;
    }
    // 0x1b2910: 0x26050110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1b2914: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1b291c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1b291c
// Address: 0x1b291c - 0x1b2968

void entry_1b291c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b291c) {
        switch (ctx->pc) {
            case 0x1b2924: ctx->pc = 0; goto label_1b2924;
            case 0x1b2950: ctx->pc = 0; goto label_1b2950;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b291c: 0x1000000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b2950;
    }
label_1b2924:
    // 0x1b2924: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b2928: 0x24428400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935552));
    // 0x1b292c: 0x78460030
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1b2930: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b2934: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1b2938: 0x78450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b293c: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1b2940: 0x7fa40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 4));
    // 0x1b2944: 0x7fa50060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 5));
    // 0x1b2948: 0x7fa60070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 6));
    // 0x1b294c: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
label_1b2950:
    // 0x1b2950: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b2954: 0x8c420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1b2958: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b2968(rdram, ctx, runtime); return;
    }
    // 0x1b2960: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b2968);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b2968
// Address: 0x1b2968 - 0x1b2974

void entry_1b2968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2968: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b296c: 0xc060bde
    SET_GPR_U32(ctx, 31, 0x1b2974);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1b2974
// Address: 0x1b2974 - 0x1b2988

void entry_1b2974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2974: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b2978: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b297c: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b2980: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Tex0FromTexIframeCtk__FP3TEXi3CTK
// Address: 0x1b2988 - 0x1b29e0

void entry_1b2a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2a24: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b2a28: 0x37a40008
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 29), 8));
    // 0x1b2a2c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2a30: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b2a38);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b2a38
// Address: 0x1b2a38 - 0x1b2a48

void entry_1b2a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2a38: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b2a3c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2a40: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b2a48);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b2a48
// Address: 0x1b2a48 - 0x1b2a58

void entry_1b2a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2a48: 0x27a40018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 24));
    // 0x1b2a4c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2a50: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b2a58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b2a58
// Address: 0x1b2a58 - 0x1b2a68

void entry_1b2a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2a58: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1b2a5c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2a60: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b2a68);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b2a68
// Address: 0x1b2a68 - 0x1b2a78

void entry_1b2a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2a68: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b2a6c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b2a70: 0xc06ca62
    SET_GPR_U32(ctx, 31, 0x1b2a78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    Tex0FromTexIframeCtk__FP3TEXi3CTK(rdram, ctx, runtime); return;
}


// Function: entry_1b2a78
// Address: 0x1b2a78 - 0x1b2a94

void entry_1b2a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2a78: 0x24030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1b2a7c: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1b2a80: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b2a84: 0x73280a
    if (GPR_U32(ctx, 19) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1b2a88: 0xffa20000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 2));
    // 0x1b2a8c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b2a94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b2a94
// Address: 0x1b2a94 - 0x1b2ad0

void entry_1b2a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2a94: 0xdfa20008
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1b2a98: 0x24040020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1b2a9c: 0x2406fe3f
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294966847));
    // 0x1b2aa0: 0x24070040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1b2aa4: 0x551025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1b2aa8: 0x24030015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1b2aac: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1b2ab0: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1b2ab4: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1b2ab8: 0x73280a
    if (GPR_U32(ctx, 19) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1b2abc: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1b2ac0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b2ac4: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b2ac8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b2ad0);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b2ad0
// Address: 0x1b2ad0 - 0x1b2b2c

void entry_1b2ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2ad0) {
        switch (ctx->pc) {
            case 0x1b2af0: ctx->pc = 0; goto label_1b2af0;
            case 0x1b2b14: ctx->pc = 0; goto label_1b2b14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2ad0: 0x96420002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x1b2ad4: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b2ad8: 0x10400005
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b2af0;
    }
    // 0x1b2ae0: 0x2403fffc
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x1b2ae4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b2ae8: 0x551025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1b2aec: 0xffa20020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 2));
label_1b2af0:
    // 0x1b2af0: 0x96420002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x1b2af4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b2af8: 0x10400006
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b2b14;
    }
    // 0x1b2b00: 0x2403fff3
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967283));
    // 0x1b2b04: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b2b08: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b2b0c: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1b2b10: 0xffa20020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 2));
label_1b2b14:
    // 0x1b2b14: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1b2b18: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1b2b1c: 0xdfa60020
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b2b20: 0x53280a
    if (GPR_U32(ctx, 19) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    // 0x1b2b24: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b2b2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b2b2c
// Address: 0x1b2b2c - 0x1b2b50

void entry_1b2b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2b2c: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b2b30: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b2b34: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b2b38: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b2b3c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b2b40: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b2b44: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b2b48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadClutFromBrx__FP18CBinaryInputStreamP4CLUT
// Address: 0x1b2b50 - 0x1b2b6c

void entry_1b2b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2b6c: 0x96020004
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1b2b70: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b2b74: 0x8c645718
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 22296)));
    // 0x1b2b78: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1b2b7c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b2b80: 0x2442000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 15));
    // 0x1b2b84: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2b88: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1b2b8c: 0x21102
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 4));
    // 0x1b2b90: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x1b2b94: 0xae040008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 4));
    // 0x1b2b98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b2b9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b2ba4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b2ba8; return;
}


// Function: LoadColorTablesFromBrx__FP18CBinaryInputStream
// Address: 0x1b2ba8 - 0x1b2be8

void entry_1b2be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2be8: 0x24040018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1b2bec: 0xae024508
    WRITE32(ADD32(GPR_U32(ctx, 16), 17672), GPR_U32(ctx, 2));
    // 0x1b2bf0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b2bf8);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b2bf8
// Address: 0x1b2bf8 - 0x1b2c30

void entry_1b2bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2bf8) {
        switch (ctx->pc) {
            case 0x1b2c20: ctx->pc = 0; goto label_1b2c20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2bf8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b2bfc: 0x8e044508
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 17672)));
    // 0x1b2c00: 0x60a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b2c04: 0xae42450c
    WRITE32(ADD32(GPR_U32(ctx, 18), 17676), GPR_U32(ctx, 2));
    // 0x1b2c08: 0x18800016
    WRITE32(ADD32(GPR_U32(ctx, 3), 17684), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1B2C64; return;
    }
    // 0x1b2c10: 0x240982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b2c14: 0x3c171000
    SET_GPR_U32(ctx, 23, ((uint32_t)4096 << 16));
    // 0x1b2c18: 0x2a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b2c1c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1b2c20:
    // 0x1b2c20: 0x8e65450c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 17676)));
    // 0x1b2c24: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b2c28: 0xc06cad4
    SET_GPR_U32(ctx, 31, 0x1b2c30);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    LoadClutFromBrx__FP18CBinaryInputStreamP4CLUT(rdram, ctx, runtime); return;
}


// Function: entry_1b2c30
// Address: 0x1b2c30 - 0x1b2ca8

void entry_1b2c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2c30) {
        switch (ctx->pc) {
            case 0x1b2c50: ctx->pc = 0; goto label_1b2c50;
            case 0x1b2c64: ctx->pc = 0; goto label_1b2c64;
            case 0x1b2c7c: ctx->pc = 0; goto label_1b2c7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2c30: 0x8e62450c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 17676)));
    // 0x1b2c34: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1b2c38: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b2c3c: 0x771824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
    // 0x1b2c40: 0x10600003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 17684)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1b2c50;
    }
    // 0x1b2c48: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1b2c4c: 0xae424514
    WRITE32(ADD32(GPR_U32(ctx, 18), 17684), GPR_U32(ctx, 2));
label_1b2c50:
    // 0x1b2c50: 0x8ec24508
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 17672)));
    // 0x1b2c54: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b2c58: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b2c5c: 0x1440fff0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 24));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2C20; return;
    }
label_1b2c64:
    // 0x1b2c64: 0x8ea24514
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 17684)));
    // 0x1b2c68: 0x8ec34508
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 17672)));
    // 0x1b2c6c: 0x621823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b2c70: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1b2c74: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 21), 17684), GPR_U32(ctx, 3));
        goto label_1b2c7c;
    }
label_1b2c7c:
    // 0x1b2c7c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b2c80: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b2c84: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b2c88: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b2c8c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b2c90: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b2c94: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b2c98: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2c9c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b2ca0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadBmpFromBrx__FP18CBinaryInputStreamP3BMP
// Address: 0x1b2ca8 - 0x1b2cc4

void entry_1b2cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2cc4: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1b2cc8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1b2ccc: 0x8c835718
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 22296)));
    // 0x1b2cd0: 0x8e050010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1b2cd4: 0x2442000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 15));
    // 0x1b2cd8: 0x21102
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 4));
    // 0x1b2cdc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2ce0: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1b2ce4: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x1b2ce8: 0xae030010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 3));
    // 0x1b2cec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b2cf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadBitmapsFromBrx__FP18CBinaryInputStream
// Address: 0x1b2cf8 - 0x1b2d38

void entry_1b2d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2d38: 0x22140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1b2d3c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b2d44);
    WRITE32(ADD32(GPR_U32(ctx, 16), 17664), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b2d44
// Address: 0x1b2d44 - 0x1b2d80

void entry_1b2d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2d44) {
        switch (ctx->pc) {
            case 0x1b2d70: ctx->pc = 0; goto label_1b2d70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2d44: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b2d48: 0x8e044500
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 17664)));
    // 0x1b2d4c: 0x60a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b2d50: 0xae424504
    WRITE32(ADD32(GPR_U32(ctx, 18), 17668), GPR_U32(ctx, 2));
    // 0x1b2d54: 0x18800017
    WRITE32(ADD32(GPR_U32(ctx, 3), 17680), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1B2DB4; return;
    }
    // 0x1b2d5c: 0x240982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b2d60: 0x3c171000
    SET_GPR_U32(ctx, 23, ((uint32_t)4096 << 16));
    // 0x1b2d64: 0x2a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b2d68: 0x8e654504
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 17668)));
    // 0x1b2d6c: 0x0
    // NOP
label_1b2d70:
    // 0x1b2d70: 0x118140
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 17), 5));
    // 0x1b2d74: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b2d78: 0xc06cb2a
    SET_GPR_U32(ctx, 31, 0x1b2d80);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    LoadBmpFromBrx__FP18CBinaryInputStreamP3BMP(rdram, ctx, runtime); return;
}


// Function: entry_1b2d80
// Address: 0x1b2d80 - 0x1b2df8

void entry_1b2d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2d80) {
        switch (ctx->pc) {
            case 0x1b2da0: ctx->pc = 0; goto label_1b2da0;
            case 0x1b2db4: ctx->pc = 0; goto label_1b2db4;
            case 0x1b2dcc: ctx->pc = 0; goto label_1b2dcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2d80: 0x8e634504
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 17668)));
    // 0x1b2d84: 0x2038021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1b2d88: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1b2d8c: 0x571024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x1b2d90: 0x10400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 17680)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b2da0;
    }
    // 0x1b2d98: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1b2d9c: 0xae424510
    WRITE32(ADD32(GPR_U32(ctx, 18), 17680), GPR_U32(ctx, 2));
label_1b2da0:
    // 0x1b2da0: 0x8ec24500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 17664)));
    // 0x1b2da4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b2da8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b2dac: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 17668)));
        ctx->pc = 0x1B2D70; return;
    }
label_1b2db4:
    // 0x1b2db4: 0x8ea24510
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 17680)));
    // 0x1b2db8: 0x8ec34500
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 17664)));
    // 0x1b2dbc: 0x621823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b2dc0: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1b2dc4: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 21), 17680), GPR_U32(ctx, 3));
        goto label_1b2dcc;
    }
label_1b2dcc:
    // 0x1b2dcc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b2dd0: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b2dd4: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b2dd8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b2ddc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b2de0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b2de4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b2de8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2dec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b2df0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadFontsFromBrx__FP18CBinaryInputStream
// Address: 0x1b2df8 - 0x1b2e28

void entry_1b2e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2e28: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b2e2c: 0x24040088
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 136));
    // 0x1b2e30: 0x2042018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b2e34: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b2e38: 0x24522264
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 8804));
    // 0x1b2e3c: 0xc07f62a
    SET_GPR_U32(ctx, 31, 0x1b2e44);
    WRITE32(ADD32(GPR_U32(ctx, 17), 8800), GPR_U32(ctx, 16));
    ctx->pc = 0x1fd8a8; return;
}


// Function: entry_1b2e44
// Address: 0x1b2e44 - 0x1b2ea8

void entry_1b2e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2e44) {
        switch (ctx->pc) {
            case 0x1b2e60: ctx->pc = 0; goto label_1b2e60;
            case 0x1b2e7c: ctx->pc = 0; goto label_1b2e7c;
            case 0x1b2e98: ctx->pc = 0; goto label_1b2e98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2e44: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b2e48: 0x2604ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1b2e4c: 0x1200000b
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1b2e7c;
    }
    // 0x1b2e54: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b2e58: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b2e5c: 0x2442a220
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294943264));
label_1b2e60:
    // 0x1b2e60: 0xac62004c
    WRITE32(ADD32(GPR_U32(ctx, 3), 76), GPR_U32(ctx, 2));
    // 0x1b2e64: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1b2e68: 0x0
    // NOP
    // 0x1b2e6c: 0x0
    // NOP
    // 0x1b2e70: 0x0
    // NOP
    // 0x1b2e74: 0x1485fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 136));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 5)) {
        goto label_1b2e60;
    }
label_1b2e7c:
    // 0x1b2e7c: 0x8ea22260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 8800)));
    // 0x1b2e80: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2e84: 0x18400011
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 6));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B2ECC; return;
    }
    // 0x1b2e8c: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x1b2e90: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b2e94: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1b2e98:
    // 0x1b2e98: 0x8e442264
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8804)));
    // 0x1b2e9c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b2ea0: 0xc05762a
    SET_GPR_U32(ctx, 31, 0x1b2ea8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 17)));
    LoadFromBrx__8CFontBrxP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b2ea8
// Address: 0x1b2ea8 - 0x1b2ed4

void entry_1b2ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2ea8) {
        switch (ctx->pc) {
            case 0x1b2ecc: ctx->pc = 0; goto label_1b2ecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2ea8: 0x8e422264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8804)));
    // 0x1b2eac: 0x2142004
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 20), GPR_U32(ctx, 16) & 0x1F));
    // 0x1b2eb0: 0x8ea32260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 8800)));
    // 0x1b2eb4: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1b2eb8: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1b2ebc: 0xac440080
    WRITE32(ADD32(GPR_U32(ctx, 2), 128), GPR_U32(ctx, 4));
    // 0x1b2ec0: 0x203182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x1b2ec4: 0x1460fff4
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 136));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2E98; return;
    }
label_1b2ecc:
    // 0x1b2ecc: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1b2ed4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1b2ed4
// Address: 0x1b2ed4 - 0x1b2f00

void entry_1b2ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2ed4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1b2ed8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b2edc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b2ee0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b2ee4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b2ee8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b2eec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b2ef0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b2ef4: 0xac62227c
    WRITE32(ADD32(GPR_U32(ctx, 3), 8828), GPR_U32(ctx, 2));
    // 0x1b2ef8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadTexFromBrx__FP18CBinaryInputStreamP3TEX
// Address: 0x1b2f00 - 0x1b2f34

void entry_1b2f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b2f34: 0x92220004
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b2f38: 0x10400017
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2F98; return;
    }
    // 0x1b2f40: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2f44: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1b2f4c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b2f4c
// Address: 0x1b2f4c - 0x1b2f68

void entry_1b2f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2f4c) {
        switch (ctx->pc) {
            case 0x1b2f60: ctx->pc = 0; goto label_1b2f60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2f4c: 0x92230004
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b2f50: 0x10600011
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2F98; return;
    }
    // 0x1b2f58: 0x3c130027
    SET_GPR_U32(ctx, 19, ((uint32_t)39 << 16));
    // 0x1b2f5c: 0x0
    // NOP
label_1b2f60:
    // 0x1b2f60: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1b2f68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b2f68
// Address: 0x1b2f68 - 0x1b2fb0

void entry_1b2f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2f68) {
        switch (ctx->pc) {
            case 0x1b2f98: ctx->pc = 0; goto label_1b2f98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2f68: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1b2f6c: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1b2f70: 0x8e644504
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 17668)));
    // 0x1b2f74: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1b2f78: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1b2f7c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1b2f80: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1b2f84: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x1b2f88: 0x92220004
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b2f8c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1b2f90: 0x1440fff3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2F60; return;
    }
label_1b2f98:
    // 0x1b2f98: 0x92220005
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 5)));
    // 0x1b2f9c: 0x1040001f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B301C; return;
    }
    // 0x1b2fa4: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b2fa8: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1b2fb0);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b2fb0
// Address: 0x1b2fb0 - 0x1b2fd0

void entry_1b2fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2fb0) {
        switch (ctx->pc) {
            case 0x1b2fc8: ctx->pc = 0; goto label_1b2fc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2fb0: 0x92230005
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 5)));
    // 0x1b2fb4: 0x10600019
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B301C; return;
    }
    // 0x1b2fbc: 0x3415ffff
    SET_GPR_U32(ctx, 21, OR32(GPR_U32(ctx, 0), 65535));
    // 0x1b2fc0: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1b2fc4: 0x24130018
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 24));
label_1b2fc8:
    // 0x1b2fc8: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1b2fd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b2fd0
// Address: 0x1b2fd0 - 0x1b3040

void entry_1b2fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b2fd0) {
        switch (ctx->pc) {
            case 0x1b2fec: ctx->pc = 0; goto label_1b2fec;
            case 0x1b3008: ctx->pc = 0; goto label_1b3008;
            case 0x1b301c: ctx->pc = 0; goto label_1b301c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b2fd0: 0x14550006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        goto label_1b2fec;
    }
    // 0x1b2fd8: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1b2fdc: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1b2fe0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b2fe4: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b3008;
    }
label_1b2fec:
    // 0x1b2fec: 0xb32818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b2ff0: 0x8e240010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1b2ff4: 0x8e83450c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 17676)));
    // 0x1b2ff8: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1b2ffc: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1b3000: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1b3004: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_1b3008:
    // 0x1b3008: 0x92220005
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 5)));
    // 0x1b300c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1b3010: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1b3014: 0x1440ffec
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B2FC8; return;
    }
label_1b301c:
    // 0x1b301c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b3020: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b3024: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b3028: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b302c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b3030: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b3034: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b3038: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadShadersFromBrx__FP18CBinaryInputStream
// Address: 0x1b3040 - 0x1b3088

void entry_1b3088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3088: 0x220f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b308c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b3090: 0xc06cb3e
    SET_GPR_U32(ctx, 31, 0x1b3098);
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadBitmapsFromBrx__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b3098
// Address: 0x1b3098 - 0x1b30a0

void entry_1b3098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3098: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1b30a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b30a0
// Address: 0x1b30a0 - 0x1b30b0

void entry_1b30a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b30a0: 0x24040028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1b30a4: 0xae0244f8
    WRITE32(ADD32(GPR_U32(ctx, 16), 17656), GPR_U32(ctx, 2));
    // 0x1b30a8: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b30b0);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b30b0
// Address: 0x1b30b0 - 0x1b30bc

void entry_1b30b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b30b0: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b30b4: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1b30bc);
    WRITE32(ADD32(GPR_U32(ctx, 17), 17660), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b30bc
// Address: 0x1b30bc - 0x1b30c8

void entry_1b30bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b30bc: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b30c0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b30c8);
    WRITE32(ADD32(GPR_U32(ctx, 18), 17724), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b30c8
// Address: 0x1b30c8 - 0x1b30fc

void entry_1b30c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b30c8) {
        switch (ctx->pc) {
            case 0x1b30e0: ctx->pc = 0; goto label_1b30e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b30c8: 0x8e0344f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 17656)));
    // 0x1b30cc: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b30d0: 0x1860009b
    WRITE32(ADD32(GPR_U32(ctx, 19), 17728), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1B3340; return;
    }
    // 0x1b30d8: 0x24020028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1b30dc: 0x0
    // NOP
label_1b30e0:
    // 0x1b30e0: 0x8fc344fc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 17660)));
    // 0x1b30e4: 0x2821018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b30e8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b30ec: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1b30f0: 0x628821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b30f4: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1b30fc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1b30fc
// Address: 0x1b30fc - 0x1b3104

void entry_1b30fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b30fc: 0xc06d284
    SET_GPR_U32(ctx, 31, 0x1b3104);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    PsaaLoadFromBrx__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b3104
// Address: 0x1b3104 - 0x1b3134

void entry_1b3104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3104) {
        switch (ctx->pc) {
            case 0x1b311c: ctx->pc = 0; goto label_1b311c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3104: 0x10400005
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b311c;
    }
    // 0x1b310c: 0xac510014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 17));
    // 0x1b3110: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1b3114: 0xaec20000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 2));
    // 0x1b3118: 0x26d60004
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 4));
label_1b311c:
    // 0x1b311c: 0x92220013
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 19)));
    // 0x1b3120: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1b3124: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1b3128: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b312c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b3134);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b3134
// Address: 0x1b3134 - 0x1b3160

void entry_1b3134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3134) {
        switch (ctx->pc) {
            case 0x1b3148: ctx->pc = 0; goto label_1b3148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3134: 0x92230013
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 19)));
    // 0x1b3138: 0x1060000e
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3174; return;
    }
    // 0x1b3140: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3144: 0x8e300014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_1b3148:
    // 0x1b3148: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b314c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1b3150: 0x2138021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    // 0x1b3154: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b3158: 0xc06cbc0
    SET_GPR_U32(ctx, 31, 0x1b3160);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 20));
    LoadTexFromBrx__FP18CBinaryInputStreamP3TEX(rdram, ctx, runtime); return;
}


// Function: entry_1b3160
// Address: 0x1b3160 - 0x1b31cc

void entry_1b3160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3160) {
        switch (ctx->pc) {
            case 0x1b3174: ctx->pc = 0; goto label_1b3174;
            case 0x1b31bc: ctx->pc = 0; goto label_1b31bc;
            case 0x1b31c0: ctx->pc = 0; goto label_1b31c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3160: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    // 0x1b3164: 0x92220013
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 19)));
    // 0x1b3168: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1b316c: 0x5440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x1B3148; return;
    }
label_1b3174:
    // 0x1b3174: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1b3178: 0x92250000
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b317c: 0x90430004
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1b3180: 0x2ca4000b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 5), 11));
    // 0x1b3184: 0x1080000e
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1b31c0;
    }
    // 0x1b318c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b3190: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1b3194: 0x2442d170
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955376));
    // 0x1b3198: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b319c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b31a0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b31a8: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b31bc;
    }
    // 0x1b31b0: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b31bc;
    }
    // 0x1b31b8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
label_1b31bc:
    // 0x1b31bc: 0xae220018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
label_1b31c0:
    // 0x1b31c0: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1b31c4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b31cc);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 3));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b31cc
// Address: 0x1b31cc - 0x1b323c

void entry_1b31cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b31cc: 0x92230000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b31d0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b31d4: 0x2c62000b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 11));
    // 0x1b31d8: 0x10400054
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B332C; return;
    }
    // 0x1b31e0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b31e4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b31e8: 0x2442d1a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955424));
    // 0x1b31ec: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b31f0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b31f4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b31fc: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1b3200: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x1b3204: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b3208: 0x10000045
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3320; return;
    }
    // 0x1b3210: 0x92220001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 1)));
    // 0x1b3214: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b3218: 0x26530008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 8));
    // 0x1b321c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b3220: 0x2180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
    // 0x1b3224: 0x24630005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 5));
    // 0x1b3228: 0xae430000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 3));
    // 0x1b322c: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b3230: 0x832018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3234: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b323c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b323c
// Address: 0x1b323c - 0x1b3258

void entry_1b323c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b323c: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1b3240: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    // 0x1b3244: 0xae430008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 3));
    // 0x1b3248: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b324c: 0x832018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3250: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b3258);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b3258
// Address: 0x1b3258 - 0x1b3278

void entry_1b3258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3258: 0xae620004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 2));
    // 0x1b325c: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1b3260: 0x26530010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 16));
    // 0x1b3264: 0xae420010
    WRITE32(ADD32(GPR_U32(ctx, 18), 16), GPR_U32(ctx, 2));
    // 0x1b3268: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b326c: 0x822018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3270: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b3278);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b3278
// Address: 0x1b3278 - 0x1b32c4

void entry_1b3278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3278: 0xae620004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 2));
    // 0x1b327c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b3280: 0x26530018
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 24));
    // 0x1b3284: 0xae420018
    WRITE32(ADD32(GPR_U32(ctx, 18), 24), GPR_U32(ctx, 2));
    // 0x1b3288: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b328c: 0x10000017
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B32EC; return;
    }
    // 0x1b3294: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1b3298: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x1b329c: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b32a0: 0x822018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b32a4: 0x1000001e
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3320; return;
    }
    // 0x1b32ac: 0x24100008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1b32b0: 0x26530008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 8));
    // 0x1b32b4: 0xae500000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 16));
    // 0x1b32b8: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b32bc: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b32c4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 7));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b32c4
// Address: 0x1b32c4 - 0x1b32d8

void entry_1b32c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b32c4: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    // 0x1b32c8: 0xae500008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 16));
    // 0x1b32cc: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b32d0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b32d8);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 7));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b32d8
// Address: 0x1b32d8 - 0x1b32f4

void entry_1b32d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b32d8) {
        switch (ctx->pc) {
            case 0x1b32ec: ctx->pc = 0; goto label_1b32ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b32d8: 0xae620004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 2));
    // 0x1b32dc: 0xae500010
    WRITE32(ADD32(GPR_U32(ctx, 18), 16), GPR_U32(ctx, 16));
    // 0x1b32e0: 0x26530010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 16));
    // 0x1b32e4: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b32e8: 0x421c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 7));
label_1b32ec:
    // 0x1b32ec: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b32f4);
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b32f4
// Address: 0x1b32f4 - 0x1b3328

void entry_1b32f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b32f4) {
        switch (ctx->pc) {
            case 0x1b3320: ctx->pc = 0; goto label_1b3320;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b32f4: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B332C; return;
    }
    // 0x1b32fc: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1b3300: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x1b3304: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1b3308: 0x822018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b330c: 0x10000004
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b3320;
    }
    // 0x1b3314: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b3318: 0x24040040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1b331c: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
label_1b3320:
    // 0x1b3320: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b3328);
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b3328
// Address: 0x1b3328 - 0x1b334c

void entry_1b3328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3328) {
        switch (ctx->pc) {
            case 0x1b332c: ctx->pc = 0; goto label_1b332c;
            case 0x1b3340: ctx->pc = 0; goto label_1b3340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3328: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
label_1b332c:
    // 0x1b332c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b3330: 0x8c6244f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 17656)));
    // 0x1b3334: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x1b3338: 0x1440ff69
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B30E0; return;
    }
label_1b3340:
    // 0x1b3340: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b3344: 0xc06cb7e
    SET_GPR_U32(ctx, 31, 0x1b334c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    LoadFontsFromBrx__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b334c
// Address: 0x1b334c - 0x1b3380

void entry_1b334c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b334c) {
        switch (ctx->pc) {
            case 0x1b3360: ctx->pc = 0; goto label_1b3360;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b334c: 0x8ee2453c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 17724)));
    // 0x1b3350: 0x18400010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B3394; return;
    }
    // 0x1b3358: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b335c: 0x0
    // NOP
label_1b3360:
    // 0x1b3360: 0x8c434540
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 17728)));
    // 0x1b3364: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1b3368: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b336c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b3370: 0x8c850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b3374: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x1b3378: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1b3380);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1b3380
// Address: 0x1b3380 - 0x1b33a4

void entry_1b3380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3380) {
        switch (ctx->pc) {
            case 0x1b3394: ctx->pc = 0; goto label_1b3394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3380: 0x8ee2453c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 17724)));
    // 0x1b3384: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1b3388: 0x1440fff5
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3360; return;
    }
    // 0x1b3390: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1b3394:
    // 0x1b3394: 0x24051e00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7680));
    // 0x1b3398: 0x24064000
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16384));
    // 0x1b339c: 0xc05a35a
    SET_GPR_U32(ctx, 31, 0x1b33a4);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitGsb__FP3GSBii(rdram, ctx, runtime); return;
}


// Function: entry_1b33a4
// Address: 0x1b33a4 - 0x1b33bc

void entry_1b33a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b33a4: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b33a8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b33ac: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b33b0: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x1b33b4: 0xc05a430
    SET_GPR_U32(ctx, 31, 0x1b33bc);
    SET_GPR_U32(ctx, 18, ((uint32_t)16384 << 16));
    FBuildUploadBitmapGifs__FiP3GSBP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b33bc
// Address: 0x1b33bc - 0x1b33c4

void entry_1b33bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b33bc: 0xc06cd44
    SET_GPR_U32(ctx, 31, 0x1b33c4);
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    FillShaders__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b33c4
// Address: 0x1b33c4 - 0x1b33d8

void entry_1b33c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b33c4: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1b33c8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1b33cc: 0x248426d8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9944));
    // 0x1b33d0: 0xc05a35a
    SET_GPR_U32(ctx, 31, 0x1b33d8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16384));
    InitGsb__FP3GSBii(rdram, ctx, runtime); return;
}


// Function: entry_1b33d8
// Address: 0x1b33d8 - 0x1b33e0

void entry_1b33d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b33d8: 0xc05797c
    SET_GPR_U32(ctx, 31, 0x1b33e0);
    PostFontsLoad__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b33e0
// Address: 0x1b33e0 - 0x1b33e8

void entry_1b33e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b33e0: 0xc06a7de
    SET_GPR_U32(ctx, 31, 0x1b33e8);
    PostBlotsLoad__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b33e8
// Address: 0x1b33e8 - 0x1b3400

void entry_1b33e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b33e8) {
        switch (ctx->pc) {
            case 0x1b33f0: ctx->pc = 0; goto label_1b33f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b33e8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b33ec: 0x24504520
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 17696));
label_1b33f0:
    // 0x1b33f0: 0x2332004
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 19), GPR_U32(ctx, 17) & 0x1F));
    // 0x1b33f4: 0x922025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1b33f8: 0xc05a5e0
    SET_GPR_U32(ctx, 31, 0x1b3400);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    PqwVifsBitmapUpload__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b3400
// Address: 0x1b3400 - 0x1b3418

void entry_1b3400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3400: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1b3404: 0x2a220006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 6));
    // 0x1b3408: 0x1440fff9
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B33F0; return;
    }
    // 0x1b3410: 0xc05a4ea
    SET_GPR_U32(ctx, 31, 0x1b3418);
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    PqwGifsBitmapUpload__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b3418
// Address: 0x1b3418 - 0x1b3450

void entry_1b3418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3418: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b341c: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b3420: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b3424: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b3428: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b342c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b3430: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b3434: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b3438: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b343c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b3440: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b3444: 0xac624538
    WRITE32(ADD32(GPR_U32(ctx, 3), 17720), GPR_U32(ctx, 2));
    // 0x1b3448: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UploadPermShaders__Fv
// Address: 0x1b3450 - 0x1b3468

void entry_1b3468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3468: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x1b346c: 0xc05a4ac
    SET_GPR_U32(ctx, 31, 0x1b3474);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    UploadBitmaps__FiP3GSB(rdram, ctx, runtime); return;
}


// Function: entry_1b3474
// Address: 0x1b3474 - 0x1b3488

void entry_1b3474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3474: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b3478: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b347c: 0xac404518
    WRITE32(ADD32(GPR_U32(ctx, 2), 17688), GPR_U32(ctx, 0));
    // 0x1b3480: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PropagateShaders__Fi
// Address: 0x1b3488 - 0x1b34a8

void entry_1b34a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b34a8: 0x8e424518
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 17688)));
    // 0x1b34ac: 0x12220011
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B34F4; return;
    }
    // 0x1b34b4: 0x261026d8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 9944));
    // 0x1b34b8: 0xc05a35e
    SET_GPR_U32(ctx, 31, 0x1b34c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResetGsb__FP3GSB(rdram, ctx, runtime); return;
}


// Function: entry_1b34c0
// Address: 0x1b34c0 - 0x1b34cc

void entry_1b34c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b34c0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b34c4: 0xc05a4ac
    SET_GPR_U32(ctx, 31, 0x1b34cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UploadBitmaps__FiP3GSB(rdram, ctx, runtime); return;
}


// Function: entry_1b34cc
// Address: 0x1b34cc - 0x1b34d4

void entry_1b34cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b34cc: 0xc06cd44
    SET_GPR_U32(ctx, 31, 0x1b34d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FillShaders__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b34d4
// Address: 0x1b34d4 - 0x1b34dc

void entry_1b34d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b34d4: 0xc05a5c6
    SET_GPR_U32(ctx, 31, 0x1b34dc);
    PropagateSurs__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b34dc
// Address: 0x1b34dc - 0x1b34e4

void entry_1b34dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b34dc: 0xc04ed0c
    SET_GPR_U32(ctx, 31, 0x1b34e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PropagateBlipgShaders__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b34e4
// Address: 0x1b34e4 - 0x1b3510

void entry_1b34e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b34e4) {
        switch (ctx->pc) {
            case 0x1b34f4: ctx->pc = 0; goto label_1b34f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b34e4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1b34e8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b34ec: 0xac6226cc
    WRITE32(ADD32(GPR_U32(ctx, 3), 9932), GPR_U32(ctx, 2));
    // 0x1b34f0: 0xae514518
    WRITE32(ADD32(GPR_U32(ctx, 18), 17688), GPR_U32(ctx, 17));
label_1b34f4:
    // 0x1b34f4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b34f8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b34fc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b3500: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b3504: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b350c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b3510; return;
}


// Function: FillShaders__Fi
// Address: 0x1b3510 - 0x1b35b8

void entry_1b35b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b35b8: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b35bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b35c0: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b35c4: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b35c8: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b35cc: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b35d4);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b35d4
// Address: 0x1b35d4 - 0x1b35f0

void entry_1b35d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b35d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b35d8: 0x2405007c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 124));
    // 0x1b35dc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b35e0: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b35e4: 0x24080412
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1042));
    // 0x1b35e8: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b35f0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b35f0
// Address: 0x1b35f0 - 0x1b3604

void entry_1b35f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b35f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b35f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b35f8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b35fc: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3604);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3604
// Address: 0x1b3604 - 0x1b3628

void entry_1b3604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3604: 0x92450000
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3608: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1b360c: 0x54a2000c
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
        ctx->pc = 0x1B3640; return;
    }
    // 0x1b3614: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3618: 0x3c060005
    SET_GPR_U32(ctx, 6, ((uint32_t)5 << 16));
    // 0x1b361c: 0x34c63001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 12289));
    // 0x1b3620: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3628);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3628
// Address: 0x1b3628 - 0x1b3638

void entry_1b3628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3628: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b362c: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3630: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3638);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 17));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3638
// Address: 0x1b3638 - 0x1b36a0

void entry_1b3638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3638) {
        switch (ctx->pc) {
            case 0x1b3640: ctx->pc = 0; goto label_1b3640;
            case 0x1b3660: ctx->pc = 0; goto label_1b3660;
            case 0x1b368c: ctx->pc = 0; goto label_1b368c;
            case 0x1b3698: ctx->pc = 0; goto label_1b3698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3638: 0x10000060
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B37BC; return;
    }
label_1b3640:
    // 0x1b3640: 0x30820008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 8));
    // 0x1b3644: 0x10400006
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b3660;
    }
    // 0x1b364c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3650: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x1b3654: 0x34c6001b
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 27));
    // 0x1b3658: 0x1000000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b3698;
    }
label_1b3660:
    // 0x1b3660: 0x10400015
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B36B8; return;
    }
    // 0x1b3668: 0x3c060001
    SET_GPR_U32(ctx, 6, ((uint32_t)1 << 16));
    // 0x1b366c: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1b3670: 0x3c030001
    SET_GPR_U32(ctx, 3, ((uint32_t)1 << 16));
    // 0x1b3674: 0x34633001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 12289));
    // 0x1b3678: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b367c: 0x62300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 3));
    // 0x1b3680: 0x10a40002
    SET_GPR_U32(ctx, 2, ((uint32_t)6 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 4)) {
        goto label_1b368c;
    }
    // 0x1b3688: 0x3c020002
    SET_GPR_U32(ctx, 2, ((uint32_t)2 << 16));
label_1b368c:
    // 0x1b368c: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1b3690: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3694: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
label_1b3698:
    // 0x1b3698: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b36a0);
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b36a0
// Address: 0x1b36a0 - 0x1b36b0

void entry_1b36a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b36a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b36a4: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b36a8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b36b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b36b0
// Address: 0x1b36b0 - 0x1b3714

void entry_1b36b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b36b0) {
        switch (ctx->pc) {
            case 0x1b36b8: ctx->pc = 0; goto label_1b36b8;
            case 0x1b36f0: ctx->pc = 0; goto label_1b36f0;
            case 0x1b3704: ctx->pc = 0; goto label_1b3704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b36b0: 0x10000042
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B37BC; return;
    }
label_1b36b8:
    // 0x1b36b8: 0x30820010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 16));
    // 0x1b36bc: 0x1040001f
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B373C; return;
    }
    // 0x1b36c4: 0x240307eb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2027));
    // 0x1b36c8: 0x240507e1
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2017));
    // 0x1b36cc: 0x30840004
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 4));
    // 0x1b36d0: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1b36d4: 0x3c020001
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    // 0x1b36d8: 0x34421000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4096));
    // 0x1b36dc: 0x10800004
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1b36f0;
    }
    // 0x1b36e4: 0x3c020001
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    // 0x1b36e8: 0x34423000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 12288));
    // 0x1b36ec: 0xa23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
label_1b36f0:
    // 0x1b36f0: 0x92430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b36f4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b36f8: 0x14620002
    SET_GPR_U32(ctx, 2, ((uint32_t)2 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1b3704;
    }
    // 0x1b3700: 0x3c020006
    SET_GPR_U32(ctx, 2, ((uint32_t)6 << 16));
label_1b3704:
    // 0x1b3704: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1b3708: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b370c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3714);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3714
// Address: 0x1b3714 - 0x1b3734

void entry_1b3714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3714: 0x92460001
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3718: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b371c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3720: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3724: 0x30c60001
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), 1));
    // 0x1b3728: 0x630f8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 3);
    // 0x1b372c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3734);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3734
// Address: 0x1b3734 - 0x1b378c

void entry_1b3734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3734) {
        switch (ctx->pc) {
            case 0x1b373c: ctx->pc = 0; goto label_1b373c;
            case 0x1b3768: ctx->pc = 0; goto label_1b3768;
            case 0x1b377c: ctx->pc = 0; goto label_1b377c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3734: 0x10000021
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B37BC; return;
    }
label_1b373c:
    // 0x1b373c: 0x240307eb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2027));
    // 0x1b3740: 0x240507e1
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2017));
    // 0x1b3744: 0x30840004
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 4));
    // 0x1b3748: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1b374c: 0x3c020001
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    // 0x1b3750: 0x34421000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4096));
    // 0x1b3754: 0x10800004
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1b3768;
    }
    // 0x1b375c: 0x3c020001
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    // 0x1b3760: 0x34423000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 12288));
    // 0x1b3764: 0xa23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
label_1b3768:
    // 0x1b3768: 0x92430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b376c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3770: 0x14620002
    SET_GPR_U32(ctx, 2, ((uint32_t)2 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1b377c;
    }
    // 0x1b3778: 0x3c020006
    SET_GPR_U32(ctx, 2, ((uint32_t)6 << 16));
label_1b377c:
    // 0x1b377c: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1b3780: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3784: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b378c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b378c
// Address: 0x1b378c - 0x1b37b8

void entry_1b378c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b378c: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3790: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3794: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b3798: 0x24070040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1b379c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b37a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b37a4: 0x62300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 3));
    // 0x1b37a8: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b37ac: 0x630b8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 2);
    // 0x1b37b0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b37b8);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b37b8
// Address: 0x1b37b8 - 0x1b37d8

void entry_1b37b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b37b8) {
        switch (ctx->pc) {
            case 0x1b37bc: ctx->pc = 0; goto label_1b37bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b37b8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1b37bc:
    // 0x1b37bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b37c0: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1b37c4: 0x2405003d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1b37c8: 0x100001fe
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 516)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3FC4; return;
    }
    // 0x1b37d0: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1b37d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b37d8
// Address: 0x1b37d8 - 0x1b37f4

void entry_1b37d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b37d8: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b37dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b37e0: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b37e4: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b37e8: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b37ec: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b37f4);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b37f4
// Address: 0x1b37f4 - 0x1b381c

void entry_1b37f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b37f4: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b37f8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b37fc: 0x1040002b
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1042));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B38AC; return;
    }
    // 0x1b3804: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3808: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b380c: 0x2405007c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 124));
    // 0x1b3810: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3814: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b381c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b381c
// Address: 0x1b381c - 0x1b3834

void entry_1b381c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b381c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1b3820: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1b3824: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3828: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b382c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3834);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3834
// Address: 0x1b3834 - 0x1b384c

void entry_1b3834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3834: 0x200a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b3838: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b383c: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x1b3840: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1b3844: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b384c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b384c
// Address: 0x1b384c - 0x1b3878

void entry_1b384c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b384c: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3850: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b3854: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3858: 0x24070040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1b385c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b3860: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3864: 0x62300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 3));
    // 0x1b3868: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b386c: 0x630b8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 2);
    // 0x1b3870: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3878);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3878
// Address: 0x1b3878 - 0x1b388c

void entry_1b3878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3878: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1b387c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3880: 0x2405003d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1b3884: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b388c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 516)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b388c
// Address: 0x1b388c - 0x1b38a4

void entry_1b388c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b388c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b3890: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b3894: 0x92470000
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3898: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b389c: 0xc06ca78
    SET_GPR_U32(ctx, 31, 0x1b38a4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PackTexGifs__FP3TEXi3CTK4SHDKP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b38a4
// Address: 0x1b38a4 - 0x1b38c8

void entry_1b38a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b38a4) {
        switch (ctx->pc) {
            case 0x1b38ac: ctx->pc = 0; goto label_1b38ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b38a4: 0x1000001e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3920; return;
    }
label_1b38ac:
    // 0x1b38ac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b38b0: 0x240804ff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1279));
    // 0x1b38b4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b38b8: 0x2405004c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    // 0x1b38bc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b38c0: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b38c8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b38c8
// Address: 0x1b38c8 - 0x1b38dc

void entry_1b38c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b38c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b38cc: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1b38d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b38d4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b38dc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b38dc
// Address: 0x1b38dc - 0x1b38f4

void entry_1b38dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b38dc: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x1b38e0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b38e4: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x1b38e8: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1b38ec: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b38f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b38f4
// Address: 0x1b38f4 - 0x1b3904

void entry_1b38f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b38f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b38f8: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b38fc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3904);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 106));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3904
// Address: 0x1b3904 - 0x1b391c

void entry_1b3904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3904: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3908: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b390c: 0x6303c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 0));
    // 0x1b3910: 0x34c60020
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 32));
    // 0x1b3914: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b391c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b391c
// Address: 0x1b391c - 0x1b3928

void entry_1b391c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b391c) {
        switch (ctx->pc) {
            case 0x1b3920: ctx->pc = 0; goto label_1b3920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b391c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1b3920:
    // 0x1b3920: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1b3928);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3928
// Address: 0x1b3928 - 0x1b3930

void entry_1b3928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3928: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x1b3930);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3930
// Address: 0x1b3930 - 0x1b3950

void entry_1b3930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3930: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b3934: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3938: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b393c: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3940: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1b3944: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b3948: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b3950);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3950
// Address: 0x1b3950 - 0x1b396c

void entry_1b3950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3950: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3954: 0x240804ff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1279));
    // 0x1b3958: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b395c: 0x2405004c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    // 0x1b3960: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3964: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b396c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b396c
// Address: 0x1b396c - 0x1b3980

void entry_1b396c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b396c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3970: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1b3974: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3978: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3980);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3980
// Address: 0x1b3980 - 0x1b3994

void entry_1b3980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3980: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3984: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x1b3988: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1b398c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3994);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3994
// Address: 0x1b3994 - 0x1b39a4

void entry_1b3994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3994: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3998: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b399c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b39a4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 106));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b39a4
// Address: 0x1b39a4 - 0x1b39c4

void entry_1b39a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b39a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b39a8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b39ac: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1b39b0: 0x34c68000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 32768));
    // 0x1b39b4: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1b39b8: 0x34c62000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 8192));
    // 0x1b39bc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b39c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b39c4
// Address: 0x1b39c4 - 0x1b39cc

void entry_1b39c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b39c4: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1b39cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b39cc
// Address: 0x1b39cc - 0x1b39d4

void entry_1b39cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b39cc: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x1b39d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b39d4
// Address: 0x1b39d4 - 0x1b39f4

void entry_1b39d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b39d4: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b39d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b39dc: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b39e0: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b39e4: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1b39e8: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b39ec: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b39f4);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b39f4
// Address: 0x1b39f4 - 0x1b3a10

void entry_1b39f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b39f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b39f8: 0x240804ff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1279));
    // 0x1b39fc: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3a00: 0x2405006c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 108));
    // 0x1b3a04: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3a08: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3a10);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3a10
// Address: 0x1b3a10 - 0x1b3a28

void entry_1b3a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3a10: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3a14: 0x3c070001
    SET_GPR_U32(ctx, 7, ((uint32_t)1 << 16));
    // 0x1b3a18: 0x34e72eee
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 12014));
    // 0x1b3a1c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3a20: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3a28);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3a28
// Address: 0x1b3a28 - 0x1b3a3c

void entry_1b3a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3a28: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3a2c: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x1b3a30: 0x34c65001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 20481));
    // 0x1b3a34: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3a3c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3a3c
// Address: 0x1b3a3c - 0x1b3a68

void entry_1b3a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3a3c: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3a40: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b3a44: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3a48: 0x24070040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1b3a4c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b3a50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3a54: 0x62300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 3));
    // 0x1b3a58: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3a5c: 0x630b8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 2);
    // 0x1b3a60: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3a68);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3a68
// Address: 0x1b3a68 - 0x1b3a7c

void entry_1b3a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3a68: 0x8e821990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    // 0x1b3a6c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3a70: 0x2405003d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1b3a74: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3a7c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 516)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3a7c
// Address: 0x1b3a7c - 0x1b3a94

void entry_1b3a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3a7c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1b3a80: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3a84: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b3a88: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1b3a8c: 0xc058548
    SET_GPR_U32(ctx, 31, 0x1b3a94);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PackSTQ__4GIFSfff(rdram, ctx, runtime); return;
}


// Function: entry_1b3a94
// Address: 0x1b3a94 - 0x1b3ae0

void entry_1b3a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3a94: 0x92430008
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1b3a98: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3a9c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1b3aa0: 0x31843
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 1));
    // 0x1b3aa4: 0xa3a30030
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 3));
    // 0x1b3aa8: 0x92420009
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 9)));
    // 0x1b3aac: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1b3ab0: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x1b3ab4: 0xa3a20031
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 2));
    // 0x1b3ab8: 0x9243000a
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 10)));
    // 0x1b3abc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1b3ac0: 0x31843
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 1));
    // 0x1b3ac4: 0xa3a30032
    WRITE8(ADD32(GPR_U32(ctx, 29), 50), (uint8_t)GPR_U32(ctx, 3));
    // 0x1b3ac8: 0x9242000b
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 11)));
    // 0x1b3acc: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1b3ad0: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x1b3ad4: 0xa3a20033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 2));
    // 0x1b3ad8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1b3ae0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1b3ae0
// Address: 0x1b3ae0 - 0x1b3ae8

void entry_1b3ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3ae0: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1b3ae8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3ae8
// Address: 0x1b3ae8 - 0x1b3af0

void entry_1b3ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3ae8: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x1b3af0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3af0
// Address: 0x1b3af0 - 0x1b3b0c

void entry_1b3af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3af0: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b3af4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3af8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b3afc: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3b00: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b3b04: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b3b0c);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3b0c
// Address: 0x1b3b0c - 0x1b3b34

void entry_1b3b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3b0c: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3b10: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b3b14: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3B3C; return;
    }
    // 0x1b3b1c: 0x2405007d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 125));
    // 0x1b3b20: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3b24: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b3b28: 0x24080412
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1042));
    // 0x1b3b2c: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3b34);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3b34
// Address: 0x1b3b34 - 0x1b3b54

void entry_1b3b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3b34) {
        switch (ctx->pc) {
            case 0x1b3b3c: ctx->pc = 0; goto label_1b3b3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3b34: 0x10000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3B58; return;
    }
label_1b3b3c:
    // 0x1b3b3c: 0x2405004d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 77));
    // 0x1b3b40: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3b44: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b3b48: 0x240804ff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1279));
    // 0x1b3b4c: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3b54);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3b54
// Address: 0x1b3b54 - 0x1b3b70

void entry_1b3b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3b54) {
        switch (ctx->pc) {
            case 0x1b3b58: ctx->pc = 0; goto label_1b3b58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3b54: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1b3b58:
    // 0x1b3b58: 0x2405006d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 109));
    // 0x1b3b5c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3b60: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b3b64: 0x240804ff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1279));
    // 0x1b3b68: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3b70);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3b70
// Address: 0x1b3b70 - 0x1b3b98

void entry_1b3b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3b70: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3b74: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b3b78: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3BA0; return;
    }
    // 0x1b3b80: 0x2405005d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 93));
    // 0x1b3b84: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3b88: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3b8c: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b3b90: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3b98);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3b98
// Address: 0x1b3b98 - 0x1b3bb8

void entry_1b3b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3b98) {
        switch (ctx->pc) {
            case 0x1b3ba0: ctx->pc = 0; goto label_1b3ba0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3b98: 0x10000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3BBC; return;
    }
label_1b3ba0:
    // 0x1b3ba0: 0x2405004d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 77));
    // 0x1b3ba4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3ba8: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3bac: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b3bb0: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3bb8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3bb8
// Address: 0x1b3bb8 - 0x1b3bd4

void entry_1b3bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3bb8) {
        switch (ctx->pc) {
            case 0x1b3bbc: ctx->pc = 0; goto label_1b3bbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3bb8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1b3bbc:
    // 0x1b3bbc: 0x2405004d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 77));
    // 0x1b3bc0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3bc4: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3bc8: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b3bcc: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3bd4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3bd4
// Address: 0x1b3bd4 - 0x1b3be4

void entry_1b3bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3bd4: 0x10000103
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1b3fe4(rdram, ctx, runtime); return;
    }
    // 0x1b3bdc: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1b3be4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3be4
// Address: 0x1b3be4 - 0x1b3c00

void entry_1b3be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3be4: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b3be8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3bec: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b3bf0: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3bf4: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b3bf8: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b3c00);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3c00
// Address: 0x1b3c00 - 0x1b3c14

void entry_1b3c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3c00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3c04: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3c08: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3c0c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3c14);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3c14
// Address: 0x1b3c14 - 0x1b3c28

void entry_1b3c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3c14: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3c18: 0x3c060005
    SET_GPR_U32(ctx, 6, ((uint32_t)5 << 16));
    // 0x1b3c1c: 0x34c6f001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 61441));
    // 0x1b3c20: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3c28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3c28
// Address: 0x1b3c28 - 0x1b3c44

void entry_1b3c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3c28: 0x92430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3c2c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b3c30: 0x14620006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B3C4C; return;
    }
    // 0x1b3c38: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3c3c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3c44);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3c44
// Address: 0x1b3c44 - 0x1b3c58

void entry_1b3c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3c44) {
        switch (ctx->pc) {
            case 0x1b3c4c: ctx->pc = 0; goto label_1b3c4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3c44: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3C5C; return;
    }
label_1b3c4c:
    // 0x1b3c4c: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3c50: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3c58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 73));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3c58
// Address: 0x1b3c58 - 0x1b3c70

void entry_1b3c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3c58) {
        switch (ctx->pc) {
            case 0x1b3c5c: ctx->pc = 0; goto label_1b3c5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3c58: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
label_1b3c5c:
    // 0x1b3c5c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b3c60: 0x92470000
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3c64: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3c68: 0xc06ca78
    SET_GPR_U32(ctx, 31, 0x1b3c70);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PackTexGifs__FP3TEXi3CTK4SHDKP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3c70
// Address: 0x1b3c70 - 0x1b3c7c

void entry_1b3c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3c70: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3c74: 0xc05849e
    SET_GPR_U32(ctx, 31, 0x1b3c7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    EndPrim__4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_1b3c7c
// Address: 0x1b3c7c - 0x1b3c8c

void entry_1b3c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3c7c: 0x100000fe
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B4078; return;
    }
    // 0x1b3c84: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1b3c8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3c8c
// Address: 0x1b3c8c - 0x1b3ca8

void entry_1b3c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3c8c: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b3c90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3c94: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b3c98: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3c9c: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b3ca0: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b3ca8);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3ca8
// Address: 0x1b3ca8 - 0x1b3cc4

void entry_1b3ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3ca8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3cac: 0x2405007c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 124));
    // 0x1b3cb0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3cb4: 0x24070004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b3cb8: 0x24084f12
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 20242));
    // 0x1b3cbc: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3cc4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3cc4
// Address: 0x1b3cc4 - 0x1b3cd8

void entry_1b3cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3cc4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3cc8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3ccc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3cd0: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3cd8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3cd8
// Address: 0x1b3cd8 - 0x1b3cf8

void entry_1b3cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3cd8: 0x92430001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3cdc: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x1b3ce0: 0x1040000b
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3D10; return;
    }
    // 0x1b3ce8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3cec: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x1b3cf0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3cf8);
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3cf8
// Address: 0x1b3cf8 - 0x1b3d08

void entry_1b3cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3cf8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3cfc: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3d00: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3d08);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3d08
// Address: 0x1b3d08 - 0x1b3d30

void entry_1b3d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3d08) {
        switch (ctx->pc) {
            case 0x1b3d10: ctx->pc = 0; goto label_1b3d10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3d08: 0x10000015
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3D60; return;
    }
label_1b3d10:
    // 0x1b3d10: 0x3c020007
    SET_GPR_U32(ctx, 2, ((uint32_t)7 << 16));
    // 0x1b3d14: 0x344217eb
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 6123));
    // 0x1b3d18: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x1b3d1c: 0x34c637eb
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 14315));
    // 0x1b3d20: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3d24: 0x43300a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    // 0x1b3d28: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3d30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3d30
// Address: 0x1b3d30 - 0x1b3d5c

void entry_1b3d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3d30: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3d34: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3d38: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b3d3c: 0x24070040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1b3d40: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b3d44: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3d48: 0x62300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 3));
    // 0x1b3d4c: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3d50: 0x630b8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 2);
    // 0x1b3d54: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3d5c);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3d5c
// Address: 0x1b3d5c - 0x1b3d78

void entry_1b3d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3d5c) {
        switch (ctx->pc) {
            case 0x1b3d60: ctx->pc = 0; goto label_1b3d60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3d5c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1b3d60:
    // 0x1b3d60: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3d64: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1b3d68: 0x2405003d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1b3d6c: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1b3d70: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3d78);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 516)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3d78
// Address: 0x1b3d78 - 0x1b3d90

void entry_1b3d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3d78: 0x92470000
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3d7c: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3d80: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b3d84: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3d88: 0xc06ca78
    SET_GPR_U32(ctx, 31, 0x1b3d90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PackTexGifs__FP3TEXi3CTK4SHDKP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3d90
// Address: 0x1b3d90 - 0x1b3d98

void entry_1b3d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3d90: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1b3d98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3d98
// Address: 0x1b3d98 - 0x1b3da0

void entry_1b3d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3d98: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x1b3da0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3da0
// Address: 0x1b3da0 - 0x1b3dbc

void entry_1b3da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3da0: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b3da4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3da8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b3dac: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3db0: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b3db4: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b3dbc);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3dbc
// Address: 0x1b3dbc - 0x1b3dd8

void entry_1b3dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3dbc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3dc0: 0x240841f2
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16882));
    // 0x1b3dc4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3dc8: 0x2405007c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 124));
    // 0x1b3dcc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3dd0: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3dd8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3dd8
// Address: 0x1b3dd8 - 0x1b3dec

void entry_1b3dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3dd8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3ddc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3de0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3de4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3dec);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3dec
// Address: 0x1b3dec - 0x1b3e00

void entry_1b3dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3dec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3df0: 0x3c060005
    SET_GPR_U32(ctx, 6, ((uint32_t)5 << 16));
    // 0x1b3df4: 0x34c63001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 12289));
    // 0x1b3df8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3e00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3e00
// Address: 0x1b3e00 - 0x1b3e24

void entry_1b3e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3e00: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3e04: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1b3e08: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3E2C; return;
    }
    // 0x1b3e10: 0x24060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1b3e14: 0x6303c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 0));
    // 0x1b3e18: 0x34c60068
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 104));
    // 0x1b3e1c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3e24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3e24
// Address: 0x1b3e24 - 0x1b3e38

void entry_1b3e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3e24) {
        switch (ctx->pc) {
            case 0x1b3e2c: ctx->pc = 0; goto label_1b3e2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3e24: 0x10000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3E3C; return;
    }
label_1b3e2c:
    // 0x1b3e2c: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3e30: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3e38);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 72));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3e38
// Address: 0x1b3e38 - 0x1b3e4c

void entry_1b3e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3e38) {
        switch (ctx->pc) {
            case 0x1b3e3c: ctx->pc = 0; goto label_1b3e3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3e38: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1b3e3c:
    // 0x1b3e3c: 0x2405003d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1b3e40: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3e44: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3e4c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3e4c
// Address: 0x1b3e4c - 0x1b3e64

void entry_1b3e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3e4c: 0x92470000
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3e50: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3e54: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b3e58: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3e5c: 0xc06ca78
    SET_GPR_U32(ctx, 31, 0x1b3e64);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PackTexGifs__FP3TEXi3CTK4SHDKP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3e64
// Address: 0x1b3e64 - 0x1b3e6c

void entry_1b3e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3e64: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1b3e6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3e6c
// Address: 0x1b3e6c - 0x1b3e74

void entry_1b3e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3e6c: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x1b3e74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3e74
// Address: 0x1b3e74 - 0x1b3e90

void entry_1b3e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3e74: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b3e78: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3e7c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b3e80: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3e84: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b3e88: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b3e90);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3e90
// Address: 0x1b3e90 - 0x1b3eac

void entry_1b3e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3e90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3e94: 0x24084f12
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 20242));
    // 0x1b3e98: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3e9c: 0x2405007c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 124));
    // 0x1b3ea0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3ea4: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3eac);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3eac
// Address: 0x1b3eac - 0x1b3ec0

void entry_1b3eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3eac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3eb0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3eb4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b3eb8: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3ec0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3ec0
// Address: 0x1b3ec0 - 0x1b3ed4

void entry_1b3ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3ec0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3ec4: 0x3c060005
    SET_GPR_U32(ctx, 6, ((uint32_t)5 << 16));
    // 0x1b3ec8: 0x34c63001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 12289));
    // 0x1b3ecc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3ed4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3ed4
// Address: 0x1b3ed4 - 0x1b3ef8

void entry_1b3ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3ed4: 0x92420001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x1b3ed8: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1b3edc: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3F00; return;
    }
    // 0x1b3ee4: 0x24060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1b3ee8: 0x6303c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 0));
    // 0x1b3eec: 0x34c60068
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 104));
    // 0x1b3ef0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3ef8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3ef8
// Address: 0x1b3ef8 - 0x1b3f0c

void entry_1b3ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3ef8) {
        switch (ctx->pc) {
            case 0x1b3f00: ctx->pc = 0; goto label_1b3f00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3ef8: 0x10000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3F10; return;
    }
label_1b3f00:
    // 0x1b3f00: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b3f04: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3f0c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 72));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3f0c
// Address: 0x1b3f0c - 0x1b3f1c

void entry_1b3f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3f0c) {
        switch (ctx->pc) {
            case 0x1b3f10: ctx->pc = 0; goto label_1b3f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3f0c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1b3f10:
    // 0x1b3f10: 0x2405003d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1b3f14: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3f1c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3f1c
// Address: 0x1b3f1c - 0x1b3f24

void entry_1b3f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3f1c: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1b3f24);
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 18), 16)));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1b3f24
// Address: 0x1b3f24 - 0x1b3f48

void entry_1b3f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3f24) {
        switch (ctx->pc) {
            case 0x1b3f34: ctx->pc = 0; goto label_1b3f34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3f24: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        goto label_1b3f34;
    }
    // 0x1b3f2c: 0x10000028
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3FD0; return;
    }
label_1b3f34:
    // 0x1b3f34: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b3f38: 0x92470000
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3f3c: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b3f40: 0xc06ca78
    SET_GPR_U32(ctx, 31, 0x1b3f48);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PackTexGifs__FP3TEXi3CTK4SHDKP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3f48
// Address: 0x1b3f48 - 0x1b3f58

void entry_1b3f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3f48: 0x10000026
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1b3fe4(rdram, ctx, runtime); return;
    }
    // 0x1b3f50: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1b3f58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3f58
// Address: 0x1b3f58 - 0x1b3f74

void entry_1b3f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3f58: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b3f5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3f60: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b3f64: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b3f68: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b3f6c: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b3f74);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3f74
// Address: 0x1b3f74 - 0x1b3f90

void entry_1b3f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3f74: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3f78: 0x24080412
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1042));
    // 0x1b3f7c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3f80: 0x2405024c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 588));
    // 0x1b3f84: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3f88: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b3f90);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b3f90
// Address: 0x1b3f90 - 0x1b3fa4

void entry_1b3f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3f90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3f94: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1b3f98: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3f9c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b3fa4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b3fa4
// Address: 0x1b3fa4 - 0x1b3fb8

void entry_1b3fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3fa4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3fa8: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1b3fac: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1b3fb0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3fb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 72));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3fb8
// Address: 0x1b3fb8 - 0x1b3fcc

void entry_1b3fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3fb8) {
        switch (ctx->pc) {
            case 0x1b3fc4: ctx->pc = 0; goto label_1b3fc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3fb8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b3fbc: 0x24050043
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 67));
    // 0x1b3fc0: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
label_1b3fc4:
    // 0x1b3fc4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b3fcc);
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b3fcc
// Address: 0x1b3fcc - 0x1b3fe4

void entry_1b3fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b3fcc) {
        switch (ctx->pc) {
            case 0x1b3fd0: ctx->pc = 0; goto label_1b3fd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b3fcc: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
label_1b3fd0:
    // 0x1b3fd0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b3fd4: 0x92470000
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b3fd8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b3fdc: 0xc06ca78
    SET_GPR_U32(ctx, 31, 0x1b3fe4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PackTexGifs__FP3TEXi3CTK4SHDKP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3fe4
// Address: 0x1b3fe4 - 0x1b3fec

void entry_1b3fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3fe4: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1b3fec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b3fec
// Address: 0x1b3fec - 0x1b3ffc

void entry_1b3fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3fec: 0x10000022
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B4078; return;
    }
    // 0x1b3ff4: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1b3ffc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1b3ffc
// Address: 0x1b3ffc - 0x1b4018

void entry_1b3ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b3ffc: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b4000: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b4004: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b4008: 0x2653018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b400c: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b4010: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1b4018);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b4018
// Address: 0x1b4018 - 0x1b4034

void entry_1b4018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4018: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b401c: 0x2408041f
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1055));
    // 0x1b4020: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b4024: 0x2405004c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    // 0x1b4028: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b402c: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x1b4034);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1b4034
// Address: 0x1b4034 - 0x1b4048

void entry_1b4034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4034: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b4038: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1b403c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b4040: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1b4048);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1b4048
// Address: 0x1b4048 - 0x1b405c

void entry_1b4048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4048: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b404c: 0x3c060005
    SET_GPR_U32(ctx, 6, ((uint32_t)5 << 16));
    // 0x1b4050: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1b4054: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b405c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b405c
// Address: 0x1b405c - 0x1b406c

void entry_1b405c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b405c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b4060: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1b4064: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1b406c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 106));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1b406c
// Address: 0x1b406c - 0x1b4074

void entry_1b406c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b406c: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1b4074);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1b4074
// Address: 0x1b4074 - 0x1b40c8

void entry_1b4074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4074) {
        switch (ctx->pc) {
            case 0x1b4078: ctx->pc = 0; goto label_1b4078;
            case 0x1b4088: ctx->pc = 0; goto label_1b4088;
            case 0x1b409c: ctx->pc = 0; goto label_1b409c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4074: 0x8e420020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
label_1b4078:
    // 0x1b4078: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1b407c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1b4080: 0x5440fd41
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1B3588; return;
    }
label_1b4088:
    // 0x1b4088: 0x8ee244f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 17656)));
    // 0x1b408c: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1b4090: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x1b4094: 0x1440fd30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 40));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B3558; return;
    }
label_1b409c:
    // 0x1b409c: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b40a0: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b40a4: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b40a8: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b40ac: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b40b0: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b40b4: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b40b8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b40bc: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b40c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UnloadShaders__Fv
// Address: 0x1b40c8 - 0x1b412c

void entry_1b412c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b412c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1b4130: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b4134: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1b4138: 0x3c080027
    SET_GPR_U32(ctx, 8, ((uint32_t)39 << 16));
    // 0x1b413c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b4140: 0xacc04540
    WRITE32(ADD32(GPR_U32(ctx, 6), 17728), GPR_U32(ctx, 0));
    // 0x1b4144: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1b4148: 0xac604518
    WRITE32(ADD32(GPR_U32(ctx, 3), 17688), GPR_U32(ctx, 0));
    // 0x1b414c: 0x24844520
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 17696));
    // 0x1b4150: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b4154: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1b4158: 0xace0451c
    WRITE32(ADD32(GPR_U32(ctx, 7), 17692), GPR_U32(ctx, 0));
    // 0x1b415c: 0xad004544
    WRITE32(ADD32(GPR_U32(ctx, 8), 17732), GPR_U32(ctx, 0));
    // 0x1b4160: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b4168);
    WRITE32(ADD32(GPR_U32(ctx, 2), 17724), GPR_U32(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b4168
// Address: 0x1b4168 - 0x1b4174

void entry_1b4168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4168: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b416c: 0xc05a340
    SET_GPR_U32(ctx, 31, 0x1b4174);
    WRITE32(ADD32(GPR_U32(ctx, 3), 17720), GPR_U32(ctx, 0));
    ResetGsMemory__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b4174
// Address: 0x1b4174 - 0x1b4180

void entry_1b4174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4174: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4178: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001B4180
// Address: 0x1b4180 - 0x1b4188

void entry_1b4458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4458) {
        switch (ctx->pc) {
            case 0x1b4560: ctx->pc = 0; goto label_1b4560;
            case 0x1b4564: ctx->pc = 0; goto label_1b4564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4458: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1b445c: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1b4460: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b4464: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b4468: 0x46161041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[22]);
    // 0x1b446c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1b4470: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1b4474: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x1b4478: 0x4601a302
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1b447c: 0x4600a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[0]);
    // 0x1b4480: 0x46001041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1b4484: 0x4600b002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x1b4488: 0x4601b042
    ctx->f[1] = FPU_MUL_S(ctx->f[22], ctx->f[1]);
    // 0x1b448c: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1b4490: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1b4494: 0x4600a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1b4498: 0x10400032
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[2]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b4564;
    }
    // 0x1b44a0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b44a4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b44a8: 0x2442d200
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955520));
    // 0x1b44ac: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b44b0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b44b4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1b44bc: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1b44c0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1b44c4: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b44c8: 0x44036000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[12]);
    // 0x1b44cc: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b44d0: 0x10000023
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b4560;
    }
    // 0x1b44d8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1b44dc: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1b44e0: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b44e4: 0x44036000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[12]);
    // 0x1b44e8: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b44ec: 0x1000001c
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b4560;
    }
    // 0x1b44f4: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x1b44f8: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1b44fc: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b4500: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1b4504: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b4508: 0x10000015
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b4560;
    }
    // 0x1b4510: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x1b4514: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1b4518: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b451c: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1b4520: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b4524: 0x1000000e
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b4560;
    }
    // 0x1b452c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b4530: 0x44036000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[12]);
    // 0x1b4534: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b4538: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1b453c: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b4540: 0x10000007
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b4560;
    }
    // 0x1b4548: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1b454c: 0x44036000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[12]);
    // 0x1b4550: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b4554: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1b4558: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1b455c: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
label_1b4560:
    // 0x1b4560: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
label_1b4564:
    // 0x1b4564: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b4568: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b456c: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x1b4570: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1b4574: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1b4578: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertUserHsvToUserRgb__FP6VECTORT0
// Address: 0x1b4580 - 0x1b45c4

void entry_1b45c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b45c4: 0x3c01437f
    SET_GPR_U32(ctx, 1, ((uint32_t)17279 << 16));
    // 0x1b45c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b45cc: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1b45d0: 0xc6020004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1b45d4: 0xc6030008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1b45d8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1b45dc: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1b45e0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b45e4: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1b45e8: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1b45ec: 0xe6020004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1b45f0: 0xe6030008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1b45f4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b45f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertUserRgbToUserHsv__FP6VECTORT0
// Address: 0x1b4600 - 0x1b463c

void entry_1b463c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b463c: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1b4640: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1b4644: 0x3c01437f
    SET_GPR_U32(ctx, 1, ((uint32_t)17279 << 16));
    // 0x1b4648: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b464c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b4650: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1b4654: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1b4658: 0xe6010004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1b465c: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1b4660: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b4664: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b466c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b4670; return;
}


// Function: junk_001B4670
// Address: 0x1b4670 - 0x1b4688

void entry_1b4830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4830) {
        switch (ctx->pc) {
            case 0x1b4840: ctx->pc = 0; goto label_1b4840;
            case 0x1b4850: ctx->pc = 0; goto label_1b4850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4830: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1b4834: 0x5600fff0
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1B47F8; return;
    }
    // 0x1b483c: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
label_1b4840:
    // 0x1b4840: 0xae200018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 0));
    // 0x1b4844: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b4848: 0x5620ffe7
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x1B47E8; return;
    }
label_1b4850:
    // 0x1b4850: 0xae40451c
    WRITE32(ADD32(GPR_U32(ctx, 18), 17692), GPR_U32(ctx, 0));
    // 0x1b4854: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b4858: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b485c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b4860: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b4864: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4868: 0xac404544
    WRITE32(ADD32(GPR_U32(ctx, 2), 17732), GPR_U32(ctx, 0));
    // 0x1b486c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b4874: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b4878; return;
}


// Function: UpdateShaders__Ff
// Address: 0x1b4878 - 0x1b48cc

void entry_1b48cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b48cc: 0x10400008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 17724)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B48F0; return;
    }
    // 0x1b48d4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b48d8: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1b48dc: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b48ec(rdram, ctx, runtime); return;
    }
    // 0x1b48e4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b48ec);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b48ec
// Address: 0x1b48ec - 0x1b4920

void entry_1b48ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b48ec) {
        switch (ctx->pc) {
            case 0x1b48f0: ctx->pc = 0; goto label_1b48f0;
            case 0x1b4900: ctx->pc = 0; goto label_1b4900;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b48ec: 0x8e62453c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 17724)));
label_1b48f0:
    // 0x1b48f0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b48f4: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b48f8: 0x1440ffef
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 17728)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B48B8; return;
    }
label_1b4900:
    // 0x1b4900: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b4904: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b4908: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b490c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b4910: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4914: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1b4918: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CbFromSaak__F4SAAK
// Address: 0x1b4920 - 0x1b4980

void entry_1b4a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4a2c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b4a30: 0x12200014
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B4A84; return;
    }
    // 0x1b4a38: 0xc06d248
    SET_GPR_U32(ctx, 31, 0x1b4a40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CbFromSaak__F4SAAK(rdram, ctx, runtime); return;
}


// Function: entry_1b4a40
// Address: 0x1b4a40 - 0x1b4a48

void entry_1b4a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4a40: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1b4a48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b4a48
// Address: 0x1b4a48 - 0x1b4a54

void entry_1b4a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4a48: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b4a4c: 0xc06d260
    SET_GPR_U32(ctx, 31, 0x1b4a54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PvtsaaFromSaak__F4SAAK(rdram, ctx, runtime); return;
}


// Function: entry_1b4a54
// Address: 0x1b4a54 - 0x1b4a6c

void entry_1b4a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4a54: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    // 0x1b4a58: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b4a5c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1b4a60: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b4a64: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1b4a6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 28));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1b4a6c
// Address: 0x1b4a6c - 0x1b4a80

void entry_1b4a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4a6c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b4a70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b4a74: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b4a78: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b4a80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b4a80
// Address: 0x1b4a80 - 0x1b4aa0

void entry_1b4a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4a80) {
        switch (ctx->pc) {
            case 0x1b4a84: ctx->pc = 0; goto label_1b4a84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4a80: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1b4a84:
    // 0x1b4a84: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b4a88: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b4a8c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b4a90: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b4a94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b4a9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b4aa0; return;
}


// Function: InitSaa__FP3SAAP4SAAF
// Address: 0x1b4aa0 - 0x1b4ad0

void entry_1b4af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4af4) {
        switch (ctx->pc) {
            case 0x1b4afc: ctx->pc = 0; goto label_1b4afc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4af4: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x1b4af8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b4afc:
    // 0x1b4afc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4b00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUpdatableSaa__FP3SAA
// Address: 0x1b4b08 - 0x1b4b38

void entry_1b4b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4b84: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b4b88: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b4b8c: 0xe620002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 44), *(uint32_t*)&val); }
    // 0x1b4b90: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b4b94: 0xe6210030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    // 0x1b4b98: 0xc600000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1b4b9c: 0xe6200034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 52), *(uint32_t*)&val); }
    // 0x1b4ba0: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1b4ba4: 0xe6210038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 56), *(uint32_t*)&val); }
    // 0x1b4ba8: 0x96020014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4bac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4bb0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b4bb4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1b4bb8: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x1b4bbc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b4bc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostLoopLoad__FP4LOOP
// Address: 0x1b4bc8 - 0x1b4bdc

void entry_1b4bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4bdc: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4be0: 0x1040000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B4C20; return;
    }
    // 0x1b4be8: 0xc60c002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 44)); ctx->f[12] = *(float*)&val; }
    // 0x1b4bec: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b4bf4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b4bf4
// Address: 0x1b4bf4 - 0x1b4c14

void entry_1b4bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4bf4: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4bf8: 0xc60c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1b4bfc: 0xc4410020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[1] = *(float*)&val; }
    // 0x1b4c00: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1b4c04: 0xc60d0038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[13] = *(float*)&val; }
    // 0x1b4c08: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1b4c0c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b4c14);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b4c14
// Address: 0x1b4c14 - 0x1b4c30

void entry_1b4c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4c14) {
        switch (ctx->pc) {
            case 0x1b4c20: ctx->pc = 0; goto label_1b4c20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4c14: 0xe6000048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 72), *(uint32_t*)&val); }
    // 0x1b4c18: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1b4c1c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b4c20:
    // 0x1b4c20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4c24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b4c2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b4c30; return;
}


// Function: UpdateLoop__FP4LOOPf
// Address: 0x1b4c30 - 0x1b4cb4

void entry_1b4cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4cb4: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4cb8: 0xc60c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1b4cbc: 0xc4410020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[1] = *(float*)&val; }
    // 0x1b4cc0: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1b4cc4: 0xc60d0038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[13] = *(float*)&val; }
    // 0x1b4cc8: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1b4ccc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b4cd4);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b4cd4
// Address: 0x1b4cd4 - 0x1b4cf0

void entry_1b4cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4cd4) {
        switch (ctx->pc) {
            case 0x1b4ce0: ctx->pc = 0; goto label_1b4ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4cd4: 0xe6000048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 72), *(uint32_t*)&val); }
    // 0x1b4cd8: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1b4cdc: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_1b4ce0:
    // 0x1b4ce0: 0xc44d0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[13] = *(float*)&val; }
    // 0x1b4ce4: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1b4ce8: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1b4cf0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[12] = *(float*)&val; }
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b4cf0
// Address: 0x1b4cf0 - 0x1b4d04

void entry_1b4cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4cf0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1b4cf4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1b4cf8: 0x26040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1b4cfc: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x1b4d04);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 64), *(uint32_t*)&val); }
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_1b4d04
// Address: 0x1b4d04 - 0x1b4d18

void entry_1b4d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4d04) {
        switch (ctx->pc) {
            case 0x1b4d08: ctx->pc = 0; goto label_1b4d08;
            case 0x1b4d0c: ctx->pc = 0; goto label_1b4d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4d04: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b4d08:
    // 0x1b4d08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b4d0c:
    // 0x1b4d0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b4d14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b4d18; return;
}


// Function: UCompleteLoop__FP4LOOP
// Address: 0x1b4d18 - 0x1b4d48

void entry_1b4d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4d64: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b4d68: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b4d6c: 0xe620002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 44), *(uint32_t*)&val); }
    // 0x1b4d70: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b4d74: 0xe6210030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    // 0x1b4d78: 0xc600000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1b4d7c: 0xe6200034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 52), *(uint32_t*)&val); }
    // 0x1b4d80: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1b4d84: 0xe6210038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 56), *(uint32_t*)&val); }
    // 0x1b4d88: 0x96020014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4d8c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4d90: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b4d94: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1b4d98: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x1b4d9c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b4da0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostPingpongLoad__FP8PINGPONG
// Address: 0x1b4da8 - 0x1b4dbc

void entry_1b4dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4dbc: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4dc0: 0x10400011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B4E08; return;
    }
    // 0x1b4dc8: 0xc60c002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 44)); ctx->f[12] = *(float*)&val; }
    // 0x1b4dcc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b4dd4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b4dd4
// Address: 0x1b4dd4 - 0x1b4dfc

void entry_1b4dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4dd4: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4dd8: 0xc60c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1b4ddc: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1b4de0: 0xc60d0038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[13] = *(float*)&val; }
    // 0x1b4de4: 0x21040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 1));
    // 0x1b4de8: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1b4dec: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1b4df0: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1b4df4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b4dfc);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b4dfc
// Address: 0x1b4dfc - 0x1b4e18

void entry_1b4dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4dfc) {
        switch (ctx->pc) {
            case 0x1b4e08: ctx->pc = 0; goto label_1b4e08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4dfc: 0xe6000048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 72), *(uint32_t*)&val); }
    // 0x1b4e00: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1b4e04: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b4e08:
    // 0x1b4e08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4e0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b4e14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b4e18; return;
}


// Function: UpdatePingpong__FP8PINGPONGf
// Address: 0x1b4e18 - 0x1b4ec4

void entry_1b4ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4ec4: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b4ec8: 0xc60c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1b4ecc: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1b4ed0: 0xc60d0038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[13] = *(float*)&val; }
    // 0x1b4ed4: 0x21040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 1));
    // 0x1b4ed8: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1b4edc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1b4ee0: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1b4ee4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b4eec);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b4eec
// Address: 0x1b4eec - 0x1b4f08

void entry_1b4eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4eec) {
        switch (ctx->pc) {
            case 0x1b4ef8: ctx->pc = 0; goto label_1b4ef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4eec: 0xe6000048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 72), *(uint32_t*)&val); }
    // 0x1b4ef0: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1b4ef4: 0xc6000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[0] = *(float*)&val; }
label_1b4ef8:
    // 0x1b4ef8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1b4efc: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1b4f00: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x1b4f08);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_1b4f08
// Address: 0x1b4f08 - 0x1b4f18

void entry_1b4f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b4f08) {
        switch (ctx->pc) {
            case 0x1b4f0c: ctx->pc = 0; goto label_1b4f0c;
            case 0x1b4f10: ctx->pc = 0; goto label_1b4f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b4f08: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b4f0c:
    // 0x1b4f0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b4f10:
    // 0x1b4f10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UCompletePingpong__FP8PINGPONG
// Address: 0x1b4f18 - 0x1b4f80

void entry_1b4f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b4f9c: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b4fa0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b4fa4: 0xe620002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 44), *(uint32_t*)&val); }
    // 0x1b4fa8: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b4fac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b4fb0: 0xe6210030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    // 0x1b4fb4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b4fb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateShuffle__FP7SHUFFLEf
// Address: 0x1b4fc0 - 0x1b5014

void entry_1b5014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5014) {
        switch (ctx->pc) {
            case 0x1b5034: ctx->pc = 0; goto label_1b5034;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5014: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b5018: 0x26040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1b501c: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1b5020: 0x8ca60020
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x1b5024: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b5028: 0x66001a
    { int32_t divisor = GPR_S32(ctx, 6); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 3) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 6) % divisor); } else { ctx->lo = (GPR_S32(ctx,3) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,6); } }
    // 0x1b502c: 0x50c00001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1b5034;
    }
label_1b5034:
    // 0x1b5034: 0x2810
    SET_GPR_U32(ctx, 5, ctx->hi);
    // 0x1b5038: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x1b5040);
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_1b5040
// Address: 0x1b5040 - 0x1b504c

void entry_1b5040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5040: 0xc60c002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 44)); ctx->f[12] = *(float*)&val; }
    // 0x1b5044: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b504c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b504c
// Address: 0x1b504c - 0x1b5060

void entry_1b504c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b504c) {
        switch (ctx->pc) {
            case 0x1b5054: ctx->pc = 0; goto label_1b5054;
            case 0x1b5058: ctx->pc = 0; goto label_1b5058;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b504c: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1b5050: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b5054:
    // 0x1b5054: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b5058:
    // 0x1b5058: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitHologram__FP8HOLOGRAMP4SAAF
// Address: 0x1b5060 - 0x1b507c

void entry_1b507c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b507c) {
        switch (ctx->pc) {
            case 0x1b50a0: ctx->pc = 0; goto label_1b50a0;
            case 0x1b50b4: ctx->pc = 0; goto label_1b50b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b507c: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b5080: 0xe620002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 44), *(uint32_t*)&val); }
    // 0x1b5084: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1b5088: 0x4400005
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 2), 1));
    if (GPR_S32(ctx, 2) < 0) {
        goto label_1b50a0;
    }
    // 0x1b5090: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1b5094: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1b5098: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b50b4;
    }
label_1b50a0:
    // 0x1b50a0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b50a4: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b50a8: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1b50ac: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1b50b0: 0x460d6b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[13]);
label_1b50b4:
    // 0x1b50b4: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1b50b8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1b50bc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b50c0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b50c4: 0xc442d260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294955616)); ctx->f[2] = *(float*)&val; }
    // 0x1b50c8: 0x460d0b43
    if (ctx->f[13] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[13] = ctx->f[1] / ctx->f[13];
    // 0x1b50cc: 0xc620002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[0] = *(float*)&val; }
    // 0x1b50d0: 0x46020032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b50d4: 0x0
    // NOP
    // 0x1b50d8: 0x45000005
    { float val = ctx->f[13]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B50F0; return;
    }
    // 0x1b50e0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1b50e4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b50ec);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b50ec
// Address: 0x1b50ec - 0x1b5108

void entry_1b50ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b50ec) {
        switch (ctx->pc) {
            case 0x1b50f0: ctx->pc = 0; goto label_1b50f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b50ec: 0xe620002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 44), *(uint32_t*)&val); }
label_1b50f0:
    // 0x1b50f0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b50f4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b50f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b50fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b5104: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5108; return;
}


// Function: PostHologramLoad__FP8HOLOGRAM
// Address: 0x1b5108 - 0x1b511c

void entry_1b511c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b511c) {
        switch (ctx->pc) {
            case 0x1b5150: ctx->pc = 0; goto label_1b5150;
            case 0x1b5154: ctx->pc = 0; goto label_1b5154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b511c: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b5120: 0x1040000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b5150;
    }
    // 0x1b5128: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b512c: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1b5130: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        goto label_1b5154;
    }
    // 0x1b5138: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1b513c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1b5140: 0xc6000030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1b5144: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1b5148: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1b514c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b5150:
    // 0x1b5150: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b5154:
    // 0x1b5154: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b515c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5160; return;
}


// Function: NotifyHologramRender__FP8HOLOGRAMP3ALOP3RPL
// Address: 0x1b5160 - 0x1b51c8

void entry_1b51c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b51c8: 0xc60c002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 44)); ctx->f[12] = *(float*)&val; }
    // 0x1b51cc: 0xc60d0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[13] = *(float*)&val; }
    // 0x1b51d0: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1b51d8);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b51d8
// Address: 0x1b51d8 - 0x1b51f0

void entry_1b51d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b51d8: 0xc6010034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1b51dc: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1b51e0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1b51e4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1b51e8: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x1b51f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_1b51f0
// Address: 0x1b51f0 - 0x1b5200

void entry_1b51f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b51f0) {
        switch (ctx->pc) {
            case 0x1b51f4: ctx->pc = 0; goto label_1b51f4;
            case 0x1b51f8: ctx->pc = 0; goto label_1b51f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b51f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b51f4:
    // 0x1b51f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b51f8:
    // 0x1b51f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitScroller__FP8SCROLLERP4SAAF
// Address: 0x1b5200 - 0x1b521c

void entry_1b521c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b521c: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b5220: 0x2403fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x1b5224: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1b5228: 0xe600002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    // 0x1b522c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b5230: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b5234: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b5238: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b523c: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x1b5240: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b5244: 0xe6010030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x1b5248: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1b524c: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1b5250: 0xc6210010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1b5254: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x1b5258: 0xe6010038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x1b525c: 0xe602003c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    // 0x1b5260: 0xe6020040
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 64), *(uint32_t*)&val); }
    // 0x1b5264: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5268: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b526c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b5274: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5278; return;
}


// Function: UpdateScroller__FP8SCROLLERf
// Address: 0x1b5278 - 0x1b52bc

void entry_1b52bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b52bc: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1b52c0: 0xc60c0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[12] = *(float*)&val; }
    // 0x1b52c4: 0xc6000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1b52c8: 0xc6010020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[1] = *(float*)&val; }
    // 0x1b52cc: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1b52d0: 0xc60d0038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[13] = *(float*)&val; }
    // 0x1b52d4: 0x46156302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[21]);
    // 0x1b52d8: 0xc081628
    SET_GPR_U32(ctx, 31, 0x1b52e0);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    fmodf(rdram, ctx, runtime); return;
}


// Function: entry_1b52e0
// Address: 0x1b52e0 - 0x1b52f0

void entry_1b52e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b52e0: 0x26040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1b52e4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1b52e8: 0xc06d1d4
    SET_GPR_U32(ctx, 31, 0x1b52f0);
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    SetSaiDuDv__FP3SAIff(rdram, ctx, runtime); return;
}


// Function: entry_1b52f0
// Address: 0x1b52f0 - 0x1b5308

void entry_1b52f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b52f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b52f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b52f8: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x1b52fc: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1b5300: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UCompleteScroller__FP8SCROLLER
// Address: 0x1b5308 - 0x1b5388

void entry_1b53b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b53b4: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b53b8: 0x2403fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x1b53bc: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1b53c0: 0xe600002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    // 0x1b53c4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b53c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b53cc: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b53d0: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x1b53d4: 0xe6010030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x1b53d8: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1b53dc: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1b53e0: 0xc6210010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1b53e4: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x1b53e8: 0xe6010038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x1b53ec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b53f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b53f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b53fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5400; return;
}


// Function: UpdateCircler__FP7CIRCLERf
// Address: 0x1b5400 - 0x1b542c

void entry_1b542c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b542c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1b5430: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b5434: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x1b543c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1b543c
// Address: 0x1b543c - 0x1b5478

void entry_1b543c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b543c: 0xc6030030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[3] = *(float*)&val; }
    // 0x1b5440: 0x26040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1b5444: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1b5448: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b544c: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1b5450: 0xc6040034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[4] = *(float*)&val; }
    // 0x1b5454: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1b5458: 0xc6020038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[2] = *(float*)&val; }
    // 0x1b545c: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x1b5460: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1b5464: 0x46000b06
    ctx->f[12] = FPU_MOV_S(ctx->f[1]);
    // 0x1b5468: 0xe7a10000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1b546c: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x1b5470: 0xc06d1d4
    SET_GPR_U32(ctx, 31, 0x1b5478);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    SetSaiDuDv__FP3SAIff(rdram, ctx, runtime); return;
}


// Function: entry_1b5478
// Address: 0x1b5478 - 0x1b5488

void entry_1b5478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5478: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b547c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5480: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UCompleteCircler__FP7CIRCLER
// Address: 0x1b5488 - 0x1b54b0

void entry_1b54b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b54b0: 0x3c013e22
    SET_GPR_U32(ctx, 1, ((uint32_t)15906 << 16));
    // 0x1b54b4: 0x3421f983
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 63875));
    // 0x1b54b8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b54bc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b54c0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1b54c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b54cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b54d0; return;
}


// Function: InitLooker__FP6LOOKERP4SAAF
// Address: 0x1b54d0 - 0x1b54ec

void entry_1b54ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b54ec: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b54f0: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x1b54f4: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1b54f8: 0xe620002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 44), *(uint32_t*)&val); }
    // 0x1b54fc: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b5500: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b5504: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b5508: 0x34630002
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 2));
    // 0x1b550c: 0xe6210030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    // 0x1b5510: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1b5514: 0xc600000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1b5518: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b551c: 0xe6200034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 52), *(uint32_t*)&val); }
    // 0x1b5520: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1b5524: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1b5528: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1b552c: 0xe6210038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 56), *(uint32_t*)&val); }
    // 0x1b5530: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b5534: 0xc6000014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[0] = *(float*)&val; }
    // 0x1b5538: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b553c: 0xe620003c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 60), *(uint32_t*)&val); }
    // 0x1b5540: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b5544: 0xc6000018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1b5548: 0xae230010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 3));
    // 0x1b554c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b5550: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b5554: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x1b5558: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b555c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b5564: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5568; return;
}


// Function: SetLookerSgvr__FP6LOOKERP4SGVRP7GLOBSETP4GLOBP7SUBGLOB
// Address: 0x1b5568 - 0x1b5588

void entry_1b5638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5638: 0x8e020224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x1b563c: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b5640: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b5644: 0x8c460060
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 96)));
    // 0x1b5648: 0x8cc40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x1b564c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1b5654);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1b5654
// Address: 0x1b5654 - 0x1b5660

void entry_1b5654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5654: 0x8e25004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x1b5658: 0xc06d562
    SET_GPR_U32(ctx, 31, 0x1b5660);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    SetVecPosad__FP6VECTORP5POSAD(rdram, ctx, runtime); return;
}


// Function: entry_1b5660
// Address: 0x1b5660 - 0x1b5674

void entry_1b5660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5660: 0x8e25004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x1b5664: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1b5668: 0x80f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1b566c: 0xc06d562
    SET_GPR_U32(ctx, 31, 0x1b5674);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    SetVecPosad__FP6VECTORP5POSAD(rdram, ctx, runtime); return;
}


// Function: entry_1b5674
// Address: 0x1b5674 - 0x1b5680

void entry_1b5674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5674: 0x8e250048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 72)));
    // 0x1b5678: 0xc06d56a
    SET_GPR_U32(ctx, 31, 0x1b5680);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 88));
    SetUvPuvqd__FP3UVFP3UVQ(rdram, ctx, runtime); return;
}


// Function: entry_1b5680
// Address: 0x1b5680 - 0x1b5694

void entry_1b5680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5680: 0x8e250048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 72)));
    // 0x1b5684: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1b5688: 0x80b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1b568c: 0xc06d56a
    SET_GPR_U32(ctx, 31, 0x1b5694);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 12));
    SetUvPuvqd__FP3UVFP3UVQ(rdram, ctx, runtime); return;
}


// Function: entry_1b5694
// Address: 0x1b5694 - 0x1b56e4

void entry_1b5694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5694) {
        switch (ctx->pc) {
            case 0x1b56a8: ctx->pc = 0; goto label_1b56a8;
            case 0x1b56c0: ctx->pc = 0; goto label_1b56c0;
            case 0x1b56d0: ctx->pc = 0; goto label_1b56d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5694: 0x8e220044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 68)));
    // 0x1b5698: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1b569c: 0x104000df
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 160));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B5A1C; return;
    }
    // 0x1b56a4: 0x32620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 1));
label_1b56a8:
    // 0x1b56a8: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b56c0;
    }
    // 0x1b56b0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b56b4: 0x24524568
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 17768));
    // 0x1b56b8: 0x10000005
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 3), 17784));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b56d0;
    }
label_1b56c0:
    // 0x1b56c0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b56c4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b56c8: 0x24524548
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 17736));
    // 0x1b56cc: 0x24744558
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 3), 17752));
label_1b56d0:
    // 0x1b56d0: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1b56d4: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1b56d8: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1b56dc: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x1b56e4);
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 19), 4));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_1b56e4
// Address: 0x1b56e4 - 0x1b56f4

void entry_1b56e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b56e4: 0x27a50058
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 88));
    // 0x1b56e8: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1b56ec: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x1b56f4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_1b56f4
// Address: 0x1b56f4 - 0x1b5704

void entry_1b56f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b56f4: 0x8e25004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x1b56f8: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1b56fc: 0xc06d562
    SET_GPR_U32(ctx, 31, 0x1b5704);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    SetVecPosad__FP6VECTORP5POSAD(rdram, ctx, runtime); return;
}


// Function: entry_1b5704
// Address: 0x1b5704 - 0x1b571c

void entry_1b5704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5704: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1b5708: 0x8e220048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 72)));
    // 0x1b570c: 0x2652818
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1b5710: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1b5714: 0xc06d56a
    SET_GPR_U32(ctx, 31, 0x1b571c);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    SetUvPuvqd__FP3UVFP3UVQ(rdram, ctx, runtime); return;
}


// Function: entry_1b571c
// Address: 0x1b571c - 0x1b5ae8

void entry_1b571c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b571c) {
        switch (ctx->pc) {
            case 0x1b5740: ctx->pc = 0; goto label_1b5740;
            case 0x1b5754: ctx->pc = 0; goto label_1b5754;
            case 0x1b5874: ctx->pc = 0; goto label_1b5874;
            case 0x1b5898: ctx->pc = 0; goto label_1b5898;
            case 0x1b5900: ctx->pc = 0; goto label_1b5900;
            case 0x1b5a00: ctx->pc = 0; goto label_1b5a00;
            case 0x1b5a0c: ctx->pc = 0; goto label_1b5a0c;
            case 0x1b5a1c: ctx->pc = 0; goto label_1b5a1c;
            case 0x1b5a74: ctx->pc = 0; goto label_1b5a74;
            case 0x1b5a7c: ctx->pc = 0; goto label_1b5a7c;
            case 0x1b5a90: ctx->pc = 0; goto label_1b5a90;
            case 0x1b5a94: ctx->pc = 0; goto label_1b5a94;
            case 0x1b5ab4: ctx->pc = 0; goto label_1b5ab4;
            case 0x1b5ac8: ctx->pc = 0; goto label_1b5ac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b571c: 0x8e22004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x1b5720: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1b5724: 0x8c43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1b5728: 0x30638000
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 32768));
    // 0x1b572c: 0x546000b7
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 68)));
        goto label_1b5a0c;
    }
    // 0x1b5734: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b5738: 0x24080003
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b573c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1b5740:
    // 0x1b5740: 0x24e50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1b5744: 0x71880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1b5748: 0xa8001a
    { int32_t divisor = GPR_S32(ctx, 8); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 5) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 8) % divisor); } else { ctx->lo = (GPR_S32(ctx,5) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,8); } }
    // 0x1b574c: 0x51090001
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 9)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1b5754;
    }
label_1b5754:
    // 0x1b5754: 0x721821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x1b5758: 0x73100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 7), 4));
    // 0x1b575c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b5760: 0xdd3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 29)));
    // 0x1b5764: 0xa0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1b5768: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1b576c: 0x28e30003
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 7), 3));
    // 0x1b5770: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1b5774: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b5778: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x1b577c: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1b5780: 0x922021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1b5784: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b5788: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1b578c: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1b5790: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b5794: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b5798: 0x1460ffe9
    WRITE128(ADD32(GPR_U32(ctx, 6), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1b5740;
    }
    // 0x1b57a0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1b57a4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b57a8: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b57ac: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b57b0: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b57b4: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b57b8: 0x4be51098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b57bc: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b57c0: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1b57c4: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b57c8: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b57cc: 0xdba80010
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b57d0: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b57d4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b57d8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b57dc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b57e0: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1b57e4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b57e8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b57ec: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1b57f0: 0xdba70000
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b57f4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1b57f8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b57fc: 0x4be0099c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1b5800: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1b5804: 0x4bc4312a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1b5808: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b580c: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1b5810: 0x4b04090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b5814: 0x4bc830ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1b5818: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b581c: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b5820: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b5824: 0x48232000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b5828: 0x4bc7306a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1b582c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b5830: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b5834: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b5838: 0x48241800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b583c: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1b5840: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b5844: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b5848: 0x46010081
    ctx->f[2] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b584c: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1b5850: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1b5854: 0x46021836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5858: 0x0
    // NOP
    // 0x1b585c: 0x45000005
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b5874;
    }
    // 0x1b5864: 0x46001836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5868: 0x0
    // NOP
    // 0x1b586c: 0x45030067
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 68)));
        goto label_1b5a0c;
    }
label_1b5874:
    // 0x1b5874: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5878: 0x0
    // NOP
    // 0x1b587c: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
        goto label_1b5898;
    }
    // 0x1b5884: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5888: 0x0
    // NOP
    // 0x1b588c: 0x4503005f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 68)));
        goto label_1b5a0c;
    }
    // 0x1b5894: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
label_1b5898:
    // 0x1b5898: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b589c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b58a0: 0x46001946
    ctx->f[5] = FPU_MOV_S(ctx->f[3]);
    // 0x1b58a4: 0x4be5333c
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1b58a8: 0x460029c6
    ctx->f[7] = FPU_MOV_S(ctx->f[5]);
    // 0x1b58ac: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b58b0: 0x46001003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[0] = ctx->f[2] / ctx->f[0];
    // 0x1b58b4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b58b8: 0x46002986
    ctx->f[6] = FPU_MOV_S(ctx->f[5]);
    // 0x1b58bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b58c0: 0x27aa0050
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1b58c4: 0x27a90054
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 84));
    // 0x1b58c8: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1b58cc: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1b58d0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b58d4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b58d8: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1b58dc: 0x4be33918
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1b58e0: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1b58e4: 0x4be14098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1b58e8: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b58ec: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b58f0: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b58f4: 0xfba200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b58f8: 0x4be4133c
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1b58fc: 0x0
    // NOP
label_1b5900:
    // 0x1b5900: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1b5904: 0x4bc50afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x1b5908: 0x4bc1286e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b590c: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b5910: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b5914: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b5918: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b591c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b5920: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b5924: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b5928: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1b592c: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1b5930: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b5934: 0x4be008dc
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1b5938: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b593c: 0x4bc4186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b5940: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b5944: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b5948: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b594c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b5950: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b5954: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1b5958: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1b595c: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1b5960: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b5964: 0x4bc1186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b5968: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b596c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b5970: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b5974: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b5978: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x1b597c: 0x46030101
    ctx->f[4] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1b5980: 0x46043834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[7], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5984: 0x0
    // NOP
    // 0x1b5988: 0x4501001d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), 3));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b5a00;
    }
    // 0x1b5990: 0x8d030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1b5994: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1b5998: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x1b599c: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x1b59a0: 0x31100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1b59a4: 0x24a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    // 0x1b59a8: 0x318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 3));
    // 0x1b59ac: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1b59b0: 0x1232021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 3)));
    // 0x1b59b4: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b59b8: 0x1431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 3)));
    // 0x1b59bc: 0x4bc1186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b59c0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b59c4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b59c8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b59cc: 0xc4620000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1b59d0: 0x28e20003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), 3));
    // 0x1b59d4: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b59d8: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1b59dc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1b59e0: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1b59e4: 0x46002003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[4] * 0.0f); } else ctx->f[0] = ctx->f[4] / ctx->f[0];
    // 0x1b59e8: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1b59ec: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1b59f0: 0x46012940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    // 0x1b59f4: 0x1440ffc2
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b5900;
    }
    // 0x1b59fc: 0x28e20003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), 3));
label_1b5a00:
    // 0x1b5a00: 0x5040001c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_MOV_S(ctx->f[6]);
        goto label_1b5a74;
    }
    // 0x1b5a08: 0x8e220044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 68)));
label_1b5a0c:
    // 0x1b5a0c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1b5a10: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1b5a14: 0x1440ff24
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B56A8; return;
    }
label_1b5a1c:
    // 0x1b5a1c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b5a20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b5a24: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b5a28: 0xc621002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1b5a2c: 0x461400c1
    ctx->f[3] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1b5a30: 0xc62d0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 52)); ctx->f[13] = *(float*)&val; }
    // 0x1b5a34: 0x46150001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x1b5a38: 0xc6220038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 56)); ctx->f[2] = *(float*)&val; }
    // 0x1b5a3c: 0x2443d268
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294955624));
    // 0x1b5a40: 0x68640007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1b5a44: 0x6c640000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1b5a48: 0x8c650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1b5a4c: 0xb3a400a7
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 167); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b5a50: 0xb7a400a0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 160); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b5a54: 0xafa500a8
    WRITE32(ADD32(GPR_U32(ctx, 29), 168), GPR_U32(ctx, 5));
    // 0x1b5a58: 0x46010301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b5a5c: 0x460d6034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5a60: 0x0
    // NOP
    // 0x1b5a64: 0x45000005
    ctx->f[21] = FPU_MOV_S(ctx->f[13]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b5a7c;
    }
    // 0x1b5a6c: 0x10000009
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 48)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5a94;
    }
label_1b5a74:
    // 0x1b5a74: 0x1000ffe9
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5a1c;
    }
label_1b5a7c:
    // 0x1b5a7c: 0x460c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5a80: 0x0
    // NOP
    // 0x1b5a84: 0x45000002
    ctx->f[21] = FPU_MOV_S(ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b5a90;
    }
    // 0x1b5a8c: 0x46001546
    ctx->f[21] = FPU_MOV_S(ctx->f[2]);
label_1b5a90:
    // 0x1b5a90: 0xc6200030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 48)); ctx->f[0] = *(float*)&val; }
label_1b5a94:
    // 0x1b5a94: 0xc621003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 60)); ctx->f[1] = *(float*)&val; }
    // 0x1b5a98: 0x46001b41
    ctx->f[13] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x1b5a9c: 0x46016834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5aa0: 0x0
    // NOP
    // 0x1b5aa4: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b5ab4;
    }
    // 0x1b5aac: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5ac8;
    }
label_1b5ab4:
    // 0x1b5ab4: 0x460d0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b5ab8: 0x0
    // NOP
    // 0x1b5abc: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[13]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b5ac8;
    }
    // 0x1b5ac4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
label_1b5ac8:
    // 0x1b5ac8: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1b5acc: 0xc62c001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[12] = *(float*)&val; }
    // 0x1b5ad0: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1b5ad4: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1b5ad8: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1b5adc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b5ae0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1b5ae8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1b5ae8
// Address: 0x1b5ae8 - 0x1b5b00

void entry_1b5ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5ae8: 0xc62c0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[12] = *(float*)&val; }
    // 0x1b5aec: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b5af0: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1b5af4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1b5af8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1b5b00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1b5b00
// Address: 0x1b5b00 - 0x1b5b10

void entry_1b5b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5b00: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1b5b04: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1b5b08: 0xc06d1d4
    SET_GPR_U32(ctx, 31, 0x1b5b10);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    SetSaiDuDv__FP3SAIff(rdram, ctx, runtime); return;
}


// Function: entry_1b5b10
// Address: 0x1b5b10 - 0x1b5b48

void entry_1b5b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5b10) {
        switch (ctx->pc) {
            case 0x1b5b14: ctx->pc = 0; goto label_1b5b14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5b10: 0x7bbf0160
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 352)));
label_1b5b14:
    // 0x1b5b14: 0x7bbe0150
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1b5b18: 0x7bb70140
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1b5b1c: 0x7bb60130
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1b5b20: 0x7bb50120
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1b5b24: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1b5b28: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1b5b2c: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1b5b30: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b5b34: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b5b38: 0xc7b50178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[21] = *(float*)&val; }
    // 0x1b5b3c: 0xc7b40170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[20] = *(float*)&val; }
    // 0x1b5b40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001B5B48
// Address: 0x1b5b48 - 0x1b5b58

void FUN_001b5b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5b58) {
        switch (ctx->pc) {
            case 0x1b5b74: ctx->pc = 0; goto label_1b5b74;
            case 0x1b5b8c: ctx->pc = 0; goto label_1b5b8c;
            case 0x1b5ba0: ctx->pc = 0; goto label_1b5ba0;
            case 0x1b5bb4: ctx->pc = 0; goto label_1b5bb4;
            case 0x1b5bc8: ctx->pc = 0; goto label_1b5bc8;
            case 0x1b5bdc: ctx->pc = 0; goto label_1b5bdc;
            case 0x1b5bf0: ctx->pc = 0; goto label_1b5bf0;
            case 0x1b5c18: ctx->pc = 0; goto label_1b5c18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5b58: 0x308600ff
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 4), 255));
    // 0x1b5b5c: 0x24c2ffe0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967264));
    // 0x1b5b60: 0x2c420010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 16));
    // 0x1b5b64: 0x10400003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b5b74;
    }
    // 0x1b5b6c: 0x10000020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5bf0;
    }
label_1b5b74:
    // 0x1b5b74: 0x24c2ffd0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967248));
    // 0x1b5b78: 0x2c42000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 10));
    // 0x1b5b7c: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967238));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b5b8c;
    }
    // 0x1b5b84: 0x1000001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5bf0;
    }
label_1b5b8c:
    // 0x1b5b8c: 0x2c420007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 7));
    // 0x1b5b90: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967231));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b5ba0;
    }
    // 0x1b5b98: 0x10000015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5bf0;
    }
label_1b5ba0:
    // 0x1b5ba0: 0x2c42001a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 26));
    // 0x1b5ba4: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967205));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b5bb4;
    }
    // 0x1b5bac: 0x10000010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5bf0;
    }
label_1b5bb4:
    // 0x1b5bb4: 0x2c420006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 6));
    // 0x1b5bb8: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967199));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b5bc8;
    }
    // 0x1b5bc0: 0x1000000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 37));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5bf0;
    }
label_1b5bc8:
    // 0x1b5bc8: 0x2c42001a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 26));
    // 0x1b5bcc: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967173));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b5bdc;
    }
    // 0x1b5bd4: 0x10000006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b5bf0;
    }
label_1b5bdc:
    // 0x1b5bdc: 0x2c420004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 4));
    // 0x1b5be0: 0x14400003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 63));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b5bf0;
    }
    // 0x1b5be8: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1b5bf0:
    // 0x1b5bf0: 0x50600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
        goto label_1b5c18;
    }
    // 0x1b5bf8: 0x2462001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 31));
    // 0x1b5bfc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b5c00: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1b5c04: 0x24634588
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 17800));
    // 0x1b5c08: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b5c0c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b5c10: 0x3e00008
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1b5c18:
    // 0x1b5c18: 0x52080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1b5c1c: 0x24634610
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 17936));
    // 0x1b5c20: 0x832821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1b5c24: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1b5c28: 0x94a20000
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1b5c2c: 0x94640002
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x1b5c30: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1b5c34: 0x441023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1b5c38: 0x3e00008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 65535));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001b5c40
// Address: 0x1b5c40 - 0x1b5c6c

void FUN_001b5c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5c40: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x1b5c44: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1b5c48: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x1b5c4c: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1b5c50: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1b5c54: 0xa0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1b5c58: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1b5c5c: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x1b5c60: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b5c64: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1b5c6c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1b5c6c
// Address: 0x1b5c6c - 0x1b5c88

void entry_1b5c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5c6c) {
        switch (ctx->pc) {
            case 0x1b5c78: ctx->pc = 0; goto label_1b5c78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5c6c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b5c70: 0x1a40000e
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x1B5CAC; return;
    }
label_1b5c78:
    // 0x1b5c78: 0x2701021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x1b5c7c: 0x90440000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b5c80: 0xc06d6d6
    SET_GPR_U32(ctx, 31, 0x1b5c88);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    FUN_001b5b58(rdram, ctx, runtime); return;
}


// Function: entry_1b5c88
// Address: 0x1b5c88 - 0x1b5cd8

void entry_1b5c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5c88) {
        switch (ctx->pc) {
            case 0x1b5cac: ctx->pc = 0; goto label_1b5cac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5c88: 0x21a02
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 2), 8));
    // 0x1b5c8c: 0x212202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 18)));
    // 0x1b5c90: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1b5c94: 0x306300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 255));
    // 0x1b5c98: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1b5c9c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b5ca0: 0xa6230000
    WRITE16(ADD32(GPR_U32(ctx, 17), 0), (uint16_t)GPR_U32(ctx, 3));
    // 0x1b5ca4: 0x1480fff4
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B5C78; return;
    }
label_1b5cac:
    // 0x1b5cac: 0x101040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 1));
    // 0x1b5cb0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b5cb4: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1b5cb8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b5cbc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b5cc0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b5cc4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5cc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b5ccc: 0xa4400000
    WRITE16(ADD32(GPR_U32(ctx, 2), 0), (uint16_t)GPR_U32(ctx, 0));
    // 0x1b5cd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSkyLoad__FP3SKY
// Address: 0x1b5cd8 - 0x1b5cec

void entry_1b5cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5cec: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1b5cf0: 0x2403fcff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x1b5cf4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1b5cf8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1b5cfc: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1b5d00: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1b5d04: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1b5d08: 0x42678
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 25);
    // 0x1b5d0c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5d10: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b5d14: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1b5d18: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x1b5d1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b5d20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSky__FP3SKYf
// Address: 0x1b5d28 - 0x1b5d3c

void entry_1b5d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5d3c) {
        switch (ctx->pc) {
            case 0x1b5d5c: ctx->pc = 0; goto label_1b5d5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5d3c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1b5d40: 0x8e0502d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x1b5d44: 0x8c831990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6544)));
    // 0x1b5d48: 0x78620040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1b5d4c: 0x14a00003
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1b5d5c;
    }
    // 0x1b5d54: 0xc6000148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[0] = *(float*)&val; }
    // 0x1b5d58: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
label_1b5d5c:
    // 0x1b5d5c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b5d60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b5d64: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1b5d68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b5d70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b5d70
// Address: 0x1b5d70 - 0x1b5d80

void entry_1b5d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5d70: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b5d74: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5d78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn__InitSlotheap__FP8SLOTHEAPii
// Address: 0x1b5d80 - 0x1b5dd0

void entry_1b5e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5e00: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x1b5e04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b5e08: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b5e0c: 0xc06d760
    SET_GPR_U32(ctx, 31, 0x1b5e14);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__InitSlotheap__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1b5e14
// Address: 0x1b5e14 - 0x1b5e30

void entry_1b5e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5e14: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b5e18: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b5e1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5e20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b5e24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b5e2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5e30; return;
}


// Function: CreateSlotheapSwAlign64__FP8SLOTHEAPii
// Address: 0x1b5e30 - 0x1b5e5c

void entry_1b5e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5e5c: 0x2403ffc0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967232));
    // 0x1b5e60: 0x2442003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 63));
    // 0x1b5e64: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b5e68: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b5e6c: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1b5e70: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b5e74: 0xc06d760
    SET_GPR_U32(ctx, 31, 0x1b5e7c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__InitSlotheap__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1b5e7c
// Address: 0x1b5e7c - 0x1b5e98

void entry_1b5e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5e7c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b5e80: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b5e84: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5e88: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b5e8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b5e94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5e98; return;
}


// Function: junk_001B5E98
// Address: 0x1b5e98 - 0x1b5ea0

void entry_1b5ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5ed0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b5ed4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b5edc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5ee0; return;
}


// Function: PvAllocSlotheapClearImpl__FP8SLOTHEAP
// Address: 0x1b5ee0 - 0x1b5ef8

void entry_1b5ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5ef8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b5efc: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b5f00: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b5f04: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b5f0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b5f0c
// Address: 0x1b5f0c - 0x1b5f28

void entry_1b5f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5f0c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b5f10: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b5f14: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b5f18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b5f1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b5f24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b5f28; return;
}


// Function: FreeSlotheapPv__FP8SLOTHEAPPv
// Address: 0x1b5f28 - 0x1b5f48

void entry_1b5f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5f8c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1b5f94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b5f94
// Address: 0x1b5f94 - 0x1b5fa0

void entry_1b5f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5f94: 0x220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1b5f98: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1b5fa0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 52), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b5fa0
// Address: 0x1b5fa0 - 0x1b5fc4

void entry_1b5fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5fa0) {
        switch (ctx->pc) {
            case 0x1b5fb0: ctx->pc = 0; goto label_1b5fb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5fa0: 0x8e430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1b5fa4: 0x1860000f
    WRITE32(ADD32(GPR_U32(ctx, 18), 56), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1B5FE4; return;
    }
    // 0x1b5fac: 0x8e500038
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 56)));
label_1b5fb0:
    // 0x1b5fb0: 0x1110c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 3));
    // 0x1b5fb4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b5fb8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b5fbc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b5fc4);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b5fc4
// Address: 0x1b5fc4 - 0x1b5fd0

void entry_1b5fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b5fc4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1b5fc8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b5fd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b5fd0
// Address: 0x1b5fd0 - 0x1b6014

void entry_1b5fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b5fd0) {
        switch (ctx->pc) {
            case 0x1b5fe4: ctx->pc = 0; goto label_1b5fe4;
            case 0x1b5ff8: ctx->pc = 0; goto label_1b5ff8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b5fd0: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1b5fd4: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1b5fd8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b5fdc: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 56)));
        ctx->pc = 0x1B5FB0; return;
    }
label_1b5fe4:
    // 0x1b5fe4: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1b5fe8: 0x18400010
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B602C; return;
    }
    // 0x1b5ff0: 0x2414ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b5ff4: 0x8e430038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 56)));
label_1b5ff8:
    // 0x1b5ff8: 0x1110c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 3));
    // 0x1b5ffc: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b6000: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1b6004: 0x50b40005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
        ctx->pc = 0x1B601C; return;
    }
    // 0x1b600c: 0xc06d8fe
    SET_GPR_U32(ctx, 31, 0x1b6014);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    IsmsFindSmRequired__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_1b6014
// Address: 0x1b6014 - 0x1b6038

void entry_1b6014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6014) {
        switch (ctx->pc) {
            case 0x1b601c: ctx->pc = 0; goto label_1b601c;
            case 0x1b602c: ctx->pc = 0; goto label_1b602c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6014: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1b6018: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
label_1b601c:
    // 0x1b601c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1b6020: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b6024: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 56)));
        ctx->pc = 0x1B5FF8; return;
    }
label_1b602c:
    // 0x1b602c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6030: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1b6038);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b6038
// Address: 0x1b6038 - 0x1b6048

void entry_1b6038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6038: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1b603c: 0xae42003c
    WRITE32(ADD32(GPR_U32(ctx, 18), 60), GPR_U32(ctx, 2));
    // 0x1b6040: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1b6048);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b6048
// Address: 0x1b6048 - 0x1b6070

void entry_1b6048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6048) {
        switch (ctx->pc) {
            case 0x1b6060: ctx->pc = 0; goto label_1b6060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6048: 0x8e43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x1b604c: 0x18600020
    WRITE32(ADD32(GPR_U32(ctx, 18), 64), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1B60D0; return;
    }
    // 0x1b6054: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b6058: 0x8e500040
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x1b605c: 0x0
    // NOP
label_1b6060:
    // 0x1b6060: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6064: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1b6068: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x1b6070);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b6070
// Address: 0x1b6070 - 0x1b6080

void entry_1b6070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6070: 0x26310014
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 20));
    // 0x1b6074: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6078: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b6080);
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b6080
// Address: 0x1b6080 - 0x1b608c

void entry_1b6080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6080: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6084: 0xc06d8fe
    SET_GPR_U32(ctx, 31, 0x1b608c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    IsmsFindSmRequired__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_1b608c
// Address: 0x1b608c - 0x1b6098

void entry_1b608c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b608c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6090: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b6098);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b6098
// Address: 0x1b6098 - 0x1b60a4

void entry_1b6098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6098: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b609c: 0xc06d8fe
    SET_GPR_U32(ctx, 31, 0x1b60a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    IsmsFindSmRequired__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_1b60a4
// Address: 0x1b60a4 - 0x1b60b0

void entry_1b60a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b60a4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b60a8: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x1b60b0);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b60b0
// Address: 0x1b60b0 - 0x1b60bc

void entry_1b60b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b60b0: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x1b60b4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x1b60bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b60bc
// Address: 0x1b60bc - 0x1b60dc

void entry_1b60bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b60bc) {
        switch (ctx->pc) {
            case 0x1b60d0: ctx->pc = 0; goto label_1b60d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b60bc: 0xe6000010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x1b60c0: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x1b60c4: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x1b60c8: 0x5440ffe5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 64)));
        ctx->pc = 0x1B6060; return;
    }
label_1b60d0:
    // 0x1b60d0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b60d4: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1b60dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b60dc
// Address: 0x1b60dc - 0x1b60e8

void entry_1b60dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b60dc: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b60e0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b60e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b60e8
// Address: 0x1b60e8 - 0x1b6114

void entry_1b60e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b60e8) {
        switch (ctx->pc) {
            case 0x1b60f8: ctx->pc = 0; goto label_1b60f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b60e8: 0x8e43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x1b60ec: 0x18600023
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1B617C; return;
    }
    // 0x1b60f4: 0x0
    // NOP
label_1b60f8:
    // 0x1b60f8: 0x8e420040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x1b60fc: 0x56a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1b6100: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1b6104: 0x50600019
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        ctx->pc = 0x1B616C; return;
    }
    // 0x1b610c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b6114);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b6114
// Address: 0x1b6114 - 0x1b6120

void entry_1b6114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6114: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6118: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b6120);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b6120
// Address: 0x1b6120 - 0x1b612c

void entry_1b6120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6120: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6124: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1b612c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1b612c
// Address: 0x1b612c - 0x1b6144

void entry_1b612c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b612c: 0x8e460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1b6130: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b6134: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b6138: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b613c: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1b6144);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1b6144
// Address: 0x1b6144 - 0x1b6160

void entry_1b6144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6144: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6148: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b614c: 0xae900000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 16));
    // 0x1b6150: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b6154: 0x8c430038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x1b6158: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1b6160);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1b6160
// Address: 0x1b6160 - 0x1b6168

void entry_1b6160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6160: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x1b6168);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1b6168
// Address: 0x1b6168 - 0x1b61a8

void entry_1b6168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6168) {
        switch (ctx->pc) {
            case 0x1b616c: ctx->pc = 0; goto label_1b616c;
            case 0x1b617c: ctx->pc = 0; goto label_1b617c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6168: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
label_1b616c:
    // 0x1b616c: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1b6170: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x1b6174: 0x1440ffe0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B60F8; return;
    }
label_1b617c:
    // 0x1b617c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b6180: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b6184: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b6188: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b618c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b6190: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b6194: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6198: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b619c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b61a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b61a8; return;
}


// Function: PostSmLoad__FP2SM
// Address: 0x1b61a8 - 0x1b61bc

void entry_1b61bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b61bc: 0x8e020044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x1b61c0: 0x10400007
    SET_GPR_U32(ctx, 5, ((uint32_t)27 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b61e0(rdram, ctx, runtime); return;
    }
    // 0x1b61c8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b61cc: 0x24a561f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 25072));
    // 0x1b61d0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b61d4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b61d8: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1b61e0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1b61e0
// Address: 0x1b61e0 - 0x1b61f0

void entry_1b61e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b61e0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b61e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b61e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSmLoadCallback__FP2SM5MSGIDPv
// Address: 0x1b61f0 - 0x1b625c

void entry_1b625c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b625c) {
        switch (ctx->pc) {
            case 0x1b6264: ctx->pc = 0; goto label_1b6264;
            case 0x1b6268: ctx->pc = 0; goto label_1b6268;
            case 0x1b626c: ctx->pc = 0; goto label_1b626c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b625c: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b626c;
    }
label_1b6264:
    // 0x1b6264: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1b6268:
    // 0x1b6268: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1b626c:
    // 0x1b626c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6270: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6274: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1b627c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1b627c
// Address: 0x1b627c - 0x1b6290

void entry_1b627c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b627c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6280: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6284: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b628c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6290; return;
}


// Function: PsmaApplySm__FP2SMP3ALO3OIDi
// Address: 0x1b6290 - 0x1b62cc

void entry_1b62cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b62cc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b62d0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b62d4: 0x3c040022
    SET_GPR_U32(ctx, 4, ((uint32_t)34 << 16));
    // 0x1b62d8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b62dc: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1b62e0: 0x248498e8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294940904));
    // 0x1b62e4: 0xac71001c
    WRITE32(ADD32(GPR_U32(ctx, 3), 28), GPR_U32(ctx, 17));
    // 0x1b62e8: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x1b62ec: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b62f0: 0xac700020
    WRITE32(ADD32(GPR_U32(ctx, 3), 32), GPR_U32(ctx, 16));
    // 0x1b62f4: 0xe4600038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 56), *(uint32_t*)&val); }
    // 0x1b62f8: 0xac730018
    WRITE32(ADD32(GPR_U32(ctx, 3), 24), GPR_U32(ctx, 19));
    // 0x1b62fc: 0xac72002c
    WRITE32(ADD32(GPR_U32(ctx, 3), 44), GPR_U32(ctx, 18));
    // 0x1b6300: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x1b6304: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1b630c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7060));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1b630c
// Address: 0x1b630c - 0x1b6318

void entry_1b630c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b630c: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6310: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1b6318);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 72));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1b6318
// Address: 0x1b6318 - 0x1b6328

void entry_1b6318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6318: 0x1292000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 18)) {
        entry_1b6344(rdram, ctx, runtime); return;
    }
    // 0x1b6320: 0xc06d8fe
    SET_GPR_U32(ctx, 31, 0x1b6328);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    IsmsFindSmRequired__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_1b6328
// Address: 0x1b6328 - 0x1b6344

void entry_1b6328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6328: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b632c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6330: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6334: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b6338: 0xac620028
    WRITE32(ADD32(GPR_U32(ctx, 3), 40), GPR_U32(ctx, 2));
    // 0x1b633c: 0xc06db8a
    SET_GPR_U32(ctx, 31, 0x1b6344);
    WRITE32(ADD32(GPR_U32(ctx, 3), 48), GPR_U32(ctx, 2));
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime); return;
}


// Function: entry_1b6344
// Address: 0x1b6344 - 0x1b634c

void entry_1b6344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6344: 0xc06d9a8
    SET_GPR_U32(ctx, 31, 0x1b634c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    ChooseSmaTransition__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1b634c
// Address: 0x1b634c - 0x1b6364

void entry_1b634c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b634c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6350: 0xafbd0004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 29));
    // 0x1b6354: 0x24050011
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 17));
    // 0x1b6358: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b635c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1b6364);
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 29), 4));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1b6364
// Address: 0x1b6364 - 0x1b6388

void entry_1b6364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6364: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6368: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b636c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b6370: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b6374: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b6378: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b637c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6380: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsmaFindSm__FP2SMP3ALO
// Address: 0x1b6388 - 0x1b63c0

void entry_1b6408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6408: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b640c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6410: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1b6414: 0x3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x1b6418: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OidFromSmIsms__FP2SMi
// Address: 0x1b6420 - 0x1b6438

void entry_1b6460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6460) {
        switch (ctx->pc) {
            case 0x1b6464: ctx->pc = 0; goto label_1b6464;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6460: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
label_1b6464:
    // 0x1b6464: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1b6468: 0x8e05003c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1b646c: 0xc076f06
    SET_GPR_U32(ctx, 31, 0x1b6474);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    FreeSwMqList__FP2SWP2MQ(rdram, ctx, runtime); return;
}


// Function: entry_1b6474
// Address: 0x1b6474 - 0x1b6488

void entry_1b6474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6474: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1b6478: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b647c: 0xae00003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 0));
    // 0x1b6480: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1b6488);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 72));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1b6488
// Address: 0x1b6488 - 0x1b649c

void entry_1b6488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6488: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1b648c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b6490: 0x8c440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1b6494: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1b649c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7060));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1b649c
// Address: 0x1b649c - 0x1b64b0

void entry_1b649c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b649c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1b64a0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b64a4: 0x8c440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1b64a8: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x1b64b0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7048));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_1b64b0
// Address: 0x1b64b0 - 0x1b64c4

void entry_1b64b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b64b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b64b4: 0x24050012
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    // 0x1b64b8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b64bc: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1b64c4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1b64c4
// Address: 0x1b64c4 - 0x1b64d8

void entry_1b64c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b64c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b64c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b64cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b64d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSmaGoal__FP3SMA3OID
// Address: 0x1b64d8 - 0x1b64f8

void entry_1b64f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b64f8) {
        switch (ctx->pc) {
            case 0x1b6500: ctx->pc = 0; goto label_1b6500;
            case 0x1b6504: ctx->pc = 0; goto label_1b6504;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b64f8: 0x10000002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b6504;
    }
label_1b6500:
    // 0x1b6500: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1b6504:
    // 0x1b6504: 0x8e020030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1b6508: 0x10620013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B6558; return;
    }
    // 0x1b6510: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1b6514: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6540; return;
    }
    // 0x1b651c: 0x8c42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1b6520: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b6524: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
        ctx->pc = 0x1B6544; return;
    }
    // 0x1b652c: 0xc06db1a
    SET_GPR_U32(ctx, 31, 0x1b6534);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndSmaTransition__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1b6534
// Address: 0x1b6534 - 0x1b653c

void entry_1b6534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6534: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1b653c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1b653c
// Address: 0x1b653c - 0x1b6554

void entry_1b653c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b653c) {
        switch (ctx->pc) {
            case 0x1b6540: ctx->pc = 0; goto label_1b6540;
            case 0x1b6544: ctx->pc = 0; goto label_1b6544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b653c: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
label_1b6540:
    // 0x1b6540: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
label_1b6544:
    // 0x1b6544: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6558; return;
    }
    // 0x1b654c: 0xc06d9a8
    SET_GPR_U32(ctx, 31, 0x1b6554);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChooseSmaTransition__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1b6554
// Address: 0x1b6554 - 0x1b6568

void entry_1b6554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6554) {
        switch (ctx->pc) {
            case 0x1b6558: ctx->pc = 0; goto label_1b6558;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6554: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b6558:
    // 0x1b6558: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b655c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6564: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6568; return;
}


// Function: GetSmaGoal__FP3SMAP3OID
// Address: 0x1b6568 - 0x1b6598

void entry_1b6618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6618) {
        switch (ctx->pc) {
            case 0x1b661c: ctx->pc = 0; goto label_1b661c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6618: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b661c:
    // 0x1b661c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6624: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6628; return;
}


// Function: SeekSma__FP3SMA3OID
// Address: 0x1b6628 - 0x1b6644

void entry_1b6644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6644) {
        switch (ctx->pc) {
            case 0x1b6668: ctx->pc = 0; goto label_1b6668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6644: 0x8e050028
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x1b6648: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b664c: 0x54b10006
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 17)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_1b6668;
    }
    // 0x1b6654: 0x8e030030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1b6658: 0x1071000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 17)) {
        entry_1b6688(rdram, ctx, runtime); return;
    }
    // 0x1b6660: 0x10620009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_1b6688(rdram, ctx, runtime); return;
    }
label_1b6668:
    // 0x1b6668: 0xc06db8a
    SET_GPR_U32(ctx, 31, 0x1b6670);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime); return;
}


// Function: entry_1b6670
// Address: 0x1b6670 - 0x1b6688

void entry_1b6670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6670: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6674: 0xae110028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 17));
    // 0x1b6678: 0xae110030
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 17));
    // 0x1b667c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b6680: 0xc06d9a8
    SET_GPR_U32(ctx, 31, 0x1b6688);
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 2));
    ChooseSmaTransition__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1b6688
// Address: 0x1b6688 - 0x1b66a0

void entry_1b6688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6688: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b668c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6690: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6694: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b669c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b66a0; return;
}


// Function: ChooseSmaTransition__FP3SMA
// Address: 0x1b66a0 - 0x1b66d8

void entry_1b66d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b66d8) {
        switch (ctx->pc) {
            case 0x1b6700: ctx->pc = 0; goto label_1b6700;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b66d8: 0x8e630030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 48)));
    // 0x1b66dc: 0x8e620028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 40)));
    // 0x1b66e0: 0x54620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 19), 48)));
        goto label_1b6700;
    }
    // 0x1b66e8: 0x8e420038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 56)));
    // 0x1b66ec: 0x318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 3));
    // 0x1b66f0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b66f4: 0x8c640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1b66f8: 0xae640030
    WRITE32(ADD32(GPR_U32(ctx, 19), 48), GPR_U32(ctx, 4));
    // 0x1b66fc: 0x8e770030
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 19), 48)));
label_1b6700:
    // 0x1b6700: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6704: 0x52e2013e
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 36)));
        ctx->pc = 0x1B6C00; return;
    }
    // 0x1b670c: 0x8e440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1b6710: 0x8e740028
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 19), 40)));
    // 0x1b6714: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1b671c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b671c
// Address: 0x1b671c - 0x1b69d4

void entry_1b671c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b671c) {
        switch (ctx->pc) {
            case 0x1b6738: ctx->pc = 0; goto label_1b6738;
            case 0x1b675c: ctx->pc = 0; goto label_1b675c;
            case 0x1b6770: ctx->pc = 0; goto label_1b6770;
            case 0x1b6788: ctx->pc = 0; goto label_1b6788;
            case 0x1b67cc: ctx->pc = 0; goto label_1b67cc;
            case 0x1b6814: ctx->pc = 0; goto label_1b6814;
            case 0x1b6828: ctx->pc = 0; goto label_1b6828;
            case 0x1b6848: ctx->pc = 0; goto label_1b6848;
            case 0x1b6874: ctx->pc = 0; goto label_1b6874;
            case 0x1b6888: ctx->pc = 0; goto label_1b6888;
            case 0x1b68a4: ctx->pc = 0; goto label_1b68a4;
            case 0x1b68bc: ctx->pc = 0; goto label_1b68bc;
            case 0x1b68d0: ctx->pc = 0; goto label_1b68d0;
            case 0x1b68e4: ctx->pc = 0; goto label_1b68e4;
            case 0x1b68e8: ctx->pc = 0; goto label_1b68e8;
            case 0x1b68f8: ctx->pc = 0; goto label_1b68f8;
            case 0x1b6908: ctx->pc = 0; goto label_1b6908;
            case 0x1b6928: ctx->pc = 0; goto label_1b6928;
            case 0x1b6960: ctx->pc = 0; goto label_1b6960;
            case 0x1b6964: ctx->pc = 0; goto label_1b6964;
            case 0x1b69a0: ctx->pc = 0; goto label_1b69a0;
            case 0x1b69a4: ctx->pc = 0; goto label_1b69a4;
            case 0x1b69b8: ctx->pc = 0; goto label_1b69b8;
            case 0x1b69c8: ctx->pc = 0; goto label_1b69c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b671c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6720: 0x176080
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 23), 2));
    // 0x1b6724: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1b6728: 0x1840000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1b675c;
    }
    // 0x1b6730: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6734: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1b6738:
    // 0x1b6738: 0x941826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 4), GPR_U32(ctx, 20)));
    // 0x1b673c: 0xc0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1b6740: 0x3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x1b6744: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1b6748: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1b674c: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1b6750: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1b6754: 0x1440fff8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b6738;
    }
label_1b675c:
    // 0x1b675c: 0x8e44003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x1b6760: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b6764: 0x240d0001
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b6768: 0x1915821
    SET_GPR_U32(ctx, 11, ADD32(GPR_U32(ctx, 12), GPR_U32(ctx, 17)));
    // 0x1b676c: 0x145080
    SET_GPR_U32(ctx, 10, SLL32(GPR_U32(ctx, 20), 2));
label_1b6770:
    // 0x1b6770: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b6774: 0x1880002c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_1b6828;
    }
    // 0x1b677c: 0x26a7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x1b6780: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b6784: 0xe0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
label_1b6788:
    // 0x1b6788: 0x8e420040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x1b678c: 0x452021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1b6790: 0x8c830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1b6794: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b6798: 0x711821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x1b679c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b67a0: 0x5449000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 9)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
        goto label_1b67cc;
    }
    // 0x1b67a8: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b67ac: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b67b0: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1b67b4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b67b8: 0x4630004
    if (GPR_S32(ctx, 3) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
        goto label_1b67cc;
    }
    // 0x1b67c0: 0xac550000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 21));
    // 0x1b67c4: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b67c8: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
label_1b67cc:
    // 0x1b67cc: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b67d0: 0x50400010
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6814;
    }
    // 0x1b67d8: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b67dc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b67e0: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1b67e4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b67e8: 0x5467000a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 7)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6814;
    }
    // 0x1b67f0: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1b67f4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b67f8: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1b67fc: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b6800: 0x4630004
    if (GPR_S32(ctx, 3) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6814;
    }
    // 0x1b6808: 0xac550000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 21));
    // 0x1b680c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b6810: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
label_1b6814:
    // 0x1b6814: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1b6818: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b681c: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1b6820: 0x1440ffd9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b6788;
    }
label_1b6828:
    // 0x1b6828: 0x16ad0017
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 13)) {
        goto label_1b6888;
    }
    // 0x1b6830: 0x18800015
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_1b6888;
    }
    // 0x1b6838: 0x1513821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 17)));
    // 0x1b683c: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b6840: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b6844: 0x0
    // NOP
label_1b6848:
    // 0x1b6848: 0x8e420040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x1b684c: 0x452021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1b6850: 0x8c830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1b6854: 0x54740007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6874;
    }
    // 0x1b685c: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b6860: 0x54540004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6874;
    }
    // 0x1b6868: 0xace90000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 9));
    // 0x1b686c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b6870: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
label_1b6874:
    // 0x1b6874: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1b6878: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b687c: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1b6880: 0x1440fff1
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b6848;
    }
label_1b6888:
    // 0x1b6888: 0x11000006
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 12), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        goto label_1b68a4;
    }
    // 0x1b6890: 0x8d620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 0)));
    // 0x1b6894: 0x5c400009
    if (GPR_S32(ctx, 2) > 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
        goto label_1b68bc;
    }
    // 0x1b689c: 0x1000ffb4
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b6770;
    }
label_1b68a4:
    // 0x1b68a4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b68a8: 0x4630004
    if (GPR_S32(ctx, 3) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
        goto label_1b68bc;
    }
    // 0x1b68b0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b68b4: 0x100000d1
    WRITE32(ADD32(GPR_U32(ctx, 19), 48), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6BFC; return;
    }
label_1b68bc:
    // 0x1b68bc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b68c0: 0x1840000d
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 21), 2));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1b68f8;
    }
    // 0x1b68c8: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b68cc: 0x220182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1b68d0:
    // 0x1b68d0: 0x50970005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 23)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
        goto label_1b68e8;
    }
    // 0x1b68d8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b68dc: 0x50550001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 21)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
        goto label_1b68e4;
    }
label_1b68e4:
    // 0x1b68e4: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
label_1b68e8:
    // 0x1b68e8: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1b68ec: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1b68f0: 0x1440fff7
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b68d0;
    }
label_1b68f8:
    // 0x1b68f8: 0x2a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b68fc: 0x14c00032
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_1b69c8;
    }
    // 0x1b6904: 0x246affff
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 3), 4294967295));
label_1b6908:
    // 0x1b6908: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1b690c: 0x1880002a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_1b69b8;
    }
    // 0x1b6914: 0x26a7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x1b6918: 0x140282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x1b691c: 0xe0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1b6920: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b6924: 0x0
    // NOP
label_1b6928:
    // 0x1b6928: 0x8e420040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x1b692c: 0x482021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x1b6930: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b6934: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b6938: 0x711821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x1b693c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b6940: 0x54490008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 9)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
        goto label_1b6964;
    }
    // 0x1b6948: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1b694c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b6950: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1b6954: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b6958: 0x50650001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 5)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 21));
        goto label_1b6960;
    }
label_1b6960:
    // 0x1b6960: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
label_1b6964:
    // 0x1b6964: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b6968: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b69a4;
    }
    // 0x1b6970: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1b6974: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b6978: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1b697c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b6980: 0x54670008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 7)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b69a4;
    }
    // 0x1b6988: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b698c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b6990: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1b6994: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b6998: 0x50650001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 5)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 21));
        goto label_1b69a0;
    }
label_1b69a0:
    // 0x1b69a0: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
label_1b69a4:
    // 0x1b69a4: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1b69a8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b69ac: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1b69b0: 0x1440ffdd
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b6928;
    }
label_1b69b8:
    // 0x1b69b8: 0x140182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x1b69bc: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1b69c0: 0x1040ffd1
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 3), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b6908;
    }
label_1b69c8:
    // 0x1b69c8: 0x8e44003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x1b69cc: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1b69d4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b69d4
// Address: 0x1b69d4 - 0x1b6aa8

void entry_1b69d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b69d4) {
        switch (ctx->pc) {
            case 0x1b69d8: ctx->pc = 0; goto label_1b69d8;
            case 0x1b69f0: ctx->pc = 0; goto label_1b69f0;
            case 0x1b6a20: ctx->pc = 0; goto label_1b6a20;
            case 0x1b6a54: ctx->pc = 0; goto label_1b6a54;
            case 0x1b6a60: ctx->pc = 0; goto label_1b6a60;
            case 0x1b6a70: ctx->pc = 0; goto label_1b6a70;
            case 0x1b6a80: ctx->pc = 0; goto label_1b6a80;
            case 0x1b6a9c: ctx->pc = 0; goto label_1b6a9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b69d4: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1b69d8:
    // 0x1b69d8: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x1b69dc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b69e0: 0x18400023
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1b6a70;
    }
    // 0x1b69e8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b69ec: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_1b69f0:
    // 0x1b69f0: 0x8e420040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x1b69f4: 0x472021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1b69f8: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b69fc: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b6a00: 0x711821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x1b6a04: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b6a08: 0x54550005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
        goto label_1b6a20;
    }
    // 0x1b6a10: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1b6a14: 0x5054000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 4));
        goto label_1b6a54;
    }
    // 0x1b6a1c: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
label_1b6a20:
    // 0x1b6a20: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b6a24: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6a60;
    }
    // 0x1b6a2c: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1b6a30: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1b6a34: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1b6a38: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b6a3c: 0x54750008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6a60;
    }
    // 0x1b6a44: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b6a48: 0x54540005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
        goto label_1b6a60;
    }
    // 0x1b6a50: 0xaca40000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 4));
label_1b6a54:
    // 0x1b6a54: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1b6a58: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1b6a5c: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
label_1b6a60:
    // 0x1b6a60: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1b6a64: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1b6a68: 0x1440ffe1
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b69f0;
    }
label_1b6a70:
    // 0x1b6a70: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1b6a74: 0x1a000009
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_1b6a9c;
    }
    // 0x1b6a7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1b6a80:
    // 0x1b6a80: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b6a84: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1b6a88: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1b6a8c: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1b6a90: 0x0
    // NOP
    // 0x1b6a94: 0x1480fffa
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[0]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1b6a80;
    }
label_1b6a9c:
    // 0x1b6a9c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1b6aa0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1b6aa8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b6aa8
// Address: 0x1b6aa8 - 0x1b6b38

void entry_1b6aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6aa8) {
        switch (ctx->pc) {
            case 0x1b6ae0: ctx->pc = 0; goto label_1b6ae0;
            case 0x1b6b08: ctx->pc = 0; goto label_1b6b08;
            case 0x1b6b0c: ctx->pc = 0; goto label_1b6b0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6aa8: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1b6aac: 0x1a000016
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_1b6b08;
    }
    // 0x1b6ab4: 0x8ec20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1b6ab8: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1b6abc: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1b6ac0: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b6ac4: 0x0
    // NOP
    // 0x1b6ac8: 0x45010010
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b6b0c;
    }
    // 0x1b6ad0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1b6ad4: 0x2c0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1b6ad8: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1b6adc: 0x0
    // NOP
label_1b6ae0:
    // 0x1b6ae0: 0x90102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 16)));
    // 0x1b6ae4: 0x10400008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b6b08;
    }
    // 0x1b6aec: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b6af0: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1b6af4: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1b6af8: 0x460c0834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b6afc: 0x0
    // NOP
    // 0x1b6b00: 0x4502fff7
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1b6ae0;
    }
label_1b6b08:
    // 0x1b6b08: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
label_1b6b0c:
    // 0x1b6b0c: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1b6b10: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b6b14: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b6b18: 0x54600010
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x1B6B5C; return;
    }
    // 0x1b6b20: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1b6b24: 0x14d40006
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 40)));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 20)) {
        ctx->pc = 0x1B6B40; return;
    }
    // 0x1b6b2c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6b30: 0xc06db8a
    SET_GPR_U32(ctx, 31, 0x1b6b38);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime); return;
}


// Function: entry_1b6b38
// Address: 0x1b6b38 - 0x1b6b48

void entry_1b6b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6b38) {
        switch (ctx->pc) {
            case 0x1b6b40: ctx->pc = 0; goto label_1b6b40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6b38: 0x10000004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6B4C; return;
    }
label_1b6b40:
    // 0x1b6b40: 0xc06db8a
    SET_GPR_U32(ctx, 31, 0x1b6b48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime); return;
}


// Function: entry_1b6b48
// Address: 0x1b6b48 - 0x1b6bac

void entry_1b6b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6b48) {
        switch (ctx->pc) {
            case 0x1b6b4c: ctx->pc = 0; goto label_1b6b4c;
            case 0x1b6b5c: ctx->pc = 0; goto label_1b6b5c;
            case 0x1b6b78: ctx->pc = 0; goto label_1b6b78;
            case 0x1b6b88: ctx->pc = 0; goto label_1b6b88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6b48: 0x8e140004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_1b6b4c:
    // 0x1b6b4c: 0x12970025
    WRITE32(ADD32(GPR_U32(ctx, 19), 40), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 23)) {
        ctx->pc = 0x1B6BE4; return;
    }
    // 0x1b6b54: 0x1000ffa0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B69D8; return;
    }
label_1b6b5c:
    // 0x1b6b5c: 0x54540006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 44), GPR_U32(ctx, 2));
        goto label_1b6b78;
    }
    // 0x1b6b64: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1b6b68: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1b6b6c: 0xae62002c
    WRITE32(ADD32(GPR_U32(ctx, 19), 44), GPR_U32(ctx, 2));
    // 0x1b6b70: 0x10000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 56)); ctx->f[13] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b6b88;
    }
label_1b6b78:
    // 0x1b6b78: 0xc6600038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 56)); ctx->f[0] = *(float*)&val; }
    // 0x1b6b7c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b6b80: 0x46000347
    ctx->f[13] = FPU_NEG_S(ctx->f[0]);
    // 0x1b6b84: 0xc44c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[12] = *(float*)&val; }
label_1b6b88:
    // 0x1b6b88: 0x8e710024
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x1b6b8c: 0xae700034
    WRITE32(ADD32(GPR_U32(ctx, 19), 52), GPR_U32(ctx, 16));
    // 0x1b6b90: 0xae600024
    WRITE32(ADD32(GPR_U32(ctx, 19), 36), GPR_U32(ctx, 0));
    // 0x1b6b94: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b6b98: 0x1080000a
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 36));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1b6bc4(rdram, ctx, runtime); return;
    }
    // 0x1b6ba0: 0x8e65001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x1b6ba4: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1b6bac);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1b6bac
// Address: 0x1b6bac - 0x1b6bc4

void entry_1b6bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6bac: 0x8e640024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x1b6bb0: 0x10800004
    SET_GPR_U32(ctx, 5, ((uint32_t)27 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1b6bc4(rdram, ctx, runtime); return;
    }
    // 0x1b6bb8: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6bbc: 0xc04bdf8
    SET_GPR_U32(ctx, 31, 0x1b6bc4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 27816));
    SubscribeAsegaStruct__FP5ASEGAPFPv5MSGIDPv_vPv(rdram, ctx, runtime); return;
}


// Function: entry_1b6bc4
// Address: 0x1b6bc4 - 0x1b6bd4

void entry_1b6bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6bc4: 0x12200015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6C1C; return;
    }
    // 0x1b6bcc: 0xc04bc64
    SET_GPR_U32(ctx, 31, 0x1b6bd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SnapAsega__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_1b6bd4
// Address: 0x1b6bd4 - 0x1b6bdc

void entry_1b6bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6bd4: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1b6bdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1b6bdc
// Address: 0x1b6bdc - 0x1b6bec

void entry_1b6bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6bdc) {
        switch (ctx->pc) {
            case 0x1b6be4: ctx->pc = 0; goto label_1b6be4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6bdc: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6C1C; return;
    }
label_1b6be4:
    // 0x1b6be4: 0xc06d9a8
    SET_GPR_U32(ctx, 31, 0x1b6bec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ChooseSmaTransition__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1b6bec
// Address: 0x1b6bec - 0x1b6bf4

void entry_1b6bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6bec: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1b6bf4);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b6bf4
// Address: 0x1b6bf4 - 0x1b6c10

void entry_1b6bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6bf4) {
        switch (ctx->pc) {
            case 0x1b6bfc: ctx->pc = 0; goto label_1b6bfc;
            case 0x1b6c00: ctx->pc = 0; goto label_1b6c00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6bf4: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6C38; return;
    }
label_1b6bfc:
    // 0x1b6bfc: 0x8e640024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 36)));
label_1b6c00:
    // 0x1b6c00: 0x10800006
    WRITE32(ADD32(GPR_U32(ctx, 19), 52), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6C1C; return;
    }
    // 0x1b6c08: 0xc04bc64
    SET_GPR_U32(ctx, 31, 0x1b6c10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SnapAsega__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_1b6c10
// Address: 0x1b6c10 - 0x1b6c18

void entry_1b6c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6c10: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1b6c18);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1b6c18
// Address: 0x1b6c18 - 0x1b6c24

void entry_1b6c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6c18) {
        switch (ctx->pc) {
            case 0x1b6c1c: ctx->pc = 0; goto label_1b6c1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6c18: 0xae600024
    WRITE32(ADD32(GPR_U32(ctx, 19), 36), GPR_U32(ctx, 0));
label_1b6c1c:
    // 0x1b6c1c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1b6c24);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b6c24
// Address: 0x1b6c24 - 0x1b6c34

void entry_1b6c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6c24: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b6c28: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1b6c2c: 0xc06db5e
    SET_GPR_U32(ctx, 31, 0x1b6c34);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    SendSmaMessage__FP3SMA5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_1b6c34
// Address: 0x1b6c34 - 0x1b6c68

void entry_1b6c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6c34) {
        switch (ctx->pc) {
            case 0x1b6c38: ctx->pc = 0; goto label_1b6c38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6c34: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1b6c38:
    // 0x1b6c38: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b6c3c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b6c40: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b6c44: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b6c48: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b6c4c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b6c50: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6c54: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6c58: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1b6c5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6c64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6c68; return;
}


// Function: EndSmaTransition__FP3SMA
// Address: 0x1b6c68 - 0x1b6c84

void entry_1b6c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6c84: 0x8e03002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x1b6c88: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6c8c: 0xae02002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 2));
    // 0x1b6c90: 0xae030028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 3));
    // 0x1b6c94: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6c98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6c9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6ca4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6ca8; return;
}


// Function: HandleSmaMessage__FP3SMA5MSGIDPv
// Address: 0x1b6ca8 - 0x1b6cd4

void entry_1b6cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6cd4: 0xc06d9a8
    SET_GPR_U32(ctx, 31, 0x1b6cdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChooseSmaTransition__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1b6cdc
// Address: 0x1b6cdc - 0x1b6cf0

void entry_1b6cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6cdc) {
        switch (ctx->pc) {
            case 0x1b6ce0: ctx->pc = 0; goto label_1b6ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6cdc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b6ce0:
    // 0x1b6ce0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6ce4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6cec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6cf0; return;
}


// Function: SkipSma__FP3SMAf
// Address: 0x1b6cf0 - 0x1b6d1c

void entry_1b6d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6d1c: 0xc06d9a8
    SET_GPR_U32(ctx, 31, 0x1b6d24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChooseSmaTransition__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1b6d24
// Address: 0x1b6d24 - 0x1b6d60

void entry_1b6d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6d24: 0x8e040024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1b6d28: 0x1080000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6D64; return;
    }
    // 0x1b6d30: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1b6d34: 0xc4810014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1b6d38: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1b6d3c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b6d40: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b6d44: 0x0
    // NOP
    // 0x1b6d48: 0x4500fff1
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B6D10; return;
    }
    // 0x1b6d50: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b6d54: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1b6d58: 0xc04bc28
    SET_GPR_U32(ctx, 31, 0x1b6d60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime); return;
}


// Function: entry_1b6d60
// Address: 0x1b6d60 - 0x1b6d78

void entry_1b6d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6d60) {
        switch (ctx->pc) {
            case 0x1b6d64: ctx->pc = 0; goto label_1b6d64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6d60: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b6d64:
    // 0x1b6d64: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6d68: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1b6d6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6d74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6d78; return;
}


// Function: SendSmaMessage__FP3SMA5MSGIDPv
// Address: 0x1b6d78 - 0x1b6db0

void entry_1b6db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6db0) {
        switch (ctx->pc) {
            case 0x1b6dc0: ctx->pc = 0; goto label_1b6dc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6db0: 0x8e10003c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1b6db4: 0x1200000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B6DE0; return;
    }
    // 0x1b6dbc: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_1b6dc0:
    // 0x1b6dc0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b6dc4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b6dc8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b6dcc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b6dd4);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b6dd4
// Address: 0x1b6dd4 - 0x1b6df8

void entry_1b6dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6dd4) {
        switch (ctx->pc) {
            case 0x1b6de0: ctx->pc = 0; goto label_1b6de0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6dd4: 0x5600fffa
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x1B6DC0; return;
    }
    // 0x1b6ddc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1b6de0:
    // 0x1b6de0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b6de4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6de8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6dec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6df4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6df8; return;
}


// Function: FUN_001b6df8
// Address: 0x1b6df8 - 0x1b6e1c

void FUN_001b6df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6df8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1b6dfc: 0xa0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1b6e00: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1b6e04: 0x2485003c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 60));
    // 0x1b6e08: 0x8c830018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1b6e0c: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1b6e10: 0x8c640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1b6e14: 0xc060c7a
    SET_GPR_U32(ctx, 31, 0x1b6e1c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 68)));
    SubscribeSwPpmqStruct__FP2SWPP2MQPFPv5MSGIDPv_vPv(rdram, ctx, runtime); return;
}


// Function: entry_1b6e1c
// Address: 0x1b6e1c - 0x1b6e28

void entry_1b6e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6e1c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6e20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: NotifySmaSpliceOnEnterState__FP3SMAii
// Address: 0x1b6e28 - 0x1b6ebc

void entry_1b6ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6ebc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b6ec0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSmartguard__FP10SMARTGUARD
// Address: 0x1b6ec8 - 0x1b6edc

void entry_1b6edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6edc) {
        switch (ctx->pc) {
            case 0x1b6f18: ctx->pc = 0; goto label_1b6f18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6edc: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1b6ee0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b6ee4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6ee8: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x1b6eec: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b6ef0: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6ef4: 0xe6000c24
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3108), *(uint32_t*)&val); }
    // 0x1b6ef8: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1b6efc: 0xe6010c20
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3104), *(uint32_t*)&val); }
    // 0x1b6f00: 0x26030cb8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 3256));
    // 0x1b6f04: 0xae020c28
    WRITE32(ADD32(GPR_U32(ctx, 16), 3112), GPR_U32(ctx, 2));
    // 0x1b6f08: 0xe6000c18
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3096), *(uint32_t*)&val); }
    // 0x1b6f0c: 0xe6000c1c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3100), *(uint32_t*)&val); }
    // 0x1b6f10: 0xae000c2c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3116), GPR_U32(ctx, 0));
    // 0x1b6f14: 0x0
    // NOP
label_1b6f18:
    // 0x1b6f18: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x1b6f1c: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1b6f20: 0x0
    // NOP
    // 0x1b6f24: 0x0
    // NOP
    // 0x1b6f28: 0x0
    // NOP
    // 0x1b6f2c: 0x481fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967288));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1b6f18;
    }
    // 0x1b6f34: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b6f38: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b6f3c: 0xae020c10
    WRITE32(ADD32(GPR_U32(ctx, 16), 3088), GPR_U32(ctx, 2));
    // 0x1b6f40: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b6f44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b6f4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b6f50; return;
}


// Function: PostSmartguardLoadFlashlight__FP10SMARTGUARD
// Address: 0x1b6f50 - 0x1b6f94

void entry_1b6f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6f94) {
        switch (ctx->pc) {
            case 0x1b6f98: ctx->pc = 0; goto label_1b6f98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6f94: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_1b6f98:
    // 0x1b6f98: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1b6f9c: 0x621fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x1B6F78; return;
    }
    // 0x1b6fa4: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1b6fac);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b6fac
// Address: 0x1b6fac - 0x1b6fc8

void entry_1b6fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6fac: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b6fb0: 0x24050201
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 513));
    // 0x1b6fb4: 0x24060060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1b6fb8: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b6fbc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b6fc0: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1b6fc8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1b6fc8
// Address: 0x1b6fc8 - 0x1b6fd4

void entry_1b6fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6fc8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6fcc: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1b6fd4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 17), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b6fd4
// Address: 0x1b6fd4 - 0x1b6ff4

void entry_1b6fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b6fd4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6fd8: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b6fdc: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b6fe0: 0x24050201
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 513));
    // 0x1b6fe4: 0x24060060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1b6fe8: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b6fec: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1b6ff4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1b6ff4
// Address: 0x1b6ff4 - 0x1b700c

void entry_1b6ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b6ff4) {
        switch (ctx->pc) {
            case 0x1b7000: ctx->pc = 0; goto label_1b7000;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b6ff4: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b6ff8: 0x1a20000f
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x1B7038; return;
    }
label_1b7000:
    // 0x1b7000: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b7004: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x1b700c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 3088)));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_1b700c
// Address: 0x1b700c - 0x1b702c

void entry_1b700c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b700c) {
        switch (ctx->pc) {
            case 0x1b701c: ctx->pc = 0; goto label_1b701c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b700c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1b701c;
    }
    // 0x1b7014: 0x10000005
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1b702c(rdram, ctx, runtime); return;
    }
label_1b701c:
    // 0x1b701c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b7020: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1b7024: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b702c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b702c
// Address: 0x1b702c - 0x1b7040

void entry_1b702c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b702c) {
        switch (ctx->pc) {
            case 0x1b7038: ctx->pc = 0; goto label_1b7038;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b702c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1b7030: 0x1620fff3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7000; return;
    }
label_1b7038:
    // 0x1b7038: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1b7040);
    WRITE32(ADD32(GPR_U32(ctx, 18), 3092), GPR_U32(ctx, 19));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b7040
// Address: 0x1b7040 - 0x1b7058

void entry_1b7040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7040: 0x8e450c14
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 3092)));
    // 0x1b7044: 0x10a00012
    SET_GPR_U32(ctx, 6, ((uint32_t)34 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7090; return;
    }
    // 0x1b704c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b7050: 0xc04848a
    SET_GPR_U32(ctx, 31, 0x1b7058);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294944656));
    PactNew__FP2SWP3ALOP5VTACT(rdram, ctx, runtime); return;
}


// Function: entry_1b7058
// Address: 0x1b7058 - 0x1b7088

void entry_1b7058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7058: 0xae420c34
    WRITE32(ADD32(GPR_U32(ctx, 18), 3124), GPR_U32(ctx, 2));
    // 0x1b705c: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b7060: 0xa0430011
    WRITE8(ADD32(GPR_U32(ctx, 2), 17), (uint8_t)GPR_U32(ctx, 3));
    // 0x1b7064: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b7068: 0x8e420c34
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3124)));
    // 0x1b706c: 0xac44001c
    WRITE32(ADD32(GPR_U32(ctx, 2), 28), GPR_U32(ctx, 4));
    // 0x1b7070: 0x8e430c34
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 3124)));
    // 0x1b7074: 0xac600084
    WRITE32(ADD32(GPR_U32(ctx, 3), 132), GPR_U32(ctx, 0));
    // 0x1b7078: 0xac600080
    WRITE32(ADD32(GPR_U32(ctx, 3), 128), GPR_U32(ctx, 0));
    // 0x1b707c: 0x8e440c14
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3092)));
    // 0x1b7080: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x1b7088);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 3124)));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1b7088
// Address: 0x1b7088 - 0x1b70b0

void entry_1b7088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7088) {
        switch (ctx->pc) {
            case 0x1b7090: ctx->pc = 0; goto label_1b7090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7088: 0x8e420c14
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3092)));
    // 0x1b708c: 0xae420bf0
    WRITE32(ADD32(GPR_U32(ctx, 18), 3056), GPR_U32(ctx, 2));
label_1b7090:
    // 0x1b7090: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b7094: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b7098: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b709c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b70a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b70a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b70ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b70b0; return;
}


// Function: UseSmartguardFlashlightTarget__FP10SMARTGUARD3SGS3OID
// Address: 0x1b70b0 - 0x1b70d8

void entry_1b70d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b70d8: 0x1080c0
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 3));
    // 0x1b70dc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b70e0: 0x2308821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x1b70e4: 0xae320c38
    WRITE32(ADD32(GPR_U32(ctx, 17), 3128), GPR_U32(ctx, 18));
    // 0x1b70e8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b70ec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b70f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b70f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b70fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7100; return;
}


// Function: FUN_001B7100
// Address: 0x1b7100 - 0x1b7128

void FUN_001B7100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7100) {
        switch (ctx->pc) {
            case 0x1b7120: ctx->pc = 0; goto label_1b7120;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7100: 0x8c830cd4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 3284)));
    // 0x1b7104: 0x2c620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 4));
    // 0x1b7108: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b7120;
    }
    // 0x1b7110: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1b7114: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1b7118: 0xac450cd8
    WRITE32(ADD32(GPR_U32(ctx, 2), 3288), GPR_U32(ctx, 5));
    // 0x1b711c: 0xac830cd4
    WRITE32(ADD32(GPR_U32(ctx, 4), 3284), GPR_U32(ctx, 3));
label_1b7120:
    // 0x1b7120: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSmartguardLoad__FP10SMARTGUARD
// Address: 0x1b7128 - 0x1b7144

void entry_1b7144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7144: 0xc06dbd4
    SET_GPR_U32(ctx, 31, 0x1b714c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PostSmartguardLoadFlashlight__FP10SMARTGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1b714c
// Address: 0x1b714c - 0x1b7168

void entry_1b714c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b714c: 0x8e250c28
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 3112)));
    // 0x1b7150: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b7154: 0x50a20006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3284)));
        ctx->pc = 0x1B7170; return;
    }
    // 0x1b715c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1b7160: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1b7168);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1b7168
// Address: 0x1b7168 - 0x1b7198

void entry_1b7168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7168) {
        switch (ctx->pc) {
            case 0x1b7170: ctx->pc = 0; goto label_1b7170;
            case 0x1b7180: ctx->pc = 0; goto label_1b7180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7168: 0xae220c2c
    WRITE32(ADD32(GPR_U32(ctx, 17), 3116), GPR_U32(ctx, 2));
    // 0x1b716c: 0x8e220cd4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3284)));
label_1b7170:
    // 0x1b7170: 0x1840000e
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B71AC; return;
    }
    // 0x1b7178: 0x26300cd8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 3288));
    // 0x1b717c: 0x0
    // NOP
label_1b7180:
    // 0x1b7180: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b7184: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x1b7188: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1b718c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b7190: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1b7198);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1b7198
// Address: 0x1b7198 - 0x1b71c8

void entry_1b7198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7198) {
        switch (ctx->pc) {
            case 0x1b71ac: ctx->pc = 0; goto label_1b71ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7198: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1b719c: 0x8e220cd4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3284)));
    // 0x1b71a0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1b71a4: 0x1440fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7180; return;
    }
label_1b71ac:
    // 0x1b71ac: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b71b0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b71b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b71b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b71bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b71c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b71c8; return;
}


// Function: FFilterSmartguardDetect__FP10SMARTGUARDP2SO
// Address: 0x1b71c8 - 0x1b7208

void entry_1b7208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7208: 0x14400015
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7260; return;
    }
    // 0x1b7210: 0x8e440050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x1b7214: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1b721c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1b721c
// Address: 0x1b721c - 0x1b7244

void entry_1b721c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b721c) {
        switch (ctx->pc) {
            case 0x1b7224: ctx->pc = 0; goto label_1b7224;
            case 0x1b722c: ctx->pc = 0; goto label_1b722c;
            case 0x1b7238: ctx->pc = 0; goto label_1b7238;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b721c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3284)));
        goto label_1b722c;
    }
label_1b7224:
    // 0x1b7224: 0x1000000e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7260; return;
    }
label_1b722c:
    // 0x1b722c: 0x1840000b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B725C; return;
    }
    // 0x1b7234: 0x26700cdc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 3292));
label_1b7238:
    // 0x1b7238: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b723c: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x1b7244);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1b7244
// Address: 0x1b7244 - 0x1b7280

void entry_1b7244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7244) {
        switch (ctx->pc) {
            case 0x1b725c: ctx->pc = 0; goto label_1b725c;
            case 0x1b7260: ctx->pc = 0; goto label_1b7260;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7244: 0x1440fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7224; return;
    }
    // 0x1b724c: 0x8e620cd4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3284)));
    // 0x1b7250: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1b7254: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7238; return;
    }
label_1b725c:
    // 0x1b725c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1b7260:
    // 0x1b7260: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b7264: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b7268: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b726c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7270: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7274: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b727c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7280; return;
}


// Function: FDetectSmartguard__FP10SMARTGUARD
// Address: 0x1b7280 - 0x1b72bc

void entry_1b72bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b72bc: 0x144000c5
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75D4; return;
    }
    // 0x1b72c4: 0x8e420ccc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3276)));
    // 0x1b72c8: 0x144000c2
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75D4; return;
    }
    // 0x1b72d0: 0x8e420cc8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3272)));
    // 0x1b72d4: 0x144000bf
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75D4; return;
    }
    // 0x1b72dc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b72e0: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1b72e4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b72ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b72ec
// Address: 0x1b72ec - 0x1b7320

void entry_1b72ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b72ec: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b72f0: 0x12a000b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75D4; return;
    }
    // 0x1b72f8: 0x8e420c14
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3092)));
    // 0x1b72fc: 0x104000b4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75D0; return;
    }
    // 0x1b7304: 0x8e430724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1828)));
    // 0x1b7308: 0x106200b1
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B75D0; return;
    }
    // 0x1b7310: 0x106200af
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B75D0; return;
    }
    // 0x1b7318: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1b7320);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1b7320
// Address: 0x1b7320 - 0x1b739c

void entry_1b7320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7320) {
        switch (ctx->pc) {
            case 0x1b733c: ctx->pc = 0; goto label_1b733c;
            case 0x1b7358: ctx->pc = 0; goto label_1b7358;
            case 0x1b735c: ctx->pc = 0; goto label_1b735c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7320: 0x5040000d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 320)));
        goto label_1b7358;
    }
    // 0x1b7328: 0x8ea20690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 1680)));
    // 0x1b732c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 320)));
        goto label_1b733c;
    }
    // 0x1b7334: 0x10000008
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 1696)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b7358;
    }
label_1b733c:
    // 0x1b733c: 0x3c01428c
    SET_GPR_U32(ctx, 1, ((uint32_t)17036 << 16));
    // 0x1b7340: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b7344: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1b7348: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1b734c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b7350: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b735c;
    }
label_1b7358:
    // 0x1b7358: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
label_1b735c:
    // 0x1b735c: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1b7360: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7364: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b7368: 0x8e440c2c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3116)));
    // 0x1b736c: 0x4b8108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b7370: 0x4b021081
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b7374: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b7378: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b737c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b7380: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1b7384: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b7388: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1b738c: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3104)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1B73A4; return;
    }
    // 0x1b7394: 0xc05045c
    SET_GPR_U32(ctx, 31, 0x1b739c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FCheckVolPoint__FP3VOLP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1b739c
// Address: 0x1b739c - 0x1b73ec

void entry_1b739c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b739c) {
        switch (ctx->pc) {
            case 0x1b73a4: ctx->pc = 0; goto label_1b73a4;
            case 0x1b73d0: ctx->pc = 0; goto label_1b73d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b739c: 0x1000000c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b73d0;
    }
label_1b73a4:
    // 0x1b73a4: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b73a8: 0x0
    // NOP
    // 0x1b73ac: 0x45000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b73d0;
    }
    // 0x1b73b4: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1b73b8: 0xc6410c24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3108)); ctx->f[1] = *(float*)&val; }
    // 0x1b73bc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b73c0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b73c4: 0x0
    // NOP
    // 0x1b73c8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1b73d0;
    }
label_1b73d0:
    // 0x1b73d0: 0x10400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B73F4; return;
    }
    // 0x1b73d8: 0x8e420cc0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3264)));
    // 0x1b73dc: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3092)));
        ctx->pc = 0x1B7404; return;
    }
    // 0x1b73e4: 0xc06fbbe
    SET_GPR_U32(ctx, 31, 0x1b73ec);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967276));
    PexcSetExcitement__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b73ec
// Address: 0x1b73ec - 0x1b73fc

void entry_1b73ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b73ec) {
        switch (ctx->pc) {
            case 0x1b73f4: ctx->pc = 0; goto label_1b73f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b73ec: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 18), 3264), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7400; return;
    }
label_1b73f4:
    // 0x1b73f4: 0xc06fc36
    SET_GPR_U32(ctx, 31, 0x1b73fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3264)));
    UnsetExcitementHyst__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_1b73fc
// Address: 0x1b73fc - 0x1b740c

void entry_1b73fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b73fc) {
        switch (ctx->pc) {
            case 0x1b7400: ctx->pc = 0; goto label_1b7400;
            case 0x1b7404: ctx->pc = 0; goto label_1b7404;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b73fc: 0xae400cc0
    WRITE32(ADD32(GPR_U32(ctx, 18), 3264), GPR_U32(ctx, 0));
label_1b7400:
    // 0x1b7400: 0x8e440c14
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3092)));
label_1b7404:
    // 0x1b7404: 0xc056a94
    SET_GPR_U32(ctx, 31, 0x1b740c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FPosFlashWithin__FP5FLASHP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1b740c
// Address: 0x1b740c - 0x1b744c

void entry_1b740c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b740c) {
        switch (ctx->pc) {
            case 0x1b7444: ctx->pc = 0; goto label_1b7444;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b740c: 0x1440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b7444;
    }
    // 0x1b7414: 0xc6400c18
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3096)); ctx->f[0] = *(float*)&val; }
    // 0x1b7418: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b741c: 0x0
    // NOP
    // 0x1b7420: 0x4501006c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B75D4; return;
    }
    // 0x1b7428: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1b742c: 0xc6410c1c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3100)); ctx->f[1] = *(float*)&val; }
    // 0x1b7430: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b7434: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b7438: 0x0
    // NOP
    // 0x1b743c: 0x45010066
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B75D8; return;
    }
label_1b7444:
    // 0x1b7444: 0xc0725ae
    SET_GPR_U32(ctx, 31, 0x1b744c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SggsGetStepguard__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1b744c
// Address: 0x1b744c - 0x1b7474

void entry_1b744c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b744c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b7450: 0x8e420cd0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3280)));
    // 0x1b7454: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1b7458: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3280)));
        ctx->pc = 0x1B7480; return;
    }
    // 0x1b7460: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b7464: 0x52020006
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3280)));
        ctx->pc = 0x1B7480; return;
    }
    // 0x1b746c: 0xc072cf4
    SET_GPR_U32(ctx, 31, 0x1b7474);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FCheckStepguardEnemyHidden__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1b7474
// Address: 0x1b7474 - 0x1b74cc

void entry_1b7474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7474) {
        switch (ctx->pc) {
            case 0x1b7480: ctx->pc = 0; goto label_1b7480;
            case 0x1b74b4: ctx->pc = 0; goto label_1b74b4;
            case 0x1b74b8: ctx->pc = 0; goto label_1b74b8;
            case 0x1b74bc: ctx->pc = 0; goto label_1b74bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7474: 0x14400057
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75D4; return;
    }
    // 0x1b747c: 0x8e420cd0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3280)));
label_1b7480:
    // 0x1b7480: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b7484: 0x14400053
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75D4; return;
    }
    // 0x1b748c: 0x600000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    if (GPR_S32(ctx, 16) < 0) {
        goto label_1b74b8;
    }
    // 0x1b7494: 0x14400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b74b4;
    }
    // 0x1b749c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b74a0: 0x56020006
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1844)));
        goto label_1b74bc;
    }
    // 0x1b74a8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b74ac: 0x10000002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 17952));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b74b8;
    }
label_1b74b4:
    // 0x1b74b4: 0x24514660
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 18016));
label_1b74b8:
    // 0x1b74b8: 0x8e430734
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1844)));
label_1b74bc:
    // 0x1b74bc: 0x26540140
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1b74c0: 0x24620140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 320));
    // 0x1b74c4: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1b74cc);
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 2));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b74cc
// Address: 0x1b74cc - 0x1b74e8

void entry_1b74cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b74cc: 0x7a830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1b74d0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b74d4: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1b74d8: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x1b74dc: 0x7a820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1b74e0: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1b74e8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1b74e8
// Address: 0x1b74e8 - 0x1b752c

void entry_1b74e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b74e8) {
        switch (ctx->pc) {
            case 0x1b7518: ctx->pc = 0; goto label_1b7518;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b74e8: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b74ec: 0x27b70020
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1b74f0: 0x27a20040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1b74f4: 0xafa20048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 2));
    // 0x1b74f8: 0x27a20044
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 68));
    // 0x1b74fc: 0xafa2004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 2));
    // 0x1b7500: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b7504: 0x18400015
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B755C; return;
    }
    // 0x1b750c: 0x220982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b7510: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1b7514: 0x24110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
label_1b7518:
    // 0x1b7518: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b751c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b7520: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b7524: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1b752c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1b752c
// Address: 0x1b752c - 0x1b7588

void entry_1b752c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b752c) {
        switch (ctx->pc) {
            case 0x1b755c: ctx->pc = 0; goto label_1b755c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b752c: 0x26730010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 16));
    // 0x1b7530: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b7534: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1b7538: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b753c: 0x4bc2086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b7540: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b7544: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b7548: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b754c: 0x4bc218eb
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b7550: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1b7554: 0x1620fff0
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7518; return;
    }
label_1b755c:
    // 0x1b755c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1b7560: 0x3c08001b
    SET_GPR_U32(ctx, 8, ((uint32_t)27 << 16));
    // 0x1b7564: 0x8faa0048
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1b7568: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1b756c: 0x8fab004c
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x1b7570: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1b7574: 0x250871c8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 29128));
    // 0x1b7578: 0x240482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b757c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b7580: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1b7588);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7588
// Address: 0x1b7588 - 0x1b75b8

void entry_1b7588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7588) {
        switch (ctx->pc) {
            case 0x1b7590: ctx->pc = 0; goto label_1b7590;
            case 0x1b7594: ctx->pc = 0; goto label_1b7594;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7588: 0x10000002
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b7594;
    }
label_1b7590:
    // 0x1b7590: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_1b7594:
    // 0x1b7594: 0x2a320004
    SET_GPR_U32(ctx, 18, SLT32(GPR_S32(ctx, 17), 4));
    // 0x1b7598: 0x12400009
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B75C0; return;
    }
    // 0x1b75a0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b75a4: 0x8fa80044
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1b75a8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b75ac: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b75b0: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1b75b8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1b75b8
// Address: 0x1b75b8 - 0x1b75c8

void entry_1b75b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b75b8) {
        switch (ctx->pc) {
            case 0x1b75c0: ctx->pc = 0; goto label_1b75c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b75b8: 0x1440fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7590; return;
    }
label_1b75c0:
    // 0x1b75c0: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1b75c8);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1b75c8
// Address: 0x1b75c8 - 0x1b7608

void entry_1b75c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b75c8) {
        switch (ctx->pc) {
            case 0x1b75d0: ctx->pc = 0; goto label_1b75d0;
            case 0x1b75d4: ctx->pc = 0; goto label_1b75d4;
            case 0x1b75d8: ctx->pc = 0; goto label_1b75d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b75c8: 0x16400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1b75d4;
    }
label_1b75d0:
    // 0x1b75d0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1b75d4:
    // 0x1b75d4: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1b75d8:
    // 0x1b75d8: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b75dc: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b75e0: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b75e4: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b75e8: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b75ec: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b75f0: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b75f4: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b75f8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b75fc: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1b7600: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSmartguard__FP10SMARTGUARDf
// Address: 0x1b7608 - 0x1b761c

void entry_1b761c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b761c: 0xc06dd8e
    SET_GPR_U32(ctx, 31, 0x1b7624);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSmartguardFlashlight__FP10SMARTGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1b7624
// Address: 0x1b7624 - 0x1b7638

void entry_1b7624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7624: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7628: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b762c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b7634: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7638; return;
}


// Function: UpdateSmartguardFlashlight__FP10SMARTGUARD
// Address: 0x1b7638 - 0x1b7664

void entry_1b7664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7664) {
        switch (ctx->pc) {
            case 0x1b768c: ctx->pc = 0; goto label_1b768c;
            case 0x1b76b0: ctx->pc = 0; goto label_1b76b0;
            case 0x1b76b8: ctx->pc = 0; goto label_1b76b8;
            case 0x1b76e0: ctx->pc = 0; goto label_1b76e0;
            case 0x1b76fc: ctx->pc = 0; goto label_1b76fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7664: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b7668: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b766c: 0x1082001c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1b76e0;
    }
    // 0x1b7674: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1b768c;
    }
    // 0x1b767c: 0x50820035
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 17));
        ctx->pc = 0x1B7754; return;
    }
    // 0x1b7684: 0x1000003b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3092)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7774; return;
    }
label_1b768c:
    // 0x1b768c: 0x4820039
    if (GPR_S32(ctx, 4) < 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3092)));
        ctx->pc = 0x1B7774; return;
    }
    // 0x1b7694: 0x8e220c30
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3120)));
    // 0x1b7698: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 17));
        goto label_1b76b0;
    }
    // 0x1b76a0: 0xae020024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    // 0x1b76a4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b76a8: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b76b8;
    }
label_1b76b0:
    // 0x1b76b0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b76b4: 0x244246a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18080));
label_1b76b8:
    // 0x1b76b8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b76bc: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x1b76c0: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1b76c4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1b76c8: 0x14800029
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7770; return;
    }
    // 0x1b76d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b76d4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1b76d8: 0x10000026
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3092)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7774; return;
    }
label_1b76e0:
    // 0x1b76e0: 0x8e220c30
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3120)));
    // 0x1b76e4: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b76fc;
    }
    // 0x1b76ec: 0xae020024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    // 0x1b76f0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b76f4: 0x10000011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B773C; return;
    }
label_1b76fc:
    // 0x1b76fc: 0xc072d5e
    SET_GPR_U32(ctx, 31, 0x1b7704);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001cb578(rdram, ctx, runtime); return;
}


// Function: entry_1b7704
// Address: 0x1b7704 - 0x1b771c

void entry_1b7704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7704: 0x5440000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 17));
        ctx->pc = 0x1B7734; return;
    }
    // 0x1b770c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b7710: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1b7714: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b771c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b771c
// Address: 0x1b771c - 0x1b7790

void entry_1b771c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b771c) {
        switch (ctx->pc) {
            case 0x1b7734: ctx->pc = 0; goto label_1b7734;
            case 0x1b773c: ctx->pc = 0; goto label_1b773c;
            case 0x1b7754: ctx->pc = 0; goto label_1b7754;
            case 0x1b7770: ctx->pc = 0; goto label_1b7770;
            case 0x1b7774: ctx->pc = 0; goto label_1b7774;
            case 0x1b777c: ctx->pc = 0; goto label_1b777c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b771c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 17));
        goto label_1b7734;
    }
    // 0x1b7724: 0xae020024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    // 0x1b7728: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1b772c: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b773c;
    }
label_1b7734:
    // 0x1b7734: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1b7738: 0x244246a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18080));
label_1b773c:
    // 0x1b773c: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b7740: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x1b7744: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1b7748: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1b774c: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b7770;
    }
label_1b7754:
    // 0x1b7754: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1b7758: 0x246346a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 18080));
    // 0x1b775c: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1b7760: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1b7764: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1b7768: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b776c: 0x7e020030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 2));
label_1b7770:
    // 0x1b7770: 0x8e220c14
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3092)));
label_1b7774:
    // 0x1b7774: 0xe45402f0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 752), *(uint32_t*)&val); }
    // 0x1b7778: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1b777c:
    // 0x1b777c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7780: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7784: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1b7788: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnSmartguardEnteringSgs__FP10SMARTGUARD3SGSP4ASEG
// Address: 0x1b7790 - 0x1b77a4

void entry_1b77a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b77a4) {
        switch (ctx->pc) {
            case 0x1b77c4: ctx->pc = 0; goto label_1b77c4;
            case 0x1b77cc: ctx->pc = 0; goto label_1b77cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b77a4: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1b77a8: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1b77ac: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b77c4;
    }
    // 0x1b77b4: 0x50620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3092)));
        goto label_1b77cc;
    }
    // 0x1b77bc: 0x1000000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B77F4; return;
    }
label_1b77c4:
    // 0x1b77c4: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 3268), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B77F0; return;
    }
label_1b77cc:
    // 0x1b77cc: 0x10800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1b77e4(rdram, ctx, runtime); return;
    }
    // 0x1b77d4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b77d8: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1b77dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b77e4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b77e4
// Address: 0x1b77e4 - 0x1b77ec

void entry_1b77e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b77e4: 0xc06fc12
    SET_GPR_U32(ctx, 31, 0x1b77ec);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3264)));
    UnsetExcitement__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_1b77ec
// Address: 0x1b77ec - 0x1b7818

void entry_1b77ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b77ec) {
        switch (ctx->pc) {
            case 0x1b77f0: ctx->pc = 0; goto label_1b77f0;
            case 0x1b77f4: ctx->pc = 0; goto label_1b77f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b77ec: 0xae000cc0
    WRITE32(ADD32(GPR_U32(ctx, 16), 3264), GPR_U32(ctx, 0));
label_1b77f0:
    // 0x1b77f0: 0x8e020724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
label_1b77f4:
    // 0x1b77f4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b77f8: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1b77fc: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1b7800: 0x8c430c3c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 3132)));
    // 0x1b7804: 0xae030c30
    WRITE32(ADD32(GPR_U32(ctx, 16), 3120), GPR_U32(ctx, 3));
    // 0x1b7808: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b780c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b7814: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7818; return;
}


// Function: FCanSmartguardAttack__FP10SMARTGUARD
// Address: 0x1b7818 - 0x1b782c

void entry_1b782c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b782c: 0x10400007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B784C; return;
    }
    // 0x1b7834: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b7838: 0x8c62016c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 364)));
    // 0x1b783c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b7844);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b7844
// Address: 0x1b7844 - 0x1b7860

void entry_1b7844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7844) {
        switch (ctx->pc) {
            case 0x1b784c: ctx->pc = 0; goto label_1b784c;
            case 0x1b7850: ctx->pc = 0; goto label_1b7850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7844: 0x10000002
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b7850;
    }
label_1b784c:
    // 0x1b784c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1b7850:
    // 0x1b7850: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7854: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b785c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7860; return;
}


// Function: SgasGetSmartguard__FP10SMARTGUARD
// Address: 0x1b7860 - 0x1b78c0

void entry_1b78e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b78e4) {
        switch (ctx->pc) {
            case 0x1b790c: ctx->pc = 0; goto label_1b790c;
            case 0x1b7910: ctx->pc = 0; goto label_1b7910;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b78e4: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1b78e8: 0x16020008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1b790c;
    }
    // 0x1b78f0: 0x8e2207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2016)));
    // 0x1b78f4: 0x16420006
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        goto label_1b7910;
    }
    // 0x1b78fc: 0x8e220cc4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3268)));
    // 0x1b7900: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1b7904: 0xae220cc4
    WRITE32(ADD32(GPR_U32(ctx, 17), 3268), GPR_U32(ctx, 2));
    // 0x1b7908: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1b790c:
    // 0x1b790c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1b7910:
    // 0x1b7910: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7914: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7918: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreezeSmartguard__FP10SMARTGUARDi
// Address: 0x1b7920 - 0x1b793c

void entry_1b793c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b793c: 0x12000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7954; return;
    }
    // 0x1b7944: 0xc06fc12
    SET_GPR_U32(ctx, 31, 0x1b794c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 3264)));
    UnsetExcitement__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_1b794c
// Address: 0x1b794c - 0x1b7968

void entry_1b794c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b794c) {
        switch (ctx->pc) {
            case 0x1b7954: ctx->pc = 0; goto label_1b7954;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b794c: 0xae200cc0
    WRITE32(ADD32(GPR_U32(ctx, 17), 3264), GPR_U32(ctx, 0));
    // 0x1b7950: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1b7954:
    // 0x1b7954: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7958: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b795c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b7964: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7968; return;
}


// Function: InitSo__FP2SO
// Address: 0x1b7968 - 0x1b7984

void entry_1b7984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7984: 0x240502e4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 740));
    // 0x1b7988: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1b7990);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 728));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1b7990
// Address: 0x1b7990 - 0x1b7998

void entry_1b7990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7990: 0xc048fb4
    SET_GPR_U32(ctx, 31, 0x1b7998);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    InitAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1b7998
// Address: 0x1b7998 - 0x1b79a0

void entry_1b7998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7998: 0xc0583a0
    SET_GPR_U32(ctx, 31, 0x1b79a0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 896));
    InitGeom__FP4GEOM(rdram, ctx, runtime); return;
}


// Function: entry_1b79a0
// Address: 0x1b79a0 - 0x1b7a08

void entry_1b79a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b79a0: 0x6a220387
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 903); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1b79a4: 0x6e220380
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 896); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1b79a8: 0x6a23038f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 911); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1b79ac: 0x6e230388
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 904); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1b79b0: 0x6a240397
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 919); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1b79b4: 0x6e240390
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 912); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1b79b8: 0x6a25039f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 927); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1b79bc: 0x6e250398
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 920); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1b79c0: 0xb22203ab
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 939); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79c4: 0xb62203a4
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 932); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79c8: 0xb22303b3
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 947); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79cc: 0xb62303ac
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 940); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79d0: 0xb22403bb
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 955); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79d4: 0xb62403b4
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 948); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79d8: 0xb22503c3
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 963); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79dc: 0xb62503bc
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 956); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1b79e0: 0x8e2203a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 928)));
    // 0x1b79e4: 0xae2203c4
    WRITE32(ADD32(GPR_U32(ctx, 17), 964), GPR_U32(ctx, 2));
    // 0x1b79e8: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1b79ec: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b7a08(rdram, ctx, runtime); return;
    }
    // 0x1b79f4: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b79f8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b79fc: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b7a00: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1b7a08);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1b7a08
// Address: 0x1b7a08 - 0x1b7a2c

void entry_1b7a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7a08: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1b7a0c: 0x8e24002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 44)));
    // 0x1b7a10: 0xae2204c0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1216), GPR_U32(ctx, 2));
    // 0x1b7a14: 0x10800013
    WRITE32(ADD32(GPR_U32(ctx, 17), 1212), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7A64; return;
    }
    // 0x1b7a1c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b7a20: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1b7a24: 0xc046926
    SET_GPR_U32(ctx, 31, 0x1b7a2c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1b7a2c
// Address: 0x1b7a2c - 0x1b7a44

void entry_1b7a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7a2c: 0x8e24002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 44)));
    // 0x1b7a30: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b7a34: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1b7a38: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b7a3c: 0xc046926
    SET_GPR_U32(ctx, 31, 0x1b7a44);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1b7a44
// Address: 0x1b7a44 - 0x1b7a78

void entry_1b7a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7a44) {
        switch (ctx->pc) {
            case 0x1b7a64: ctx->pc = 0; goto label_1b7a64;
            case 0x1b7a68: ctx->pc = 0; goto label_1b7a68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7a44: 0x2028025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1b7a48: 0x52000007
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_1b7a68;
    }
    // 0x1b7a50: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1b7a54: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1b7a58: 0x31c3c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 16));
    // 0x1b7a5c: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b7a60: 0xfe220538
    WRITE64(ADD32(GPR_U32(ctx, 17), 1336), GPR_U64(ctx, 2));
label_1b7a64:
    // 0x1b7a64: 0x8e230014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_1b7a68:
    // 0x1b7a68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b7a6c: 0x78621ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x1b7a70: 0xc06ed28
    SET_GPR_U32(ctx, 31, 0x1b7a78);
    WRITE128(ADD32(GPR_U32(ctx, 17), 848), GPR_VEC(ctx, 2));
    RebuildSoPhysHook__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7a78
// Address: 0x1b7a78 - 0x1b7a84

void entry_1b7a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7a78: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b7a7c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1b7a84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1b7a84
// Address: 0x1b7a84 - 0x1b7a98

void entry_1b7a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7a84: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b7a88: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b7a8c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7a90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnSoAdd__FP2SO
// Address: 0x1b7a98 - 0x1b7ad4

void entry_1b7ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7ad4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b7ad8: 0xc0771f4
    SET_GPR_U32(ctx, 31, 0x1b7ae0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PoxaAllocSw__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7ae0
// Address: 0x1b7ae0 - 0x1b7af0

void entry_1b7ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7ae0: 0xae020480
    WRITE32(ADD32(GPR_U32(ctx, 16), 1152), GPR_U32(ctx, 2));
    // 0x1b7ae4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b7ae8: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x1b7af0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7af0
// Address: 0x1b7af0 - 0x1b7b08

void entry_1b7af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7af0: 0x8e220038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 56)));
    // 0x1b7af4: 0x2624003c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 60));
    // 0x1b7af8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b7afc: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1b7b00: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1b7b08);
    WRITE32(ADD32(GPR_U32(ctx, 17), 56), GPR_U32(ctx, 2));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1b7b08
// Address: 0x1b7b08 - 0x1b7b10

void entry_1b7b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7b08: 0xc04903e
    SET_GPR_U32(ctx, 31, 0x1b7b10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnAloAdd__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1b7b10
// Address: 0x1b7b10 - 0x1b7b1c

void entry_1b7b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7b10: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b7b14: 0xc06df10
    SET_GPR_U32(ctx, 31, 0x1b7b1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    EnableSoPhys__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1b7b1c
// Address: 0x1b7b1c - 0x1b7b2c

void entry_1b7b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7b1c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b7b20: 0x8c430120
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 288)));
    // 0x1b7b24: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1b7b2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1b7b2c
// Address: 0x1b7b2c - 0x1b7b4c

void entry_1b7b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7b2c: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1b7b30: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1b7b34: 0x319fc
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 7));
    // 0x1b7b38: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b7b3c: 0x14400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7B54; return;
    }
    // 0x1b7b44: 0xc06ed60
    SET_GPR_U32(ctx, 31, 0x1b7b4c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    RecalcSoLocked__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7b4c
// Address: 0x1b7b4c - 0x1b7b5c

void entry_1b7b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7b4c) {
        switch (ctx->pc) {
            case 0x1b7b54: ctx->pc = 0; goto label_1b7b54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7b4c: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1b7b5c(rdram, ctx, runtime); return;
    }
label_1b7b54:
    // 0x1b7b54: 0xc06ed60
    SET_GPR_U32(ctx, 31, 0x1b7b5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RecalcSoLocked__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7b5c
// Address: 0x1b7b5c - 0x1b7b64

void entry_1b7b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7b5c: 0xc06ed28
    SET_GPR_U32(ctx, 31, 0x1b7b64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebuildSoPhysHook__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7b64
// Address: 0x1b7b64 - 0x1b7b78

void entry_1b7b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7b64: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b7b68: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7b6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7b70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnSoRemove__FP2SO
// Address: 0x1b7b78 - 0x1b7ba0

void entry_1b7ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7ba0: 0xc0490f8
    SET_GPR_U32(ctx, 31, 0x1b7ba8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnAloRemove__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1b7ba8
// Address: 0x1b7ba8 - 0x1b7bcc

void entry_1b7ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7ba8: 0x8e220034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1b7bac: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1b7bb0: 0xae220034
    WRITE32(ADD32(GPR_U32(ctx, 17), 52), GPR_U32(ctx, 2));
    // 0x1b7bb4: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1b7bb8: 0x5460000e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1344)));
        ctx->pc = 0x1B7BF4; return;
    }
    // 0x1b7bc0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b7bc4: 0xc04e228
    SET_GPR_U32(ctx, 31, 0x1b7bcc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveSwAaobrObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7bcc
// Address: 0x1b7bcc - 0x1b7bd8

void entry_1b7bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7bcc: 0x8e050480
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1152)));
    // 0x1b7bd0: 0xc07720a
    SET_GPR_U32(ctx, 31, 0x1b7bd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FreeSwPoxa__FP2SWP3OXA(rdram, ctx, runtime); return;
}


// Function: entry_1b7bd8
// Address: 0x1b7bd8 - 0x1b7bf0

void entry_1b7bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7bd8: 0x8e220038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 56)));
    // 0x1b7bdc: 0x2624003c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 60));
    // 0x1b7be0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b7be4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1b7be8: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1b7bf0);
    WRITE32(ADD32(GPR_U32(ctx, 17), 56), GPR_U32(ctx, 2));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1b7bf0
// Address: 0x1b7bf0 - 0x1b7bfc

void entry_1b7bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7bf0) {
        switch (ctx->pc) {
            case 0x1b7bf4: ctx->pc = 0; goto label_1b7bf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7bf0: 0x8e050540
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1344)));
label_1b7bf4:
    // 0x1b7bf4: 0xc077042
    SET_GPR_U32(ctx, 31, 0x1b7bfc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FreeSwStsoList__FP2SWP4STSO(rdram, ctx, runtime); return;
}


// Function: entry_1b7bfc
// Address: 0x1b7bfc - 0x1b7c24

void entry_1b7bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7bfc: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1b7c00: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1b7c04: 0x319fc
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 7));
    // 0x1b7c08: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b7c0c: 0x14400005
    WRITE32(ADD32(GPR_U32(ctx, 16), 1344), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1b7c24(rdram, ctx, runtime); return;
    }
    // 0x1b7c14: 0x12500004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x1B7C28; return;
    }
    // 0x1b7c1c: 0xc06ed60
    SET_GPR_U32(ctx, 31, 0x1b7c24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RecalcSoLocked__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b7c24
// Address: 0x1b7c24 - 0x1b7c40

void entry_1b7c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7c24) {
        switch (ctx->pc) {
            case 0x1b7c28: ctx->pc = 0; goto label_1b7c28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7c24: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1b7c28:
    // 0x1b7c28: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b7c2c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7c30: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7c34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b7c3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7c40; return;
}


// Function: EnableSoPhys__FP2SOi
// Address: 0x1b7c40 - 0x1b7c80

void entry_1b7c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7c80) {
        switch (ctx->pc) {
            case 0x1b7c88: ctx->pc = 0; goto label_1b7c88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7c80: 0x10000005
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7C98; return;
    }
label_1b7c88:
    // 0x1b7c88: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1b7c8c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1b7c94);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 728));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1b7c94
// Address: 0x1b7c94 - 0x1b7cd4

void entry_1b7c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7c94) {
        switch (ctx->pc) {
            case 0x1b7c98: ctx->pc = 0; goto label_1b7c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7c94: 0xde030538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
label_1b7c98:
    // 0x1b7c98: 0x3c04fffb
    SET_GPR_U32(ctx, 4, ((uint32_t)65531 << 16));
    // 0x1b7c9c: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1b7ca0: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1b7ca4: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1b7ca8: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1b7cac: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1b7cb0: 0x32220001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 1));
    // 0x1b7cb4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b7cb8: 0x214bc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 18));
    // 0x1b7cbc: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1b7cc0: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b7cc4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b7cc8: 0xfe030538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 3));
    // 0x1b7ccc: 0xc04e2f8
    SET_GPR_U32(ctx, 31, 0x1b7cd4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    InvalidateSwXpForObject__FP2SWP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1b7cd4
// Address: 0x1b7cd4 - 0x1b7ce8

void entry_1b7cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7cd4: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1b7cd8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b7cdc: 0x8c6200d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 216)));
    // 0x1b7ce0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b7ce8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b7ce8
// Address: 0x1b7ce8 - 0x1b7d00

void entry_1b7ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7ce8) {
        switch (ctx->pc) {
            case 0x1b7cec: ctx->pc = 0; goto label_1b7cec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7ce8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1b7cec:
    // 0x1b7cec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7cf0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7cf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b7cfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7d00; return;
}


// Function: DisplaceSo__FP2SOi
// Address: 0x1b7d00 - 0x1b7da8

void entry_1b7da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7da8) {
        switch (ctx->pc) {
            case 0x1b7db8: ctx->pc = 0; goto label_1b7db8;
            case 0x1b7e10: ctx->pc = 0; goto label_1b7e10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7da8: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b7dac: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b7db0: 0xfa010490
    WRITE128(ADD32(GPR_U32(ctx, 16), 1168), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b7db4: 0x7a0204a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 1184)));
label_1b7db8:
    // 0x1b7db8: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b7dbc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b7dc0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b7dc4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b7dc8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b7dcc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b7dd0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b7dd4: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b7e10;
    }
    // 0x1b7ddc: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b7de0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b7de4: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b7de8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b7dec: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b7e10;
    }
    // 0x1b7df4: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1b7df8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b7dfc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b7e00: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b7e04: 0x0
    // NOP
    // 0x1b7e08: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1b7e10;
    }
label_1b7e10:
    // 0x1b7e10: 0x14600028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7EB4; return;
    }
    // 0x1b7e18: 0x260404a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1184));
    // 0x1b7e1c: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x1b7e24);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1b7e24
// Address: 0x1b7e24 - 0x1b7ea4

void entry_1b7e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b7e24: 0xda0400d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1b7e28: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1b7e2c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b7e30: 0xdba60010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b7e34: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b7e38: 0x8e0401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 496)));
    // 0x1b7e3c: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1b7e40: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1b7e44: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b7e48: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b7e4c: 0xfba40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b7e50: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1b7e54: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1b7e58: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b7e5c: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b7e60: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b7e64: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b7e68: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b7e6c: 0x4bc111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b7e70: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b7e74: 0x4bc1288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b7e78: 0xfa0400d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b7e7c: 0xfa0300e0
    WRITE128(ADD32(GPR_U32(ctx, 16), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b7e80: 0xfa0200f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b7e84: 0xfba200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b7e88: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b7e8c: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b7e90: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b7e94: 0x10800003
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1b7ea4(rdram, ctx, runtime); return;
    }
    // 0x1b7e9c: 0xc0489b6
    SET_GPR_U32(ctx, 31, 0x1b7ea4);
    AdaptAct__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1b7ea4
// Address: 0x1b7ea4 - 0x1b7f10

void entry_1b7ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7ea4) {
        switch (ctx->pc) {
            case 0x1b7eb4: ctx->pc = 0; goto label_1b7eb4;
            case 0x1b7ef0: ctx->pc = 0; goto label_1b7ef0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7ea4: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b7ea8: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b7eac: 0xfa0104a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 1184), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b7eb0: 0x26030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
label_1b7eb4:
    // 0x1b7eb4: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1b7eb8: 0xafa30064
    WRITE32(ADD32(GPR_U32(ctx, 29), 100), GPR_U32(ctx, 3));
    // 0x1b7ebc: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1b7ec0: 0xafa30060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 3));
    // 0x1b7ec4: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1b7ec8: 0x8c86b314
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1b7ecc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1b7ed0: 0xac85b314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 5));
    // 0x1b7ed4: 0xafa6006c
    WRITE32(ADD32(GPR_U32(ctx, 29), 108), GPR_U32(ctx, 6));
    // 0x1b7ed8: 0x8e030034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1b7edc: 0xafa20068
    WRITE32(ADD32(GPR_U32(ctx, 29), 104), GPR_U32(ctx, 2));
    // 0x1b7ee0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b7ee4: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b7ee8: 0x1080000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 100), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7F28; return;
    }
label_1b7ef0:
    // 0x1b7ef0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b7ef4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1b7ef8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b7efc: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 100)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7F14; return;
    }
    // 0x1b7f04: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x1b7f08: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b7f10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b7f10
// Address: 0x1b7f10 - 0x1b7f50

void entry_1b7f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7f10) {
        switch (ctx->pc) {
            case 0x1b7f14: ctx->pc = 0; goto label_1b7f14;
            case 0x1b7f28: ctx->pc = 0; goto label_1b7f28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7f10: 0x8fa20064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 100)));
label_1b7f14:
    // 0x1b7f14: 0x8fa30068
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 104)));
    // 0x1b7f18: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b7f1c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1b7f20: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 100), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7EF0; return;
    }
label_1b7f28:
    // 0x1b7f28: 0x1220000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 108)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7F54; return;
    }
    // 0x1b7f30: 0x16400009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B7F58; return;
    }
    // 0x1b7f38: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b7f3c: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1b7f40: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 108)));
        ctx->pc = 0x1B7F58; return;
    }
    // 0x1b7f48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b7f50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b7f50
// Address: 0x1b7f50 - 0x1b7f78

void entry_1b7f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b7f50) {
        switch (ctx->pc) {
            case 0x1b7f54: ctx->pc = 0; goto label_1b7f54;
            case 0x1b7f58: ctx->pc = 0; goto label_1b7f58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b7f50: 0x8fa2006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 108)));
label_1b7f54:
    // 0x1b7f54: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_1b7f58:
    // 0x1b7f58: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x1b7f5c: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1b7f60: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b7f64: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b7f68: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b7f6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b7f74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b7f78; return;
}


// Function: ImpactSo__FP2SOi
// Address: 0x1b7f78 - 0x1b8018

void entry_1b8018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8018) {
        switch (ctx->pc) {
            case 0x1b8028: ctx->pc = 0; goto label_1b8028;
            case 0x1b8080: ctx->pc = 0; goto label_1b8080;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8018: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b801c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b8020: 0xfa010490
    WRITE128(ADD32(GPR_U32(ctx, 16), 1168), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b8024: 0x7a0204a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 1184)));
label_1b8028:
    // 0x1b8028: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b802c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b8030: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b8034: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b8038: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b803c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b8040: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8044: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b8080;
    }
    // 0x1b804c: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b8050: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b8054: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b8058: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b805c: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b8080;
    }
    // 0x1b8064: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1b8068: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b806c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b8070: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8074: 0x0
    // NOP
    // 0x1b8078: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1b8080;
    }
label_1b8080:
    // 0x1b8080: 0x1460000d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B80B8; return;
    }
    // 0x1b8088: 0xda010160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x1b808c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b8090: 0x8e0401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 496)));
    // 0x1b8094: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b8098: 0x10800003
    WRITE128(ADD32(GPR_U32(ctx, 16), 352), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1b80a8(rdram, ctx, runtime); return;
    }
    // 0x1b80a0: 0xc0489b6
    SET_GPR_U32(ctx, 31, 0x1b80a8);
    AdaptAct__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1b80a8
// Address: 0x1b80a8 - 0x1b8110

void entry_1b80a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b80a8) {
        switch (ctx->pc) {
            case 0x1b80b8: ctx->pc = 0; goto label_1b80b8;
            case 0x1b80f0: ctx->pc = 0; goto label_1b80f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b80a8: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b80ac: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b80b0: 0xfa0104a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 1184), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b80b4: 0x26030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
label_1b80b8:
    // 0x1b80b8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1b80bc: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1b80c0: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1b80c4: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1b80c8: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1b80cc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1b80d0: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1b80d4: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1b80d8: 0x8e030034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1b80dc: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1b80e0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b80e4: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b80e8: 0x1080000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8128; return;
    }
label_1b80f0:
    // 0x1b80f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b80f4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1b80f8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b80fc: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8114; return;
    }
    // 0x1b8104: 0x8c6200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 208)));
    // 0x1b8108: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b8110);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b8110
// Address: 0x1b8110 - 0x1b8148

void entry_1b8110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8110) {
        switch (ctx->pc) {
            case 0x1b8114: ctx->pc = 0; goto label_1b8114;
            case 0x1b8128: ctx->pc = 0; goto label_1b8128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8110: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1b8114:
    // 0x1b8114: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1b8118: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b811c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1b8120: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B80F0; return;
    }
label_1b8128:
    // 0x1b8128: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1b812c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b8130: 0xae42b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 2));
    // 0x1b8134: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b8138: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b813c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b8140: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PivotSo__FP2SOi
// Address: 0x1b8148 - 0x1b8220

void entry_1b8220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8220) {
        switch (ctx->pc) {
            case 0x1b8230: ctx->pc = 0; goto label_1b8230;
            case 0x1b828c: ctx->pc = 0; goto label_1b828c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8220: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b8224: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b8228: 0xfa010490
    WRITE128(ADD32(GPR_U32(ctx, 16), 1168), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b822c: 0x7a0204a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 1184)));
label_1b8230:
    // 0x1b8230: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b8234: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b8238: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b823c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b8240: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b8244: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b8248: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b824c: 0x0
    // NOP
    // 0x1b8250: 0x4500000e
    SET_GPR_VEC(ctx, 3, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b828c;
    }
    // 0x1b8258: 0x700317c9
    SET_GPR_VEC(ctx, 2, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b825c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b8260: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b8264: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8268: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b828c;
    }
    // 0x1b8270: 0x700314a8
    SET_GPR_VEC(ctx, 2, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x1b8274: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b8278: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b827c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8280: 0x0
    // NOP
    // 0x1b8284: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1b828c;
    }
label_1b828c:
    // 0x1b828c: 0x54800034
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
        ctx->pc = 0x1B8360; return;
    }
    // 0x1b8294: 0xda010160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x1b8298: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b829c: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1b82a0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1b82a4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b82a8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b82ac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b82b0: 0xfa010160
    WRITE128(ADD32(GPR_U32(ctx, 16), 352), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b82b4: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b82b8: 0xda0204a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1184)));
    // 0x1b82bc: 0xc4401860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[0] = *(float*)&val; }
    // 0x1b82c0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1b82c4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b82c8: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b82cc: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b82d0: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b82d4: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x1b82dc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1b82dc
// Address: 0x1b82dc - 0x1b8350

void entry_1b82dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b82dc: 0xda0400d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1b82e0: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1b82e4: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b82e8: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b82ec: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b82f0: 0x8e0401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 496)));
    // 0x1b82f4: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1b82f8: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1b82fc: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b8300: 0xfba40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b8304: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b8308: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1b830c: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1b8310: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b8314: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b8318: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b831c: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b8320: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b8324: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b8328: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b832c: 0x4bc128ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b8330: 0xfa0400d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b8334: 0xfa0200e0
    WRITE128(ADD32(GPR_U32(ctx, 16), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b8338: 0xfa0300f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b833c: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b8340: 0x10800003
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1b8350(rdram, ctx, runtime); return;
    }
    // 0x1b8348: 0xc0489b6
    SET_GPR_U32(ctx, 31, 0x1b8350);
    AdaptAct__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1b8350
// Address: 0x1b8350 - 0x1b83b8

void entry_1b8350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8350) {
        switch (ctx->pc) {
            case 0x1b8360: ctx->pc = 0; goto label_1b8360;
            case 0x1b8398: ctx->pc = 0; goto label_1b8398;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8350: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b8354: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b8358: 0xfa0104a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 1184), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b835c: 0x26030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
label_1b8360:
    // 0x1b8360: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1b8364: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1b8368: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1b836c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1b8370: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1b8374: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1b8378: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1b837c: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1b8380: 0x8e030034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1b8384: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1b8388: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1b838c: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b8390: 0x1080000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B83D0; return;
    }
label_1b8398:
    // 0x1b8398: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b839c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1b83a0: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1b83a4: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B83BC; return;
    }
    // 0x1b83ac: 0x8c6200d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 212)));
    // 0x1b83b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b83b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b83b8
// Address: 0x1b83b8 - 0x1b83f8

void entry_1b83b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b83b8) {
        switch (ctx->pc) {
            case 0x1b83bc: ctx->pc = 0; goto label_1b83bc;
            case 0x1b83d0: ctx->pc = 0; goto label_1b83d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b83b8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1b83bc:
    // 0x1b83bc: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1b83c0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b83c4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1b83c8: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8398; return;
    }
label_1b83d0:
    // 0x1b83d0: 0x1220000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B83FC; return;
    }
    // 0x1b83d8: 0x16600009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8400; return;
    }
    // 0x1b83e0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b83e4: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1b83e8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
        ctx->pc = 0x1B8400; return;
    }
    // 0x1b83f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b83f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b83f8
// Address: 0x1b83f8 - 0x1b8420

void entry_1b83f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b83f8) {
        switch (ctx->pc) {
            case 0x1b83fc: ctx->pc = 0; goto label_1b83fc;
            case 0x1b8400: ctx->pc = 0; goto label_1b8400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b83f8: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_1b83fc:
    // 0x1b83fc: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_1b8400:
    // 0x1b8400: 0xae42b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 2));
    // 0x1b8404: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1b8408: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b840c: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b8410: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b8414: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b841c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b8420; return;
}


// Function: ExtendSoBounds__FP2SOP6VECTORf
// Address: 0x1b8420 - 0x1b8540

void entry_1b8978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b8978: 0x26110110
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1b897c: 0x7a060140
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1b8980: 0x26040380
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 896));
    // 0x1b8984: 0x260503a4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 932));
    // 0x1b8988: 0xc06e208
    SET_GPR_U32(ctx, 31, 0x1b8990);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1b8990
// Address: 0x1b8990 - 0x1b89a4

void entry_1b8990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b8990: 0x7a060140
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1b8994: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b8998: 0x260404e8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1256));
    // 0x1b899c: 0xc06e208
    SET_GPR_U32(ctx, 31, 0x1b89a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1292));
    UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1b89a4
// Address: 0x1b89a4 - 0x1b89b8

void entry_1b89a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b89a4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b89a8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b89ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b89b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSoXfWorld__FP2SO
// Address: 0x1b89b8 - 0x1b89cc

void entry_1b89cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b89cc: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1b89d0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b89d4: 0x8c6200d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 216)));
    // 0x1b89d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b89e0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b89e0
// Address: 0x1b89e0 - 0x1b89f0

void entry_1b89e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b89e0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b89e4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b89e8: 0xc04e2f8
    SET_GPR_U32(ctx, 31, 0x1b89f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    InvalidateSwXpForObject__FP2SWP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1b89f0
// Address: 0x1b89f0 - 0x1b89f8

void entry_1b89f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b89f0: 0xc04e272
    SET_GPR_U32(ctx, 31, 0x1b89f8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    InvalidateSwAaox__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1b89f8
// Address: 0x1b89f8 - 0x1b8a08

void entry_1b89f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b89f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b89fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b8a00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIgnoreSoIntersection__FP2SOT0
// Address: 0x1b8a08 - 0x1b8a48

void entry_1b8ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b8ab4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b8ab8: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x1B8ADC; return;
    }
    // 0x1b8ac0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b8ac4: 0x8c420114
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 276)));
    // 0x1b8ac8: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b8ad8(rdram, ctx, runtime); return;
    }
    // 0x1b8ad0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b8ad8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b8ad8
// Address: 0x1b8ad8 - 0x1b8b30

void entry_1b8ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8ad8) {
        switch (ctx->pc) {
            case 0x1b8adc: ctx->pc = 0; goto label_1b8adc;
            case 0x1b8af0: ctx->pc = 0; goto label_1b8af0;
            case 0x1b8b08: ctx->pc = 0; goto label_1b8b08;
            case 0x1b8b14: ctx->pc = 0; goto label_1b8b14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8ad8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_1b8adc:
    // 0x1b8adc: 0x2a420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    // 0x1b8ae0: 0x1440fff1
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8AA8; return;
    }
    // 0x1b8ae8: 0xae0000c4
    WRITE32(ADD32(GPR_U32(ctx, 16), 196), GPR_U32(ctx, 0));
    // 0x1b8aec: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_1b8af0:
    // 0x1b8af0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        goto label_1b8b08;
    }
    // 0x1b8af8: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1b8afc: 0x5600ffe4
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 196)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1B8A90; return;
    }
    // 0x1b8b04: 0x8e730004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
label_1b8b08:
    // 0x1b8b08: 0x5660ffdb
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1B8A78; return;
    }
    // 0x1b8b10: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1b8b14:
    // 0x1b8b14: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b8b18: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b8b1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b8b20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b8b24: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1b8b28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UProjectVector__FP6VECTORN20
// Address: 0x1b8b30 - 0x1b8b90

void entry_1b8cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8cb0) {
        switch (ctx->pc) {
            case 0x1b8cb4: ctx->pc = 0; goto label_1b8cb4;
            case 0x1b8cd8: ctx->pc = 0; goto label_1b8cd8;
            case 0x1b8cf4: ctx->pc = 0; goto label_1b8cf4;
            case 0x1b8d04: ctx->pc = 0; goto label_1b8d04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8cb0: 0x8fa30044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
label_1b8cb4:
    // 0x1b8cb4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b8cb8: 0x1062000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b8cf4;
    }
    // 0x1b8cc0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
        goto label_1b8cd8;
    }
    // 0x1b8cc8: 0x106000b9
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8FB0; return;
    }
    // 0x1b8cd0: 0x10000091
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 968)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8F18; return;
    }
label_1b8cd8:
    // 0x1b8cd8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1b8cdc: 0x10620009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1b8d04;
    }
    // 0x1b8ce4: 0x10620022
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1B8D70; return;
    }
    // 0x1b8cec: 0x1000008a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 968)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8F18; return;
    }
label_1b8cf4:
    // 0x1b8cf4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b8cf8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b8cfc: 0x10000085
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8F14; return;
    }
label_1b8d04:
    // 0x1b8d04: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b8d08: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b8d0c: 0x24460010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1b8d10: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1b8d14: 0x8ee203ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 940)));
    // 0x1b8d18: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x1b8d1c: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x1b8d20: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1b8d24: 0xc06e2cc
    SET_GPR_U32(ctx, 31, 0x1b8d2c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    UProjectVector__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_1b8d2c
// Address: 0x1b8d2c - 0x1b8de8

void entry_1b8d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8d2c) {
        switch (ctx->pc) {
            case 0x1b8d58: ctx->pc = 0; goto label_1b8d58;
            case 0x1b8d70: ctx->pc = 0; goto label_1b8d70;
            case 0x1b8d90: ctx->pc = 0; goto label_1b8d90;
            case 0x1b8db4: ctx->pc = 0; goto label_1b8db4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8d2c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1b8d30: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b8d34: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1b8d38: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8d3c: 0x45010006
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b8d58;
    }
    // 0x1b8d44: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8d48: 0x0
    // NOP
    // 0x1b8d4c: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b8d58;
    }
    // 0x1b8d54: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_1b8d58:
    // 0x1b8d58: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b8d5c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b8d60: 0xe7a10014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    // 0x1b8d64: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b8d68: 0x1000006a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8F14; return;
    }
label_1b8d70:
    // 0x1b8d70: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b8d74: 0x8ef503ac
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 23), 940)));
    // 0x1b8d78: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b8d7c: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1b8d80: 0xafa2004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 2));
    // 0x1b8d84: 0xafa30048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    // 0x1b8d88: 0x27be0020
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1b8d8c: 0x24160003
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 3));
label_1b8d90:
    // 0x1b8d90: 0x24820002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 2));
    // 0x1b8d94: 0x24940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1b8d98: 0x56001a
    { int32_t divisor = GPR_S32(ctx, 22); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 22) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,22); } }
    // 0x1b8d9c: 0x49080
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1b8da0: 0x141080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 20), 2));
    // 0x1b8da4: 0x3b28821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 18)));
    // 0x1b8da8: 0x3a28021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1b8dac: 0x52c00001
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1b8db4;
    }
label_1b8db4:
    // 0x1b8db4: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b8db8: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b8dbc: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x1b8dc0: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x1b8dc4: 0x2a42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 4)));
    // 0x1b8dc8: 0x2a52821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 5)));
    // 0x1b8dcc: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1b8dd0: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1b8dd4: 0x3a39821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    // 0x1b8dd8: 0x8e660000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1b8ddc: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1b8de0: 0xc06e2cc
    SET_GPR_U32(ctx, 31, 0x1b8de8);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 6)));
    UProjectVector__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_1b8de8
// Address: 0x1b8de8 - 0x1b8e70

void entry_1b8de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8de8) {
        switch (ctx->pc) {
            case 0x1b8e40: ctx->pc = 0; goto label_1b8e40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8de8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1b8dec: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1b8df0: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1b8df4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b8df8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b8dfc: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1b8e00: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b8e04: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1b8e08: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1b8e0c: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1b8e10: 0x751821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x1b8e14: 0x8fa60048
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1b8e18: 0xd8460000
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b8e1c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b8e20: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b8e24: 0xfba50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1b8e28: 0x3c023f80
    SET_GPR_U32(ctx, 2, ((uint32_t)16256 << 16));
    // 0x1b8e2c: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b8e30: 0xd8640000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b8e34: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b8e38: 0x52c00001
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1b8e40;
    }
label_1b8e40:
    // 0x1b8e40: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1b8e44: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1b8e48: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1b8e4c: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b8e50: 0x4be231bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1b8e54: 0x4be520bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1b8e58: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b8e5c: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b8e60: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b8e64: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x1b8e68: 0xc06e2cc
    SET_GPR_U32(ctx, 31, 0x1b8e70);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 4)));
    UProjectVector__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_1b8e70
// Address: 0x1b8e70 - 0x1b8f98

void entry_1b8e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8e70) {
        switch (ctx->pc) {
            case 0x1b8ebc: ctx->pc = 0; goto label_1b8ebc;
            case 0x1b8ee4: ctx->pc = 0; goto label_1b8ee4;
            case 0x1b8ef8: ctx->pc = 0; goto label_1b8ef8;
            case 0x1b8f14: ctx->pc = 0; goto label_1b8f14;
            case 0x1b8f18: ctx->pc = 0; goto label_1b8f18;
            case 0x1b8f48: ctx->pc = 0; goto label_1b8f48;
            case 0x1b8f84: ctx->pc = 0; goto label_1b8f84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8e70: 0x8fa3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x1b8e74: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b8e78: 0x28820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    // 0x1b8e7c: 0x729021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x1b8e80: 0x1440ffc3
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8D90; return;
    }
    // 0x1b8e88: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1b8e8c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1b8e90: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b8e94: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1b8e98: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8e9c: 0x0
    // NOP
    // 0x1b8ea0: 0x45010006
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b8ebc;
    }
    // 0x1b8ea8: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8eac: 0x0
    // NOP
    // 0x1b8eb0: 0x45000002
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b8ebc;
    }
    // 0x1b8eb8: 0x46001886
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
label_1b8ebc:
    // 0x1b8ebc: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1b8ec0: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1b8ec4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b8ec8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b8ecc: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8ed0: 0xe7a20010
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1b8ed4: 0x45000003
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b8ee4;
    }
    // 0x1b8edc: 0x10000006
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b8ef8;
    }
label_1b8ee4:
    // 0x1b8ee4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b8ee8: 0x0
    // NOP
    // 0x1b8eec: 0x45000002
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b8ef8;
    }
    // 0x1b8ef4: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
label_1b8ef8:
    // 0x1b8ef8: 0xc7a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1b8efc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b8f00: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b8f04: 0xe7a20014
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    // 0x1b8f08: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1b8f0c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1b8f10: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
label_1b8f14:
    // 0x1b8f14: 0x8ee303c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 968)));
label_1b8f18:
    // 0x1b8f18: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1b8f1c: 0x10400024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B8FB0; return;
    }
    // 0x1b8f24: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b8f28: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1b8f2c: 0x27be0020
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1b8f30: 0x10400014
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b8f84;
    }
    // 0x1b8f38: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1b8f3c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b8f40: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b8f44: 0x0
    // NOP
label_1b8f48:
    // 0x1b8f48: 0x8c830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1b8f4c: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1b8f50: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1b8f54: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b8f58: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1b8f5c: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1b8f60: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b8f64: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1b8f68: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b8f6c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b8f70: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b8f74: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b8f78: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b8f7c: 0x14a0fff2
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1b8f48;
    }
label_1b8f84:
    // 0x1b8f84: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1b8f88: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1b8f8c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b8f90: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1b8f98);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1b8f98
// Address: 0x1b8f98 - 0x1b8fe0

void entry_1b8f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b8f98) {
        switch (ctx->pc) {
            case 0x1b8fac: ctx->pc = 0; goto label_1b8fac;
            case 0x1b8fb0: ctx->pc = 0; goto label_1b8fb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b8f98: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b8f9c: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b8fa0: 0xd8410030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1b8fa4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b8fa8: 0xf8410030
    WRITE128(ADD32(GPR_U32(ctx, 2), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_1b8fac:
    // 0x1b8fac: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1b8fb0:
    // 0x1b8fb0: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1b8fb4: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b8fb8: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b8fbc: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b8fc0: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b8fc4: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b8fc8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b8fcc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b8fd0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b8fd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b8fdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b8fe0; return;
}


// Function: junk_001B8FE0
// Address: 0x1b8fe0 - 0x1b8fe8

void entry_1b9198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9198: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b919c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b91a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b91a8; return;
}


// Function: AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f
// Address: 0x1b91a8 - 0x1b91f8

void entry_1b91f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b91f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b91fc: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1b9200: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1b9208);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1b9208
// Address: 0x1b9208 - 0x1b9310

void entry_1b9208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9208) {
        switch (ctx->pc) {
            case 0x1b925c: ctx->pc = 0; goto label_1b925c;
            case 0x1b92e8: ctx->pc = 0; goto label_1b92e8;
            case 0x1b9308: ctx->pc = 0; goto label_1b9308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9208: 0xc7a30060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[3] = *(float*)&val; }
    // 0x1b920c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b9210: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b9214: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b9218: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b921c: 0x0
    // NOP
    // 0x1b9220: 0x4500000e
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b925c;
    }
    // 0x1b9228: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1b922c: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1b9230: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1b9234: 0xc6220000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1b9238: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1b923c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1b9240: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1b9244: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1b9248: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b924c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b9250: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9254: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b9258: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_1b925c:
    // 0x1b925c: 0x1240002a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1b9308;
    }
    // 0x1b9264: 0xda820000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1b9268: 0xda610160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 352)));
    // 0x1b926c: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9270: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1b9274: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1b9278: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b927c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1b9280: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b9284: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b9288: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b928c: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b9290: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b9294: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b9298: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1b929c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b92a0: 0x44822000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 2);
    // 0x1b92a4: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b92a8: 0x45000017
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b9308;
    }
    // 0x1b92b0: 0xc6420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1b92b4: 0xc6410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1b92b8: 0x46041083
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[4];
    // 0x1b92bc: 0xc6430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1b92c0: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x1b92c4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b92c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b92cc: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1b92d0: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1b92d4: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1b92d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b92dc: 0x0
    // NOP
    // 0x1b92e0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[0]);
        goto label_1b92e8;
    }
label_1b92e8:
    // 0x1b92e8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1b92ec: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b92f0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b92f4: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b92f8: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b92fc: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b9300: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b9304: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1b9308:
    // 0x1b9308: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x1b9310);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1b9310
// Address: 0x1b9310 - 0x1b9338

void entry_1b9310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9310: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b9314: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b9318: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b931c: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b9320: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b9324: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b9328: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x1b932c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b9334: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9338; return;
}


// Function: PresetSoAccel__FP2SOf
// Address: 0x1b9338 - 0x1b9384

void entry_1b9384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9384: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b9388: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1b9390);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1b9390
// Address: 0x1b9390 - 0x1b93b4

void entry_1b9390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9390) {
        switch (ctx->pc) {
            case 0x1b9394: ctx->pc = 0; goto label_1b9394;
            case 0x1b93a0: ctx->pc = 0; goto label_1b93a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9390: 0x8e1004b0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1200)));
label_1b9394:
    // 0x1b9394: 0x1200000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B93C4; return;
    }
    // 0x1b939c: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b93a0:
    // 0x1b93a0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b93a4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1b93a8: 0x8c6200dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 220)));
    // 0x1b93ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b93b4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b93b4
// Address: 0x1b93b4 - 0x1b93d8

void entry_1b93b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b93b4) {
        switch (ctx->pc) {
            case 0x1b93c4: ctx->pc = 0; goto label_1b93c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b93b4: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1b93b8: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1B93A0; return;
    }
    // 0x1b93c0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1b93c4:
    // 0x1b93c4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b93c8: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1b93cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b93d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b93d8; return;
}


// Function: RenderSoSelf__FP2SOP2CMP2RO
// Address: 0x1b93d8 - 0x1b93e8

void entry_1b93e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b93e8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b93ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b93f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b93f8; return;
}


// Function: UpdateSo__FP2SOf
// Address: 0x1b93f8 - 0x1b9408

void entry_1b9408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9408: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b940c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b9414: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9418; return;
}


// Function: SetSoMass__FP2SOf
// Address: 0x1b9418 - 0x1b9438

void entry_1b9438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9438: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b943c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b9444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9448; return;
}


// Function: AdjustSoMomint__FP2SOf
// Address: 0x1b9448 - 0x1b94a0

void entry_1b94a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b94a0: 0x7ba60000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b94a4: 0x260402f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 752));
    // 0x1b94a8: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b94ac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b94b0: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b94b4: 0x7e0602f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 752), GPR_VEC(ctx, 6));
    // 0x1b94b8: 0x7e030300
    WRITE128(ADD32(GPR_U32(ctx, 16), 768), GPR_VEC(ctx, 3));
    // 0x1b94bc: 0xc0625fc
    SET_GPR_U32(ctx, 31, 0x1b94c4);
    WRITE128(ADD32(GPR_U32(ctx, 16), 784), GPR_VEC(ctx, 2));
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime); return;
}


// Function: entry_1b94c4
// Address: 0x1b94c4 - 0x1b94dc

void entry_1b94c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b94c4: 0x14400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B94E0; return;
    }
    // 0x1b94cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b94d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b94d4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1b94dc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1b94dc
// Address: 0x1b94dc - 0x1b94f0

void entry_1b94dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b94dc) {
        switch (ctx->pc) {
            case 0x1b94e0: ctx->pc = 0; goto label_1b94e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b94dc: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1b94e0:
    // 0x1b94e0: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b94e4: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b94e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DiscardSoXps__FP2SO
// Address: 0x1b94f0 - 0x1b95b8

void entry_1b95b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b95b8) {
        switch (ctx->pc) {
            case 0x1b95c8: ctx->pc = 0; goto label_1b95c8;
            case 0x1b95d8: ctx->pc = 0; goto label_1b95d8;
            case 0x1b9600: ctx->pc = 0; goto label_1b9600;
            case 0x1b9618: ctx->pc = 0; goto label_1b9618;
            case 0x1b9624: ctx->pc = 0; goto label_1b9624;
            case 0x1b963c: ctx->pc = 0; goto label_1b963c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b95b8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b95bc: 0x7ba60000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b95c0: 0x1000000f
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b9600;
    }
label_1b95c8:
    // 0x1b95c8: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1b95cc: 0x541026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1b95d0: 0x1000000b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b9600;
    }
label_1b95d8:
    // 0x1b95d8: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1b95dc: 0x14540008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        goto label_1b9600;
    }
    // 0x1b95e4: 0x14800006
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1b9600;
    }
    // 0x1b95ec: 0x8e02009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    // 0x1b95f0: 0x2a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1b95f4: 0x2442fff8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967288));
    // 0x1b95f8: 0x2a2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x1b95fc: 0x2180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
label_1b9600:
    // 0x1b9600: 0x50600005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 208));
        goto label_1b9618;
    }
    // 0x1b9608: 0x8e0200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1b960c: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x1b9610: 0xae1e00d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 208), GPR_U32(ctx, 30));
    // 0x1b9614: 0x200f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1b9618:
    // 0x1b9618: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b961c: 0x5600ffd2
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1B9568; return;
    }
label_1b9624:
    // 0x1b9624: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1b9628: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b962c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1b9630: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1b9634: 0x5620ffc4
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1B9548; return;
    }
label_1b963c:
    // 0x1b963c: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1b9640: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1b9648);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1b9648
// Address: 0x1b9648 - 0x1b9680

void entry_1b9648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9648) {
        switch (ctx->pc) {
            case 0x1b964c: ctx->pc = 0; goto label_1b964c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9648: 0xaee004b8
    WRITE32(ADD32(GPR_U32(ctx, 23), 1208), GPR_U32(ctx, 0));
label_1b964c:
    // 0x1b964c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b9650: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b9654: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b9658: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b965c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b9660: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b9664: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b9668: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b966c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b9670: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b9674: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b967c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9680; return;
}


// Function: UpdateSoPosWorldPrev__FP2SO
// Address: 0x1b9680 - 0x1b9690

void entry_1b9728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9728: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b972c: 0x8e230050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1b9730: 0x1060001e
    WRITE128(ADD32(GPR_U32(ctx, 17), 256), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B97AC; return;
    }
    // 0x1b9738: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1b973c: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1b9740: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B9754; return;
    }
    // 0x1b9748: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b9750);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b9750
// Address: 0x1b9750 - 0x1b975c

void entry_1b9750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9750) {
        switch (ctx->pc) {
            case 0x1b9754: ctx->pc = 0; goto label_1b9754;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9750: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1b9754:
    // 0x1b9754: 0xc06e53c
    SET_GPR_U32(ctx, 31, 0x1b975c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    DiscardSoXps__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b975c
// Address: 0x1b975c - 0x1b9788

void entry_1b975c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b975c) {
        switch (ctx->pc) {
            case 0x1b9770: ctx->pc = 0; goto label_1b9770;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b975c: 0x8e320050
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1b9760: 0x8e5002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x1b9764: 0x52000012
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1B97B0; return;
    }
    // 0x1b976c: 0x0
    // NOP
label_1b9770:
    // 0x1b9770: 0x52320008
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1B9794; return;
    }
    // 0x1b9778: 0x12300005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x1B9790; return;
    }
    // 0x1b9780: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x1b9788);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1b9788
// Address: 0x1b9788 - 0x1b97a0

void entry_1b9788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9788) {
        switch (ctx->pc) {
            case 0x1b9790: ctx->pc = 0; goto label_1b9790;
            case 0x1b9794: ctx->pc = 0; goto label_1b9794;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9788: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x1B97A4; return;
    }
label_1b9790:
    // 0x1b9790: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b9794:
    // 0x1b9794: 0x8c620120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 288)));
    // 0x1b9798: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b97a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b97a0
// Address: 0x1b97a0 - 0x1b97c4

void entry_1b97a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b97a0) {
        switch (ctx->pc) {
            case 0x1b97a4: ctx->pc = 0; goto label_1b97a4;
            case 0x1b97ac: ctx->pc = 0; goto label_1b97ac;
            case 0x1b97b0: ctx->pc = 0; goto label_1b97b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b97a0: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_1b97a4:
    // 0x1b97a4: 0x1600fff2
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B9770; return;
    }
label_1b97ac:
    // 0x1b97ac: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1b97b0:
    // 0x1b97b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b97b4: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1b97b8: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x1b97bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b97c4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b97c4
// Address: 0x1b97c4 - 0x1b97e0

void entry_1b97c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b97c4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b97c8: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b97cc: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b97d0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b97d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b97dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b97e0; return;
}


// Function: RotateSoToMat__FP2SOP7MATRIX3
// Address: 0x1b97e0 - 0x1b9828

void entry_1b9828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9828) {
        switch (ctx->pc) {
            case 0x1b982c: ctx->pc = 0; goto label_1b982c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9828: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1b982c:
    // 0x1b982c: 0xc06e53c
    SET_GPR_U32(ctx, 31, 0x1b9834);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    DiscardSoXps__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b9834
// Address: 0x1b9834 - 0x1b984c

void entry_1b9834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9834: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b9838: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b983c: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1b9840: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x1b9844: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1b984c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1b984c
// Address: 0x1b984c - 0x1b9860

void entry_1b984c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b984c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b9850: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1b9854: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b985c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9860; return;
}


// Function: TranslateSoToPosSafe__FP2SOP6VECTORT1
// Address: 0x1b9860 - 0x1b989c

void entry_1b989c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b989c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1b98a0: 0xc04e300
    SET_GPR_U32(ctx, 31, 0x1b98a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RecalcSwXpAll__FP2SWi(rdram, ctx, runtime); return;
}


// Function: entry_1b98a8
// Address: 0x1b98a8 - 0x1b9938

void entry_1b98a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b98a8) {
        switch (ctx->pc) {
            case 0x1b98c0: ctx->pc = 0; goto label_1b98c0;
            case 0x1b98d8: ctx->pc = 0; goto label_1b98d8;
            case 0x1b98f8: ctx->pc = 0; goto label_1b98f8;
            case 0x1b9908: ctx->pc = 0; goto label_1b9908;
            case 0x1b9920: ctx->pc = 0; goto label_1b9920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b98a8: 0x8e020480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1152)));
    // 0x1b98ac: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b98b0: 0x1040001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1b9920;
    }
    // 0x1b98b8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1b98bc: 0x0
    // NOP
label_1b98c0:
    // 0x1b98c0: 0x5060000d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
        goto label_1b98f8;
    }
    // 0x1b98c8: 0x3c01c000
    SET_GPR_U32(ctx, 1, ((uint32_t)49152 << 16));
    // 0x1b98cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b98d0: 0xc4600090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 144)); ctx->f[0] = *(float*)&val; }
    // 0x1b98d4: 0x0
    // NOP
label_1b98d8:
    // 0x1b98d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b98dc: 0x0
    // NOP
    // 0x1b98e0: 0x45010009
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1b9908;
    }
    // 0x1b98e8: 0x8c6300d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 208)));
    // 0x1b98ec: 0x5460fffa
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 144)); ctx->f[0] = *(float*)&val; }
        goto label_1b98d8;
    }
    // 0x1b98f4: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
label_1b98f8:
    // 0x1b98f8: 0x5440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
        goto label_1b98c0;
    }
    // 0x1b9900: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b9920;
    }
label_1b9908:
    // 0x1b9908: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1b990c: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1b9910: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9914: 0x621ffdc
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x1B9888; return;
    }
    // 0x1b991c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1b9920:
    // 0x1b9920: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b9924: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b9928: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b992c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b9934: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9938; return;
}


// Function: junk_001B9938
// Address: 0x1b9938 - 0x1b9940

void entry_1b995c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b995c) {
        switch (ctx->pc) {
            case 0x1b99c4: ctx->pc = 0; goto label_1b99c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b995c: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b9960: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b9964: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x1b9968: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b996c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1b9970: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b9974: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b9978: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b997c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b9980: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b9984: 0x0
    // NOP
    // 0x1b9988: 0x4500000e
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b99c4;
    }
    // 0x1b9990: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b9994: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b9998: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b999c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b99a0: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b99c4;
    }
    // 0x1b99a8: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1b99ac: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b99b0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b99b4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b99b8: 0x0
    // NOP
    // 0x1b99bc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1b99c4;
    }
label_1b99c4:
    // 0x1b99c4: 0x14600006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B99E0; return;
    }
    // 0x1b99cc: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1b99d0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b99d4: 0xc04e2f8
    SET_GPR_U32(ctx, 31, 0x1b99dc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    InvalidateSwXpForObject__FP2SWP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1b99dc
// Address: 0x1b99dc - 0x1b99f0

void entry_1b99dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b99dc) {
        switch (ctx->pc) {
            case 0x1b99e0: ctx->pc = 0; goto label_1b99e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b99dc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1b99e0:
    // 0x1b99e0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b99e4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b99e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSoAngularVelocityVec__FP2SOP6VECTOR
// Address: 0x1b99f0 - 0x1b9a0c

void entry_1b9a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9a0c) {
        switch (ctx->pc) {
            case 0x1b9a78: ctx->pc = 0; goto label_1b9a78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9a0c: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1b9a10: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b9a14: 0xda210160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 352)));
    // 0x1b9a18: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9a1c: 0x3c013ca3
    SET_GPR_U32(ctx, 1, ((uint32_t)15523 << 16));
    // 0x1b9a20: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x1b9a24: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b9a28: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b9a2c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1b9a30: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b9a34: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b9a38: 0x0
    // NOP
    // 0x1b9a3c: 0x4500000e
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b9a78;
    }
    // 0x1b9a44: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1b9a48: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b9a4c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b9a50: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b9a54: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b9a78;
    }
    // 0x1b9a5c: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1b9a60: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1b9a64: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1b9a68: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b9a6c: 0x0
    // NOP
    // 0x1b9a70: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1b9a78;
    }
label_1b9a78:
    // 0x1b9a78: 0x14600006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B9A94; return;
    }
    // 0x1b9a80: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1b9a84: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b9a88: 0xc04e2f8
    SET_GPR_U32(ctx, 31, 0x1b9a90);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    InvalidateSwXpForObject__FP2SWP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1b9a90
// Address: 0x1b9a90 - 0x1b9aa8

void entry_1b9a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9a90) {
        switch (ctx->pc) {
            case 0x1b9a94: ctx->pc = 0; goto label_1b9a94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9a90: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1b9a94:
    // 0x1b9a94: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b9a98: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1b9a9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b9aa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9aa8; return;
}


// Function: junk_001B9AA8
// Address: 0x1b9aa8 - 0x1b9ab0

void entry_1b9b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9b44) {
        switch (ctx->pc) {
            case 0x1b9b48: ctx->pc = 0; goto label_1b9b48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9b44: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1b9b48:
    // 0x1b9b48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSoParent__FP2SOP3ALO
// Address: 0x1b9b50 - 0x1b9b9c

void entry_1b9b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9b9c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b9ba0: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1b9ba4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b9ba8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b9bac: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1b9bb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1b9bb4
// Address: 0x1b9bb4 - 0x1b9bc0

void entry_1b9bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9bb4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1b9bb8: 0xc04916a
    SET_GPR_U32(ctx, 31, 0x1b9bc0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetAloParent__FP3ALOT0(rdram, ctx, runtime); return;
}


// Function: entry_1b9bc0
// Address: 0x1b9bc0 - 0x1b9bd4

void entry_1b9bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9bc0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b9bc4: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b9bc8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1b9bcc: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1b9bd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1b9bd4
// Address: 0x1b9bd4 - 0x1b9be8

void entry_1b9bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9bd4: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1b9bd8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b9bdc: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b9be0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1b9be8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1b9be8
// Address: 0x1b9be8 - 0x1b9c1c

void entry_1b9be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9be8: 0x8e620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 80)));
    // 0x1b9bec: 0x10400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1b9c50(rdram, ctx, runtime); return;
    }
    // 0x1b9bf4: 0xde620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 1336)));
    // 0x1b9bf8: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1b9bfc: 0x319fc
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 7));
    // 0x1b9c00: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b9c04: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 80)));
        ctx->pc = 0x1B9C20; return;
    }
    // 0x1b9c0c: 0x52a00004
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 80)));
        ctx->pc = 0x1B9C20; return;
    }
    // 0x1b9c14: 0xc06ed60
    SET_GPR_U32(ctx, 31, 0x1b9c1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    RecalcSoLocked__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b9c1c
// Address: 0x1b9c1c - 0x1b9c40

void entry_1b9c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9c1c) {
        switch (ctx->pc) {
            case 0x1b9c20: ctx->pc = 0; goto label_1b9c20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9c1c: 0x8e640050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 80)));
label_1b9c20:
    // 0x1b9c20: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1b9c24: 0x31a3c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 8));
    // 0x1b9c28: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1b9c2c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1b9c30: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B9C48; return;
    }
    // 0x1b9c38: 0xc06ed60
    SET_GPR_U32(ctx, 31, 0x1b9c40);
    RecalcSoLocked__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b9c40
// Address: 0x1b9c40 - 0x1b9c50

void entry_1b9c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9c40) {
        switch (ctx->pc) {
            case 0x1b9c48: ctx->pc = 0; goto label_1b9c48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9c40: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1b9c50(rdram, ctx, runtime); return;
    }
label_1b9c48:
    // 0x1b9c48: 0xc06ed60
    SET_GPR_U32(ctx, 31, 0x1b9c50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RecalcSoLocked__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b9c50
// Address: 0x1b9c50 - 0x1b9c58

void entry_1b9c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9c50: 0xc06ed28
    SET_GPR_U32(ctx, 31, 0x1b9c58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RebuildSoPhysHook__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1b9c58
// Address: 0x1b9c58 - 0x1b9c80

void entry_1b9c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9c58: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1b9c5c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1b9c60: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1b9c64: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1b9c68: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b9c6c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b9c70: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b9c74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b9c7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9c80; return;
}


// Function: ApplySoProxy__FP2SOP5PROXY
// Address: 0x1b9c80 - 0x1b9c9c

void entry_1b9c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9c9c: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1b9ca0: 0xda0500d0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1b9ca4: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b9ca8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1b9cac: 0xd8440010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1b9cb0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b9cb4: 0xda210440
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1088)));
    // 0x1b9cb8: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1b9cbc: 0x4bc129bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1b9cc0: 0x4bc120bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b9cc4: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b9cc8: 0xda220460
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1120)));
    // 0x1b9ccc: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b9cd0: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1b9cd4: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1b9cd8: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1b9cdc: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9ce0: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b9ce4: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b9ce8: 0x8c850450
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1104)));
    // 0x1b9cec: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1b9cf4);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 1136)));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1b9cf4
// Address: 0x1b9cf4 - 0x1b9d08

void entry_1b9cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9cf4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b9cf8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b9cfc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1b9d00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001B9D08
// Address: 0x1b9d08 - 0x1b9d10

void entry_1b9dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9dc4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b9dc8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b9dcc: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1b9dd4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1b9dd4
// Address: 0x1b9dd4 - 0x1b9de4

void entry_1b9dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9dd4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1b9dd8: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1b9ddc: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1b9de4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1b9de4
// Address: 0x1b9de4 - 0x1b9df8

void entry_1b9de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9de4: 0xc7ac0080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[12] = *(float*)&val; }
    // 0x1b9de8: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1b9dec: 0x46156303
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[21];
    // 0x1b9df0: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1b9df8);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b9df8
// Address: 0x1b9df8 - 0x1b9e54

void entry_1b9df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9df8: 0xda020160
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x1b9dfc: 0x46000106
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    // 0x1b9e00: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b9e04: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e08: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e0c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e10: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b9e14: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1b9e18: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b9e1c: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b9e20: 0xc7a20080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[2] = *(float*)&val; }
    // 0x1b9e24: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x1b9e28: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x1b9e2c: 0x46041800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[4]);
    // 0x1b9e30: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1b9e34: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1b9e38: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b9e3c: 0x0
    // NOP
    // 0x1b9e40: 0x45000005
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1B9E58; return;
    }
    // 0x1b9e48: 0x46150303
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[21];
    // 0x1b9e4c: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1b9e54);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1b9e54
// Address: 0x1b9e54 - 0x1b9f00

void entry_1b9e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9e54) {
        switch (ctx->pc) {
            case 0x1b9e58: ctx->pc = 0; goto label_1b9e58;
            case 0x1b9edc: ctx->pc = 0; goto label_1b9edc;
            case 0x1b9ee0: ctx->pc = 0; goto label_1b9ee0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9e54: 0x46000106
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
label_1b9e58:
    // 0x1b9e58: 0x44022000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[4]);
    // 0x1b9e5c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b9e60: 0xda010180
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 384)));
    // 0x1b9e64: 0x4402b800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[23]);
    // 0x1b9e68: 0xda030160
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x1b9e6c: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b9e70: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b9e74: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1b9e78: 0x4be508c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b9e7c: 0x4be41098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e80: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1b9e84: 0x4be311ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e88: 0x4617b002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[23]);
    // 0x1b9e8c: 0x4bc6306a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e90: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e94: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b9e98: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1b9e9c: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b9ea0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1b9ea4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1b9ea8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1b9eac: 0xfba50070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1b9eb0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b9eb4: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1b9eb8: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1b9ebc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1b9ec0: 0x0
    // NOP
    // 0x1b9ec4: 0x45000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[6]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1b9edc;
    }
    // 0x1b9ecc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1b9ed0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1b9ed4: 0x10000002
    if (ctx->f[23] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[23];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1b9ee0;
    }
label_1b9edc:
    // 0x1b9edc: 0x4601b003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[22] * 0.0f); } else ctx->f[0] = ctx->f[22] / ctx->f[1];
label_1b9ee0:
    // 0x1b9ee0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1b9ee4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1b9ee8: 0x4be13098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1b9eec: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1b9ef0: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1b9ef4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1b9ef8: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x1b9f00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1b9f00
// Address: 0x1b9f00 - 0x1b9f28

void entry_1b9f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9f00: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1b9f04: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1b9f08: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1b9f0c: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1b9f10: 0xc7b700e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[23] = *(float*)&val; }
    // 0x1b9f14: 0xc7b600e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    // 0x1b9f18: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x1b9f1c: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x1b9f20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001B9F28
// Address: 0x1b9f28 - 0x1b9f30

void entry_1b9f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9f64: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1b9f68: 0xc7ad0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    // 0x1b9f6c: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    // 0x1b9f70: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1b9f78);
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1b9f78
// Address: 0x1b9f78 - 0x1b9fb0

void entry_1b9f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1b9f78: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1b9f7c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1b9f80: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1b9f84: 0xe6000030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x1b9f88: 0xe6010034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1b9f8c: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
    // 0x1b9f90: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1b9f94: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1b9f98: 0xae00003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 0));
    // 0x1b9f9c: 0xe6000038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x1b9fa0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1b9fa4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1b9fac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1b9fb0; return;
}


// Function: FIsSoTouching__FP2SOT0
// Address: 0x1b9fb0 - 0x1b9fdc

void entry_1b9fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1b9fdc) {
        switch (ctx->pc) {
            case 0x1b9ff0: ctx->pc = 0; goto label_1b9ff0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1b9fdc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1b9fe0: 0x12000016
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BA03C; return;
    }
    // 0x1b9fe8: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1b9fec: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b9ff0:
    // 0x1b9ff0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1b9ff4: 0x2831826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 20), GPR_U32(ctx, 3)));
    // 0x1b9ff8: 0x3882b
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1b9ffc: 0x111180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 6));
    // 0x1ba000: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1ba004: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x1ba00c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1ba00c
// Address: 0x1ba00c - 0x1ba028

void entry_1ba00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba00c: 0x10400008
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BA030; return;
    }
    // 0x1ba014: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ba018: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1ba01c: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1ba020: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x1ba028);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1ba028
// Address: 0x1ba028 - 0x1ba068

void entry_1ba028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ba028) {
        switch (ctx->pc) {
            case 0x1ba030: ctx->pc = 0; goto label_1ba030;
            case 0x1ba03c: ctx->pc = 0; goto label_1ba03c;
            case 0x1ba040: ctx->pc = 0; goto label_1ba040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ba028: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ba040;
    }
label_1ba030:
    // 0x1ba030: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1ba034: 0x5600ffee
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1B9FF0; return;
    }
label_1ba03c:
    // 0x1ba03c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ba040:
    // 0x1ba040: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ba044: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ba048: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ba04c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ba050: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ba054: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ba058: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ba05c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ba064: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ba068; return;
}


// Function: PsoFirstSoTouching__FP2SO
// Address: 0x1ba068 - 0x1ba0d4

void entry_1ba0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ba0d4) {
        switch (ctx->pc) {
            case 0x1ba0ec: ctx->pc = 0; goto label_1ba0ec;
            case 0x1ba0fc: ctx->pc = 0; goto label_1ba0fc;
            case 0x1ba108: ctx->pc = 0; goto label_1ba108;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ba0d4: 0x10400005
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ba0ec;
    }
    // 0x1ba0dc: 0x31980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 6));
    // 0x1ba0e0: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1ba0e4: 0x10000008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ba108;
    }
label_1ba0ec:
    // 0x1ba0ec: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1ba0f0: 0x5600fff1
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BA0B8; return;
    }
    // 0x1ba0f8: 0x8e520004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1ba0fc:
    // 0x1ba0fc: 0x5640ffea
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1BA0A8; return;
    }
    // 0x1ba104: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ba108:
    // 0x1ba108: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ba10c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ba110: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ba114: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ba118: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ba11c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ba120: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ba124: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ba12c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ba130; return;
}


// Function: CloneSo__FP2SOT0
// Address: 0x1ba130 - 0x1ba1b8

void entry_1ba1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba1b8: 0xae710480
    WRITE32(ADD32(GPR_U32(ctx, 19), 1152), GPR_U32(ctx, 17));
    // 0x1ba1bc: 0x3c03fffb
    SET_GPR_U32(ctx, 3, ((uint32_t)65531 << 16));
    // 0x1ba1c0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1ba1c4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1ba1c8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1ba1cc: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1ba1d0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1ba1d4: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1ba1d8: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1ba1dc: 0xb26202d7
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 727); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba1e0: 0xb66202d0
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 720); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba1e4: 0x1084bc
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 18));
    // 0x1ba1e8: 0x6ba70037
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1ba1ec: 0x6fa70030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1ba1f0: 0x8fa80038
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1ba1f4: 0xb26702df
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 735); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba1f8: 0xb66702d8
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 728); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba1fc: 0xae6802e0
    WRITE32(ADD32(GPR_U32(ctx, 19), 736), GPR_U32(ctx, 8));
    // 0x1ba200: 0x6ba50017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1ba204: 0x6fa50010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1ba208: 0xb26502eb
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 747); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba20c: 0xb66502e4
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 740); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba210: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ba214: 0x6ba20027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1ba218: 0x6fa20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1ba21c: 0xb262041b
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 1051); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba220: 0xb6620414
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 1044); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ba224: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ba228: 0xae7204e4
    WRITE32(ADD32(GPR_U32(ctx, 19), 1252), GPR_U32(ctx, 18));
    // 0x1ba22c: 0xde620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 1336)));
    // 0x1ba230: 0xae6004b0
    WRITE32(ADD32(GPR_U32(ctx, 19), 1200), GPR_U32(ctx, 0));
    // 0x1ba234: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ba238: 0xae6004b8
    WRITE32(ADD32(GPR_U32(ctx, 19), 1208), GPR_U32(ctx, 0));
    // 0x1ba23c: 0x501025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1ba240: 0xc06df10
    SET_GPR_U32(ctx, 31, 0x1ba248);
    WRITE64(ADD32(GPR_U32(ctx, 19), 1336), GPR_U64(ctx, 2));
    EnableSoPhys__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1ba248
// Address: 0x1ba248 - 0x1ba260

void entry_1ba248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba248: 0x8e6203a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 936)));
    // 0x1ba24c: 0x10400004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 932));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ba260(rdram, ctx, runtime); return;
    }
    // 0x1ba254: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba258: 0xc0583a8
    SET_GPR_U32(ctx, 31, 0x1ba260);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 932));
    CloneGeom__FP4GEOMP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1ba260
// Address: 0x1ba260 - 0x1ba27c

void entry_1ba260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba260: 0x8e6203f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1016)));
    // 0x1ba264: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 932));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ba27c(rdram, ctx, runtime); return;
    }
    // 0x1ba26c: 0x268503f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 1008));
    // 0x1ba270: 0x266603a4
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 932));
    // 0x1ba274: 0xc04f9b2
    SET_GPR_U32(ctx, 31, 0x1ba27c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 1008));
    CloneBspc__FP4GEOMP4BSPCT0T1(rdram, ctx, runtime); return;
}


// Function: entry_1ba27c
// Address: 0x1ba27c - 0x1ba294

void entry_1ba27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba27c: 0x8e620510
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1296)));
    // 0x1ba280: 0x10400004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 1292));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ba294(rdram, ctx, runtime); return;
    }
    // 0x1ba288: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba28c: 0xc0583a8
    SET_GPR_U32(ctx, 31, 0x1ba294);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 1292));
    CloneGeom__FP4GEOMP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1ba294
// Address: 0x1ba294 - 0x1ba2b0

void entry_1ba294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba294: 0x8e620538
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1336)));
    // 0x1ba298: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 1328));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ba2b0(rdram, ctx, runtime); return;
    }
    // 0x1ba2a0: 0x2684050c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 1292));
    // 0x1ba2a4: 0x2666050c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 1292));
    // 0x1ba2a8: 0xc04f9b2
    SET_GPR_U32(ctx, 31, 0x1ba2b0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 1328));
    CloneBspc__FP4GEOMP4BSPCT0T1(rdram, ctx, runtime); return;
}


// Function: entry_1ba2b0
// Address: 0x1ba2b0 - 0x1ba2e8

void entry_1ba2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba2b0: 0xde620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 1336)));
    // 0x1ba2b4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1ba2b8: 0x31eb8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 26);
    // 0x1ba2bc: 0xae600540
    WRITE32(ADD32(GPR_U32(ctx, 19), 1344), GPR_U32(ctx, 0));
    // 0x1ba2c0: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ba2c4: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ba2c8: 0xfe620538
    WRITE64(ADD32(GPR_U32(ctx, 19), 1336), GPR_U64(ctx, 2));
    // 0x1ba2cc: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ba2d0: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ba2d4: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ba2d8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ba2dc: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ba2e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22
// Address: 0x1ba2e8 - 0x1ba430

void entry_1ba51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba51c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ba520: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddSoXa__FP2SOP2XA
// Address: 0x1ba528 - 0x1ba544

void entry_1ba544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba544: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ba548: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveSoXa__FP2SOP2XA
// Address: 0x1ba550 - 0x1ba5a0

void entry_1ba5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba5a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ba5a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ba5ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ba5b0; return;
}


// Function: AddSoWaterAcceleration__FP2SOP5WATERf
// Address: 0x1ba5b0 - 0x1ba610

void entry_1ba610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba610: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1ba614: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1ba618: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1ba61c: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1ba620: 0x4614a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ba624: 0x0
    // NOP
    // 0x1ba628: 0x4501016f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BABE8; return;
    }
    // 0x1ba630: 0x8e620278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 632)));
    // 0x1ba634: 0x1040002d
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BA6EC; return;
    }
    // 0x1ba63c: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1ba640: 0x27b10070
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1ba644: 0x26108d20
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937888));
    // 0x1ba648: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ba64c: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x1ba650: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1ba654: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba658: 0x24c68d00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937856));
    // 0x1ba65c: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x1ba664);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_1ba664
// Address: 0x1ba664 - 0x1ba68c

void entry_1ba664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba664: 0x8e620278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 632)));
    // 0x1ba668: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ba66c: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1ba670: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ba674: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ba678: 0x8c44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1ba67c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba680: 0xc0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ba684: 0xc07cbbc
    SET_GPR_U32(ctx, 31, 0x1ba68c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime); return;
}


// Function: entry_1ba68c
// Address: 0x1ba68c - 0x1ba770

void entry_1ba68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ba68c) {
        switch (ctx->pc) {
            case 0x1ba6dc: ctx->pc = 0; goto label_1ba6dc;
            case 0x1ba6e8: ctx->pc = 0; goto label_1ba6e8;
            case 0x1ba6ec: ctx->pc = 0; goto label_1ba6ec;
            case 0x1ba714: ctx->pc = 0; goto label_1ba714;
            case 0x1ba718: ctx->pc = 0; goto label_1ba718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ba68c: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ba690: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ba694: 0x4bc11afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1ba698: 0x4bc3086e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ba69c: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba6a0: 0x7a100000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ba6a4: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba6a8: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ba6ac: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ba6b0: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ba6b4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ba6b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ba6bc: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ba6c0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ba6c4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1ba6c8: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ba6cc: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ba6dc;
    }
    // 0x1ba6d4: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ba6e8;
    }
label_1ba6dc:
    // 0x1ba6dc: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1ba6e0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ba6e4: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1ba6e8:
    // 0x1ba6e8: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
label_1ba6ec:
    // 0x1ba6ec: 0xde420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x1ba6f0: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1ba6f4: 0x3193c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 4));
    // 0x1ba6f8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ba6fc: 0x14400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ba714;
    }
    // 0x1ba704: 0xc6410360
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 864)); ctx->f[1] = *(float*)&val; }
    // 0x1ba708: 0xc6600360
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 864)); ctx->f[0] = *(float*)&val; }
    // 0x1ba70c: 0x10000002
    ctx->f[23] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ba718;
    }
label_1ba714:
    // 0x1ba714: 0x4480b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 0);
label_1ba718:
    // 0x1ba718: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x1ba71c: 0xc6410364
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 868)); ctx->f[1] = *(float*)&val; }
    // 0x1ba720: 0xc6600364
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 868)); ctx->f[0] = *(float*)&val; }
    // 0x1ba724: 0x4616b832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[23], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ba728: 0x0
    // NOP
    // 0x1ba72c: 0x45010013
    ctx->f[20] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    if ((ctx->fcr31 & 0x800000)) {
        entry_1ba77c(rdram, ctx, runtime); return;
    }
    // 0x1ba734: 0x4600b807
    ctx->f[0] = FPU_NEG_S(ctx->f[23]);
    // 0x1ba738: 0xda420350
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 848)));
    // 0x1ba73c: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ba740: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ba744: 0x26450440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1088));
    // 0x1ba748: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba74c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1ba750: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba754: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba758: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1ba75c: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1ba760: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ba764: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ba768: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x1ba770);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1ba770
// Address: 0x1ba770 - 0x1ba77c

void entry_1ba770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba770: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba774: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1ba77c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ba77c
// Address: 0x1ba77c - 0x1ba79c

void entry_1ba77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba77c: 0x4616a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ba780: 0x0
    // NOP
    // 0x1ba784: 0x4501008a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        entry_1ba9b0(rdram, ctx, runtime); return;
    }
    // 0x1ba78c: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ba790: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ba794: 0xc07bb5a
    SET_GPR_U32(ctx, 31, 0x1ba79c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 320));
    CalculateWaterCurrent__FP5WATERP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_1ba79c
// Address: 0x1ba79c - 0x1ba7c0

void entry_1ba79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba79c: 0xda420150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1ba7a0: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ba7a4: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ba7a8: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1ba7ac: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba7b0: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1ba7b4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ba7b8: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1ba7c0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1ba7c0
// Address: 0x1ba7c0 - 0x1ba870

void entry_1ba7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ba7c0) {
        switch (ctx->pc) {
            case 0x1ba7fc: ctx->pc = 0; goto label_1ba7fc;
            case 0x1ba800: ctx->pc = 0; goto label_1ba800;
            case 0x1ba828: ctx->pc = 0; goto label_1ba828;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ba7c0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ba7c4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ba7c8: 0x4601a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ba7cc: 0x0
    // NOP
    // 0x1ba7d0: 0x4501000a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ba7fc;
    }
    // 0x1ba7d8: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ba7dc: 0x0
    // NOP
    // 0x1ba7e0: 0x45010007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ba800;
    }
    // 0x1ba7e8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ba7ec: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ba7f0: 0x4601a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x1ba7f4: 0x46010040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ba7f8: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
label_1ba7fc:
    // 0x1ba7fc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1ba800:
    // 0x1ba800: 0x244246c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18112));
    // 0x1ba804: 0x27a70090
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1ba808: 0x27b100a0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1ba80c: 0x27b40030
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ba810: 0x27b500b0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1ba814: 0x27b600c0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1ba818: 0x27b700d0
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1ba81c: 0x27be00e0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1ba820: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba824: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
label_1ba828:
    // 0x1ba828: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1ba82c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1ba830: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1ba834: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ba838: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ba83c: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1ba840: 0x461fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_1ba828;
    }
    // 0x1ba848: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1ba84c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ba850: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ba854: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba858: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba85c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba860: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ba864: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba868: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x1ba870);
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_1ba870
// Address: 0x1ba870 - 0x1ba8cc

void entry_1ba870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ba870) {
        switch (ctx->pc) {
            case 0x1ba880: ctx->pc = 0; goto label_1ba880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ba870: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ba874: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba878: 0x244246c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18112));
    // 0x1ba87c: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
label_1ba880:
    // 0x1ba880: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1ba884: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1ba888: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1ba88c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1ba890: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ba894: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1ba898: 0x461fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_1ba880;
    }
    // 0x1ba8a0: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ba8a4: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ba8a8: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1ba8ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ba8b0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba8b4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba8b8: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ba8bc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba8c0: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba8c4: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x1ba8cc);
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_1ba8cc
// Address: 0x1ba8cc - 0x1ba8f8

void entry_1ba8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba8cc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1ba8d0: 0xda420160
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x1ba8d4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1ba8d8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ba8dc: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ba8e0: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1ba8e4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba8e8: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1ba8ec: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ba8f0: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1ba8f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1ba8f8
// Address: 0x1ba8f8 - 0x1ba954

void entry_1ba8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ba8f8) {
        switch (ctx->pc) {
            case 0x1ba908: ctx->pc = 0; goto label_1ba908;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ba8f8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ba8fc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba900: 0x244246d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18128));
    // 0x1ba904: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
label_1ba908:
    // 0x1ba908: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1ba90c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1ba910: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1ba914: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1ba918: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ba91c: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1ba920: 0x461fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_1ba908;
    }
    // 0x1ba928: 0xda410160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x1ba92c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ba930: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ba934: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1ba938: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba93c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba940: 0xfba100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ba944: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba948: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba94c: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x1ba954);
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_1ba954
// Address: 0x1ba954 - 0x1ba9b0

void entry_1ba954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ba954) {
        switch (ctx->pc) {
            case 0x1ba968: ctx->pc = 0; goto label_1ba968;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ba954: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ba958: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba95c: 0x244246d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18128));
    // 0x1ba960: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ba964: 0x0
    // NOP
label_1ba968:
    // 0x1ba968: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1ba96c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1ba970: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1ba974: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ba978: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1ba97c: 0x461fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_1ba968;
    }
    // 0x1ba984: 0xda410160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x1ba988: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1ba98c: 0xdba200c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ba990: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ba994: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ba998: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ba99c: 0xfba100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ba9a0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba9a4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ba9a8: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x1ba9b0);
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_1ba9b0
// Address: 0x1ba9b0 - 0x1ba9f0

void entry_1ba9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba9b0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1ba9b4: 0x4600b832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ba9b8: 0x0
    // NOP
    // 0x1ba9bc: 0x4501005c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BAB30; return;
    }
    // 0x1ba9c4: 0x7a4701a0
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 18), 416)));
    // 0x1ba9c8: 0x7a4301c0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 448)));
    // 0x1ba9cc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ba9d0: 0x7a4201b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 432)));
    // 0x1ba9d4: 0x7fa70070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 7));
    // 0x1ba9d8: 0x7fa30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 3));
    // 0x1ba9dc: 0x7fa20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    // 0x1ba9e0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1ba9e4: 0x8c4300b4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 180)));
    // 0x1ba9e8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ba9f0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ba9f0
// Address: 0x1ba9f0 - 0x1baa04

void entry_1ba9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ba9f0: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1ba9f4: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1ba9f8: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x1ba9fc: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x1baa04);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 160));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1baa04
// Address: 0x1baa04 - 0x1baa84

void entry_1baa04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1baa04: 0xdba200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1baa08: 0xdba600b0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1baa0c: 0xdba500c0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1baa10: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1baa14: 0xda410130
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 304)));
    // 0x1baa18: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1baa1c: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1baa20: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1baa24: 0xdba40070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1baa28: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1baa2c: 0x4b000203
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1baa30: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1baa34: 0x4b01404a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1baa38: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1baa3c: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1baa40: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1baa44: 0xdba70080
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1baa48: 0x4bc711bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1baa4c: 0x4bc730bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1baa50: 0x4bc7288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1baa54: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1baa58: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1baa5c: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1baa60: 0xfba20130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1baa64: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1baa68: 0xfba30140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1baa6c: 0xfba30110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1baa70: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1baa74: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1baa78: 0xfba40120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1baa7c: 0xc08155e
    SET_GPR_U32(ctx, 31, 0x1baa84);
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[4]));
    acosf(rdram, ctx, runtime); return;
}


// Function: entry_1baa84
// Address: 0x1baa84 - 0x1bab2c

void entry_1baa84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1baa84) {
        switch (ctx->pc) {
            case 0x1baaf4: ctx->pc = 0; goto label_1baaf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1baa84: 0xda420130
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 304)));
    // 0x1baa88: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    // 0x1baa8c: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1baa90: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1baa94: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1baa98: 0x4bc208ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1baa9c: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1baaa0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1baaa4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1baaa8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1baaac: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1baab0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1baab4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1baab8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1baabc: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1baac0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1baac4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1baac8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1baacc: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1baad0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1baad4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1baad8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1baadc: 0x0
    // NOP
    // 0x1baae0: 0x45010004
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1baaf4;
    }
    // 0x1baae8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1baaec: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1baaf0: 0x4be0189c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1baaf4:
    // 0x1baaf4: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1baaf8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1baafc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bab00: 0xfba200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bab04: 0x27a500e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1bab08: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1bab0c: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1bab10: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1bab14: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1bab18: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1bab1c: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bab20: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bab24: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x1bab2c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1bab2c
// Address: 0x1bab2c - 0x1babbc

void entry_1bab2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bab2c) {
        switch (ctx->pc) {
            case 0x1bab30: ctx->pc = 0; goto label_1bab30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bab2c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
label_1bab30:
    // 0x1bab30: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bab34: 0x0
    // NOP
    // 0x1bab38: 0x45020023
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1BABC8; return;
    }
    // 0x1bab40: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bab44: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bab48: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bab4c: 0x0
    // NOP
    // 0x1bab50: 0x4500001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BABC4; return;
    }
    // 0x1bab58: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x1bab5c: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1bab60: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bab64: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bab68: 0x0
    // NOP
    // 0x1bab6c: 0x45000015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BABC4; return;
    }
    // 0x1bab74: 0xc64e0430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1072)); ctx->f[14] = *(float*)&val; }
    // 0x1bab78: 0xc6420420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1056)); ctx->f[2] = *(float*)&val; }
    // 0x1bab7c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bab80: 0xc6400434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1076)); ctx->f[0] = *(float*)&val; }
    // 0x1bab84: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x1bab88: 0xc6410424
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1060)); ctx->f[1] = *(float*)&val; }
    // 0x1bab8c: 0x46027381
    ctx->f[14] = FPU_SUB_S(ctx->f[14], ctx->f[2]);
    // 0x1bab90: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1bab94: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1bab98: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1bab9c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1baba0: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1baba4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1baba8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1babac: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1babb0: 0x46007380
    ctx->f[14] = FPU_ADD_S(ctx->f[14], ctx->f[0]);
    // 0x1babb4: 0xc0558a2
    SET_GPR_U32(ctx, 31, 0x1babbc);
    ctx->f[14] = FPU_MUL_S(ctx->f[14], ctx->f[3]);
    WakeSoWater__FP2SOP5WATERfP6VECTORT3ff(rdram, ctx, runtime); return;
}


// Function: entry_1babbc
// Address: 0x1babbc - 0x1babe4

void entry_1babbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1babbc) {
        switch (ctx->pc) {
            case 0x1babc4: ctx->pc = 0; goto label_1babc4;
            case 0x1babc8: ctx->pc = 0; goto label_1babc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1babbc: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BABE8; return;
    }
label_1babc4:
    // 0x1babc4: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1babc8:
    // 0x1babc8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1babcc: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1babd0: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BABE8; return;
    }
    // 0x1babd8: 0x8e440574
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1396)));
    // 0x1babdc: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x1babe4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_1babe4
// Address: 0x1babe4 - 0x1bac28

void entry_1babe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1babe4) {
        switch (ctx->pc) {
            case 0x1babe8: ctx->pc = 0; goto label_1babe8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1babe4: 0x7bbf01e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
label_1babe8:
    // 0x1babe8: 0x7bbe01d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1babec: 0x7bb701c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1babf0: 0x7bb601b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1babf4: 0x7bb501a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1babf8: 0x7bb40190
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1babfc: 0x7bb30180
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1bac00: 0x7bb20170
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1bac04: 0x7bb10160
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1bac08: 0x7bb00150
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1bac0c: 0xc7b80210
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 528)); ctx->f[24] = *(float*)&val; }
    // 0x1bac10: 0xc7b70208
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 520)); ctx->f[23] = *(float*)&val; }
    // 0x1bac14: 0xc7b60200
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 512)); ctx->f[22] = *(float*)&val; }
    // 0x1bac18: 0xc7b501f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 504)); ctx->f[21] = *(float*)&val; }
    // 0x1bac1c: 0xc7b401f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[20] = *(float*)&val; }
    // 0x1bac20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 544));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddSoExternalAccelerations__FP2SOP2XAf
// Address: 0x1bac28 - 0x1bac30

void entry_1bac68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bac68: 0xde2302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x1bac6c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1bac70: 0x2404fffd
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967293));
    // 0x1bac74: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1bac78: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1bac7c: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1bac80: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1bac84: 0x2107c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 1));
    // 0x1bac88: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1bac8c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bac90: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bac94: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bac98: 0xc04dfec
    SET_GPR_U32(ctx, 31, 0x1baca0);
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 3));
    ReadGeom__18CBinaryInputStreamP4GEOM(rdram, ctx, runtime); return;
}


// Function: entry_1baca0
// Address: 0x1baca0 - 0x1bad24

void entry_1baca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1baca0) {
        switch (ctx->pc) {
            case 0x1bad10: ctx->pc = 0; goto label_1bad10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1baca0: 0xc6200380
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 896)); ctx->f[0] = *(float*)&val; }
    // 0x1baca4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1baca8: 0x31cb8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 18);
    // 0x1bacac: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x1bacb0: 0xe62003cc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 972), *(uint32_t*)&val); }
    // 0x1bacb4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bacb8: 0x10400015
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 976), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bad10;
    }
    // 0x1bacc0: 0x6a220387
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 903); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bacc4: 0x6e220380
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 896); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bacc8: 0x6a23038f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 911); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1baccc: 0x6e230388
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 904); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1bacd0: 0x6a240397
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 919); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1bacd4: 0x6e240390
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 912); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1bacd8: 0x6a26039f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 927); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1bacdc: 0x6e260398
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 920); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1bace0: 0xb22203ab
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 939); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bace4: 0xb62203a4
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 932); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bace8: 0xb22303b3
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 947); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bacec: 0xb62303ac
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 940); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bacf0: 0xb22403bb
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 955); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bacf4: 0xb62403b4
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 948); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bacf8: 0xb22603c3
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 963); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bacfc: 0xb62603bc
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 956); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bad00: 0x8e2203a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 928)));
    // 0x1bad04: 0xae2203c4
    WRITE32(ADD32(GPR_U32(ctx, 17), 964), GPR_U32(ctx, 2));
    // 0x1bad08: 0x10000007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 932));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BAD28; return;
    }
label_1bad10:
    // 0x1bad10: 0x263003a4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 932));
    // 0x1bad14: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bad18: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bad1c: 0xc0583a8
    SET_GPR_U32(ctx, 31, 0x1bad24);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CloneGeom__FP4GEOMP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1bad24
// Address: 0x1bad24 - 0x1bad34

void entry_1bad24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bad24) {
        switch (ctx->pc) {
            case 0x1bad28: ctx->pc = 0; goto label_1bad28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bad24: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1bad28:
    // 0x1bad28: 0x262603f0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1008));
    // 0x1bad2c: 0xc04e09e
    SET_GPR_U32(ctx, 31, 0x1bad34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadBspc__18CBinaryInputStreamP4GEOMP4BSPC(rdram, ctx, runtime); return;
}


// Function: entry_1bad34
// Address: 0x1bad34 - 0x1bad44

void entry_1bad34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bad34: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bad38: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bad3c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x1bad44);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 1256));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1bad44
// Address: 0x1bad44 - 0x1bad5c

void entry_1bad44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bad44: 0x2635050c
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 1292));
    // 0x1bad48: 0xe6200368
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 872), *(uint32_t*)&val); }
    // 0x1bad4c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bad50: 0x262502f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 752));
    // 0x1bad54: 0xc04dfac
    SET_GPR_U32(ctx, 31, 0x1bad5c);
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 17), 1328));
    ReadMatrix__18CBinaryInputStreamP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1bad5c
// Address: 0x1bad5c - 0x1bad68

void entry_1bad5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bad5c: 0x262504d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1232));
    // 0x1bad60: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1bad68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1bad68
// Address: 0x1bad68 - 0x1bad78

void entry_1bad68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bad68: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bad6c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1bad70: 0xc06e512
    SET_GPR_U32(ctx, 31, 0x1bad78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AdjustSoMomint__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_1bad78
// Address: 0x1bad78 - 0x1bad80

void entry_1bad78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bad78: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1bad80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1bad80
// Address: 0x1bad80 - 0x1bad8c

void entry_1bad80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bad80: 0x220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1bad84: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1bad8c);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1020), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bad8c
// Address: 0x1bad8c - 0x1badb4

void entry_1bad8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bad8c) {
        switch (ctx->pc) {
            case 0x1bada0: ctx->pc = 0; goto label_1bada0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bad8c: 0x8e2303fc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1020)));
    // 0x1bad90: 0x18600010
    WRITE32(ADD32(GPR_U32(ctx, 17), 1024), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1BADD4; return;
    }
    // 0x1bad98: 0x8e300400
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1024)));
    // 0x1bad9c: 0x0
    // NOP
label_1bada0:
    // 0x1bada0: 0x1210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 3));
    // 0x1bada4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bada8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1badac: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1badb4);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1badb4
// Address: 0x1badb4 - 0x1badc0

void entry_1badb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1badb4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1badb8: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1badc0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1badc0
// Address: 0x1badc0 - 0x1bade0

void entry_1badc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1badc0) {
        switch (ctx->pc) {
            case 0x1badd4: ctx->pc = 0; goto label_1badd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1badc0: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1badc4: 0x8e2203fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1020)));
    // 0x1badc8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1badcc: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1024)));
        ctx->pc = 0x1BADA0; return;
    }
label_1badd4:
    // 0x1badd4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1badd8: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x1bade0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1bade0
// Address: 0x1bade0 - 0x1badec

void entry_1bade0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bade0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bade4: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1badec);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1badec
// Address: 0x1badec - 0x1bae00

void entry_1badec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1badec) {
        switch (ctx->pc) {
            case 0x1badf8: ctx->pc = 0; goto label_1badf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1badec: 0x1a40000b
    WRITE32(ADD32(GPR_U32(ctx, 17), 1028), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x1BAE1C; return;
    }
    // 0x1badf4: 0x0
    // NOP
label_1badf8:
    // 0x1badf8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1bae00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1bae00
// Address: 0x1bae00 - 0x1bae28

void entry_1bae00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bae00) {
        switch (ctx->pc) {
            case 0x1bae1c: ctx->pc = 0; goto label_1bae1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bae00: 0x8e230404
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1028)));
    // 0x1bae04: 0x102080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1bae08: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1bae0c: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1bae10: 0x212282a
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 18)));
    // 0x1bae14: 0x14a0fff8
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BADF8; return;
    }
label_1bae1c:
    // 0x1bae1c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bae20: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x1bae28);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1bae28
// Address: 0x1bae28 - 0x1bae34

void entry_1bae28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bae28: 0x220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1bae2c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1bae34);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1032), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bae34
// Address: 0x1bae34 - 0x1bae5c

void entry_1bae34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bae34) {
        switch (ctx->pc) {
            case 0x1bae48: ctx->pc = 0; goto label_1bae48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bae34: 0x8e230408
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1032)));
    // 0x1bae38: 0x18600010
    WRITE32(ADD32(GPR_U32(ctx, 17), 1036), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1BAE7C; return;
    }
    // 0x1bae40: 0x8e30040c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1036)));
    // 0x1bae44: 0x0
    // NOP
label_1bae48:
    // 0x1bae48: 0x1210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 3));
    // 0x1bae4c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bae50: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1bae54: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1bae5c);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1bae5c
// Address: 0x1bae5c - 0x1bae68

void entry_1bae5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bae5c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1bae60: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1bae68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1bae68
// Address: 0x1bae68 - 0x1bae9c

void entry_1bae68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bae68) {
        switch (ctx->pc) {
            case 0x1bae7c: ctx->pc = 0; goto label_1bae7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bae68: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1bae6c: 0x8e220408
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1032)));
    // 0x1bae70: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1bae74: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1036)));
        ctx->pc = 0x1BAE48; return;
    }
label_1bae7c:
    // 0x1bae7c: 0x8e220408
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1032)));
    // 0x1bae80: 0x58400015
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
        ctx->pc = 0x1BAED8; return;
    }
    // 0x1bae88: 0x8e2403b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 944)));
    // 0x1bae8c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bae90: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1bae94: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1bae9c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bae9c
// Address: 0x1bae9c - 0x1baeb0

void entry_1bae9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bae9c) {
        switch (ctx->pc) {
            case 0x1baea8: ctx->pc = 0; goto label_1baea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bae9c: 0x8e2303b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 944)));
    // 0x1baea0: 0x460000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1040), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x1BAED4; return;
    }
label_1baea8:
    // 0x1baea8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1baeb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1baeb0
// Address: 0x1baeb0 - 0x1baee0

void entry_1baeb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1baeb0) {
        switch (ctx->pc) {
            case 0x1baed4: ctx->pc = 0; goto label_1baed4;
            case 0x1baed8: ctx->pc = 0; goto label_1baed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1baeb0: 0x8e240410
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1040)));
    // 0x1baeb4: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1baeb8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1baebc: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1baec0: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1baec4: 0x8e2203b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 944)));
    // 0x1baec8: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x1baecc: 0x1040fff6
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BAEA8; return;
    }
label_1baed4:
    // 0x1baed4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1baed8:
    // 0x1baed8: 0xc04dfec
    SET_GPR_U32(ctx, 31, 0x1baee0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ReadGeom__18CBinaryInputStreamP4GEOM(rdram, ctx, runtime); return;
}


// Function: entry_1baee0
// Address: 0x1baee0 - 0x1baf58

void entry_1baee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1baee0) {
        switch (ctx->pc) {
            case 0x1baf48: ctx->pc = 0; goto label_1baf48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1baee0: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x1baee4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1baee8: 0x31cb8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 18);
    // 0x1baeec: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1baef0: 0x10400015
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1baf48;
    }
    // 0x1baef8: 0x6a2204ef
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1263); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1baefc: 0x6e2204e8
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1256); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1baf00: 0x6a2304f7
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1271); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1baf04: 0x6e2304f0
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1264); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1baf08: 0x6a2404ff
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1279); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1baf0c: 0x6e2404f8
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1272); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1baf10: 0x6a250507
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1287); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1baf14: 0x6e250500
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1280); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1baf18: 0xb2220513
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1299); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf1c: 0xb622050c
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1292); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf20: 0xb223051b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1307); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf24: 0xb6230514
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1300); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf28: 0xb2240523
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1315); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf2c: 0xb624051c
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1308); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf30: 0xb225052b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1323); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf34: 0xb6250524
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 1316); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1baf38: 0x8e220508
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1288)));
    // 0x1baf3c: 0xae22052c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1324), GPR_U32(ctx, 2));
    // 0x1baf40: 0x10000007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BAF60; return;
    }
label_1baf48:
    // 0x1baf48: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1baf4c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1baf50: 0xc0583a8
    SET_GPR_U32(ctx, 31, 0x1baf58);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    CloneGeom__FP4GEOMP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1baf58
// Address: 0x1baf58 - 0x1baf68

void entry_1baf58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1baf58) {
        switch (ctx->pc) {
            case 0x1baf60: ctx->pc = 0; goto label_1baf60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1baf58: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1baf5c: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_1baf60:
    // 0x1baf60: 0xc04e09e
    SET_GPR_U32(ctx, 31, 0x1baf68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadBspc__18CBinaryInputStreamP4GEOMP4BSPC(rdram, ctx, runtime); return;
}


// Function: entry_1baf68
// Address: 0x1baf68 - 0x1baf74

void entry_1baf68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1baf68: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1baf6c: 0xc04a270
    SET_GPR_U32(ctx, 31, 0x1baf74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadAloFromBrx__FP3ALOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1baf74
// Address: 0x1baf74 - 0x1baf80

void entry_1baf74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1baf74: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1baf78: 0xc06df10
    SET_GPR_U32(ctx, 31, 0x1baf80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    EnableSoPhys__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1baf80
// Address: 0x1baf80 - 0x1baf90

void entry_1baf80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1baf80: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1baf84: 0x8c430120
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 288)));
    // 0x1baf88: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1baf90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1baf90
// Address: 0x1baf90 - 0x1bafac

void entry_1baf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1baf90: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1baf94: 0x14400009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BAFBC; return;
    }
    // 0x1baf9c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1bafa0: 0x8c6200d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 216)));
    // 0x1bafa4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bafac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bafac
// Address: 0x1bafac - 0x1bafb8

void entry_1bafac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bafac: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1bafb0: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x1bafb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1bafb8
// Address: 0x1bafb8 - 0x1bafe0

void entry_1bafb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bafb8) {
        switch (ctx->pc) {
            case 0x1bafbc: ctx->pc = 0; goto label_1bafbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bafb8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1bafbc:
    // 0x1bafbc: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bafc0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bafc4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bafc8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bafcc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bafd0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bafd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bafd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSoSphere__FP2SOf
// Address: 0x1bafe0 - 0x1bb000

void entry_1bb01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb01c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bb020: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConstrFromCnstr__F5CNSTRP2CTP6VECTOR
// Address: 0x1bb028 - 0x1bb058

void entry_1bb078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb078: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1bb07c: 0xda0100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1bb080: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1bb084: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bb088: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1bb08c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bb090: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bb094: 0x24880460
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 4), 1120));
    // 0x1bb098: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1bb09c: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bb0a0: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bb0a4: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bb0a8: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bb0ac: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1bb0b4);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 1136)));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1bb0b4
// Address: 0x1bb0b4 - 0x1bb0c8

void entry_1bb0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb0b4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bb0b8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bb0bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bb0c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bb0c8; return;
}


// Function: SetSoCnstrTorque__FP2SO5CNSTR
// Address: 0x1bb0c8 - 0x1bb0e8

void entry_1bb0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb0e8: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1bb0ec: 0xda0100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1bb0f0: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1bb0f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bb0f8: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1bb0fc: 0x24860440
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1088));
    // 0x1bb100: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bb104: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bb108: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1bb10c: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bb110: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bb114: 0x8fa70020
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bb118: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bb11c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1bb124);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1104)));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1bb124
// Address: 0x1bb124 - 0x1bb138

void entry_1bb124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb124: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bb128: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bb12c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bb134: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bb138; return;
}


// Function: SetSoCameraStyle__FP2SO3CMK
// Address: 0x1bb138 - 0x1bb168

void entry_1bb238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb238) {
        switch (ctx->pc) {
            case 0x1bb248: ctx->pc = 0; goto label_1bb248;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb238: 0x8e2204b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1200)));
    // 0x1bb23c: 0x1040000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BB278; return;
    }
    // 0x1bb244: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_1bb248:
    // 0x1bb248: 0x10910007
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 17)) {
        entry_1bb268(rdram, ctx, runtime); return;
    }
    // 0x1bb250: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bb254: 0x8c420044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 68)));
    // 0x1bb258: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1bb268(rdram, ctx, runtime); return;
    }
    // 0x1bb260: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bb268);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bb268
// Address: 0x1bb268 - 0x1bb290

void entry_1bb268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb268) {
        switch (ctx->pc) {
            case 0x1bb278: ctx->pc = 0; goto label_1bb278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb268: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bb26c: 0x5440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
        ctx->pc = 0x1BB248; return;
    }
    // 0x1bb274: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1bb278:
    // 0x1bb278: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bb27c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bb280: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bb284: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bb288: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PxpFindSoGround__FP2SOT0Pi
// Address: 0x1bb290 - 0x1bb378

void entry_1bb3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb3f4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bb3f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSoNoXpsSelf__FP2SOi
// Address: 0x1bb400 - 0x1bb444

void entry_1bb444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb444: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bb448: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSoNoXpsCenter__FP2SOi
// Address: 0x1bb450 - 0x1bb494

void entry_1bb494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb494: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bb498: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RebuildSoPhysHook__FP2SO
// Address: 0x1bb4a0 - 0x1bb520

void entry_1bb520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb520) {
        switch (ctx->pc) {
            case 0x1bb524: ctx->pc = 0; goto label_1bb524;
            case 0x1bb530: ctx->pc = 0; goto label_1bb530;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb520: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_1bb524:
    // 0x1bb524: 0x5600fff8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BB508; return;
    }
    // 0x1bb52c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1bb530:
    // 0x1bb530: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bb534: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bb53c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bb540; return;
}


// Function: PsoFindSoPhysHook__FP2SOi
// Address: 0x1bb540 - 0x1bb580

void entry_1bb680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb680) {
        switch (ctx->pc) {
            case 0x1bb690: ctx->pc = 0; goto label_1bb690;
            case 0x1bb698: ctx->pc = 0; goto label_1bb698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb680: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1bb684: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1bb688: 0x2900a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 0));
    // 0x1bb68c: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_1bb690:
    // 0x1bb690: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BB668; return;
    }
label_1bb698:
    // 0x1bb698: 0xde240538
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1bb69c: 0x415fe
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) >> (32 + 23));
    // 0x1bb6a0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1bb6a4: 0x10520013
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        entry_1bb6f4(rdram, ctx, runtime); return;
    }
    // 0x1bb6ac: 0x3c03ff7f
    SET_GPR_U32(ctx, 3, ((uint32_t)65407 << 16));
    // 0x1bb6b0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1bb6b4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1bb6b8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1bb6bc: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1bb6c0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1bb6c4: 0x831824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1bb6c8: 0x215fc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 23));
    // 0x1bb6cc: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bb6d0: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1bb6d4: 0x14800007
    WRITE64(ADD32(GPR_U32(ctx, 17), 1336), GPR_U64(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        entry_1bb6f4(rdram, ctx, runtime); return;
    }
    // 0x1bb6dc: 0x8e220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1bb6e0: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BB6F8; return;
    }
    // 0x1bb6e8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1bb6ec: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x1bb6f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1bb6f4
// Address: 0x1bb6f4 - 0x1bb710

void entry_1bb6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb6f4) {
        switch (ctx->pc) {
            case 0x1bb6f8: ctx->pc = 0; goto label_1bb6f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb6f4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1bb6f8:
    // 0x1bb6f8: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bb6fc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bb700: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bb704: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bb708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FGetSoContactList__FP2SOPv
// Address: 0x1bb710 - 0x1bb79c

void entry_1bb79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bb79c: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x1BB7C0; return;
    }
    // 0x1bb7a4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bb7a8: 0xc07068a
    SET_GPR_U32(ctx, 31, 0x1bb7b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FAppendSpliceListElement__FPvT0(rdram, ctx, runtime); return;
}


// Function: entry_1bb7b0
// Address: 0x1bb7b0 - 0x1bb800

void entry_1bb7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb7b0) {
        switch (ctx->pc) {
            case 0x1bb7c0: ctx->pc = 0; goto label_1bb7c0;
            case 0x1bb7cc: ctx->pc = 0; goto label_1bb7cc;
            case 0x1bb7d4: ctx->pc = 0; goto label_1bb7d4;
            case 0x1bb7d8: ctx->pc = 0; goto label_1bb7d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb7b0: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        goto label_1bb7c0;
    }
    // 0x1bb7b8: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bb7d8;
    }
label_1bb7c0:
    // 0x1bb7c0: 0x5600ffe7
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BB760; return;
    }
    // 0x1bb7c8: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_1bb7cc:
    // 0x1bb7cc: 0x5620ffe0
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1BB750; return;
    }
label_1bb7d4:
    // 0x1bb7d4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1bb7d8:
    // 0x1bb7d8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bb7dc: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bb7e0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bb7e4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bb7e8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bb7ec: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bb7f0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bb7f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bb7fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bb800; return;
}


// Function: GetSoContacts__FP2SOPiPPP2SO
// Address: 0x1bb800 - 0x1bb878

void entry_1bb878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb878) {
        switch (ctx->pc) {
            case 0x1bb88c: ctx->pc = 0; goto label_1bb88c;
            case 0x1bb894: ctx->pc = 0; goto label_1bb894;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb878: 0x26230001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1bb87c: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1bb880: 0x1600fff5
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BB858; return;
    }
    // 0x1bb888: 0x8e730004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
label_1bb88c:
    // 0x1bb88c: 0x5660fff0
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1BB850; return;
    }
label_1bb894:
    // 0x1bb894: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bb89c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 17), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bb89c
// Address: 0x1bb89c - 0x1bb8e4

void entry_1bb89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb89c) {
        switch (ctx->pc) {
            case 0x1bb8b8: ctx->pc = 0; goto label_1bb8b8;
            case 0x1bb8c8: ctx->pc = 0; goto label_1bb8c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb89c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bb8a0: 0x8ea20480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 1152)));
    // 0x1bb8a4: 0x8c530000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bb8a8: 0x1260002c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BB95C; return;
    }
    // 0x1bb8b0: 0x8e710000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1bb8b4: 0x0
    // NOP
label_1bb8b8:
    // 0x1bb8b8: 0x52200026
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1BB954; return;
    }
    // 0x1bb8c0: 0x24170001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bb8c4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1bb8c8:
    // 0x1bb8c8: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1bb8cc: 0x751826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x1bb8d0: 0x3802b
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1bb8d4: 0x101180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 6));
    // 0x1bb8d8: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1bb8dc: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x1bb8e4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1bb8e4
// Address: 0x1bb8e4 - 0x1bb9a0

void entry_1bb8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bb8e4) {
        switch (ctx->pc) {
            case 0x1bb918: ctx->pc = 0; goto label_1bb918;
            case 0x1bb934: ctx->pc = 0; goto label_1bb934;
            case 0x1bb93c: ctx->pc = 0; goto label_1bb93c;
            case 0x1bb940: ctx->pc = 0; goto label_1bb940;
            case 0x1bb944: ctx->pc = 0; goto label_1bb944;
            case 0x1bb948: ctx->pc = 0; goto label_1bb948;
            case 0x1bb954: ctx->pc = 0; goto label_1bb954;
            case 0x1bb95c: ctx->pc = 0; goto label_1bb95c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bb8e4: 0x10400017
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 23), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bb944;
    }
    // 0x1bb8ec: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bb8f0: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1bb8f4: 0x292182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 20), GPR_U32(ctx, 18)));
    // 0x1bb8f8: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1bb8fc: 0x1060000f
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1bb93c;
    }
    // 0x1bb904: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1bb908: 0x1045000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_1bb934;
    }
    // 0x1bb910: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1bb914: 0x0
    // NOP
label_1bb918:
    // 0x1bb918: 0x92102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1bb91c: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 5));
        goto label_1bb940;
    }
    // 0x1bb924: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bb928: 0x5445fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
        goto label_1bb918;
    }
    // 0x1bb930: 0x92102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
label_1bb934:
    // 0x1bb934: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        goto label_1bb948;
    }
label_1bb93c:
    // 0x1bb93c: 0xae450000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 5));
label_1bb940:
    // 0x1bb940: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
label_1bb944:
    // 0x1bb944: 0x8e3100d0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
label_1bb948:
    // 0x1bb948: 0x5620ffdf
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1BB8C8; return;
    }
    // 0x1bb950: 0x8e730004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
label_1bb954:
    // 0x1bb954: 0x5660ffd8
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1BB8B8; return;
    }
label_1bb95c:
    // 0x1bb95c: 0xafd40000
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 20));
    // 0x1bb960: 0x2541023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 20)));
    // 0x1bb964: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x1bb968: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1bb96c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bb970: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1bb974: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1bb978: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bb97c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bb980: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bb984: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bb988: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bb98c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bb990: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bb994: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1bb998: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FSoInStsoList__FP4STSOP2SO
// Address: 0x1bb9a0 - 0x1bb9d0

void entry_1bba5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bba5c: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x1BBA80; return;
    }
    // 0x1bba64: 0xafbd0004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 29));
    // 0x1bba68: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bba6c: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1bba70: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bba74: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1bba7c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 4));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1bba7c
// Address: 0x1bba7c - 0x1bbb54

void entry_1bba7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bba7c) {
        switch (ctx->pc) {
            case 0x1bba80: ctx->pc = 0; goto label_1bba80;
            case 0x1bba8c: ctx->pc = 0; goto label_1bba8c;
            case 0x1bba98: ctx->pc = 0; goto label_1bba98;
            case 0x1bbaa8: ctx->pc = 0; goto label_1bbaa8;
            case 0x1bbab8: ctx->pc = 0; goto label_1bbab8;
            case 0x1bbad0: ctx->pc = 0; goto label_1bbad0;
            case 0x1bbb10: ctx->pc = 0; goto label_1bbb10;
            case 0x1bbb24: ctx->pc = 0; goto label_1bbb24;
            case 0x1bbb34: ctx->pc = 0; goto label_1bbb34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bba7c: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
label_1bba80:
    // 0x1bba80: 0x5600ffe7
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BBA20; return;
    }
    // 0x1bba88: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_1bba8c:
    // 0x1bba8c: 0x5620ffe0
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1BBA10; return;
    }
    // 0x1bba94: 0x8e530540
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 1344)));
label_1bba98:
    // 0x1bba98: 0x52600032
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        ctx->pc = 0x1BBB64; return;
    }
    // 0x1bbaa0: 0x8e820480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1152)));
    // 0x1bbaa4: 0x0
    // NOP
label_1bbaa8:
    // 0x1bbaa8: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bbaac: 0x12200021
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1bbb34;
    }
    // 0x1bbab4: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1bbab8:
    // 0x1bbab8: 0x5200001a
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_1bbb24;
    }
    // 0x1bbac0: 0x54a00018
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_1bbb24;
    }
    // 0x1bbac8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bbacc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1bbad0:
    // 0x1bbad0: 0x541026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1bbad4: 0x2202b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1bbad8: 0x41980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 6));
    // 0x1bbadc: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1bbae0: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1bbae4: 0x5452000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        goto label_1bbb10;
    }
    // 0x1bbaec: 0xc41023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x1bbaf0: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1bbaf4: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1bbaf8: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1bbafc: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1bbb00: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1bbb04: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bbb08: 0xc3280a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 6));
    // 0x1bbb0c: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
label_1bbb10:
    // 0x1bbb10: 0x52000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_1bbb24;
    }
    // 0x1bbb18: 0x50a0ffed
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1bbad0;
    }
    // 0x1bbb20: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_1bbb24:
    // 0x1bbb24: 0x12200003
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1bbb34;
    }
    // 0x1bbb2c: 0x50a0ffe2
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_1bbab8;
    }
label_1bbb34:
    // 0x1bbb34: 0x54a00008
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1BBB58; return;
    }
    // 0x1bbb3c: 0xafb30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 19));
    // 0x1bbb40: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bbb44: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1bbb48: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bbb4c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1bbb54);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 4));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1bbb54
// Address: 0x1bbb54 - 0x1bbb6c

void entry_1bbb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bbb54) {
        switch (ctx->pc) {
            case 0x1bbb58: ctx->pc = 0; goto label_1bbb58;
            case 0x1bbb64: ctx->pc = 0; goto label_1bbb64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bbb54: 0x8e730004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
label_1bbb58:
    // 0x1bbb58: 0x5660ffd3
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1152)));
        ctx->pc = 0x1BBAA8; return;
    }
    // 0x1bbb60: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
label_1bbb64:
    // 0x1bbb64: 0xc077042
    SET_GPR_U32(ctx, 31, 0x1bbb6c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1344)));
    FreeSwStsoList__FP2SWP4STSO(rdram, ctx, runtime); return;
}


// Function: entry_1bbb6c
// Address: 0x1bbb6c - 0x1bbbd0

void entry_1bbb6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bbb6c) {
        switch (ctx->pc) {
            case 0x1bbb88: ctx->pc = 0; goto label_1bbb88;
            case 0x1bbb98: ctx->pc = 0; goto label_1bbb98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bbb6c: 0xae400540
    WRITE32(ADD32(GPR_U32(ctx, 18), 1344), GPR_U32(ctx, 0));
    // 0x1bbb70: 0x8e820480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1152)));
    // 0x1bbb74: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bbb78: 0x12200024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BBC0C; return;
    }
    // 0x1bbb80: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1bbb84: 0x0
    // NOP
label_1bbb88:
    // 0x1bbb88: 0x5200001d
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x1BBC00; return;
    }
    // 0x1bbb90: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bbb94: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1bbb98:
    // 0x1bbb98: 0x541026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1bbb9c: 0x2202b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1bbba0: 0x41980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 6));
    // 0x1bbba4: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1bbba8: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1bbbac: 0x54520011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x1BBBF4; return;
    }
    // 0x1bbbb4: 0x2641023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 4)));
    // 0x1bbbb8: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1bbbbc: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1bbbc0: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1bbbc4: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1bbbc8: 0xc077032
    SET_GPR_U32(ctx, 31, 0x1bbbd0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    PstsoAllocSw__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1bbbd0
// Address: 0x1bbbd0 - 0x1bbc30

void entry_1bbbd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bbbd0) {
        switch (ctx->pc) {
            case 0x1bbbec: ctx->pc = 0; goto label_1bbbec;
            case 0x1bbbf4: ctx->pc = 0; goto label_1bbbf4;
            case 0x1bbc00: ctx->pc = 0; goto label_1bbc00;
            case 0x1bbc0c: ctx->pc = 0; goto label_1bbc0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bbbd0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bbbd4: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bbbd8: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x1bbbdc: 0x8e430540
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1344)));
    // 0x1bbbe0: 0x50600002
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 1344), GPR_U32(ctx, 4));
        goto label_1bbbec;
    }
    // 0x1bbbe8: 0xaea40004
    WRITE32(ADD32(GPR_U32(ctx, 21), 4), GPR_U32(ctx, 4));
label_1bbbec:
    // 0x1bbbec: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1bbbf0: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
label_1bbbf4:
    // 0x1bbbf4: 0x5600ffe8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BBB98; return;
    }
    // 0x1bbbfc: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_1bbc00:
    // 0x1bbc00: 0x5620ffe1
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1BBB88; return;
    }
    // 0x1bbc08: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1bbc0c:
    // 0x1bbc0c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bbc10: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bbc14: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bbc18: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bbc1c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bbc20: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bbc24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bbc2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bbc30; return;
}


// Function: FInflictSoZap__FP2SOP2XPP3ZPR
// Address: 0x1bbc30 - 0x1bbc38

void entry_1bbc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bbc60: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1bbc68);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bbc68
// Address: 0x1bbc68 - 0x1bbc7c

void entry_1bbc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bbc68: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bbc6c: 0x8e0403a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 936)));
    // 0x1bbc70: 0xae1103c8
    WRITE32(ADD32(GPR_U32(ctx, 16), 968), GPR_U32(ctx, 17));
    // 0x1bbc74: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1bbc7c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bbc7c
// Address: 0x1bbc7c - 0x1bbc8c

void entry_1bbc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bbc7c: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x1bbc80: 0x8e0403a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 936)));
    // 0x1bbc84: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1bbc8c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bbc8c
// Address: 0x1bbc8c - 0x1bbca0

void entry_1bbc8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bbc8c: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x1bbc90: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1bbc94: 0x8e0403b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 944)));
    // 0x1bbc98: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1bbca0);
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bbca0
// Address: 0x1bbca0 - 0x1bbcb0

void entry_1bbca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bbca0: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x1bbca4: 0x8e0403b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 944)));
    // 0x1bbca8: 0xc0635aa
    SET_GPR_U32(ctx, 31, 0x1bbcb0);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bbcb0
// Address: 0x1bbcb0 - 0x1bbea4

void entry_1bbcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bbcb0) {
        switch (ctx->pc) {
            case 0x1bbcc8: ctx->pc = 0; goto label_1bbcc8;
            case 0x1bbce0: ctx->pc = 0; goto label_1bbce0;
            case 0x1bbd10: ctx->pc = 0; goto label_1bbd10;
            case 0x1bbd40: ctx->pc = 0; goto label_1bbd40;
            case 0x1bbd5c: ctx->pc = 0; goto label_1bbd5c;
            case 0x1bbd68: ctx->pc = 0; goto label_1bbd68;
            case 0x1bbd90: ctx->pc = 0; goto label_1bbd90;
            case 0x1bbdc0: ctx->pc = 0; goto label_1bbdc0;
            case 0x1bbdd8: ctx->pc = 0; goto label_1bbdd8;
            case 0x1bbe8c: ctx->pc = 0; goto label_1bbe8c;
            case 0x1bbe9c: ctx->pc = 0; goto label_1bbe9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bbcb0: 0x40782d
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bbcb4: 0x8e0203b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 952)));
    // 0x1bbcb8: 0x18400041
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1bbdc0;
    }
    // 0x1bbcc0: 0x2418000c
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1bbcc4: 0x8e0303bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 956)));
label_1bbcc8:
    // 0x1bbcc8: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x1bbccc: 0x248e0001
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1bbcd0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bbcd4: 0x625021
    SET_GPR_U32(ctx, 10, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bbcd8: 0x254d0004
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 10), 4));
    // 0x1bbcdc: 0x51040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 1));
label_1bbce0:
    // 0x1bbce0: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1bbce4: 0x1a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 13), GPR_U32(ctx, 2)));
    // 0x1bbce8: 0x24ac0001
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1bbcec: 0x84460000
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bbcf0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bbcf4: 0xd81818
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 24); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1bbcf8: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1bbcfc: 0x4f3821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 15)));
    // 0x1bbd00: 0xe0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1bbd04: 0x834021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1bbd08: 0x51040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 1));
    // 0x1bbd0c: 0x0
    // NOP
label_1bbd10:
    // 0x1bbd10: 0x8ce30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1bbd14: 0x1421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 2)));
    // 0x1bbd18: 0x24a90001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1bbd1c: 0x84460000
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bbd20: 0x18600011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1bbd68;
    }
    // 0x1bbd28: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1bbd2c: 0x50c2000b
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
        goto label_1bbd5c;
    }
    // 0x1bbd34: 0x8d650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 11), 0)));
    // 0x1bbd38: 0x100182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1bbd3c: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_1bbd40:
    // 0x1bbd40: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x1bbd44: 0x10400008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bbd68;
    }
    // 0x1bbd4c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bbd50: 0x54c2fffb
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1bbd40;
    }
    // 0x1bbd58: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
label_1bbd5c:
    // 0x1bbd5c: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1bbd60: 0x1440000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bbd90;
    }
label_1bbd68:
    // 0x1bbd68: 0x28820003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 3));
    // 0x1bbd6c: 0x10400008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bbd90;
    }
    // 0x1bbd74: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1bbd78: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1bbd7c: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x1bbd80: 0xac460000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 6));
    // 0x1bbd84: 0x8ce30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1bbd88: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1bbd8c: 0xace30000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 3));
label_1bbd90:
    // 0x1bbd90: 0x28a20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    // 0x1bbd94: 0x1440ffde
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bbd10;
    }
    // 0x1bbd9c: 0x180282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 12) + GPR_U64(ctx, 0));
    // 0x1bbda0: 0x28a20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    // 0x1bbda4: 0x1440ffce
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bbce0;
    }
    // 0x1bbdac: 0x8e0203b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 952)));
    // 0x1bbdb0: 0x1c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 14) + GPR_U64(ctx, 0));
    // 0x1bbdb4: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1bbdb8: 0x5440ffc3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 956)));
        goto label_1bbcc8;
    }
label_1bbdc0:
    // 0x1bbdc0: 0x8e0203b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 944)));
    // 0x1bbdc4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bbdc8: 0x18400034
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 904)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1bbe9c;
    }
    // 0x1bbdd0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1bbdd4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1bbdd8:
    // 0x1bbdd8: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1bbddc: 0x62140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 6), 5));
    // 0x1bbde0: 0x8e050390
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 912)));
    // 0x1bbde4: 0x494021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1bbde8: 0x8d030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 4)));
    // 0x1bbdec: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1bbdf0: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1bbdf4: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1bbdf8: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1bbdfc: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1bbe00: 0x471021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1bbe04: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bbe08: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bbe0c: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bbe10: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1bbe14: 0x8d020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x1bbe18: 0x8d030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1bbe1c: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1bbe20: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1bbe24: 0x471021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1bbe28: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1bbe2c: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bbe30: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bbe34: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bbe38: 0x4bc21afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1bbe3c: 0x4bc310ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bbe40: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bbe44: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bbe48: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1bbe4c: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1bbe50: 0x4bc118ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bbe54: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bbe58: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bbe5c: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bbe60: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1bbe64: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1bbe68: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bbe6c: 0x0
    // NOP
    // 0x1bbe70: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 944)));
        goto label_1bbe8c;
    }
    // 0x1bbe78: 0x8d020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 4)));
    // 0x1bbe7c: 0x8d030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x1bbe80: 0xad020008
    WRITE32(ADD32(GPR_U32(ctx, 8), 8), GPR_U32(ctx, 2));
    // 0x1bbe84: 0xad030004
    WRITE32(ADD32(GPR_U32(ctx, 8), 4), GPR_U32(ctx, 3));
    // 0x1bbe88: 0x8e0203b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 944)));
label_1bbe8c:
    // 0x1bbe8c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1bbe90: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1bbe94: 0x1440ffd0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bbdd8;
    }
label_1bbe9c:
    // 0x1bbe9c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1bbea4);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bbea4
// Address: 0x1bbea4 - 0x1bbeb8

void entry_1bbea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bbea4) {
        switch (ctx->pc) {
            case 0x1bbea8: ctx->pc = 0; goto label_1bbea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bbea4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1bbea8:
    // 0x1bbea8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bbeac: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bbeb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectSoLvo__FP2SOf
// Address: 0x1bbeb8 - 0x1bc088

void entry_1bc0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc0b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bc0bc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bc0c0: 0xc049510
    SET_GPR_U32(ctx, 31, 0x1bc0c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ProjectAloTransform__FP3ALOfi(rdram, ctx, runtime); return;
}


// Function: entry_1bc0c8
// Address: 0x1bc0c8 - 0x1bc0e0

void entry_1bc0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc0c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc0cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bc0d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bc0d4: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1bc0d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplySoImpulse__FP2SOP6VECTORT1f
// Address: 0x1bc0e0 - 0x1bc12c

void entry_1bc12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc12c) {
        switch (ctx->pc) {
            case 0x1bc188: ctx->pc = 0; goto label_1bc188;
            case 0x1bc194: ctx->pc = 0; goto label_1bc194;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc12c: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1bc130: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1bc134: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bc138: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1bc13c: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bc140: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1bc144: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1bc148: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1bc14c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bc150: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bc154: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc158: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bc15c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bc160: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc164: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bc168: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1bc16c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bc170: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1bc174: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bc178: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1bc188;
    }
    // 0x1bc180: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bc194;
    }
label_1bc188:
    // 0x1bc188: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1bc18c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bc190: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1bc194:
    // 0x1bc194: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1bc198: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1bc19c: 0x200582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bc1a0: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1bc1a4: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bc1a8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bc1ac: 0xafa00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    // 0x1bc1b0: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bc1b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bc1b8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bc1bc: 0x2408000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1bc1c0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bc1c4: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1bc1cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1bc1cc
// Address: 0x1bc1cc - 0x1bc208

void entry_1bc1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc1cc: 0x8fa40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc1d0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bc1d4: 0x7a630000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1bc1d8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bc1dc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bc1e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bc1e4: 0x7c830070
    WRITE128(ADD32(GPR_U32(ctx, 4), 112), GPR_VEC(ctx, 3));
    // 0x1bc1e8: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc1ec: 0xe4540098
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 152), *(uint32_t*)&val); }
    // 0x1bc1f0: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc1f4: 0xe4600094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 148), *(uint32_t*)&val); }
    // 0x1bc1f8: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc1fc: 0xe45500a0
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 160), *(uint32_t*)&val); }
    // 0x1bc200: 0xc06182a
    SET_GPR_U32(ctx, 31, 0x1bc208);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    RecalcSwXpMovement__FP2SWiPP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1bc208
// Address: 0x1bc208 - 0x1bc230

void entry_1bc208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc208: 0x8e220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1bc20c: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bc210: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1bc214: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bc218: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x1bc21c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bc220: 0x27a60024
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 36));
    // 0x1bc224: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bc228: 0xc06f340
    SET_GPR_U32(ctx, 31, 0x1bc230);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 2));
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime); return;
}


// Function: entry_1bc230
// Address: 0x1bc230 - 0x1bc23c

void entry_1bc230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc230: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1bc234: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1bc23c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1bc23c
// Address: 0x1bc23c - 0x1bc260

void entry_1bc23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc23c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bc240: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bc244: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bc248: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bc24c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bc250: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x1bc254: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1bc258: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateSoTrajectoryApex__FP2SOP6VECTORfT1
// Address: 0x1bc260 - 0x1bc2d4

void entry_1bc2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc2d4: 0xc6000140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 320)); ctx->f[0] = *(float*)&val; }
    // 0x1bc2d8: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1bc2dc: 0xc7a30000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[3] = *(float*)&val; }
    // 0x1bc2e0: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1bc2e4: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1bc2e8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bc2ec: 0x460310a8
    ctx->f[2] = std::max(ctx->f[2], ctx->f[3]);
    // 0x1bc2f0: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x1bc2f4: 0xe6410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x1bc2f8: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1bc2fc: 0xc6010144
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 324)); ctx->f[1] = *(float*)&val; }
    // 0x1bc300: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc304: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1bc308: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bc30c: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1bc310: 0xe6400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 4), *(uint32_t*)&val); }
    // 0x1bc314: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bc318: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FAbsorbSoWkr__FP2SOP3WKR
// Address: 0x1bc320 - 0x1bc34c

void entry_1bc34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc34c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1bc350: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bc354: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bc358: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1bc35c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bc364: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bc368; return;
}


// Function: CloneSoPhys__FP2SOT0i
// Address: 0x1bc368 - 0x1bc3a0

void entry_1bc3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc3a0) {
        switch (ctx->pc) {
            case 0x1bc3b8: ctx->pc = 0; goto label_1bc3b8;
            case 0x1bc3e4: ctx->pc = 0; goto label_1bc3e4;
            case 0x1bc3f0: ctx->pc = 0; goto label_1bc3f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc3a0: 0x8e620384
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 900)));
    // 0x1bc3a4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1bc3a8: 0x18400011
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1bc3f0;
    }
    // 0x1bc3b0: 0x8e630388
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 904)));
    // 0x1bc3b4: 0x0
    // NOP
label_1bc3b8:
    // 0x1bc3b8: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bc3bc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc3c0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bc3c4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc3c8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bc3cc: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bc3d0: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1bc3d4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bc3d8: 0x0
    // NOP
    // 0x1bc3dc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[0]);
        goto label_1bc3e4;
    }
label_1bc3e4:
    // 0x1bc3e4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1bc3e8: 0x1440fff3
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bc3b8;
    }
label_1bc3f0:
    // 0x1bc3f0: 0x46010004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x1bc3f4: 0xe64003cc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 972), *(uint32_t*)&val); }
    // 0x1bc3f8: 0x26500380
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 896));
    // 0x1bc3fc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bc400: 0x265103a4
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 932));
    // 0x1bc404: 0x6a660387
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 903); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1bc408: 0x6e660380
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 896); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1bc40c: 0x6a67038f
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 911); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1bc410: 0x6e670388
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 904); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1bc414: 0x6a620397
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 919); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bc418: 0x6e620390
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 912); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bc41c: 0x6a63039f
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 927); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1bc420: 0x6e630398
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 920); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1bc424: 0xb3a60047
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 71); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc428: 0xb7a60040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc42c: 0xb3a7004f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 79); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc430: 0xb7a70048
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 72); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc434: 0xb3a20057
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 87); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc438: 0xb7a20050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc43c: 0xb3a3005f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 95); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc440: 0xb7a30058
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 88); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bc444: 0x8e6603a0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 928)));
    // 0x1bc448: 0xafa60060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 6));
    // 0x1bc44c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bc450: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1bc454: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1bc458: 0xc0583a8
    SET_GPR_U32(ctx, 31, 0x1bc460);
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 2));
    CloneGeom__FP4GEOMP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1bc460
// Address: 0x1bc460 - 0x1bc470

void entry_1bc460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc460: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bc464: 0x26440140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1bc468: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1bc470);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 272));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1bc470
// Address: 0x1bc470 - 0x1bc480

void entry_1bc470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc470: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bc474: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bc478: 0xc0583a8
    SET_GPR_U32(ctx, 31, 0x1bc480);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CloneGeom__FP4GEOMP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1bc480
// Address: 0x1bc480 - 0x1bc498

void entry_1bc480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc480: 0xae4004b8
    WRITE32(ADD32(GPR_U32(ctx, 18), 1208), GPR_U32(ctx, 0));
    // 0x1bc484: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bc488: 0x266403a4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 932));
    // 0x1bc48c: 0x266503f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 1008));
    // 0x1bc490: 0xc04f9b2
    SET_GPR_U32(ctx, 31, 0x1bc498);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 1008));
    CloneBspc__FP4GEOMP4BSPCT0T1(rdram, ctx, runtime); return;
}


// Function: entry_1bc498
// Address: 0x1bc498 - 0x1bc4ac

void entry_1bc498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc498: 0x26650530
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 1328));
    // 0x1bc49c: 0x2664050c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 1292));
    // 0x1bc4a0: 0x2646050c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 1292));
    // 0x1bc4a4: 0xc04f9b2
    SET_GPR_U32(ctx, 31, 0x1bc4ac);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 1328));
    CloneBspc__FP4GEOMP4BSPCT0T1(rdram, ctx, runtime); return;
}


// Function: entry_1bc4ac
// Address: 0x1bc4ac - 0x1bc4b4

void entry_1bc4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc4ac: 0xc06ef0e
    SET_GPR_U32(ctx, 31, 0x1bc4b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    EnsureSoLvo__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1bc4b4
// Address: 0x1bc4b4 - 0x1bc4d8

void entry_1bc4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc4b4: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1bc4b8: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1bc4bc: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1bc4c0: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1bc4c4: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1bc4c8: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bc4cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bc4d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bc4d8; return;
}


// Function: FUN_001bc4d8
// Address: 0x1bc4d8 - 0x1bc5ac

void FUN_001bc4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc4d8) {
        switch (ctx->pc) {
            case 0x1bc528: ctx->pc = 0; goto label_1bc528;
            case 0x1bc540: ctx->pc = 0; goto label_1bc540;
            case 0x1bc558: ctx->pc = 0; goto label_1bc558;
            case 0x1bc594: ctx->pc = 0; goto label_1bc594;
            case 0x1bc5a4: ctx->pc = 0; goto label_1bc5a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc4d8: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x1bc4dc: 0x7fb50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 21));
    // 0x1bc4e0: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1bc4e4: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bc4e8: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1bc4ec: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1bc4f0: 0x7fbf0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 31));
    // 0x1bc4f4: 0x7fb70070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 23));
    // 0x1bc4f8: 0x7fb60060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 22));
    // 0x1bc4fc: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x1bc500: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1bc504: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1bc508: 0x8e620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 80)));
    // 0x1bc50c: 0x1453004d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        entry_1bc644(rdram, ctx, runtime); return;
    }
    // 0x1bc514: 0x8e620480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1152)));
    // 0x1bc518: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bc51c: 0x52200047
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x1BC63C; return;
    }
    // 0x1bc524: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1bc528:
    // 0x1bc528: 0x1200003d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BC620; return;
    }
    // 0x1bc530: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bc534: 0x24170003
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1bc538: 0x24160004
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1bc53c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1bc540:
    // 0x1bc540: 0x531026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1bc544: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1bc548: 0x2821023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1bc54c: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1bc550: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1bc554: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
label_1bc558:
    // 0x1bc558: 0x5040002e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
        ctx->pc = 0x1BC614; return;
    }
    // 0x1bc560: 0x8c4304e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1248)));
    // 0x1bc564: 0x5060fffc
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        goto label_1bc558;
    }
    // 0x1bc56c: 0x50400029
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
        ctx->pc = 0x1BC614; return;
    }
    // 0x1bc574: 0x1077001c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 23)) {
        ctx->pc = 0x1BC5E8; return;
    }
    // 0x1bc57c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bc594;
    }
    // 0x1bc584: 0x50740007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        goto label_1bc5a4;
    }
    // 0x1bc58c: 0x10000021
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BC614; return;
    }
label_1bc594:
    // 0x1bc594: 0x50760019
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 22)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x1BC5FC; return;
    }
    // 0x1bc59c: 0x1000001d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BC614; return;
    }
label_1bc5a4:
    // 0x1bc5a4: 0xc06d7b0
    SET_GPR_U32(ctx, 31, 0x1bc5ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6908));
    PvAllocSlotheapImpl__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_1bc5ac
// Address: 0x1bc5ac - 0x1bc644

void entry_1bc5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc5ac) {
        switch (ctx->pc) {
            case 0x1bc5bc: ctx->pc = 0; goto label_1bc5bc;
            case 0x1bc5e8: ctx->pc = 0; goto label_1bc5e8;
            case 0x1bc5fc: ctx->pc = 0; goto label_1bc5fc;
            case 0x1bc610: ctx->pc = 0; goto label_1bc610;
            case 0x1bc614: ctx->pc = 0; goto label_1bc614;
            case 0x1bc620: ctx->pc = 0; goto label_1bc620;
            case 0x1bc63c: ctx->pc = 0; goto label_1bc63c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc5ac: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bc5b0: 0x260500e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 224));
    // 0x1bc5b4: 0x80182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1bc5b8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1bc5bc:
    // 0x1bc5bc: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bc5c0: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1bc5c4: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x1bc5c8: 0x7c670010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 7));
    // 0x1bc5cc: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1bc5d0: 0x1445fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_1bc5bc;
    }
    // 0x1bc5d8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1bc5dc: 0xac8200d0
    WRITE32(ADD32(GPR_U32(ctx, 4), 208), GPR_U32(ctx, 2));
    // 0x1bc5e0: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bc610;
    }
label_1bc5e8:
    // 0x1bc5e8: 0x8e0200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1bc5ec: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x1bc5f0: 0xae1500d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 208), GPR_U32(ctx, 21));
    // 0x1bc5f4: 0x10000007
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bc614;
    }
label_1bc5fc:
    // 0x1bc5fc: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x1bc600: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1bc604: 0xae0300d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 208), GPR_U32(ctx, 3));
    // 0x1bc608: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bc614;
    }
label_1bc610:
    // 0x1bc610: 0x260400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
label_1bc614:
    // 0x1bc614: 0x8c900000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bc618: 0x5600ffc9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BC540; return;
    }
label_1bc620:
    // 0x1bc620: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1bc624: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1bc628: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1bc62c: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1bc630: 0x5620ffbd
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1BC528; return;
    }
    // 0x1bc638: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
label_1bc63c:
    // 0x1bc63c: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1bc644);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1bc644
// Address: 0x1bc644 - 0x1bc670

void entry_1bc644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc644: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1bc648: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bc64c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bc650: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bc654: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bc658: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bc65c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc660: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bc664: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bc668: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001bc670
// Address: 0x1bc670 - 0x1bc6f4

void FUN_001bc670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc670) {
        switch (ctx->pc) {
            case 0x1bc6d8: ctx->pc = 0; goto label_1bc6d8;
            case 0x1bc6e0: ctx->pc = 0; goto label_1bc6e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc670: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1bc674: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bc678: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x1bc67c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1bc680: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1bc684: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bc688: 0x10400015
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bc6e0;
    }
    // 0x1bc690: 0xd8820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x1bc694: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bc698: 0xd8c10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1bc69c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc6a0: 0xc48103cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 972)); ctx->f[1] = *(float*)&val; }
    // 0x1bc6a4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc6a8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bc6ac: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc6b0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bc6b4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bc6b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bc6bc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1bc6c0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bc6c4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1bc6c8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bc6cc: 0x0
    // NOP
    // 0x1bc6d0: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1bc6d8;
    }
label_1bc6d8:
    // 0x1bc6d8: 0x1440000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BC704; return;
    }
label_1bc6e0:
    // 0x1bc6e0: 0x8c8503f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1016)));
    // 0x1bc6e4: 0x50a00007
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x1BC704; return;
    }
    // 0x1bc6ec: 0xc04f996
    SET_GPR_U32(ctx, 31, 0x1bc6f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_1bc6f4
// Address: 0x1bc6f4 - 0x1bc710

void entry_1bc6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc6f4) {
        switch (ctx->pc) {
            case 0x1bc704: ctx->pc = 0; goto label_1bc704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc6f4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bc6f8: 0x14600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1bc704;
    }
    // 0x1bc700: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1bc704:
    // 0x1bc704: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bc708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001bc710
// Address: 0x1bc710 - 0x1bc748

void FUN_001bc710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc710: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1bc714: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x1bc718: 0x3c03ffef
    SET_GPR_U32(ctx, 3, ((uint32_t)65519 << 16));
    // 0x1bc71c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1bc720: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1bc724: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1bc728: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1bc72c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1bc730: 0x52d3c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 20));
    // 0x1bc734: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bc738: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1bc73c: 0x3e00008
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bc744: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bc748; return;
}


// Function: FUN_001bc748
// Address: 0x1bc748 - 0x1bc760

void FUN_001bc748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc748: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1bc74c: 0x2153e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 20));
    // 0x1bc750: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1bc754: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bc75c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bc760; return;
}


// Function: RenumberSo__FP2SOPiPP2SO
// Address: 0x1bc760 - 0x1bc7d0

void entry_1bc7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc7d0) {
        switch (ctx->pc) {
            case 0x1bc7e0: ctx->pc = 0; goto label_1bc7e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc7d0: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1bc7d4: 0x5600fff6
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BC7B0; return;
    }
    // 0x1bc7dc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1bc7e0:
    // 0x1bc7e0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bc7e4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bc7e8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bc7ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bc7f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bc7f8; return;
}


// Function: CalculateSoEffect__FP2SOP6VECTORP2FXT1
// Address: 0x1bc7f8 - 0x1bc828

void entry_1bc8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc8d0: 0x26110010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1bc8d4: 0xc6410368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 872)); ctx->f[1] = *(float*)&val; }
    // 0x1bc8d8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bc8dc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bc8e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bc8e4: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1bc8e8: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bc8ec: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bc8f0: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1bc8f4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1bc8f8: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1bc8fc: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bc900: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bc904: 0xc06e3fa
    SET_GPR_U32(ctx, 31, 0x1bc90c);
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    CalculateSoAngularEffectWorld__FP2SOP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1bc90c
// Address: 0x1bc90c - 0x1bc924

void entry_1bc90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bc90c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bc910: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bc914: 0x26450460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1120));
    // 0x1bc918: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1bc91c: 0xc06e8ba
    SET_GPR_U32(ctx, 31, 0x1bc924);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1bc924
// Address: 0x1bc924 - 0x1bc978

void entry_1bc924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bc924) {
        switch (ctx->pc) {
            case 0x1bc928: ctx->pc = 0; goto label_1bc928;
            case 0x1bc95c: ctx->pc = 0; goto label_1bc95c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bc924: 0x8e520018
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 24)));
label_1bc928:
    // 0x1bc928: 0x1240000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1bc95c;
    }
    // 0x1bc930: 0xde430538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x1bc934: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bc938: 0x211fc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 7));
    // 0x1bc93c: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bc940: 0x5040ffd3
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
        ctx->pc = 0x1BC890; return;
    }
    // 0x1bc948: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bc94c: 0x2127c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 9));
    // 0x1bc950: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bc954: 0x5040fff4
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 24)));
        goto label_1bc928;
    }
label_1bc95c:
    // 0x1bc95c: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1bc960: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bc964: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bc968: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bc96c: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bc970: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DistributeSoEffects__FP2SOiiPP2SOP2FX
// Address: 0x1bc978 - 0x1bca0c

void entry_1bca0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bca0c) {
        switch (ctx->pc) {
            case 0x1bca44: ctx->pc = 0; goto label_1bca44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bca0c: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1bca10: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bca14: 0x319fc
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 7));
    // 0x1bca18: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bca1c: 0x10400009
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bca44;
    }
    // 0x1bca24: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1bca28: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bca2c: 0xda630010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1bca30: 0xfa620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bca34: 0xda410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1bca38: 0x4be118e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bca3c: 0x1000009e
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BCCB8; return;
    }
label_1bca44:
    // 0x1bca44: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bca48: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bca4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bca50: 0x26250440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1088));
    // 0x1bca54: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bca58: 0xc06e8ba
    SET_GPR_U32(ctx, 31, 0x1bca60);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1120));
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1bca60
// Address: 0x1bca60 - 0x1bca78

void entry_1bca60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bca60: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bca64: 0x26460010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 16));
    // 0x1bca68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bca6c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bca70: 0xc06e8ba
    SET_GPR_U32(ctx, 31, 0x1bca78);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1bca78
// Address: 0x1bca78 - 0x1bcc88

void entry_1bca78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bca78) {
        switch (ctx->pc) {
            case 0x1bcae4: ctx->pc = 0; goto label_1bcae4;
            case 0x1bcb88: ctx->pc = 0; goto label_1bcb88;
            case 0x1bcb98: ctx->pc = 0; goto label_1bcb98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bca78: 0x8e230470
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1136)));
    // 0x1bca7c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1bca80: 0x10620085
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1BCC98; return;
    }
    // 0x1bca88: 0x7a2204d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 1232)));
    // 0x1bca8c: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bca90: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1bca94: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1bca98: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1bca9c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1bcaa0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1bcaa4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bcaa8: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1bcae4;
    }
    // 0x1bcab0: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1bcab4: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1bcab8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1bcabc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bcac0: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1bcae4;
    }
    // 0x1bcac8: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1bcacc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1bcad0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1bcad4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bcad8: 0x0
    // NOP
    // 0x1bcadc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1bcae4;
    }
label_1bcae4:
    // 0x1bcae4: 0x1460006d
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BCC9C; return;
    }
    // 0x1bcaec: 0x26220110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 272));
    // 0x1bcaf0: 0xda240110
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x1bcaf4: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1bcaf8: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1bcafc: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1bcb00: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bcb04: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bcb08: 0x24628d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x1bcb0c: 0x4be121ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb10: 0x4be00213
    // Unhandled VU0 Special1 function: 0x13
    // 0x1bcb14: 0x4be119aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb18: 0x4be1116a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb1c: 0x4b07383d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb20: 0x4b07424a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcb24: 0x4a86303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1bcb28: 0x4a86424a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcb2c: 0x4a45283c
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1bcb30: 0x4a454249
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcb34: 0xfba90020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x1bcb38: 0xda2104d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1232)));
    // 0x1bcb3c: 0x4bc90afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[9] = READ32(addr); }
    // 0x1bcb40: 0x4bc1486e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcb44: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb48: 0x4bc108ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb4c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb50: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb54: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcb58: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bcb5c: 0x4a0303bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bcb60: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bcb64: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1bcb68: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bcb6c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1bcb70: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bcb74: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1bcb88;
    }
    // 0x1bcb7c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bcb80: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bcb98;
    }
label_1bcb88:
    // 0x1bcb88: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1bcb8c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bcb90: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1bcb94: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_1bcb98:
    // 0x1bcb98: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bcb9c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1bcba0: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bcba4: 0x0
    // NOP
    // 0x1bcba8: 0x4500003b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 752));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BCC98; return;
    }
    // 0x1bcbb0: 0xda2102f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 752)));
    // 0x1bcbb4: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1bcbb8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bcbbc: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1bcbc0: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bcbc4: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bcbc8: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bcbcc: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1bcbd0: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bcbd4: 0x4bc2204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcbd8: 0xdba70000
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bcbdc: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bcbe0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bcbe4: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bcbe8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bcbec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bcbf0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcbf4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bcbf8: 0xda2204d0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1232)));
    // 0x1bcbfc: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x1bcc00: 0x4bc210ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc04: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc08: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc0c: 0x4b0308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcc10: 0xc6210368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 872)); ctx->f[1] = *(float*)&val; }
    // 0x1bcc14: 0x48231800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1bcc18: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1bcc1c: 0xd9210010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 9), 16)));
    // 0x1bcc20: 0x46001083
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[0];
    // 0x1bcc24: 0xd9260020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 9), 32)));
    // 0x1bcc28: 0xda230110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x1bcc2c: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1bcc30: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc34: 0x4bc2308a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcc38: 0x4bc2116a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc3c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc40: 0x4b05283d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc44: 0x4b05214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcc48: 0x4bc23afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1bcc4c: 0x4bc711ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[7]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bcc50: 0x4a2739ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc54: 0x48222800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1bcc58: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1bcc5c: 0xfba70060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1bcc60: 0x46020880
    ctx->f[2] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1bcc64: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bcc68: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x1bcc6c: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1bcc70: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1bcc74: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1bcc78: 0x4be139d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc7c: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bcc80: 0xc06e8ba
    SET_GPR_U32(ctx, 31, 0x1bcc88);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[7]));
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1bcc88
// Address: 0x1bcc88 - 0x1bcd00

void entry_1bcc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bcc88) {
        switch (ctx->pc) {
            case 0x1bcc98: ctx->pc = 0; goto label_1bcc98;
            case 0x1bcc9c: ctx->pc = 0; goto label_1bcc9c;
            case 0x1bccb8: ctx->pc = 0; goto label_1bccb8;
            case 0x1bccc8: ctx->pc = 0; goto label_1bccc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bcc88: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bcc8c: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bcc90: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bcc94: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1bcc98:
    // 0x1bcc98: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1bcc9c:
    // 0x1bcc9c: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bcca0: 0xda610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1bcca4: 0xda620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1bcca8: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bccac: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bccb0: 0xfa610000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bccb4: 0xfa620010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_1bccb8:
    // 0x1bccb8: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1bccbc: 0x297102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 23)));
    // 0x1bccc0: 0x1440ff45
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 20), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BC9D8; return;
    }
label_1bccc8:
    // 0x1bccc8: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1bcccc: 0x7bbe0100
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1bccd0: 0x7bb700f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1bccd4: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1bccd8: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1bccdc: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1bcce0: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1bcce4: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1bcce8: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1bccec: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1bccf0: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x1bccf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bccfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bcd00; return;
}


// Function: SolveSwGroup__FP2SWiPP2SOiPP2XPfi
// Address: 0x1bcd00 - 0x1bcebc

void entry_1bcebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bcebc: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bcec0: 0x38080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1bcec4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bcecc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bcecc
// Address: 0x1bcecc - 0x1bcee0

void entry_1bcecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bcecc: 0x33c40001
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 30), 1));
    // 0x1bced0: 0xafa2005c
    WRITE32(ADD32(GPR_U32(ctx, 29), 92), GPR_U32(ctx, 2));
    // 0x1bced4: 0xafa40060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 4));
    // 0x1bced8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bcee0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bcee0
// Address: 0x1bcee0 - 0x1bcefc

void entry_1bcee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bcee0: 0x33c30004
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 30), 4));
    // 0x1bcee4: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bcee8: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bceec: 0xafa30064
    WRITE32(ADD32(GPR_U32(ctx, 29), 100), GPR_U32(ctx, 3));
    // 0x1bcef0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bcef4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1bcefc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1bcefc
// Address: 0x1bcefc - 0x1bcf2c

void entry_1bcefc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bcefc) {
        switch (ctx->pc) {
            case 0x1bcf18: ctx->pc = 0; goto label_1bcf18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bcefc: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bcf00: 0x18800017
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1BCF60; return;
    }
    // 0x1bcf08: 0x8fb3005c
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    // 0x1bcf0c: 0x2e0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bcf10: 0x8fb20058
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    // 0x1bcf14: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1bcf18:
    // 0x1bcf18: 0x240400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    // 0x1bcf1c: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x1bcf20: 0xae1104bc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1212), GPR_U32(ctx, 17));
    // 0x1bcf24: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bcf2c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bcf2c
// Address: 0x1bcf2c - 0x1bcf50

void entry_1bcf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bcf2c: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x1bcf30: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bcf34: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bcf38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bcf3c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1bcf40: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x1bcf44: 0x8c6200e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 228)));
    // 0x1bcf48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bcf50);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bcf50
// Address: 0x1bcf50 - 0x1bcf98

void entry_1bcf50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bcf50) {
        switch (ctx->pc) {
            case 0x1bcf60: ctx->pc = 0; goto label_1bcf60;
            case 0x1bcf70: ctx->pc = 0; goto label_1bcf70;
            case 0x1bcf8c: ctx->pc = 0; goto label_1bcf8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bcf50: 0x8fa20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bcf54: 0x222182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1bcf58: 0x5460ffef
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1BCF18; return;
    }
label_1bcf60:
    // 0x1bcf60: 0x1aa0000a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_1bcf8c;
    }
    // 0x1bcf68: 0x2c0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1bcf6c: 0x0
    // NOP
label_1bcf70:
    // 0x1bcf70: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bcf74: 0xac5000cc
    WRITE32(ADD32(GPR_U32(ctx, 2), 204), GPR_U32(ctx, 16));
    // 0x1bcf78: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1bcf7c: 0x215102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 21)));
    // 0x1bcf80: 0x0
    // NOP
    // 0x1bcf84: 0x1440fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bcf70;
    }
label_1bcf8c:
    // 0x1bcf8c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bcf90: 0xc054d4a
    SET_GPR_U32(ctx, 31, 0x1bcf98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    InitDzg__FP3DZGi(rdram, ctx, runtime); return;
}


// Function: entry_1bcf98
// Address: 0x1bcf98 - 0x1bd010

void entry_1bcf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bcf98) {
        switch (ctx->pc) {
            case 0x1bcfb8: ctx->pc = 0; goto label_1bcfb8;
            case 0x1bcff0: ctx->pc = 0; goto label_1bcff0;
            case 0x1bcff8: ctx->pc = 0; goto label_1bcff8;
            case 0x1bd004: ctx->pc = 0; goto label_1bd004;
            case 0x1bd008: ctx->pc = 0; goto label_1bd008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bcf98: 0x1aa00021
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 100)));
    if (GPR_S32(ctx, 21) <= 0) {
        ctx->pc = 0x1BD020; return;
    }
    // 0x1bcfa0: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1bcfa4: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bcfa8: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bcfac: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1bcfb0: 0x2a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bcfb4: 0x0
    // NOP
label_1bcfb8:
    // 0x1bcfb8: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1bcfbc: 0x2404000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1bcfc0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1bcfc4: 0x522821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1bcfc8: 0xaca30000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 3));
    // 0x1bcfcc: 0x78620080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x1bcfd0: 0x7ca20010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 2));
    // 0x1bcfd4: 0x8c62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 156)));
    // 0x1bcfd8: 0x10440005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_1bcff0;
    }
    // 0x1bcfe0: 0x10440005
    WRITE32(ADD32(GPR_U32(ctx, 5), 40), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_1bcff8;
    }
    // 0x1bcfe8: 0x10000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bd008;
    }
label_1bcff0:
    // 0x1bcff0: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 5), 40), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bd004;
    }
label_1bcff8:
    // 0x1bcff8: 0xacb3002c
    WRITE32(ADD32(GPR_U32(ctx, 5), 44), GPR_U32(ctx, 19));
    // 0x1bcffc: 0xc46000a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 160)); ctx->f[0] = *(float*)&val; }
    // 0x1bd000: 0xe4a00030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 48), *(uint32_t*)&val); }
label_1bd004:
    // 0x1bd004: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1bd008:
    // 0x1bd008: 0xc054db2
    SET_GPR_U32(ctx, 31, 0x1bd010);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 96));
    AppendDzgDz__FP3DZGP2DZ(rdram, ctx, runtime); return;
}


// Function: entry_1bd010
// Address: 0x1bd010 - 0x1bd08c

void entry_1bd010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd010) {
        switch (ctx->pc) {
            case 0x1bd020: ctx->pc = 0; goto label_1bd020;
            case 0x1bd040: ctx->pc = 0; goto label_1bd040;
            case 0x1bd06c: ctx->pc = 0; goto label_1bd06c;
            case 0x1bd074: ctx->pc = 0; goto label_1bd074;
            case 0x1bd080: ctx->pc = 0; goto label_1bd080;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd010: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1bd014: 0x1600ffe8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BCFB8; return;
    }
    // 0x1bd01c: 0x8fa20064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 100)));
label_1bd020:
    // 0x1bd020: 0x10400051
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD168; return;
    }
    // 0x1bd028: 0x1aa0002b
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        ctx->pc = 0x1BD0D8; return;
    }
    // 0x1bd030: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bd034: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1bd038: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1bd03c: 0x24030060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 96));
label_1bd040:
    // 0x1bd040: 0x71080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1bd044: 0xe32018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1bd048: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1bd04c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1bd050: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bd054: 0x648821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1bd058: 0x8e220028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x1bd05c: 0x14540003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 144)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        goto label_1bd06c;
    }
    // 0x1bd064: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 56), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bd074;
    }
label_1bd06c:
    // 0x1bd06c: 0x46150000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x1bd070: 0xe6200038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 56), *(uint32_t*)&val); }
label_1bd074:
    // 0x1bd074: 0x24f30001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1bd078: 0x24b00004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1bd07c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1bd080:
    // 0x1bd080: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1bd084: 0xc06ed50
    SET_GPR_U32(ctx, 31, 0x1bd08c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 264));
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1bd08c
// Address: 0x1bd08c - 0x1bd0b8

void entry_1bd08c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd08c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bd090: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x1BD0BC; return;
    }
    // 0x1bd098: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd09c: 0x8c420108
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 264)));
    // 0x1bd0a0: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1bd0b8(rdram, ctx, runtime); return;
    }
    // 0x1bd0a8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bd0ac: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bd0b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bd0b8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bd0b8
// Address: 0x1bd0b8 - 0x1bd0f4

void entry_1bd0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd0b8) {
        switch (ctx->pc) {
            case 0x1bd0bc: ctx->pc = 0; goto label_1bd0bc;
            case 0x1bd0d8: ctx->pc = 0; goto label_1bd0d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd0b8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_1bd0bc:
    // 0x1bd0bc: 0x2a420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    // 0x1bd0c0: 0x1440ffef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD080; return;
    }
    // 0x1bd0c8: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bd0cc: 0xf5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 21)));
    // 0x1bd0d0: 0x1440ffdb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 96));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD040; return;
    }
label_1bd0d8:
    // 0x1bd0d8: 0x8fa9005c
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    // 0x1bd0dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bd0e0: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1bd0e4: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bd0e8: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1bd0ec: 0xc054fb0
    SET_GPR_U32(ctx, 31, 0x1bd0f4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    SolveDzg__FP3DZGiiPP2XPPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1bd0f4
// Address: 0x1bd0f4 - 0x1bd118

void entry_1bd0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd0f4: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1bd0f8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1bd0fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bd100: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bd104: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1bd108: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bd10c: 0x8fa50054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bd110: 0xc0550dc
    SET_GPR_U32(ctx, 31, 0x1bd118);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    ApplyDzg__FP3DZGiPiPPP2SOff(rdram, ctx, runtime); return;
}


// Function: entry_1bd118
// Address: 0x1bd118 - 0x1bd148

void entry_1bd118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd118) {
        switch (ctx->pc) {
            case 0x1bd130: ctx->pc = 0; goto label_1bd130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd118: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bd11c: 0x1880000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1BD154; return;
    }
    // 0x1bd124: 0x8fb10058
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    // 0x1bd128: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1bd12c: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1bd130:
    // 0x1bd130: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bd134: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x1bd138: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd13c: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x1bd140: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bd148);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bd148
// Address: 0x1bd148 - 0x1bd164

void entry_1bd148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd148) {
        switch (ctx->pc) {
            case 0x1bd154: ctx->pc = 0; goto label_1bd154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd148: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1BD130; return;
    }
    // 0x1bd150: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
label_1bd154:
    // 0x1bd154: 0x13c20099
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1BD3BC; return;
    }
    // 0x1bd15c: 0xc054d82
    SET_GPR_U32(ctx, 31, 0x1bd164);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ClearDzgSolution__FP3DZG(rdram, ctx, runtime); return;
}


// Function: entry_1bd164
// Address: 0x1bd164 - 0x1bd17c

void entry_1bd164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd164) {
        switch (ctx->pc) {
            case 0x1bd168: ctx->pc = 0; goto label_1bd168;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd164: 0x8fa20060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 96)));
label_1bd168:
    // 0x1bd168: 0x10400035
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD240; return;
    }
    // 0x1bd170: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bd174: 0xc0617d2
    SET_GPR_U32(ctx, 31, 0x1bd17c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    RecalcSwXpPos__FP2SWiPP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1bd17c
// Address: 0x1bd17c - 0x1bd18c

void entry_1bd17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd17c: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bd180: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bd184: 0xc06182a
    SET_GPR_U32(ctx, 31, 0x1bd18c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    RecalcSwXpMovement__FP2SWiPP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1bd18c
// Address: 0x1bd18c - 0x1bd1ec

void entry_1bd18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd18c) {
        switch (ctx->pc) {
            case 0x1bd1a0: ctx->pc = 0; goto label_1bd1a0;
            case 0x1bd1e0: ctx->pc = 0; goto label_1bd1e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd18c: 0x1aa0006a
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        ctx->pc = 0x1BD338; return;
    }
    // 0x1bd194: 0x24140060
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1bd198: 0x71080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1bd19c: 0x0
    // NOP
label_1bd1a0:
    // 0x1bd1a0: 0xf42818
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1bd1a4: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1bd1a8: 0x8fa40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1bd1ac: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bd1b0: 0x24f30001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1bd1b4: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bd1b8: 0xd86100b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x1bd1bc: 0x24700004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1bd1c0: 0xd8620080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x1bd1c4: 0x859021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1bd1c8: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bd1cc: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bd1d0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bd1d4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bd1d8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bd1dc: 0xae430038
    WRITE32(ADD32(GPR_U32(ctx, 18), 56), GPR_U32(ctx, 3));
label_1bd1e0:
    // 0x1bd1e0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1bd1e4: 0xc06ed50
    SET_GPR_U32(ctx, 31, 0x1bd1ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 264));
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1bd1ec
// Address: 0x1bd1ec - 0x1bd218

void entry_1bd1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd1ec: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bd1f0: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        ctx->pc = 0x1BD21C; return;
    }
    // 0x1bd1f8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd1fc: 0x8c420108
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 264)));
    // 0x1bd200: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1bd218(rdram, ctx, runtime); return;
    }
    // 0x1bd208: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bd20c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bd210: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bd218);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bd218
// Address: 0x1bd218 - 0x1bd2c4

void entry_1bd218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd218) {
        switch (ctx->pc) {
            case 0x1bd21c: ctx->pc = 0; goto label_1bd21c;
            case 0x1bd240: ctx->pc = 0; goto label_1bd240;
            case 0x1bd260: ctx->pc = 0; goto label_1bd260;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd218: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_1bd21c:
    // 0x1bd21c: 0x2a220002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    // 0x1bd220: 0x1440ffef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD1E0; return;
    }
    // 0x1bd228: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bd22c: 0xf5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 21)));
    // 0x1bd230: 0x1440ffdb
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD1A0; return;
    }
    // 0x1bd238: 0x10000040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967291));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD33C; return;
    }
label_1bd240:
    // 0x1bd240: 0x8fa40060
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bd244: 0x95102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 21)));
    // 0x1bd248: 0x1040003b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD338; return;
    }
    // 0x1bd250: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bd254: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1bd258: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1bd25c: 0x0
    // NOP
label_1bd260:
    // 0x1bd260: 0x24030060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1bd264: 0x2232018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1bd268: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1bd26c: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bd270: 0x26340001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1bd274: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1bd278: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bd27c: 0xda0100b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 176)));
    // 0x1bd280: 0x26110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1bd284: 0xda020080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1bd288: 0x649821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1bd28c: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bd290: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bd294: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bd298: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bd29c: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x1bd2a0: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1bd2a4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1bd2a8: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bd2ac: 0x3c013f8c
    SET_GPR_U32(ctx, 1, ((uint32_t)16268 << 16));
    // 0x1bd2b0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1bd2b4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1bd2b8: 0xae0400c8
    WRITE32(ADD32(GPR_U32(ctx, 16), 200), GPR_U32(ctx, 4));
    // 0x1bd2bc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1bd2c4);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1bd2c4
// Address: 0x1bd2c4 - 0x1bd2ec

void entry_1bd2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd2c4) {
        switch (ctx->pc) {
            case 0x1bd2e0: ctx->pc = 0; goto label_1bd2e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd2c4: 0xc6010098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 152)); ctx->f[1] = *(float*)&val; }
    // 0x1bd2c8: 0xc60200c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 200)); ctx->f[2] = *(float*)&val; }
    // 0x1bd2cc: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1bd2d0: 0x46150840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[21]);
    // 0x1bd2d4: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1bd2d8: 0xe6620038
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 19), 56), *(uint32_t*)&val); }
    // 0x1bd2dc: 0x0
    // NOP
label_1bd2e0:
    // 0x1bd2e0: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1bd2e4: 0xc06ed50
    SET_GPR_U32(ctx, 31, 0x1bd2ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 264));
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1bd2ec
// Address: 0x1bd2ec - 0x1bd318

void entry_1bd2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd2ec: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bd2f0: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x1BD31C; return;
    }
    // 0x1bd2f8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd2fc: 0x8c420108
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 264)));
    // 0x1bd300: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1bd318(rdram, ctx, runtime); return;
    }
    // 0x1bd308: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bd30c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bd310: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bd318);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bd318
// Address: 0x1bd318 - 0x1bd35c

void entry_1bd318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd318) {
        switch (ctx->pc) {
            case 0x1bd31c: ctx->pc = 0; goto label_1bd31c;
            case 0x1bd338: ctx->pc = 0; goto label_1bd338;
            case 0x1bd33c: ctx->pc = 0; goto label_1bd33c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd318: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_1bd31c:
    // 0x1bd31c: 0x2a420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    // 0x1bd320: 0x1440ffef
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD2E0; return;
    }
    // 0x1bd328: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bd32c: 0x235102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 21)));
    // 0x1bd330: 0x1440ffcb
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD260; return;
    }
label_1bd338:
    // 0x1bd338: 0x2405fffb
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967291));
label_1bd33c:
    // 0x1bd33c: 0x8fa9005c
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    // 0x1bd340: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bd344: 0x3c52824
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 30), GPR_U32(ctx, 5)));
    // 0x1bd348: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bd34c: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bd350: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1bd354: 0xc055022
    SET_GPR_U32(ctx, 31, 0x1bd35c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    SolveDzgFric__FP3DZGiiPP2XPPiPPP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_1bd35c
// Address: 0x1bd35c - 0x1bd38c

void entry_1bd35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd35c: 0x8fa20060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bd360: 0x1040000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD394; return;
    }
    // 0x1bd368: 0x3c01459c
    SET_GPR_U32(ctx, 1, ((uint32_t)17820 << 16));
    // 0x1bd36c: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1bd370: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1bd374: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1bd378: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1bd37c: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bd380: 0x8fa50054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bd384: 0xc0550dc
    SET_GPR_U32(ctx, 31, 0x1bd38c);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    ApplyDzg__FP3DZGiPiPPP2SOff(rdram, ctx, runtime); return;
}


// Function: entry_1bd38c
// Address: 0x1bd38c - 0x1bd3b8

void entry_1bd38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd38c) {
        switch (ctx->pc) {
            case 0x1bd394: ctx->pc = 0; goto label_1bd394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd38c: 0x1000000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD3BC; return;
    }
label_1bd394:
    // 0x1bd394: 0x3c01459c
    SET_GPR_U32(ctx, 1, ((uint32_t)17820 << 16));
    // 0x1bd398: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1bd39c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1bd3a0: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1bd3a4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1bd3a8: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bd3ac: 0x8fa50054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bd3b0: 0xc0550dc
    SET_GPR_U32(ctx, 31, 0x1bd3b8);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    ApplyDzg__FP3DZGiPiPPP2SOff(rdram, ctx, runtime); return;
}


// Function: entry_1bd3b8
// Address: 0x1bd3b8 - 0x1bd400

void entry_1bd3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd3b8) {
        switch (ctx->pc) {
            case 0x1bd3bc: ctx->pc = 0; goto label_1bd3bc;
            case 0x1bd3d0: ctx->pc = 0; goto label_1bd3d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd3b8: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
label_1bd3bc:
    // 0x1bd3bc: 0x18600032
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1BD488; return;
    }
    // 0x1bd3c4: 0x2413ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1bd3c8: 0x33d20002
    SET_GPR_U32(ctx, 18, AND32(GPR_U32(ctx, 30), 2));
    // 0x1bd3cc: 0x8fa40058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 88)));
label_1bd3d0:
    // 0x1bd3d0: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1bd3d4: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bd3d8: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1bd3dc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bd3e0: 0xac9304bc
    WRITE32(ADD32(GPR_U32(ctx, 4), 1212), GPR_U32(ctx, 19));
    // 0x1bd3e4: 0x8fa20060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bd3e8: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD408; return;
    }
    // 0x1bd3f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd3f4: 0x8c6200d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 212)));
    // 0x1bd3f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bd400);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bd400
// Address: 0x1bd400 - 0x1bd420

void entry_1bd400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd400) {
        switch (ctx->pc) {
            case 0x1bd408: ctx->pc = 0; goto label_1bd408;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd400: 0x10000008
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD424; return;
    }
label_1bd408:
    // 0x1bd408: 0x12400006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD424; return;
    }
    // 0x1bd410: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd414: 0x8c6200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 208)));
    // 0x1bd418: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bd420);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bd420
// Address: 0x1bd420 - 0x1bd51c

void entry_1bd420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd420) {
        switch (ctx->pc) {
            case 0x1bd424: ctx->pc = 0; goto label_1bd424;
            case 0x1bd440: ctx->pc = 0; goto label_1bd440;
            case 0x1bd474: ctx->pc = 0; goto label_1bd474;
            case 0x1bd488: ctx->pc = 0; goto label_1bd488;
            case 0x1bd4a8: ctx->pc = 0; goto label_1bd4a8;
            case 0x1bd4d4: ctx->pc = 0; goto label_1bd4d4;
            case 0x1bd4f0: ctx->pc = 0; goto label_1bd4f0;
            case 0x1bd514: ctx->pc = 0; goto label_1bd514;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd420: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1bd424:
    // 0x1bd424: 0x26080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1bd428: 0xd71821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 23)));
    // 0x1bd42c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bd430: 0x18400010
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1bd474;
    }
    // 0x1bd438: 0x2409ffff
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1bd43c: 0x8fa3005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 92)));
label_1bd440:
    // 0x1bd440: 0x72080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1bd444: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1bd448: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1bd44c: 0xc31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1bd450: 0xb72821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 23)));
    // 0x1bd454: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bd458: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1bd45c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd460: 0xac6904c0
    WRITE32(ADD32(GPR_U32(ctx, 3), 1216), GPR_U32(ctx, 9));
    // 0x1bd464: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1bd468: 0xe2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x1bd46c: 0x1440fff4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bd440;
    }
label_1bd474:
    // 0x1bd474: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1bd478: 0x100802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1bd47c: 0x204102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 4)));
    // 0x1bd480: 0x1440ffd3
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BD3D0; return;
    }
label_1bd488:
    // 0x1bd488: 0x8fa20060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bd48c: 0x10400011
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 30), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bd4d4;
    }
    // 0x1bd494: 0x1aa0001f
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_1bd514;
    }
    // 0x1bd49c: 0x2a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bd4a0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bd4a4: 0x0
    // NOP
label_1bd4a8:
    // 0x1bd4a8: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1bd4ac: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1bd4b0: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1bd4b4: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1bd4b8: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x1bd4bc: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1bd4c0: 0x24840060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 96));
    // 0x1bd4c4: 0x1600fff8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 192), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1bd4a8;
    }
    // 0x1bd4cc: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bd514;
    }
label_1bd4d4:
    // 0x1bd4d4: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bd514;
    }
    // 0x1bd4dc: 0x1aa0000d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_1bd514;
    }
    // 0x1bd4e4: 0x2a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bd4e8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bd4ec: 0x0
    // NOP
label_1bd4f0:
    // 0x1bd4f0: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1bd4f4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1bd4f8: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1bd4fc: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1bd500: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x1bd504: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1bd508: 0x24840060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 96));
    // 0x1bd50c: 0x1600fff8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 196), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1bd4f0;
    }
label_1bd514:
    // 0x1bd514: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1bd51c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bd51c
// Address: 0x1bd51c - 0x1bd558

void entry_1bd51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd51c) {
        switch (ctx->pc) {
            case 0x1bd520: ctx->pc = 0; goto label_1bd520;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd51c: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_1bd520:
    // 0x1bd520: 0x7bbe00f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1bd524: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1bd528: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1bd52c: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1bd530: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1bd534: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1bd538: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1bd53c: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1bd540: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bd544: 0xc7b50118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[21] = *(float*)&val; }
    // 0x1bd548: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x1bd54c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bd554: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bd558; return;
}


// Function: CpxpBuildXpArray__FiPP2SOiPP2XP
// Address: 0x1bd558 - 0x1bd678

void entry_1bd8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd8bc: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bd8c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bd8c4
// Address: 0x1bd8c4 - 0x1bd8d0

void entry_1bd8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd8c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bd8c8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bd8d0);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bd8d0
// Address: 0x1bd8d0 - 0x1bd8e4

void entry_1bd8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd8d0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bd8d4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bd8d8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bd8dc: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1bd8e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1bd8e4
// Address: 0x1bd8e4 - 0x1bd8f4

void entry_1bd8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bd8e4: 0x24060014
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1bd8e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bd8ec: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1bd8f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1bd8f4
// Address: 0x1bd8f4 - 0x1bda24

void entry_1bd8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bd8f4) {
        switch (ctx->pc) {
            case 0x1bd910: ctx->pc = 0; goto label_1bd910;
            case 0x1bd940: ctx->pc = 0; goto label_1bd940;
            case 0x1bd974: ctx->pc = 0; goto label_1bd974;
            case 0x1bd978: ctx->pc = 0; goto label_1bd978;
            case 0x1bd998: ctx->pc = 0; goto label_1bd998;
            case 0x1bd9a8: ctx->pc = 0; goto label_1bd9a8;
            case 0x1bd9b0: ctx->pc = 0; goto label_1bd9b0;
            case 0x1bd9e0: ctx->pc = 0; goto label_1bd9e0;
            case 0x1bda18: ctx->pc = 0; goto label_1bda18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bd8f4: 0x1a20002c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_1bd9a8;
    }
    // 0x1bd8fc: 0x340a8000
    SET_GPR_U32(ctx, 10, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bd900: 0xa523c
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 10) << (32 + 8));
    // 0x1bd904: 0x240482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bd908: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bd90c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1bd910:
    // 0x1bd910: 0x8d050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1bd914: 0x8ca20480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 1152)));
    // 0x1bd918: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bd91c: 0x10600015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1bd974;
    }
    // 0x1bd924: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bd928: 0x10400005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bd940;
    }
    // 0x1bd930: 0xdca20538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 1336)));
    // 0x1bd934: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bd938: 0x4a1024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x1bd93c: 0x2200a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 0));
label_1bd940:
    // 0x1bd940: 0x1060000d
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1bd978;
    }
    // 0x1bd948: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1bd94c: 0x5040fffc
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
        goto label_1bd940;
    }
    // 0x1bd954: 0xdca20538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 1336)));
    // 0x1bd958: 0x4a1024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x1bd95c: 0x5040fff8
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
        goto label_1bd940;
    }
    // 0x1bd964: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1bd968: 0x2c820004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 4));
    // 0x1bd96c: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
        goto label_1bd940;
    }
label_1bd974:
    // 0x1bd974: 0x2c820004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 4));
label_1bd978:
    // 0x1bd978: 0x10400007
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bd998;
    }
    // 0x1bd980: 0x24820001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1bd984: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1bd988: 0x3a22021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1bd98c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bd990: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1bd994: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
label_1bd998:
    // 0x1bd998: 0x25290004
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4));
    // 0x1bd99c: 0x24e7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x1bd9a0: 0x14e0ffdb
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        goto label_1bd910;
    }
label_1bd9a8:
    // 0x1bd9a8: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bd9ac: 0x27a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 4));
label_1bd9b0:
    // 0x1bd9b0: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1bd9b4: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1bd9b8: 0x8ca3fffc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4294967292)));
    // 0x1bd9bc: 0x2ce40005
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 7), 5));
    // 0x1bd9c0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bd9c4: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1bd9c8: 0x1480fff9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1bd9b0;
    }
    // 0x1bd9d0: 0x1a200011
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_1bda18;
    }
    // 0x1bd9d8: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bd9dc: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1bd9e0:
    // 0x1bd9e0: 0x8d220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1bd9e4: 0x24e7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x1bd9e8: 0x8d050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1bd9ec: 0x25290004
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4));
    // 0x1bd9f0: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1bd9f4: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x1bd9f8: 0x3a22021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1bd9fc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bda00: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1bda04: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1bda08: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1bda0c: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x1bda10: 0x14e0fff3
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        goto label_1bd9e0;
    }
label_1bda18:
    // 0x1bda18: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bda1c: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1bda24);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1bda24
// Address: 0x1bda24 - 0x1bda2c

void entry_1bda24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bda24: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1bda2c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bda2c
// Address: 0x1bda2c - 0x1bda50

void entry_1bda2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bda2c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bda30: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bda34: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bda38: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bda3c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bda40: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bda44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bda4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bda50; return;
}


// Function: SplitSwGroup__FP2SWiPP2SOfi
// Address: 0x1bda50 - 0x1bdaa8

void entry_1bdaa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdaa8) {
        switch (ctx->pc) {
            case 0x1bdac4: ctx->pc = 0; goto label_1bdac4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdaa8: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bdaac: 0x28e20040
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), 64));
    // 0x1bdab0: 0x14400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bdac4;
    }
    // 0x1bdab8: 0x2a420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    // 0x1bdabc: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x1BDAE4; return;
    }
label_1bdac4:
    // 0x1bdac4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bdac8: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bdacc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bdad0: 0x3c0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1bdad4: 0xc06f340
    SET_GPR_U32(ctx, 31, 0x1bdadc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime); return;
}


// Function: entry_1bdadc
// Address: 0x1bdadc - 0x1bdaec

void entry_1bdadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdadc) {
        switch (ctx->pc) {
            case 0x1bdae4: ctx->pc = 0; goto label_1bdae4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdadc: 0x1000007b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDCCC; return;
    }
label_1bdae4:
    // 0x1bdae4: 0xc06f622
    SET_GPR_U32(ctx, 31, 0x1bdaec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SortSwGroup__FiPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1bdaec
// Address: 0x1bdaec - 0x1bdb48

void entry_1bdaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdaec) {
        switch (ctx->pc) {
            case 0x1bdb10: ctx->pc = 0; goto label_1bdb10;
            case 0x1bdb2c: ctx->pc = 0; goto label_1bdb2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdaec: 0x1217c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 18), 31));
    // 0x1bdaf0: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1bdaf4: 0x28843
    SET_GPR_S32(ctx, 17, SRA32(GPR_S32(ctx, 2), 1));
    // 0x1bdaf8: 0x1a20000c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_1bdb2c;
    }
    // 0x1bdb00: 0x34068000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bdb04: 0x632fc
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 11));
    // 0x1bdb08: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bdb0c: 0x0
    // NOP
label_1bdb10:
    // 0x1bdb10: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1bdb14: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1bdb18: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1bdb1c: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1bdb20: 0x461025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1bdb24: 0x1480fffa
    WRITE64(ADD32(GPR_U32(ctx, 3), 1336), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1bdb10;
    }
label_1bdb2c:
    // 0x1bdb2c: 0x113080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1bdb30: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bdb34: 0x2663021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 6)));
    // 0x1bdb38: 0x2512823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 17)));
    // 0x1bdb3c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bdb40: 0xc06f694
    SET_GPR_U32(ctx, 31, 0x1bdb48);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    SplitSwGroup__FP2SWiPP2SOfi(rdram, ctx, runtime); return;
}


// Function: entry_1bdb48
// Address: 0x1bdb48 - 0x1bdbf4

void entry_1bdb48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdb48) {
        switch (ctx->pc) {
            case 0x1bdb70: ctx->pc = 0; goto label_1bdb70;
            case 0x1bdb8c: ctx->pc = 0; goto label_1bdb8c;
            case 0x1bdba8: ctx->pc = 0; goto label_1bdba8;
            case 0x1bdbe8: ctx->pc = 0; goto label_1bdbe8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdb48: 0x1a200010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_1bdb8c;
    }
    // 0x1bdb50: 0x3c06fbff
    SET_GPR_U32(ctx, 6, ((uint32_t)64511 << 16));
    // 0x1bdb54: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x1bdb58: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1bdb5c: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x1bdb60: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1bdb64: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x1bdb68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bdb6c: 0x0
    // NOP
label_1bdb70:
    // 0x1bdb70: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1bdb74: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1bdb78: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1bdb7c: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1bdb80: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1bdb84: 0x1480fffa
    WRITE64(ADD32(GPR_U32(ctx, 3), 1336), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1bdb70;
    }
label_1bdb8c:
    // 0x1bdb8c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bdb90: 0x92102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 18)));
    // 0x1bdb94: 0x10400022
    SET_GPR_U32(ctx, 23, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDC20; return;
    }
    // 0x1bdb9c: 0x27b60100
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1bdba0: 0x2e0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bdba4: 0x0
    // NOP
label_1bdba8:
    // 0x1bdba8: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1bdbac: 0x24900001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1bdbb0: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1bdbb4: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bdbb8: 0x24a302d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 728));
    // 0x1bdbbc: 0xafa30104
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 3));
    // 0x1bdbc0: 0xafa30100
    WRITE32(ADD32(GPR_U32(ctx, 29), 256), GPR_U32(ctx, 3));
    // 0x1bdbc4: 0x8c640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1bdbc8: 0xafa40108
    WRITE32(ADD32(GPR_U32(ctx, 29), 264), GPR_U32(ctx, 4));
    // 0x1bdbcc: 0x8e82b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294947604)));
    // 0x1bdbd0: 0xafa2010c
    WRITE32(ADD32(GPR_U32(ctx, 29), 268), GPR_U32(ctx, 2));
    // 0x1bdbd4: 0xae96b314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 22));
    // 0x1bdbd8: 0x8ca202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 728)));
    // 0x1bdbdc: 0x442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1bdbe0: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDC0C; return;
    }
label_1bdbe8:
    // 0x1bdbe8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bdbec: 0xc06f5e4
    SET_GPR_U32(ctx, 31, 0x1bdbf4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SplitSoFreeze__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1bdbf4
// Address: 0x1bdbf4 - 0x1bdc38

void entry_1bdbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdbf4) {
        switch (ctx->pc) {
            case 0x1bdc0c: ctx->pc = 0; goto label_1bdc0c;
            case 0x1bdc20: ctx->pc = 0; goto label_1bdc20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdbf4: 0x8fa40104
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1bdbf8: 0x8fa30108
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x1bdbfc: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bdc00: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bdc04: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDBE8; return;
    }
label_1bdc0c:
    // 0x1bdc0c: 0x8fa3010c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 268)));
    // 0x1bdc10: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bdc14: 0x92102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 18)));
    // 0x1bdc18: 0x1440ffe3
    WRITE32(ADD32(GPR_U32(ctx, 23), 4294947604), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDBA8; return;
    }
label_1bdc20:
    // 0x1bdc20: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bdc24: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bdc28: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1bdc2c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bdc30: 0xc06f694
    SET_GPR_U32(ctx, 31, 0x1bdc38);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SplitSwGroup__FP2SWiPP2SOfi(rdram, ctx, runtime); return;
}


// Function: entry_1bdc38
// Address: 0x1bdc38 - 0x1bdc9c

void entry_1bdc38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdc38) {
        switch (ctx->pc) {
            case 0x1bdc50: ctx->pc = 0; goto label_1bdc50;
            case 0x1bdc90: ctx->pc = 0; goto label_1bdc90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdc38: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bdc3c: 0x92102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 18)));
    // 0x1bdc40: 0x10400021
    SET_GPR_U32(ctx, 23, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDCC8; return;
    }
    // 0x1bdc48: 0x27b40100
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1bdc4c: 0x2e0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_1bdc50:
    // 0x1bdc50: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1bdc54: 0x24900001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1bdc58: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1bdc5c: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bdc60: 0x24a302d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 728));
    // 0x1bdc64: 0xafa30104
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 3));
    // 0x1bdc68: 0xafa30100
    WRITE32(ADD32(GPR_U32(ctx, 29), 256), GPR_U32(ctx, 3));
    // 0x1bdc6c: 0x8c640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1bdc70: 0xafa40108
    WRITE32(ADD32(GPR_U32(ctx, 29), 264), GPR_U32(ctx, 4));
    // 0x1bdc74: 0x8e22b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294947604)));
    // 0x1bdc78: 0xafa2010c
    WRITE32(ADD32(GPR_U32(ctx, 29), 268), GPR_U32(ctx, 2));
    // 0x1bdc7c: 0xae34b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 20));
    // 0x1bdc80: 0x8ca202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 728)));
    // 0x1bdc84: 0x442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1bdc88: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDCB4; return;
    }
label_1bdc90:
    // 0x1bdc90: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bdc94: 0xc06f5e4
    SET_GPR_U32(ctx, 31, 0x1bdc9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SplitSoFreeze__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1bdc9c
// Address: 0x1bdc9c - 0x1bdd00

void entry_1bdc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdc9c) {
        switch (ctx->pc) {
            case 0x1bdcb4: ctx->pc = 0; goto label_1bdcb4;
            case 0x1bdcc8: ctx->pc = 0; goto label_1bdcc8;
            case 0x1bdccc: ctx->pc = 0; goto label_1bdccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdc9c: 0x8fa40104
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1bdca0: 0x8fa30108
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x1bdca4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bdca8: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bdcac: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDC90; return;
    }
label_1bdcb4:
    // 0x1bdcb4: 0x8fa3010c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 268)));
    // 0x1bdcb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bdcbc: 0x92102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 18)));
    // 0x1bdcc0: 0x1440ffe3
    WRITE32(ADD32(GPR_U32(ctx, 23), 4294947604), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDC50; return;
    }
label_1bdcc8:
    // 0x1bdcc8: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
label_1bdccc:
    // 0x1bdccc: 0x7bbe0190
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1bdcd0: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1bdcd4: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1bdcd8: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1bdcdc: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1bdce0: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1bdce4: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1bdce8: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1bdcec: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1bdcf0: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x1bdcf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bdcfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bdd00; return;
}


// Function: SolveSw__FP2SWfi
// Address: 0x1bdd00 - 0x1bdd3c

void entry_1bdd3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bdd3c: 0x8ea40038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x1bdd40: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bdd48);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bdd48
// Address: 0x1bdd48 - 0x1bdd5c

void entry_1bdd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bdd48: 0x8ea40038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x1bdd4c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bdd50: 0xafa00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    // 0x1bdd54: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1bdd5c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bdd5c
// Address: 0x1bdd5c - 0x1bdd6c

void entry_1bdd5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bdd5c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bdd60: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x1bdd64: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1bdd6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1bdd6c
// Address: 0x1bdd6c - 0x1bde08

void entry_1bdd6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdd6c) {
        switch (ctx->pc) {
            case 0x1bddc8: ctx->pc = 0; goto label_1bddc8;
            case 0x1bddf0: ctx->pc = 0; goto label_1bddf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdd6c: 0x32e20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 23), 1));
    // 0x1bdd70: 0x5040002e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 21), 108)));
        ctx->pc = 0x1BDE2C; return;
    }
    // 0x1bdd78: 0x26a30060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 21), 96));
    // 0x1bdd7c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1bdd80: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1bdd84: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1bdd88: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1bdd8c: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1bdd90: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1bdd94: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1bdd98: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1bdd9c: 0x8ea30060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 96)));
    // 0x1bdda0: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1bdda4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bdda8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1bddac: 0x1080001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDE20; return;
    }
    // 0x1bddb4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1bddb8: 0x34118000
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bddbc: 0x118a3c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) << (32 + 8));
    // 0x1bddc0: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1bddc4: 0x0
    // NOP
label_1bddc8:
    // 0x1bddc8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bddcc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1bddd0: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1bddd4: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 552)));
        goto label_1bddf0;
    }
    // 0x1bdddc: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1bdde0: 0x511024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1bdde4: 0x10400009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDE0C; return;
    }
    // 0x1bddec: 0x8c820228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 552)));
label_1bddf0:
    // 0x1bddf0: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1bddf4: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1bde08(rdram, ctx, runtime); return;
    }
    // 0x1bddfc: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1bde00: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bde08);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bde08
// Address: 0x1bde08 - 0x1bde78

void entry_1bde08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bde08) {
        switch (ctx->pc) {
            case 0x1bde0c: ctx->pc = 0; goto label_1bde0c;
            case 0x1bde20: ctx->pc = 0; goto label_1bde20;
            case 0x1bde2c: ctx->pc = 0; goto label_1bde2c;
            case 0x1bde38: ctx->pc = 0; goto label_1bde38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bde08: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1bde0c:
    // 0x1bde0c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1bde10: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bde14: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1bde18: 0x1480ffeb
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDDC8; return;
    }
label_1bde20:
    // 0x1bde20: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1bde24: 0xae42b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 2));
    // 0x1bde28: 0x8eb2006c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 21), 108)));
label_1bde2c:
    // 0x1bde2c: 0x5240006f
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 21), 60)));
        ctx->pc = 0x1BDFEC; return;
    }
    // 0x1bde34: 0xde430538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
label_1bde38:
    // 0x1bde38: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bde3c: 0x212bc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 10));
    // 0x1bde40: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bde44: 0x54400066
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 1044)));
        ctx->pc = 0x1BDFE0; return;
    }
    // 0x1bde4c: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1bde50: 0x2123c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 8));
    // 0x1bde54: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bde58: 0x54400061
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 1044)));
        ctx->pc = 0x1BDFE0; return;
    }
    // 0x1bde60: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bde64: 0x27a50014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 20));
    // 0x1bde68: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bde6c: 0x27a70018
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 24));
    // 0x1bde70: 0xc06f59e
    SET_GPR_U32(ctx, 31, 0x1bde78);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1bde78
// Address: 0x1bde78 - 0x1bdf74

void entry_1bde78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bde78) {
        switch (ctx->pc) {
            case 0x1bdeb0: ctx->pc = 0; goto label_1bdeb0;
            case 0x1bded4: ctx->pc = 0; goto label_1bded4;
            case 0x1bdedc: ctx->pc = 0; goto label_1bdedc;
            case 0x1bdf10: ctx->pc = 0; goto label_1bdf10;
            case 0x1bdf34: ctx->pc = 0; goto label_1bdf34;
            case 0x1bdf3c: ctx->pc = 0; goto label_1bdf3c;
            case 0x1bdf58: ctx->pc = 0; goto label_1bdf58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bde78: 0x32e20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 23), 1));
    // 0x1bde7c: 0x10400041
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDF84; return;
    }
    // 0x1bde84: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bde88: 0x18400014
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1bdedc;
    }
    // 0x1bde90: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1bde94: 0x8c620228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 552)));
    // 0x1bde98: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1bde9c: 0x1440000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 8)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bded4;
    }
    // 0x1bdea4: 0x100282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1bdea8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bdeac: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_1bdeb0:
    // 0x1bdeb0: 0x225102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 5)));
    // 0x1bdeb4: 0x10400009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bdedc;
    }
    // 0x1bdebc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bdec0: 0x8c620228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 552)));
    // 0x1bdec4: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1bdec8: 0x5040fff9
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_1bdeb0;
    }
    // 0x1bded0: 0x228102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 8)));
label_1bded4:
    // 0x1bded4: 0x14400019
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bdf3c;
    }
label_1bdedc:
    // 0x1bdedc: 0x8fa20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x1bdee0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bdee4: 0x1840003d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1BDFDC; return;
    }
    // 0x1bdeec: 0x8ec30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1bdef0: 0x8c620228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 552)));
    // 0x1bdef4: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1bdef8: 0x1440000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 7)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bdf34;
    }
    // 0x1bdf00: 0xe0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1bdf04: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1bdf08: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1bdf0c: 0x0
    // NOP
label_1bdf10:
    // 0x1bdf10: 0xa6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 6)));
    // 0x1bdf14: 0x10400031
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDFDC; return;
    }
    // 0x1bdf1c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bdf20: 0x8c620228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 552)));
    // 0x1bdf24: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1bdf28: 0x5040fff9
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_1bdf10;
    }
    // 0x1bdf30: 0xa7102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 7)));
label_1bdf34:
    // 0x1bdf34: 0x5040002a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 1044)));
        ctx->pc = 0x1BDFE0; return;
    }
label_1bdf3c:
    // 0x1bdf3c: 0x19000011
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 8) <= 0) {
        ctx->pc = 0x1BDF84; return;
    }
    // 0x1bdf44: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1bdf48: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bdf4c: 0x24531858
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1bdf50: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1bdf54: 0x0
    // NOP
label_1bdf58:
    // 0x1bdf58: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bdf5c: 0xc66c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1bdf60: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1bdf64: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bdf68: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1bdf6c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1bdf74);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1bdf74
// Address: 0x1bdf74 - 0x1bdfa0

void entry_1bdf74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdf74) {
        switch (ctx->pc) {
            case 0x1bdf84: ctx->pc = 0; goto label_1bdf84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdf74: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1bdf78: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1bdf7c: 0x5440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1BDF58; return;
    }
label_1bdf84:
    // 0x1bdf84: 0x8fa50014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1bdf88: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bdf8c: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bdf90: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1bdf94: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bdf98: 0xc06f694
    SET_GPR_U32(ctx, 31, 0x1bdfa0);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SplitSwGroup__FP2SWiPP2SOfi(rdram, ctx, runtime); return;
}


// Function: entry_1bdfa0
// Address: 0x1bdfa0 - 0x1bdfb8

void entry_1bdfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdfa0) {
        switch (ctx->pc) {
            case 0x1bdfb0: ctx->pc = 0; goto label_1bdfb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdfa0: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1bdfa4: 0x5840000e
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 1044)));
        ctx->pc = 0x1BDFE0; return;
    }
    // 0x1bdfac: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1bdfb0:
    // 0x1bdfb0: 0xc04a75c
    SET_GPR_U32(ctx, 31, 0x1bdfb8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    FIsAloStatic__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1bdfb8
// Address: 0x1bdfb8 - 0x1bdfc8

void entry_1bdfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bdfb8: 0x14400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDFCC; return;
    }
    // 0x1bdfc0: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1bdfc8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1bdfc8
// Address: 0x1bdfc8 - 0x1be034

void entry_1bdfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bdfc8) {
        switch (ctx->pc) {
            case 0x1bdfcc: ctx->pc = 0; goto label_1bdfcc;
            case 0x1bdfdc: ctx->pc = 0; goto label_1bdfdc;
            case 0x1bdfe0: ctx->pc = 0; goto label_1bdfe0;
            case 0x1bdfec: ctx->pc = 0; goto label_1bdfec;
            case 0x1be010: ctx->pc = 0; goto label_1be010;
            case 0x1be02c: ctx->pc = 0; goto label_1be02c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bdfc8: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
label_1bdfcc:
    // 0x1bdfcc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1bdfd0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1bdfd4: 0x1440fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BDFB0; return;
    }
label_1bdfdc:
    // 0x1bdfdc: 0x8e520414
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 1044)));
label_1bdfe0:
    // 0x1bdfe0: 0x5640ff95
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
        ctx->pc = 0x1BDE38; return;
    }
    // 0x1bdfe8: 0x8eb2003c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 21), 60)));
label_1bdfec:
    // 0x1bdfec: 0x1240000f
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1be02c;
    }
    // 0x1bdff4: 0x3c03fdff
    SET_GPR_U32(ctx, 3, ((uint32_t)65023 << 16));
    // 0x1bdff8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1bdffc: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1be000: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1be004: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1be008: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1be00c: 0xde420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
label_1be010:
    // 0x1be010: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1be014: 0xfe420538
    WRITE64(ADD32(GPR_U32(ctx, 18), 1336), GPR_U64(ctx, 2));
    // 0x1be018: 0x8e5202d0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    // 0x1be01c: 0x0
    // NOP
    // 0x1be020: 0x0
    // NOP
    // 0x1be024: 0x5640fffa
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
        goto label_1be010;
    }
label_1be02c:
    // 0x1be02c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1be034);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1be034
// Address: 0x1be034 - 0x1be068

void entry_1be034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be034: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1be038: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1be03c: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1be040: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1be044: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1be048: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1be04c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1be050: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1be054: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1be058: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1be05c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be064: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be068; return;
}


// Function: SwapEntries__FPviii
// Address: 0x1be068 - 0x1be0a8

void entry_1be118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be118) {
        switch (ctx->pc) {
            case 0x1be128: ctx->pc = 0; goto label_1be128;
            case 0x1be148: ctx->pc = 0; goto label_1be148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be118: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1be11c: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1be120: 0x14400025
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE1B8; return;
    }
label_1be128:
    // 0x1be128: 0x2c0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1be12c: 0x121040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 1));
    // 0x1be130: 0x24510001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1be134: 0x271182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 17)));
    // 0x1be138: 0x1460ffef
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE0F8; return;
    }
    // 0x1be140: 0x233102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 19)));
    // 0x1be144: 0x0
    // NOP
label_1be148:
    // 0x1be148: 0x10400008
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE16C; return;
    }
    // 0x1be150: 0x26300001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1be154: 0x552021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1be158: 0x2141018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1be15c: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1be164);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1be164
// Address: 0x1be164 - 0x1be180

void entry_1be164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be164) {
        switch (ctx->pc) {
            case 0x1be16c: ctx->pc = 0; goto label_1be16c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be164: 0x3c2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 30), GPR_S32(ctx, 2)));
    // 0x1be168: 0x202880a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 16));
label_1be16c:
    // 0x1be16c: 0x2541018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1be170: 0x552021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1be174: 0x2341018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1be178: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1be180);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1be180
// Address: 0x1be180 - 0x1be198

void entry_1be180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be180: 0x441ffdd
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1BE0F8; return;
    }
    // 0x1be188: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1be18c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1be190: 0xc06f81a
    SET_GPR_U32(ctx, 31, 0x1be198);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SwapEntries__FPviii(rdram, ctx, runtime); return;
}


// Function: entry_1be198
// Address: 0x1be198 - 0x1be1e8

void entry_1be198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be198) {
        switch (ctx->pc) {
            case 0x1be1b8: ctx->pc = 0; goto label_1be1b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be198: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1be19c: 0x26220001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1be1a0: 0x2228821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1be1a4: 0x271182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 17)));
    // 0x1be1a8: 0x1060ffe7
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 19)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE148; return;
    }
    // 0x1be1b0: 0x1000ffd1
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE0F8; return;
    }
label_1be1b8:
    // 0x1be1b8: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1be1bc: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1be1c0: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1be1c4: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1be1c8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1be1cc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1be1d0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1be1d4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1be1d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1be1dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be1e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UnloadMusic__Fv
// Address: 0x1be1e8 - 0x1be228

void entry_1be228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be228: 0xc047514
    SET_GPR_U32(ctx, 31, 0x1be230);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 18236)));
    snd_UnloadBank(rdram, ctx, runtime); return;
}


// Function: entry_1be230
// Address: 0x1be230 - 0x1be238

void entry_1be230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be230: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1be238);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1be238
// Address: 0x1be238 - 0x1be268

void entry_1be238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be238) {
        switch (ctx->pc) {
            case 0x1be244: ctx->pc = 0; goto label_1be244;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be238: 0x1440fffd
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1be230(rdram, ctx, runtime); return;
    }
    // 0x1be240: 0xae40473c
    WRITE32(ADD32(GPR_U32(ctx, 18), 18236), GPR_U32(ctx, 0));
label_1be244:
    // 0x1be244: 0xae004720
    WRITE32(ADD32(GPR_U32(ctx, 16), 18208), GPR_U32(ctx, 0));
    // 0x1be248: 0xae204728
    WRITE32(ADD32(GPR_U32(ctx, 17), 18216), GPR_U32(ctx, 0));
    // 0x1be24c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1be250: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1be254: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1be258: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be25c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be264: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be268; return;
}


// Function: SbpEnsureBank__Fi
// Address: 0x1be268 - 0x1be2e0

void entry_1be2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be2e0: 0x8e024740
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 18240)));
    // 0x1be2e4: 0x4400014
    SET_GPR_U32(ctx, 4, ((uint32_t)96 << 16));
    if (GPR_S32(ctx, 2) < 0) {
        entry_1be338(rdram, ctx, runtime); return;
    }
    // 0x1be2ec: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1be2f0: 0x24834790
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 18320));
    // 0x1be2f4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1be2f8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1be2fc: 0x5080000f
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 18240), GPR_U32(ctx, 22));
        ctx->pc = 0x1BE33C; return;
    }
    // 0x1be304: 0xc047514
    SET_GPR_U32(ctx, 31, 0x1be30c);
    snd_UnloadBank(rdram, ctx, runtime); return;
}


// Function: entry_1be30c
// Address: 0x1be30c - 0x1be318

void entry_1be30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be30c) {
        switch (ctx->pc) {
            case 0x1be310: ctx->pc = 0; goto label_1be310;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be30c: 0x0
    // NOP
label_1be310:
    // 0x1be310: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1be318);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1be318
// Address: 0x1be318 - 0x1be338

void entry_1be318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be318: 0x1440fffd
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 18240)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE310; return;
    }
    // 0x1be320: 0x3c040060
    SET_GPR_U32(ctx, 4, ((uint32_t)96 << 16));
    // 0x1be324: 0x24834790
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 18320));
    // 0x1be328: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1be32c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1be330: 0xc047508
    SET_GPR_U32(ctx, 31, 0x1be338);
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    snd_ResolveBankXREFS(rdram, ctx, runtime); return;
}


// Function: entry_1be338
// Address: 0x1be338 - 0x1be344

void entry_1be338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be338) {
        switch (ctx->pc) {
            case 0x1be33c: ctx->pc = 0; goto label_1be33c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be338: 0xae164740
    WRITE32(ADD32(GPR_U32(ctx, 16), 18240), GPR_U32(ctx, 22));
label_1be33c:
    // 0x1be33c: 0xc063504
    SET_GPR_U32(ctx, 31, 0x1be344);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_1be344
// Address: 0x1be344 - 0x1be398

void entry_1be344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be344) {
        switch (ctx->pc) {
            case 0x1be364: ctx->pc = 0; goto label_1be364;
            case 0x1be384: ctx->pc = 0; goto label_1be384;
            case 0x1be390: ctx->pc = 0; goto label_1be390;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be344: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x1be348: 0x161940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 22), 5));
    // 0x1be34c: 0x24424f40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 20288));
    // 0x1be350: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1be354: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 20)));
        goto label_1be364;
    }
    // 0x1be35c: 0x10000009
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1be384;
    }
label_1be364:
    // 0x1be364: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1be368: 0x8c44001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1be36c: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1be370: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1be374: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1be378: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1be37c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1be380: 0x3182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
label_1be384:
    // 0x1be384: 0x10600037
    SET_GPR_U32(ctx, 23, SLL32(GPR_U32(ctx, 22), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE464; return;
    }
    // 0x1be38c: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
label_1be390:
    // 0x1be390: 0xc080e0a
    SET_GPR_U32(ctx, 31, 0x1be398);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceCdDiskReady(rdram, ctx, runtime); return;
}


// Function: entry_1be398
// Address: 0x1be398 - 0x1be3a8

void entry_1be398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be398: 0x1450fffd
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x1BE390; return;
    }
    // 0x1be3a0: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x1be3a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_1be3a8
// Address: 0x1be3a8 - 0x1be3b4

void entry_1be3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be3a8: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be3ac: 0xc047450
    SET_GPR_U32(ctx, 31, 0x1be3b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_BankLoadByLoc(rdram, ctx, runtime); return;
}


// Function: entry_1be3b4
// Address: 0x1be3b4 - 0x1be3d0

void entry_1be3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be3b4: 0x3c040060
    SET_GPR_U32(ctx, 4, ((uint32_t)96 << 16));
    // 0x1be3b8: 0x24834790
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 18320));
    // 0x1be3bc: 0x2e38021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 3)));
    // 0x1be3c0: 0x10400028
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE464; return;
    }
    // 0x1be3c8: 0xc047508
    SET_GPR_U32(ctx, 31, 0x1be3d0);
    snd_ResolveBankXREFS(rdram, ctx, runtime); return;
}


// Function: entry_1be3d0
// Address: 0x1be3d0 - 0x1be430

void entry_1be3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be3d0) {
        switch (ctx->pc) {
            case 0x1be410: ctx->pc = 0; goto label_1be410;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be3d0: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    // 0x1be3d4: 0x244247b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18352));
    // 0x1be3d8: 0x2e22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x1be3dc: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1be3e0: 0x14600021
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE468; return;
    }
    // 0x1be3e8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1be3ec: 0x3c040024
    SET_GPR_U32(ctx, 4, ((uint32_t)36 << 16));
    // 0x1be3f0: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1be3f4: 0x3c030060
    SET_GPR_U32(ctx, 3, ((uint32_t)96 << 16));
    // 0x1be3f8: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x1be3fc: 0x200f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1be400: 0x24556838
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 2), 26680));
    // 0x1be404: 0x247447d0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 3), 18384));
    // 0x1be408: 0x24925020
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 4), 20512));
    // 0x1be40c: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1be410:
    // 0x1be410: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1be414: 0x5456000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 22)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        ctx->pc = 0x1BE450; return;
    }
    // 0x1be41c: 0x8fc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x1be420: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1be424: 0x8e450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1be428: 0xc0475d8
    SET_GPR_U32(ctx, 31, 0x1be430);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_IsSoundALooper(rdram, ctx, runtime); return;
}


// Function: entry_1be430
// Address: 0x1be430 - 0x1be4a8

void entry_1be430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be430) {
        switch (ctx->pc) {
            case 0x1be448: ctx->pc = 0; goto label_1be448;
            case 0x1be44c: ctx->pc = 0; goto label_1be44c;
            case 0x1be450: ctx->pc = 0; goto label_1be450;
            case 0x1be464: ctx->pc = 0; goto label_1be464;
            case 0x1be468: ctx->pc = 0; goto label_1be468;
            case 0x1be470: ctx->pc = 0; goto label_1be470;
            case 0x1be478: ctx->pc = 0; goto label_1be478;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be430: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1be448;
    }
    // 0x1be438: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1be43c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
        goto label_1be44c;
    }
    // 0x1be444: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
label_1be448:
    // 0x1be448: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
label_1be44c:
    // 0x1be44c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_1be450:
    // 0x1be450: 0x26b50004
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
    // 0x1be454: 0x26940004
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4));
    // 0x1be458: 0x2a620303
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 771));
    // 0x1be45c: 0x1440ffec
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE410; return;
    }
label_1be464:
    // 0x1be464: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
label_1be468:
    // 0x1be468: 0x24434790
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 18320));
    // 0x1be46c: 0x2e31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 3)));
label_1be470:
    // 0x1be470: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1be474: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_1be478:
    // 0x1be478: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1be47c: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1be480: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1be484: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1be488: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1be48c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1be490: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1be494: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1be498: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1be49c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be4a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be4a8; return;
}


// Function: SbpEnsureBank__F5SFXID
// Address: 0x1be4a8 - 0x1be4c8

void entry_1be4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be4c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be4cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be4d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be4d8; return;
}


// Function: NewSfx__FPP3SFX
// Address: 0x1be4d8 - 0x1be4f0

void entry_1be4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be4f0: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1be4f4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1be4f8: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x1be4fc: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1be500: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1be504: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1be508: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be50c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1be510: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1be514: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x1be518: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1be51c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1be520: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be524: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1be528: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1be52c: 0xe4610008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 8), *(uint32_t*)&val); }
    // 0x1be530: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1be534: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be538: 0xe442000c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x1be53c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be540: 0xac600010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 0));
    // 0x1be544: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be548: 0xac40001c
    WRITE32(ADD32(GPR_U32(ctx, 2), 28), GPR_U32(ctx, 0));
    // 0x1be54c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be550: 0xe4600014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 20), *(uint32_t*)&val); }
    // 0x1be554: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be558: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be55c: 0xac400020
    WRITE32(ADD32(GPR_U32(ctx, 2), 32), GPR_U32(ctx, 0));
    // 0x1be560: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FContinuousSound__F5SFXID
// Address: 0x1be568 - 0x1be5b0

void entry_1be5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be5b0) {
        switch (ctx->pc) {
            case 0x1be5b4: ctx->pc = 0; goto label_1be5b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be5b0: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
label_1be5b4:
    // 0x1be5b4: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1be5b8: 0x244247d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18384));
    // 0x1be5bc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1be5c0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1be5c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be5c8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1be5cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be5d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be5d8; return;
}


// Function: FUN_001BE5D8
// Address: 0x1be5d8 - 0x1be5e8

void FUN_001BE5D8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be5d8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1be5dc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 2), 18224), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be5e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be5e8; return;
}


// Function: SetVagUnpaused__FUiUl
// Address: 0x1be5e8 - 0x1be5f8

void entry_1be630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be630: 0x10400004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE644; return;
    }
    // 0x1be638: 0xc06fa66
    SET_GPR_U32(ctx, 31, 0x1be640);
    StopVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1be640
// Address: 0x1be640 - 0x1be64c

void entry_1be640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be640) {
        switch (ctx->pc) {
            case 0x1be644: ctx->pc = 0; goto label_1be644;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be640: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
label_1be644:
    // 0x1be644: 0xc063504
    SET_GPR_U32(ctx, 31, 0x1be64c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_1be64c
// Address: 0x1be64c - 0x1be694

void entry_1be64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be64c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1be650: 0x8e23001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1be654: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1be658: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1be65c: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1be660: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1be664: 0x852026
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1be668: 0x10400020
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1be6ec(rdram, ctx, runtime); return;
    }
    // 0x1be670: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1be674: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be678: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be67c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be680: 0x24080400
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x1be684: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be688: 0x240a0002
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1be68c: 0xc047812
    SET_GPR_U32(ctx, 31, 0x1be694);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_PlayVAGStreamByLoc(rdram, ctx, runtime); return;
}


// Function: entry_1be694
// Address: 0x1be694 - 0x1be6cc

void entry_1be694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be694: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1be698: 0x10800014
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1be6ec(rdram, ctx, runtime); return;
    }
    // 0x1be6a0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1be6a4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1be6a8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1be6ac: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1be6b0: 0xac44472c
    WRITE32(ADD32(GPR_U32(ctx, 2), 18220), GPR_U32(ctx, 4));
    // 0x1be6b4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1be6b8: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1be6bc: 0xae434744
    WRITE32(ADD32(GPR_U32(ctx, 18), 18244), GPR_U32(ctx, 3));
    // 0x1be6c0: 0xacc04730
    WRITE32(ADD32(GPR_U32(ctx, 6), 18224), GPR_U32(ctx, 0));
    // 0x1be6c4: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1be6cc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1be6cc
// Address: 0x1be6cc - 0x1be6dc

void entry_1be6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be6cc: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1be6d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be6d4: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1be6dc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1be6dc
// Address: 0x1be6dc - 0x1be6ec

void entry_1be6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be6dc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1be6e0: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1be6e4: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1be6ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1be6ec
// Address: 0x1be6ec - 0x1be708

void entry_1be6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be6ec) {
        switch (ctx->pc) {
            case 0x1be6f0: ctx->pc = 0; goto label_1be6f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be6ec: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1be6f0:
    // 0x1be6f0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1be6f4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1be6f8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1be6fc: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1be700: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001be708
// Address: 0x1be708 - 0x1be71c

void FUN_001be708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be708: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1be70c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1be710: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1be714: 0xc06fa66
    SET_GPR_U32(ctx, 31, 0x1be71c);
    WRITE32(ADD32(GPR_U32(ctx, 2), 18244), GPR_U32(ctx, 0));
    StopVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1be71c
// Address: 0x1be71c - 0x1be728

void entry_1be71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be71c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be720: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PreloadVag1
// Address: 0x1be728 - 0x1be750

void entry_1be750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be750: 0x10400004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE764; return;
    }
    // 0x1be758: 0xc06fa66
    SET_GPR_U32(ctx, 31, 0x1be760);
    StopVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1be760
// Address: 0x1be760 - 0x1be76c

void entry_1be760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be760) {
        switch (ctx->pc) {
            case 0x1be764: ctx->pc = 0; goto label_1be764;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be760: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
label_1be764:
    // 0x1be764: 0xc063504
    SET_GPR_U32(ctx, 31, 0x1be76c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_1be76c
// Address: 0x1be76c - 0x1be7c8

void entry_1be76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be76c) {
        switch (ctx->pc) {
            case 0x1be798: ctx->pc = 0; goto label_1be798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be76c: 0x1200000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1be798;
    }
    // 0x1be774: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1be778: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1be77c: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1be780: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be784: 0x441026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1be788: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x1be78c: 0x651826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1be790: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1be794: 0xafa30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
label_1be798:
    // 0x1be798: 0x10400017
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1be7f8(rdram, ctx, runtime); return;
    }
    // 0x1be7a0: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1be7a4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be7a8: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1be7ac: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be7b0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be7b4: 0x24080400
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x1be7b8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be7bc: 0x240a0002
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1be7c0: 0xc047812
    SET_GPR_U32(ctx, 31, 0x1be7c8);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_PlayVAGStreamByLoc(rdram, ctx, runtime); return;
}


// Function: entry_1be7c8
// Address: 0x1be7c8 - 0x1be7f8

void entry_1be7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be7c8: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1be7cc: 0x10e0000a
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_1be7f8(rdram, ctx, runtime); return;
    }
    // 0x1be7d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1be7d8: 0x3c05001c
    SET_GPR_U32(ctx, 5, ((uint32_t)28 << 16));
    // 0x1be7dc: 0x7303c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) << (32 + 0));
    // 0x1be7e0: 0xac504730
    WRITE32(ADD32(GPR_U32(ctx, 2), 18224), GPR_U32(ctx, 16));
    // 0x1be7e4: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1be7e8: 0xac67472c
    WRITE32(ADD32(GPR_U32(ctx, 3), 18220), GPR_U32(ctx, 7));
    // 0x1be7ec: 0x24a5e5d8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294960600));
    // 0x1be7f0: 0xc047838
    SET_GPR_U32(ctx, 31, 0x1be7f8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) >> (32 + 0));
    snd_IsVAGStreamBuffered_CB(rdram, ctx, runtime); return;
}


// Function: entry_1be7f8
// Address: 0x1be7f8 - 0x1be810

void entry_1be7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be7f8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1be7fc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1be800: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1be804: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be80c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be810; return;
}


// Function: FPauseForVag__Fv
// Address: 0x1be810 - 0x1be84c

void entry_1be84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be84c) {
        switch (ctx->pc) {
            case 0x1be850: ctx->pc = 0; goto label_1be850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be84c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1be850:
    // 0x1be850: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be854: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1be85c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1be860; return;
}


// Function: RefreshPambVolPan__FP3AMB
// Address: 0x1be860 - 0x1be8ec

void entry_1be8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be8ec: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1be8f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001be8f8
// Address: 0x1be8f8 - 0x1be948

void FUN_001be8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be8f8) {
        switch (ctx->pc) {
            case 0x1be91c: ctx->pc = 0; goto label_1be91c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be8f8: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1be8fc: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1be900: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1be904: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be908: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1be90c: 0x16000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1be91c;
    }
    // 0x1be914: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1be918: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1be91c:
    // 0x1be91c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1be920: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1be924: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1be928: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1be92c: 0x2404fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x1be930: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1be934: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be938: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1be93c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1be940: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1be948);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1be948
// Address: 0x1be948 - 0x1be95c

void entry_1be948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be948: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1be94c: 0x10800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE970; return;
    }
    // 0x1be954: 0xc06fa18
    SET_GPR_U32(ctx, 31, 0x1be95c);
    RefreshPambVolPan__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1be95c
// Address: 0x1be95c - 0x1be96c

void entry_1be95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1be95c: 0x12200004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE970; return;
    }
    // 0x1be964: 0xc06fdc6
    SET_GPR_U32(ctx, 31, 0x1be96c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DropPamb__FPP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1be96c
// Address: 0x1be96c - 0x1be980

void entry_1be96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be96c) {
        switch (ctx->pc) {
            case 0x1be970: ctx->pc = 0; goto label_1be970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be96c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1be970:
    // 0x1be970: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1be974: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1be978: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FVagPlaying__Fv
// Address: 0x1be980 - 0x1be990

void entry_1be9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1be9cc) {
        switch (ctx->pc) {
            case 0x1be9d8: ctx->pc = 0; goto label_1be9d8;
            case 0x1be9e0: ctx->pc = 0; goto label_1be9e0;
            case 0x1be9fc: ctx->pc = 0; goto label_1be9fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1be9cc: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1be9fc;
    }
    // 0x1be9d4: 0x0
    // NOP
label_1be9d8:
    // 0x1be9d8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1be9dc: 0x0
    // NOP
label_1be9e0:
    // 0x1be9e0: 0x0
    // NOP
    // 0x1be9e4: 0x0
    // NOP
    // 0x1be9e8: 0x0
    // NOP
    // 0x1be9ec: 0x0
    // NOP
    // 0x1be9f0: 0x0
    // NOP
    // 0x1be9f4: 0x441fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_1be9e0;
    }
label_1be9fc:
    // 0x1be9fc: 0xc0475c2
    SET_GPR_U32(ctx, 31, 0x1bea04);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 18220)));
    snd_SoundIsStillPlaying(rdram, ctx, runtime); return;
}


// Function: entry_1bea04
// Address: 0x1bea04 - 0x1bea28

void entry_1bea04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bea04) {
        switch (ctx->pc) {
            case 0x1bea14: ctx->pc = 0; goto label_1bea14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bea04: 0x1440fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19999));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BE9D8; return;
    }
    // 0x1bea0c: 0xae00472c
    WRITE32(ADD32(GPR_U32(ctx, 16), 18220), GPR_U32(ctx, 0));
    // 0x1bea10: 0xae204730
    WRITE32(ADD32(GPR_U32(ctx, 17), 18224), GPR_U32(ctx, 0));
label_1bea14:
    // 0x1bea14: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bea18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bea1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bea20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PauseVag__Fv
// Address: 0x1bea28 - 0x1bea44

void entry_1bea44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bea44: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bea48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ContinueVag__Fv
// Address: 0x1bea50 - 0x1bea6c

void entry_1bea6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bea6c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bea70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: KillMusic__Fv
// Address: 0x1bea78 - 0x1beaa4

void entry_1beaa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1beaa4) {
        switch (ctx->pc) {
            case 0x1beab0: ctx->pc = 0; goto label_1beab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1beaa4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1beaa8: 0xae004728
    WRITE32(ADD32(GPR_U32(ctx, 16), 18216), GPR_U32(ctx, 0));
    // 0x1beaac: 0xae224720
    WRITE32(ADD32(GPR_U32(ctx, 17), 18208), GPR_U32(ctx, 2));
label_1beab0:
    // 0x1beab0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1beab4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1beab8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1beabc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1beac4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1beac8; return;
}


// Function: PreloadMusidSongComplete__FUiUl
// Address: 0x1beac8 - 0x1beae4

void entry_1beae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1beae4) {
        switch (ctx->pc) {
            case 0x1beaf4: ctx->pc = 0; goto label_1beaf4;
            case 0x1beb04: ctx->pc = 0; goto label_1beb04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1beae4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1beae8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1beaec: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 3), 18208), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1beb04;
    }
label_1beaf4:
    // 0x1beaf4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1beaf8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1beafc: 0xac404724
    WRITE32(ADD32(GPR_U32(ctx, 2), 18212), GPR_U32(ctx, 0));
    // 0x1beb00: 0xac604720
    WRITE32(ADD32(GPR_U32(ctx, 3), 18208), GPR_U32(ctx, 0));
label_1beb04:
    // 0x1beb04: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1beb08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PreloadMusidSong__F5MUSID
// Address: 0x1beb10 - 0x1beb38

void entry_1beb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1beb38) {
        switch (ctx->pc) {
            case 0x1beb40: ctx->pc = 0; goto label_1beb40;
            case 0x1beb6c: ctx->pc = 0; goto label_1beb6c;
            case 0x1beb88: ctx->pc = 0; goto label_1beb88;
            case 0x1beb9c: ctx->pc = 0; goto label_1beb9c;
            case 0x1beba8: ctx->pc = 0; goto label_1beba8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1beb38: 0x10000041
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BEC40; return;
    }
label_1beb40:
    // 0x1beb40: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1beb44: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1beb48: 0x8c424724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 18212)));
    // 0x1beb4c: 0x1202000e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_1beb88;
    }
    // 0x1beb54: 0x1200000c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1beb88;
    }
    // 0x1beb5c: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        goto label_1beb6c;
    }
    // 0x1beb64: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1beb88;
    }
label_1beb6c:
    // 0x1beb6c: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1beb70: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1beb74: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1beb78: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1beb7c: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1beb80: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1beb84: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
label_1beb88:
    // 0x1beb88: 0x10600004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1beb9c;
    }
    // 0x1beb90: 0x8c434720
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 18208)));
    // 0x1beb94: 0x1460002a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BEC40; return;
    }
label_1beb9c:
    // 0x1beb9c: 0x3c120027
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    // 0x1beba0: 0x10000003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1bebb0(rdram, ctx, runtime); return;
    }
label_1beba8:
    // 0x1beba8: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1bebb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1bebb0
// Address: 0x1bebb0 - 0x1bebb8

void entry_1bebb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bebb0: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1bebb8);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1bebb8
// Address: 0x1bebb8 - 0x1bebd0

void entry_1bebb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bebb8) {
        switch (ctx->pc) {
            case 0x1bebc8: ctx->pc = 0; goto label_1bebc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bebb8: 0x10400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 18208)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bebc8;
    }
    // 0x1bebc0: 0x1051fff9
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1BEBA8; return;
    }
label_1bebc8:
    // 0x1bebc8: 0xc06f87a
    SET_GPR_U32(ctx, 31, 0x1bebd0);
    UnloadMusic__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bebd0
// Address: 0x1bebd0 - 0x1bebdc

void entry_1bebd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bebd0: 0xae704724
    WRITE32(ADD32(GPR_U32(ctx, 19), 18212), GPR_U32(ctx, 16));
    // 0x1bebd4: 0xc063504
    SET_GPR_U32(ctx, 31, 0x1bebdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_1bebdc
// Address: 0x1bebdc - 0x1bec24

void entry_1bebdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bebdc) {
        switch (ctx->pc) {
            case 0x1bebec: ctx->pc = 0; goto label_1bebec;
            case 0x1bec0c: ctx->pc = 0; goto label_1bec0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bebdc: 0x56000003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_1bebec;
    }
    // 0x1bebe4: 0x10000009
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bec0c;
    }
label_1bebec:
    // 0x1bebec: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1bebf0: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1bebf4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1bebf8: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1bebfc: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1bec00: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1bec04: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1bec08: 0x3182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
label_1bec0c:
    // 0x1bec0c: 0x1060000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1bec3c(rdram, ctx, runtime); return;
    }
    // 0x1bec14: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bec18: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bec1c: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x1bec24);
    WRITE32(ADD32(GPR_U32(ctx, 2), 18208), GPR_U32(ctx, 3));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_1bec24
// Address: 0x1bec24 - 0x1bec3c

void entry_1bec24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bec24: 0x3c06001c
    SET_GPR_U32(ctx, 6, ((uint32_t)28 << 16));
    // 0x1bec28: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bec2c: 0x24c6eac8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294961864));
    // 0x1bec30: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bec34: 0xc0474aa
    SET_GPR_U32(ctx, 31, 0x1bec3c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_BankLoadByLoc_CB(rdram, ctx, runtime); return;
}


// Function: entry_1bec3c
// Address: 0x1bec3c - 0x1bec58

void entry_1bec3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bec3c) {
        switch (ctx->pc) {
            case 0x1bec40: ctx->pc = 0; goto label_1bec40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bec3c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1bec40:
    // 0x1bec40: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bec44: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bec48: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bec4c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bec50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartMusidSong__F5MUSID
// Address: 0x1bec58 - 0x1bec6c

void entry_1bec6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bec6c) {
        switch (ctx->pc) {
            case 0x1bec80: ctx->pc = 0; goto label_1bec80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bec6c: 0x1200001e
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BECE8; return;
    }
    // 0x1bec74: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1bec88(rdram, ctx, runtime); return;
    }
    // 0x1bec7c: 0x0
    // NOP
label_1bec80:
    // 0x1bec80: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1bec88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1bec88
// Address: 0x1bec88 - 0x1bec90

void entry_1bec88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bec88: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1bec90);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1bec90
// Address: 0x1bec90 - 0x1becd4

void entry_1bec90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bec90) {
        switch (ctx->pc) {
            case 0x1beca4: ctx->pc = 0; goto label_1beca4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bec90: 0x10400004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 18208)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1beca4;
    }
    // 0x1bec98: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bec9c: 0x1062fff8
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1BEC80; return;
    }
label_1beca4:
    // 0x1beca4: 0x8e034720
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 18208)));
    // 0x1beca8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1becac: 0x1462000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1BECEC; return;
    }
    // 0x1becb4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1becb8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1becbc: 0x8c44473c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 18236)));
    // 0x1becc0: 0x24060400
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x1becc4: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1becc8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1beccc: 0xc047566
    SET_GPR_U32(ctx, 31, 0x1becd4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_PlaySoundVolPanPMPB(rdram, ctx, runtime); return;
}


// Function: entry_1becd4
// Address: 0x1becd4 - 0x1becf8

void entry_1becd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1becd4) {
        switch (ctx->pc) {
            case 0x1bece8: ctx->pc = 0; goto label_1bece8;
            case 0x1becec: ctx->pc = 0; goto label_1becec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1becd4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1becd8: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 3), 18216), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bece8;
    }
    // 0x1bece0: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1bece4: 0xae024720
    WRITE32(ADD32(GPR_U32(ctx, 16), 18208), GPR_U32(ctx, 2));
label_1bece8:
    // 0x1bece8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1becec:
    // 0x1becec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1becf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PauseMusic__Fv
// Address: 0x1becf8 - 0x1bed10

void entry_1bed10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bed10: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bed14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bed1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bed20; return;
}


// Function: ContinueMusic__Fv
// Address: 0x1bed20 - 0x1bed3c

void entry_1bed3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bed3c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bed40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SfxhMusicUnknown1
// Address: 0x1bed48 - 0x1bed60

void entry_1bed60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bed60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bed64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bed6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bed70; return;
}


// Function: SfxhMusicUnknown2
// Address: 0x1bed70 - 0x1bed88

void entry_1bed88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bed88: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bed8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bed94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bed98; return;
}


// Function: PexcAlloc__Fv
// Address: 0x1bed98 - 0x1bedb8

void entry_1bedb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bedb8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bedbc: 0x12000008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1bede0(rdram, ctx, runtime); return;
    }
    // 0x1bedc4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bedc8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1bedd0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1bedd0
// Address: 0x1bedd0 - 0x1bede0

void entry_1bedd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bedd0: 0x8e245710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1bedd4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bedd8: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1bede0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7108));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1bede0
// Address: 0x1bede0 - 0x1bedf8

void entry_1bede0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bede0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bede4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bede8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bedec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bedf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveExc__FP3EXC
// Address: 0x1bedf8 - 0x1bee20

void entry_1bee20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bee20: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1bee24: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bee28: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x1bee30);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7096));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_1bee30
// Address: 0x1bee30 - 0x1bee48

void entry_1bee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bee30: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bee34: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bee38: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bee3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bee44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bee48; return;
}


// Function: KillExcitement__Fv
// Address: 0x1bee48 - 0x1beea0

void entry_1beea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1beea0) {
        switch (ctx->pc) {
            case 0x1beebc: ctx->pc = 0; goto label_1beebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1beea0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1beea4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1beea8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1beeac: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1beeb0: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1beeb4: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BEE98; return;
    }
label_1beebc:
    // 0x1beebc: 0xc04764a
    SET_GPR_U32(ctx, 31, 0x1beec4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    snd_SetGlobalExcite(rdram, ctx, runtime); return;
}


// Function: entry_1beec4
// Address: 0x1beec4 - 0x1beef8

void entry_1beec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1beec4: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1beec8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1beecc: 0xac4048ec
    WRITE32(ADD32(GPR_U32(ctx, 2), 18668), GPR_U32(ctx, 0));
    // 0x1beed0: 0xae03b314
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294947604), GPR_U32(ctx, 3));
    // 0x1beed4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1beed8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1beedc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1beee0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1beee4: 0xac404738
    WRITE32(ADD32(GPR_U32(ctx, 2), 18232), GPR_U32(ctx, 0));
    // 0x1beee8: 0xac604734
    WRITE32(ADD32(GPR_U32(ctx, 3), 18228), GPR_U32(ctx, 0));
    // 0x1beeec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1beef4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1beef8; return;
}


// Function: PexcSetExcitement__Fi
// Address: 0x1beef8 - 0x1bef1c

void entry_1bef1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bef1c: 0xc06fb66
    SET_GPR_U32(ctx, 31, 0x1bef24);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PexcAlloc__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bef24
// Address: 0x1bef24 - 0x1bef88

void entry_1bef24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bef24) {
        switch (ctx->pc) {
            case 0x1bef44: ctx->pc = 0; goto label_1bef44;
            case 0x1bef68: ctx->pc = 0; goto label_1bef68;
            case 0x1bef70: ctx->pc = 0; goto label_1bef70;
            case 0x1bef74: ctx->pc = 0; goto label_1bef74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bef24: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bef28: 0x2404006b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 107));
    // 0x1bef2c: 0x2a02ffec
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 4294967276));
    // 0x1bef30: 0x14400004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967276));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bef44;
    }
    // 0x1bef38: 0x80182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1bef3c: 0x90102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 16)));
    // 0x1bef40: 0x202180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 16));
label_1bef44:
    // 0x1bef44: 0x10a0000a
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1bef70;
    }
    // 0x1bef4c: 0xaca30000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 3));
    // 0x1bef50: 0x8cc44734
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 18228)));
    // 0x1bef54: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1bef58: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bef68;
    }
    // 0x1bef60: 0x12200004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1bef74;
    }
label_1bef68:
    // 0x1bef68: 0xacc34734
    WRITE32(ADD32(GPR_U32(ctx, 6), 18228), GPR_U32(ctx, 3));
    // 0x1bef6c: 0xac444738
    WRITE32(ADD32(GPR_U32(ctx, 2), 18232), GPR_U32(ctx, 4));
label_1bef70:
    // 0x1bef70: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1bef74:
    // 0x1bef74: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1bef78: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bef7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bef80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetIexcCurHigh__FP3EXC
// Address: 0x1bef88 - 0x1befc8

void entry_1befc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1befc8) {
        switch (ctx->pc) {
            case 0x1befd8: ctx->pc = 0; goto label_1befd8;
            case 0x1bf000: ctx->pc = 0; goto label_1bf000;
            case 0x1bf014: ctx->pc = 0; goto label_1bf014;
            case 0x1bf02c: ctx->pc = 0; goto label_1bf02c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1befc8: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1befd8;
    }
    // 0x1befd0: 0x10000016
    WRITE32(ADD32(GPR_U32(ctx, 2), 18228), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bf02c;
    }
label_1befd8:
    // 0x1befd8: 0x2403ffec
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967276));
    // 0x1befdc: 0xac434734
    WRITE32(ADD32(GPR_U32(ctx, 2), 18228), GPR_U32(ctx, 3));
    // 0x1befe0: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1befe4: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1befe8: 0x8fa50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1befec: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1beff0: 0x451821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1beff4: 0x1040000d
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1bf02c;
    }
    // 0x1beffc: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
label_1bf000:
    // 0x1bf000: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bf004: 0x8ce24734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 18228)));
    // 0x1bf008: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1bf00c: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 6), 18228), GPR_U32(ctx, 3));
        goto label_1bf014;
    }
label_1bf014:
    // 0x1bf014: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1bf018: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bf01c: 0x652021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1bf020: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1bf024: 0x1440fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bf000;
    }
label_1bf02c:
    // 0x1bf02c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1bf030: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bf034: 0xae02b314
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294947604), GPR_U32(ctx, 2));
    // 0x1bf038: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf03c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bf044: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bf048; return;
}


// Function: UnsetExcitement__FP3EXC
// Address: 0x1bf048 - 0x1bf06c

void entry_1bf06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf06c: 0x3c120027
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    // 0x1bf070: 0x8e424734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 18228)));
    // 0x1bf074: 0x16020013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1BF0C4; return;
    }
    // 0x1bf07c: 0xc06fbe2
    SET_GPR_U32(ctx, 31, 0x1bf084);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetIexcCurHigh__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_1bf084
// Address: 0x1bf084 - 0x1bf0a4

void entry_1bf084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf084) {
        switch (ctx->pc) {
            case 0x1bf094: ctx->pc = 0; goto label_1bf094;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf084: 0x8e434734
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 18228)));
    // 0x1bf088: 0x4600002
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_1bf094;
    }
    // 0x1bf090: 0xac4048ec
    WRITE32(ADD32(GPR_U32(ctx, 2), 18668), GPR_U32(ctx, 0));
label_1bf094:
    // 0x1bf094: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1bf098: 0x24640014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 20));
    // 0x1bf09c: 0xc04764a
    SET_GPR_U32(ctx, 31, 0x1bf0a4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 18232), GPR_U32(ctx, 3));
    snd_SetGlobalExcite(rdram, ctx, runtime); return;
}


// Function: entry_1bf0a4
// Address: 0x1bf0a4 - 0x1bf0b8

void entry_1bf0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf0a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bf0a8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1bf0ac: 0x24040007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1bf0b0: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1bf0b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1bf0b8
// Address: 0x1bf0b8 - 0x1bf0d8

void entry_1bf0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf0b8) {
        switch (ctx->pc) {
            case 0x1bf0c0: ctx->pc = 0; goto label_1bf0c0;
            case 0x1bf0c4: ctx->pc = 0; goto label_1bf0c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf0b8: 0x2402ff9c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    // 0x1bf0bc: 0xae024738
    WRITE32(ADD32(GPR_U32(ctx, 16), 18232), GPR_U32(ctx, 2));
label_1bf0c0:
    // 0x1bf0c0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1bf0c4:
    // 0x1bf0c4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bf0c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf0cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf0d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UnsetExcitementHyst__FP3EXC
// Address: 0x1bf0d8 - 0x1bf0f8

void entry_1bf0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf0f8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1bf0fc: 0x8c434734
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 18228)));
    // 0x1bf100: 0x16230006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1BF11C; return;
    }
    // 0x1bf108: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1bf10c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bf110: 0xc06fbe2
    SET_GPR_U32(ctx, 31, 0x1bf118);
    WRITE32(ADD32(GPR_U32(ctx, 2), 18232), GPR_U32(ctx, 17));
    SetIexcCurHigh__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_1bf118
// Address: 0x1bf118 - 0x1bf130

void entry_1bf118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf118) {
        switch (ctx->pc) {
            case 0x1bf11c: ctx->pc = 0; goto label_1bf11c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf118: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1bf11c:
    // 0x1bf11c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf120: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf124: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bf12c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bf130; return;
}


// Function: StartupSound__Fv
// Address: 0x1bf130 - 0x1bf14c

void entry_1bf14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf14c: 0xc0472ee
    SET_GPR_U32(ctx, 31, 0x1bf154);
    snd_StartSoundSystem(rdram, ctx, runtime); return;
}


// Function: entry_1bf154
// Address: 0x1bf154 - 0x1bf15c

void entry_1bf154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf154: 0xc06f89a
    SET_GPR_U32(ctx, 31, 0x1bf15c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SbpEnsureBank__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1bf15c
// Address: 0x1bf15c - 0x1bf170

void entry_1bf15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf15c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bf160: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bf164: 0x24052000
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8192));
    // 0x1bf168: 0xc0477d6
    SET_GPR_U32(ctx, 31, 0x1bf170);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    snd_InitVAGStreamingEx(rdram, ctx, runtime); return;
}


// Function: entry_1bf170
// Address: 0x1bf170 - 0x1bf178

void entry_1bf170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf170: 0xc04764a
    SET_GPR_U32(ctx, 31, 0x1bf178);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    snd_SetGlobalExcite(rdram, ctx, runtime); return;
}


// Function: entry_1bf178
// Address: 0x1bf178 - 0x1bf180

void entry_1bf178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf178: 0xc0701b6
    SET_GPR_U32(ctx, 31, 0x1bf180);
    MvgkUnknown2__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bf180
// Address: 0x1bf180 - 0x1bf18c

void entry_1bf180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf180: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf184: 0xc047548
    SET_GPR_U32(ctx, 31, 0x1bf18c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    snd_SetMixerMode(rdram, ctx, runtime); return;
}


// Function: entry_1bf18c
// Address: 0x1bf18c - 0x1bf19c

void entry_1bf18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf18c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf190: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf194: 0xc047556
    SET_GPR_U32(ctx, 31, 0x1bf19c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 47));
    snd_SetGroupVoiceRange(rdram, ctx, runtime); return;
}


// Function: entry_1bf19c
// Address: 0x1bf19c - 0x1bf1ac

void entry_1bf19c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf19c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bf1a0: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1bf1a4: 0xc047556
    SET_GPR_U32(ctx, 31, 0x1bf1ac);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 47));
    snd_SetGroupVoiceRange(rdram, ctx, runtime); return;
}


// Function: entry_1bf1ac
// Address: 0x1bf1ac - 0x1bf1bc

void entry_1bf1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf1ac: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1bf1b0: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1bf1b4: 0xc047556
    SET_GPR_U32(ctx, 31, 0x1bf1bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 47));
    snd_SetGroupVoiceRange(rdram, ctx, runtime); return;
}


// Function: entry_1bf1bc
// Address: 0x1bf1bc - 0x1bf1cc

void entry_1bf1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf1bc: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1bf1c0: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1bf1c4: 0xc047556
    SET_GPR_U32(ctx, 31, 0x1bf1cc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 47));
    snd_SetGroupVoiceRange(rdram, ctx, runtime); return;
}


// Function: entry_1bf1cc
// Address: 0x1bf1cc - 0x1bf1d8

void entry_1bf1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf1cc: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1bf1d0: 0xc0478e8
    SET_GPR_U32(ctx, 31, 0x1bf1d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    snd_PreAllocReverbWorkArea(rdram, ctx, runtime); return;
}


// Function: entry_1bf1d8
// Address: 0x1bf1d8 - 0x1bf1e8

void entry_1bf1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf1d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf1dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bf1e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bf1e8; return;
}


// Function: junk_001BF1E8
// Address: 0x1bf1e8 - 0x1bf1f0

void FUN_001BF2E0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf2e0: 0xd8810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bf2e4: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1bf2e8: 0xd8a30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1bf2ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1bf2f0: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bf2f4: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1bf2f8: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1bf2fc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1bf300: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1bf304: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1bf308: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1bf30c: 0xc4600478
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 1144)); ctx->f[0] = *(float*)&val; }
    // 0x1bf310: 0xd8610080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x1bf314: 0x46001041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1bf318: 0x4bc118aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bf31c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bf320: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bf324: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bf328: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1bf32c: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf330: 0x4be218ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bf334: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1bf338: 0x46011083
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[1];
    // 0x1bf33c: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1bf340: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1bf344: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1bf348: 0xd8610080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x1bf34c: 0x4bc118ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bf350: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bf354: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bf358: 0x4b0328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bf35c: 0x4be308d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf360: 0x4be41918
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bf364: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bf368: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bf36c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bf370: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf374: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bf378: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bf37c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf380: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bf384: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1bf388: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bf38c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1bf390: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001BF398
// Address: 0x1bf398 - 0x1bf3d0

void FUN_001BF398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf398: 0xd8810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1bf39c: 0xd8a20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1bf3a0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf3a4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf3a8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bf3ac: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf3b0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bf3b4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf3b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bf3bc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1bf3c0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bf3c4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1bf3c8: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PposEar__Fv
// Address: 0x1bf3d0 - 0x1bf3e4

void entry_1bf3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf3e4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bf3e8: 0x12000008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BF40C; return;
    }
    // 0x1bf3f0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1bf3f4: 0x8c620138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 312)));
    // 0x1bf3f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bf400);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bf400
// Address: 0x1bf400 - 0x1bf428

void entry_1bf400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf400) {
        switch (ctx->pc) {
            case 0x1bf40c: ctx->pc = 0; goto label_1bf40c;
            case 0x1bf414: ctx->pc = 0; goto label_1bf414;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf400: 0x14400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 320));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bf414;
    }
    // 0x1bf408: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1bf40c:
    // 0x1bf40c: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1bf410: 0x24620040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 64));
label_1bf414:
    // 0x1bf414: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf418: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf41c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bf424: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bf428; return;
}


// Function: SetDoppler__FP3AMB
// Address: 0x1bf428 - 0x1bf474

void entry_1bf474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf474: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bf478: 0x12000037
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BF558; return;
    }
    // 0x1bf480: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bf484: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf488: 0x26260140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1bf48c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf490: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf494: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1bf49c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1bf49c
// Address: 0x1bf49c - 0x1bf4bc

void entry_1bf49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf49c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bf4a0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf4a4: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1bf4a8: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1bf4ac: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf4b0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf4b4: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1bf4bc);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1bf4bc
// Address: 0x1bf4bc - 0x1bf550

void entry_1bf4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf4bc: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bf4c0: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bf4c4: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1bf4c8: 0xc641005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 92)); ctx->f[1] = *(float*)&val; }
    // 0x1bf4cc: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1bf4d0: 0x3c014561
    SET_GPR_U32(ctx, 1, ((uint32_t)17761 << 16));
    // 0x1bf4d4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bf4d8: 0x3c0136d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14033 << 16));
    // 0x1bf4dc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1bf4e0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1bf4e4: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1bf4e8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1bf4ec: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1bf4f0: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bf4f4: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1bf4f8: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bf4fc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf500: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bf504: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1bf508: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf50c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bf510: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1bf514: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1bf518: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1bf51c: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1bf520: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf524: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1bf528: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bf52c: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1bf530: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bf534: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1bf538: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1bf53c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1bf540: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1bf544: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1bf548: 0xc04794e
    SET_GPR_U32(ctx, 31, 0x1bf550);
    snd_GetDopplerPitchMod(rdram, ctx, runtime); return;
}


// Function: entry_1bf550
// Address: 0x1bf550 - 0x1bf578

void entry_1bf550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf550) {
        switch (ctx->pc) {
            case 0x1bf558: ctx->pc = 0; goto label_1bf558;
            case 0x1bf55c: ctx->pc = 0; goto label_1bf55c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf550: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 18), 96), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bf55c;
    }
label_1bf558:
    // 0x1bf558: 0xae400060
    WRITE32(ADD32(GPR_U32(ctx, 18), 96), GPR_U32(ctx, 0));
label_1bf55c:
    // 0x1bf55c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bf560: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bf564: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bf568: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bf56c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bf574: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bf578; return;
}


// Function: PfneardistGet__Fv
// Address: 0x1bf578 - 0x1bf594

void entry_1bf594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf594: 0x1040000b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BF5C4; return;
    }
    // 0x1bf59c: 0xc05258e
    SET_GPR_U32(ctx, 31, 0x1bf5a4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1120));
    LookkCurCplook__FP6CPLOOK(rdram, ctx, runtime); return;
}


// Function: entry_1bf5a4
// Address: 0x1bf5a4 - 0x1bf5e0

void entry_1bf5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf5a4) {
        switch (ctx->pc) {
            case 0x1bf5c4: ctx->pc = 0; goto label_1bf5c4;
            case 0x1bf5c8: ctx->pc = 0; goto label_1bf5c8;
            case 0x1bf5cc: ctx->pc = 0; goto label_1bf5cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf5a4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bf5a8: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x1bf5ac: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)28 << 16));
        goto label_1bf5c8;
    }
    // 0x1bf5b4: 0x18600003
    SET_GPR_U32(ctx, 2, ((uint32_t)28 << 16));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1bf5c4;
    }
    // 0x1bf5bc: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963936));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bf5cc;
    }
label_1bf5c4:
    // 0x1bf5c4: 0x3c02001c
    SET_GPR_U32(ctx, 2, ((uint32_t)28 << 16));
label_1bf5c8:
    // 0x1bf5c8: 0x2442f398
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964120));
label_1bf5cc:
    // 0x1bf5cc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf5d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf5d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bf5dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bf5e0; return;
}


// Function: SDistEar__FP6VECTOR
// Address: 0x1bf5e0 - 0x1bf5f8

void entry_1bf5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf5f8: 0xc06fd5e
    SET_GPR_U32(ctx, 31, 0x1bf600);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PfneardistGet__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bf600
// Address: 0x1bf600 - 0x1bf60c

void entry_1bf600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf600: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bf604: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1bf60c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1bf60c
// Address: 0x1bf60c - 0x1bf620

void entry_1bf60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf60c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bf610: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf614: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf618: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateDistVolPan__FP6VECTORPfT1fff
// Address: 0x1bf620 - 0x1bf664

void entry_1bf664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf664: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1bf668: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bf66c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bf670: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1bf674: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1bf678: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1bf67c: 0xc06fc80
    SET_GPR_U32(ctx, 31, 0x1bf684);
    ctx->f[15] = FPU_MOV_S(ctx->f[22]);
    CalculateVolPan__FfP6VECTORPfT2fff(rdram, ctx, runtime); return;
}


// Function: entry_1bf684
// Address: 0x1bf684 - 0x1bf6b8

void entry_1bf684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf684) {
        switch (ctx->pc) {
            case 0x1bf68c: ctx->pc = 0; goto label_1bf68c;
            case 0x1bf698: ctx->pc = 0; goto label_1bf698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf684: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bf698;
    }
label_1bf68c:
    // 0x1bf68c: 0xe6340000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1bf690: 0xae400000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 0));
    // 0x1bf694: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1bf698:
    // 0x1bf698: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bf69c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf6a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf6a4: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x1bf6a8: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x1bf6ac: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1bf6b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PambAlloc__Fv
// Address: 0x1bf6b8 - 0x1bf6d8

void entry_1bf6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf6d8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bf6dc: 0x12000008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1bf700(rdram, ctx, runtime); return;
    }
    // 0x1bf6e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bf6e8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1bf6f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 144));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1bf6f0
// Address: 0x1bf6f0 - 0x1bf700

void entry_1bf6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf6f0: 0x8e245710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1bf6f4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bf6f8: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1bf700);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7084));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1bf700
// Address: 0x1bf700 - 0x1bf718

void entry_1bf700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf700: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bf704: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bf708: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf70c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf710: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DropPamb__FPP3AMB
// Address: 0x1bf718 - 0x1bf728

void entry_1bf764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf764: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1bf768: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bf76c: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x1bf774);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7072));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_1bf774
// Address: 0x1bf774 - 0x1bf788

void entry_1bf774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf774: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bf778: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf77c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf780: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StopSound__FP3AMBi
// Address: 0x1bf788 - 0x1bf7ac

void entry_1bf7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf7ac) {
        switch (ctx->pc) {
            case 0x1bf7b4: ctx->pc = 0; goto label_1bf7b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf7ac: 0x1000000c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1bf7e0(rdram, ctx, runtime); return;
    }
label_1bf7b4:
    // 0x1bf7b4: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1bf7b8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1bf7bc: 0x3c013e75
    SET_GPR_U32(ctx, 1, ((uint32_t)15989 << 16));
    // 0x1bf7c0: 0x3421c290
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49808));
    // 0x1bf7c4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1bf7c8: 0x2405fffc
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x1bf7cc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1bf7d0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1bf7d4: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1bf7d8: 0xc047618
    SET_GPR_U32(ctx, 31, 0x1bf7e0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    snd_AutoVol(rdram, ctx, runtime); return;
}


// Function: entry_1bf7e0
// Address: 0x1bf7e0 - 0x1bf7e8

void entry_1bf7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf7e0: 0xc06fdca
    SET_GPR_U32(ctx, 31, 0x1bf7e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveAmb__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1bf7e8
// Address: 0x1bf7e8 - 0x1bf7f8

void entry_1bf7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf7e8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bf7ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf7f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetPambFrq__FP3AMBf
// Address: 0x1bf7f8 - 0x1bf878

void entry_1bf878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf878) {
        switch (ctx->pc) {
            case 0x1bf884: ctx->pc = 0; goto label_1bf884;
            case 0x1bf8cc: ctx->pc = 0; goto label_1bf8cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf878: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bf87c: 0xae020070
    WRITE32(ADD32(GPR_U32(ctx, 16), 112), GPR_U32(ctx, 2));
    // 0x1bf880: 0xae03006c
    WRITE32(ADD32(GPR_U32(ctx, 16), 108), GPR_U32(ctx, 3));
label_1bf884:
    // 0x1bf884: 0x3c0144be
    SET_GPR_U32(ctx, 1, ((uint32_t)17598 << 16));
    // 0x1bf888: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1bf88c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1bf890: 0x24067fff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32767));
    // 0x1bf894: 0xc6000058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[0] = *(float*)&val; }
    // 0x1bf898: 0x8e030070
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 112)));
    // 0x1bf89c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1bf8a0: 0x8e040060
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x1bf8a4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1bf8a8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1bf8ac: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1bf8b0: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1bf8b4: 0x28628000
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4294934528));
    // 0x1bf8b8: 0x14400004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294934528));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1bf8cc;
    }
    // 0x1bf8c0: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1bf8c4: 0xc3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 3)));
    // 0x1bf8c8: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
label_1bf8cc:
    // 0x1bf8cc: 0xc047604
    SET_GPR_U32(ctx, 31, 0x1bf8d4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    snd_SetSoundPitch(rdram, ctx, runtime); return;
}


// Function: entry_1bf8d4
// Address: 0x1bf8d4 - 0x1bf8e8

void entry_1bf8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf8d4) {
        switch (ctx->pc) {
            case 0x1bf8d8: ctx->pc = 0; goto label_1bf8d8;
            case 0x1bf8dc: ctx->pc = 0; goto label_1bf8dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf8d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1bf8d8:
    // 0x1bf8d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1bf8dc:
    // 0x1bf8dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1bf8e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1bf8e8; return;
}


// Function: SetPambVol__FP3AMBf
// Address: 0x1bf8e8 - 0x1bf914

void entry_1bf914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bf914: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bf918: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FillPamb__FP3AMBPP3AMBiP3ALOP6VECTORfffffP2LMT10_
// Address: 0x1bf920 - 0x1bf9a4

void entry_1bf9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bf9a4) {
        switch (ctx->pc) {
            case 0x1bf9c8: ctx->pc = 0; goto label_1bf9c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bf9a4: 0x26430140
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1bf9a8: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bf9ac: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bf9b0: 0xb202006b
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 107); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bf9b4: 0xb6020064
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 100); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bf9b8: 0x72980b
    if (GPR_U32(ctx, 18) != 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 3));
    // 0x1bf9bc: 0x12200002
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1bf9c8;
    }
    // 0x1bf9c4: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
label_1bf9c8:
    // 0x1bf9c8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1bf9cc: 0xe6140058
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 88), *(uint32_t*)&val); }
    // 0x1bf9d0: 0x8c62474c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 18252)));
    // 0x1bf9d4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bf9d8: 0xe615005c
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 92), *(uint32_t*)&val); }
    // 0x1bf9dc: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1bf9e0: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1bf9e4: 0xae16003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 22));
    // 0x1bf9e8: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1bf9ec: 0xae120030
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 18));
    // 0x1bf9f0: 0xe6170034
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1bf9f4: 0xe6180038
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x1bf9f8: 0xe6160014
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x1bf9fc: 0xae000048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 0));
    // 0x1bfa00: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x1bfa08);
    WRITE32(ADD32(GPR_U32(ctx, 3), 18252), GPR_U32(ctx, 2));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1bfa08
// Address: 0x1bfa08 - 0x1bfab4

void entry_1bfa08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bfa08) {
        switch (ctx->pc) {
            case 0x1bfa28: ctx->pc = 0; goto label_1bfa28;
            case 0x1bfa34: ctx->pc = 0; goto label_1bfa34;
            case 0x1bfa54: ctx->pc = 0; goto label_1bfa54;
            case 0x1bfa60: ctx->pc = 0; goto label_1bfa60;
            case 0x1bfa70: ctx->pc = 0; goto label_1bfa70;
            case 0x1bfa90: ctx->pc = 0; goto label_1bfa90;
            case 0x1bfa98: ctx->pc = 0; goto label_1bfa98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bfa08: 0x12800007
    WRITE8(ADD32(GPR_U32(ctx, 16), 76), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1bfa28;
    }
    // 0x1bfa10: 0x6a870007
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1bfa14: 0x6e870000
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1bfa18: 0xb207007f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 127); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bfa1c: 0xb6070078
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 120); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bfa20: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bfa34;
    }
label_1bfa28:
    // 0x1bfa28: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1bfa2c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bfa30: 0xe6000078
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 120), *(uint32_t*)&val); }
label_1bfa34:
    // 0x1bfa34: 0x12a00007
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_1bfa54;
    }
    // 0x1bfa3c: 0x6aa40007
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1bfa40: 0x6ea40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1bfa44: 0xb2040087
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 135); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bfa48: 0xb6040080
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 128); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bfa4c: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bfa60;
    }
label_1bfa54:
    // 0x1bfa54: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1bfa58: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bfa5c: 0xe6000080
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 128), *(uint32_t*)&val); }
label_1bfa60:
    // 0x1bfa60: 0x12600003
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1bfa70;
    }
    // 0x1bfa68: 0x7a620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1bfa6c: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
label_1bfa70:
    // 0x1bfa70: 0x16600007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        goto label_1bfa90;
    }
    // 0x1bfa78: 0xc6010078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 120)); ctx->f[1] = *(float*)&val; }
    // 0x1bfa7c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1bfa80: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bfa84: 0x0
    // NOP
    // 0x1bfa88: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
        goto label_1bfa98;
    }
label_1bfa90:
    // 0x1bfa90: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1bfa94: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1bfa98:
    // 0x1bfa98: 0xae020044
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 2));
    // 0x1bfa9c: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1bfaa0: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x1bfaa4: 0x4600c386
    ctx->f[14] = FPU_MOV_S(ctx->f[24]);
    // 0x1bfaa8: 0x26050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1bfaac: 0xc06fd88
    SET_GPR_U32(ctx, 31, 0x1bfab4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 84));
    CalculateDistVolPan__FP6VECTORPfT1fff(rdram, ctx, runtime); return;
}


// Function: entry_1bfab4
// Address: 0x1bfab4 - 0x1bfabc

void entry_1bfab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfab4: 0xc06fd0a
    SET_GPR_U32(ctx, 31, 0x1bfabc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDoppler__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1bfabc
// Address: 0x1bfabc - 0x1bfaf8

void entry_1bfabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfabc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1bfac0: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1bfac4: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1bfac8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1bfacc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1bfad0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bfad4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bfad8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bfadc: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x1bfae0: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x1bfae4: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x1bfae8: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1bfaec: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1bfaf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ActivatePamb__FP3AMB5SFXID
// Address: 0x1bfaf8 - 0x1bfb24

void entry_1bfb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bfb24) {
        switch (ctx->pc) {
            case 0x1bfb40: ctx->pc = 0; goto label_1bfb40;
            case 0x1bfb68: ctx->pc = 0; goto label_1bfb68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bfb24: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bfb28: 0x1118c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 3));
    // 0x1bfb2c: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x1bfb30: 0x24425020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 20512));
    // 0x1bfb34: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1bfb38: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1bfb3c: 0xae060008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 6));
label_1bfb40:
    // 0x1bfb40: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x1bfb44: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1bfb48: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1bfb4c: 0x16320006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 18)) {
        goto label_1bfb68;
    }
    // 0x1bfb54: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1bfb58: 0x8c43472c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 18220)));
    // 0x1bfb5c: 0xae000040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 0));
    // 0x1bfb60: 0x1000001f
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BFBE0; return;
    }
label_1bfb68:
    // 0x1bfb68: 0xc6000050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[0] = *(float*)&val; }
    // 0x1bfb6c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1bfb70: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bfb74: 0x0
    // NOP
    // 0x1bfb78: 0x45010017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BFBD8; return;
    }
    // 0x1bfb80: 0xc6000078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 120)); ctx->f[0] = *(float*)&val; }
    // 0x1bfb84: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bfb88: 0x0
    // NOP
    // 0x1bfb8c: 0x45000012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BFBD8; return;
    }
    // 0x1bfb94: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1bfb98: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bfb9c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bfba0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bfba4: 0xc047566
    SET_GPR_U32(ctx, 31, 0x1bfbac);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_PlaySoundVolPanPMPB(rdram, ctx, runtime); return;
}


// Function: entry_1bfbac
// Address: 0x1bfbac - 0x1bfbbc

void entry_1bfbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfbac: 0xae000040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 0));
    // 0x1bfbb0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bfbb4: 0xc06fd0a
    SET_GPR_U32(ctx, 31, 0x1bfbbc);
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    SetDoppler__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1bfbbc
// Address: 0x1bfbbc - 0x1bfbc8

void entry_1bfbbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfbbc: 0xc60c0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[12] = *(float*)&val; }
    // 0x1bfbc0: 0xc06fdfe
    SET_GPR_U32(ctx, 31, 0x1bfbc8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetPambFrq__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1bfbc8
// Address: 0x1bfbc8 - 0x1bfbd0

void entry_1bfbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfbc8: 0xc06fa18
    SET_GPR_U32(ctx, 31, 0x1bfbd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefreshPambVolPan__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1bfbd0
// Address: 0x1bfbd0 - 0x1bfbf8

void entry_1bfbd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bfbd0) {
        switch (ctx->pc) {
            case 0x1bfbd8: ctx->pc = 0; goto label_1bfbd8;
            case 0x1bfbe0: ctx->pc = 0; goto label_1bfbe0;
            case 0x1bfbe4: ctx->pc = 0; goto label_1bfbe4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bfbd0: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bfbe4;
    }
label_1bfbd8:
    // 0x1bfbd8: 0xae000018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 0));
    // 0x1bfbdc: 0xae020040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 2));
label_1bfbe0:
    // 0x1bfbe0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1bfbe4:
    // 0x1bfbe4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bfbe8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bfbec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1bfbf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ScheduleNextIntermittentSound__FP3AMB
// Address: 0x1bfbf8 - 0x1bfc24

void entry_1bfc24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfc24: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1bfc28: 0x8e030030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1bfc2c: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1bfc30: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1bfc34: 0x14600020
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 116), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BFCB8; return;
    }
    // 0x1bfc3c: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1bfc40: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1bfc44: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1bfc48: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1bfc4c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1bfc54);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1bfc54
// Address: 0x1bfc54 - 0x1bfc64

void entry_1bfc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfc54: 0xc60d0084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 132)); ctx->f[13] = *(float*)&val; }
    // 0x1bfc58: 0x460005c6
    ctx->f[23] = FPU_MOV_S(ctx->f[0]);
    // 0x1bfc5c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1bfc64);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 128)); ctx->f[12] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1bfc64
// Address: 0x1bfc64 - 0x1bfc70

void entry_1bfc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfc64: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x1bfc68: 0xc081484
    SET_GPR_U32(ctx, 31, 0x1bfc70);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_1bfc70
// Address: 0x1bfc70 - 0x1bfc7c

void entry_1bfc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfc70: 0x46160502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1bfc74: 0xc081500
    SET_GPR_U32(ctx, 31, 0x1bfc7c);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_1bfc7c
// Address: 0x1bfc7c - 0x1bfca8

void entry_1bfc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfc7c: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1bfc80: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1bfc84: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1bfc88: 0x70431c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x1bfc8c: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x1bfc90: 0x70431b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 3)));
    // 0x1bfc94: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1bfc98: 0xfa010020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bfc9c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1bfca0: 0xc06fcf4
    SET_GPR_U32(ctx, 31, 0x1bfca8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    PposEar__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bfca8
// Address: 0x1bfca8 - 0x1bfcd8

void entry_1bfca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bfca8) {
        switch (ctx->pc) {
            case 0x1bfcb8: ctx->pc = 0; goto label_1bfcb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bfca8: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bfcac: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1bfcb0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1bfcb4: 0xfa010020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_1bfcb8:
    // 0x1bfcb8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1bfcbc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1bfcc0: 0xc7b70058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[23] = *(float*)&val; }
    // 0x1bfcc4: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x1bfcc8: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x1bfccc: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1bfcd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9
// Address: 0x1bfcd8 - 0x1bfd84

void entry_1bfd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bfd84) {
        switch (ctx->pc) {
            case 0x1bfd8c: ctx->pc = 0; goto label_1bfd8c;
            case 0x1bfd90: ctx->pc = 0; goto label_1bfd90;
            case 0x1bfda8: ctx->pc = 0; goto label_1bfda8;
            case 0x1bfdcc: ctx->pc = 0; goto label_1bfdcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bfd84: 0x10000002
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1bfd90;
    }
label_1bfd8c:
    // 0x1bfd8c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1bfd90:
    // 0x1bfd90: 0x16a00005
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        goto label_1bfda8;
    }
    // 0x1bfd98: 0x16800003
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        goto label_1bfda8;
    }
    // 0x1bfda0: 0x12c00063
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BFF30; return;
    }
label_1bfda8:
    // 0x1bfda8: 0x1600003a
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BFE94; return;
    }
    // 0x1bfdb0: 0x12600006
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1bfdcc;
    }
    // 0x1bfdb8: 0xc6610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1bfdbc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1bfdc0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bfdc4: 0x45000033
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BFE94; return;
    }
label_1bfdcc:
    // 0x1bfdcc: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bfdd0: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1bfdd4: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x1bfdd8: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1bfddc: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1bfde0: 0x4600c406
    ctx->f[16] = FPU_MOV_S(ctx->f[24]);
    // 0x1bfde4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bfde8: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1bfdec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bfdf0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bfdf4: 0xc06fe48
    SET_GPR_U32(ctx, 31, 0x1bfdfc);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FillPamb__FP3AMBPP3AMBiP3ALOP6VECTORfffffP2LMT10_(rdram, ctx, runtime); return;
}


// Function: entry_1bfdfc
// Address: 0x1bfdfc - 0x1bfe1c

void entry_1bfdfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfdfc: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x1bfe00: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1bfe04: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bfe08: 0x0
    // NOP
    // 0x1bfe0c: 0x45010017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BFE6C; return;
    }
    // 0x1bfe14: 0xc06fdae
    SET_GPR_U32(ctx, 31, 0x1bfe1c);
    PambAlloc__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bfe1c
// Address: 0x1bfe1c - 0x1bfe84

void entry_1bfe1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bfe1c) {
        switch (ctx->pc) {
            case 0x1bfe44: ctx->pc = 0; goto label_1bfe44;
            case 0x1bfe6c: ctx->pc = 0; goto label_1bfe6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bfe1c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bfe20: 0x12200018
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_1bfe84(rdram, ctx, runtime); return;
    }
    // 0x1bfe28: 0x6a22006b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 107); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bfe2c: 0x6e220064
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 100); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1bfe30: 0xb3a2006b
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 107); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bfe34: 0xb7a20064
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 100); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1bfe38: 0x220182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1bfe3c: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1bfe40: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
label_1bfe44:
    // 0x1bfe44: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bfe48: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1bfe4c: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x1bfe50: 0x7c670010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 7));
    // 0x1bfe54: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1bfe58: 0x1444fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1bfe44;
    }
    // 0x1bfe60: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1bfe64: 0x10000007
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1bfe84(rdram, ctx, runtime); return;
    }
label_1bfe6c:
    // 0x1bfe6c: 0x16420005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        entry_1bfe84(rdram, ctx, runtime); return;
    }
    // 0x1bfe74: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bfe78: 0x8c44472c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 18220)));
    // 0x1bfe7c: 0xc0475e6
    SET_GPR_U32(ctx, 31, 0x1bfe84);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_SetSoundVolPan(rdram, ctx, runtime); return;
}


// Function: entry_1bfe84
// Address: 0x1bfe84 - 0x1bfe9c

void entry_1bfe84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bfe84) {
        switch (ctx->pc) {
            case 0x1bfe94: ctx->pc = 0; goto label_1bfe94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bfe84: 0x56c00014
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 17));
        entry_1bfed8(rdram, ctx, runtime); return;
    }
    // 0x1bfe8c: 0x10000012
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1bfed8(rdram, ctx, runtime); return;
    }
label_1bfe94:
    // 0x1bfe94: 0xc06fdae
    SET_GPR_U32(ctx, 31, 0x1bfe9c);
    PambAlloc__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1bfe9c
// Address: 0x1bfe9c - 0x1bfed8

void entry_1bfe9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfe9c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bfea0: 0x12200039
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_1bff88(rdram, ctx, runtime); return;
    }
    // 0x1bfea8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1bfeac: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1bfeb0: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1bfeb4: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1bfeb8: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x1bfebc: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1bfec0: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1bfec4: 0x4600c406
    ctx->f[16] = FPU_MOV_S(ctx->f[24]);
    // 0x1bfec8: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1bfecc: 0x2e0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1bfed0: 0xc06fe48
    SET_GPR_U32(ctx, 31, 0x1bfed8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FillPamb__FP3AMBPP3AMBiP3ALOP6VECTORfffffP2LMT10_(rdram, ctx, runtime); return;
}


// Function: entry_1bfed8
// Address: 0x1bfed8 - 0x1bff00

void entry_1bfed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bfed8: 0x1220002c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BFF8C; return;
    }
    // 0x1bfee0: 0xc6200078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 120)); ctx->f[0] = *(float*)&val; }
    // 0x1bfee4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1bfee8: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1bfeec: 0x0
    // NOP
    // 0x1bfef0: 0x4500000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1BFF20; return;
    }
    // 0x1bfef8: 0xc06fefe
    SET_GPR_U32(ctx, 31, 0x1bff00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ScheduleNextIntermittentSound__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1bff00
// Address: 0x1bff00 - 0x1bff0c

void entry_1bff00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bff00: 0xc62d0078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 120)); ctx->f[13] = *(float*)&val; }
    // 0x1bff04: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1bff0c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1bff0c
// Address: 0x1bff0c - 0x1bff28

void entry_1bff0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bff0c) {
        switch (ctx->pc) {
            case 0x1bff20: ctx->pc = 0; goto label_1bff20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bff0c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1bff10: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1bff14: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1bff18: 0xe6210074
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 116), *(uint32_t*)&val); }
    // 0x1bff1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1bff20:
    // 0x1bff20: 0xc06febe
    SET_GPR_U32(ctx, 31, 0x1bff28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ActivatePamb__FP3AMB5SFXID(rdram, ctx, runtime); return;
}


// Function: entry_1bff28
// Address: 0x1bff28 - 0x1bff38

void entry_1bff28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bff28) {
        switch (ctx->pc) {
            case 0x1bff30: ctx->pc = 0; goto label_1bff30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bff28: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1BFF8C; return;
    }
label_1bff30:
    // 0x1bff30: 0xc06f92a
    SET_GPR_U32(ctx, 31, 0x1bff38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SbpEnsureBank__F5SFXID(rdram, ctx, runtime); return;
}


// Function: entry_1bff38
// Address: 0x1bff38 - 0x1bff88

void entry_1bff38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1bff38: 0x3c014480
    SET_GPR_U32(ctx, 1, ((uint32_t)17536 << 16));
    // 0x1bff3c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1bff40: 0x3c030024
    SET_GPR_U32(ctx, 3, ((uint32_t)36 << 16));
    // 0x1bff44: 0x3c0144be
    SET_GPR_U32(ctx, 1, ((uint32_t)17598 << 16));
    // 0x1bff48: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1bff4c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1bff50: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x1bff54: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1bff58: 0x24635020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 20512));
    // 0x1bff5c: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x1bff60: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1bff64: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1bff68: 0x8c650004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1bff6c: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1bff70: 0x44061000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[2]);
    // 0x1bff74: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1bff78: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1bff7c: 0x44080000
    SET_GPR_U32(ctx, 8, *(uint32_t*)&ctx->f[0]);
    // 0x1bff80: 0xc047566
    SET_GPR_U32(ctx, 31, 0x1bff88);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_PlaySoundVolPanPMPB(rdram, ctx, runtime); return;
}


// Function: entry_1bff88
// Address: 0x1bff88 - 0x1bffc8

void entry_1bff88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bff88) {
        switch (ctx->pc) {
            case 0x1bff8c: ctx->pc = 0; goto label_1bff8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bff88: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
label_1bff8c:
    // 0x1bff8c: 0x7bb70100
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1bff90: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1bff94: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1bff98: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1bff9c: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1bffa0: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1bffa4: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1bffa8: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1bffac: 0xc7b80140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[24] = *(float*)&val; }
    // 0x1bffb0: 0xc7b70138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[23] = *(float*)&val; }
    // 0x1bffb4: 0xc7b60130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[22] = *(float*)&val; }
    // 0x1bffb8: 0xc7b50128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[21] = *(float*)&val; }
    // 0x1bffbc: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x1bffc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001BFFC8
// Address: 0x1bffc8 - 0x1c0000

void FUN_001BFFC8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1bffc8) {
        switch (ctx->pc) {
            case 0x1bfff8: ctx->pc = 0; goto label_1bfff8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1bffc8: 0x1480000b
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1bfff8;
    }
    // 0x1bffd0: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1bffd4: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1bffd8: 0x5203f
    SET_GPR_S64(ctx, 4, GPR_S64(ctx, 5) >> (32 + 0));
    // 0x1bffdc: 0xa21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1bffe0: 0x2283c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1bffe4: 0x5283f
    SET_GPR_S64(ctx, 5, GPR_S64(ctx, 5) >> (32 + 0));
    // 0x1bffe8: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x1bffec: 0x14640002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_1bfff8;
    }
    // 0x1bfff4: 0xaca20048
    WRITE32(ADD32(GPR_U32(ctx, 5), 72), GPR_U32(ctx, 2));
label_1bfff8:
    // 0x1bfff8: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleWipeHandleWipeVolumes__FifVolumes
// Address: 0x1c0000 - 0x1c0024

void entry_1b0024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0024 inside entry_1affa8 (0x1affa8 - 0x1b002c)
    ctx->pc = 0x1b0024;
    entry_1affa8(rdram, ctx, runtime);
}

void entry_1b006c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b006c inside entry_1b0064 (0x1b0064 - 0x1b0074)
    ctx->pc = 0x1b006c;
    entry_1b0064(rdram, ctx, runtime);
}

void entry_1b0078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0078 inside entry_1b0074 (0x1b0074 - 0x1b00a4)
    ctx->pc = 0x1b0078;
    entry_1b0074(rdram, ctx, runtime);
}

void entry_1b0088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0088 inside entry_1b0074 (0x1b0074 - 0x1b00a4)
    ctx->pc = 0x1b0088;
    entry_1b0074(rdram, ctx, runtime);
}

void entry_1b009c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b009c inside entry_1b0074 (0x1b0074 - 0x1b00a4)
    ctx->pc = 0x1b009c;
    entry_1b0074(rdram, ctx, runtime);
}

void entry_1b019c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b019c inside entry_1b0198 (0x1b0198 - 0x1b01b0)
    ctx->pc = 0x1b019c;
    entry_1b0198(rdram, ctx, runtime);
}

void entry_1b01a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b01a0 inside entry_1b0198 (0x1b0198 - 0x1b01b0)
    ctx->pc = 0x1b01a0;
    entry_1b0198(rdram, ctx, runtime);
}

void entry_1b01f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b01f8 inside SetLasenSensors__FP5LASEN7SENSORS (0x1b01b0 - 0x1b0238)
    ctx->pc = 0x1b01f8;
    SetLasenSensors__FP5LASEN7SENSORS(rdram, ctx, runtime);
}

void entry_1b023c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b023c inside entry_1b0238 (0x1b0238 - 0x1b02b4)
    ctx->pc = 0x1b023c;
    entry_1b0238(rdram, ctx, runtime);
}

void entry_1b025c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b025c inside entry_1b0238 (0x1b0238 - 0x1b02b4)
    ctx->pc = 0x1b025c;
    entry_1b0238(rdram, ctx, runtime);
}

void entry_1b0270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0270 inside entry_1b0238 (0x1b0238 - 0x1b02b4)
    ctx->pc = 0x1b0270;
    entry_1b0238(rdram, ctx, runtime);
}

void entry_1b0288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0288 inside entry_1b0238 (0x1b0238 - 0x1b02b4)
    ctx->pc = 0x1b0288;
    entry_1b0238(rdram, ctx, runtime);
}

void entry_1b02a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b02a8 inside entry_1b0238 (0x1b0238 - 0x1b02b4)
    ctx->pc = 0x1b02a8;
    entry_1b0238(rdram, ctx, runtime);
}

void entry_1b02c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b02c4 inside entry_1b02b4 (0x1b02b4 - 0x1b030c)
    ctx->pc = 0x1b02c4;
    entry_1b02b4(rdram, ctx, runtime);
}

void entry_1b02e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b02e0 inside entry_1b02b4 (0x1b02b4 - 0x1b030c)
    ctx->pc = 0x1b02e0;
    entry_1b02b4(rdram, ctx, runtime);
}

void entry_1b02f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b02f0 inside entry_1b02b4 (0x1b02b4 - 0x1b030c)
    ctx->pc = 0x1b02f0;
    entry_1b02b4(rdram, ctx, runtime);
}

void entry_1b0328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0328 inside entry_1b031c (0x1b031c - 0x1b0334)
    ctx->pc = 0x1b0328;
    entry_1b031c(rdram, ctx, runtime);
}

void entry_1b032c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b032c inside entry_1b031c (0x1b031c - 0x1b0334)
    ctx->pc = 0x1b032c;
    entry_1b031c(rdram, ctx, runtime);
}

void entry_1b03b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b03b0 inside SCalcLasenShapeExtent__FP5LASENP5LBEAM (0x1b0360 - 0x1b0470)
    ctx->pc = 0x1b03b0;
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime);
}

void entry_1b03f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b03f8 inside SCalcLasenShapeExtent__FP5LASENP5LBEAM (0x1b0360 - 0x1b0470)
    ctx->pc = 0x1b03f8;
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime);
}

void entry_1b0444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0444 inside SCalcLasenShapeExtent__FP5LASENP5LBEAM (0x1b0360 - 0x1b0470)
    ctx->pc = 0x1b0444;
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime);
}

void entry_1b0454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0454 inside SCalcLasenShapeExtent__FP5LASENP5LBEAM (0x1b0360 - 0x1b0470)
    ctx->pc = 0x1b0454;
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime);
}

void entry_1b045c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b045c inside SCalcLasenShapeExtent__FP5LASENP5LBEAM (0x1b0360 - 0x1b0470)
    ctx->pc = 0x1b045c;
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime);
}

void entry_1b0460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0460 inside SCalcLasenShapeExtent__FP5LASENP5LBEAM (0x1b0360 - 0x1b0470)
    ctx->pc = 0x1b0460;
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime);
}

void entry_1b0504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0504 inside entry_1b04f8 (0x1b04f8 - 0x1b0554)
    ctx->pc = 0x1b0504;
    entry_1b04f8(rdram, ctx, runtime);
}

void entry_1b0520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0520 inside entry_1b04f8 (0x1b04f8 - 0x1b0554)
    ctx->pc = 0x1b0520;
    entry_1b04f8(rdram, ctx, runtime);
}

void entry_1b0528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0528 inside entry_1b04f8 (0x1b04f8 - 0x1b0554)
    ctx->pc = 0x1b0528;
    entry_1b04f8(rdram, ctx, runtime);
}

void entry_1b0694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0694 inside entry_1b0664 (0x1b0664 - 0x1b06c4)
    ctx->pc = 0x1b0694;
    entry_1b0664(rdram, ctx, runtime);
}

void entry_1b06a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b06a4 inside entry_1b0664 (0x1b0664 - 0x1b06c4)
    ctx->pc = 0x1b06a4;
    entry_1b0664(rdram, ctx, runtime);
}

void entry_1b06cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b06cc inside entry_1b06c4 (0x1b06c4 - 0x1b0704)
    ctx->pc = 0x1b06cc;
    entry_1b06c4(rdram, ctx, runtime);
}

void entry_1b0734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0734 inside entry_1b072c (0x1b072c - 0x1b07a0)
    ctx->pc = 0x1b0734;
    entry_1b072c(rdram, ctx, runtime);
}

void entry_1b073c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b073c inside entry_1b072c (0x1b072c - 0x1b07a0)
    ctx->pc = 0x1b073c;
    entry_1b072c(rdram, ctx, runtime);
}

void entry_1b0768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0768 inside entry_1b072c (0x1b072c - 0x1b07a0)
    ctx->pc = 0x1b0768;
    entry_1b072c(rdram, ctx, runtime);
}

void entry_1b0794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0794 inside entry_1b072c (0x1b072c - 0x1b07a0)
    ctx->pc = 0x1b0794;
    entry_1b072c(rdram, ctx, runtime);
}

void entry_1b0798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0798 inside entry_1b072c (0x1b072c - 0x1b07a0)
    ctx->pc = 0x1b0798;
    entry_1b072c(rdram, ctx, runtime);
}

void entry_1b07fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b07fc inside entry_1b07a0 (0x1b07a0 - 0x1b081c)
    ctx->pc = 0x1b07fc;
    entry_1b07a0(rdram, ctx, runtime);
}

void entry_1b0804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0804 inside entry_1b07a0 (0x1b07a0 - 0x1b081c)
    ctx->pc = 0x1b0804;
    entry_1b07a0(rdram, ctx, runtime);
}

void entry_1b0808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0808 inside entry_1b07a0 (0x1b07a0 - 0x1b081c)
    ctx->pc = 0x1b0808;
    entry_1b07a0(rdram, ctx, runtime);
}

void entry_1b080c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b080c inside entry_1b07a0 (0x1b07a0 - 0x1b081c)
    ctx->pc = 0x1b080c;
    entry_1b07a0(rdram, ctx, runtime);
}

void entry_1b08c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b08c4 inside entry_1b0874 (0x1b0874 - 0x1b0af0)
    ctx->pc = 0x1b08c4;
    entry_1b0874(rdram, ctx, runtime);
}

void entry_1b0950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0950 inside entry_1b0874 (0x1b0874 - 0x1b0af0)
    ctx->pc = 0x1b0950;
    entry_1b0874(rdram, ctx, runtime);
}

void entry_1b0960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0960 inside entry_1b0874 (0x1b0874 - 0x1b0af0)
    ctx->pc = 0x1b0960;
    entry_1b0874(rdram, ctx, runtime);
}

void entry_1b09d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b09d0 inside entry_1b0874 (0x1b0874 - 0x1b0af0)
    ctx->pc = 0x1b09d0;
    entry_1b0874(rdram, ctx, runtime);
}

void entry_1b09e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b09e0 inside entry_1b0874 (0x1b0874 - 0x1b0af0)
    ctx->pc = 0x1b09e0;
    entry_1b0874(rdram, ctx, runtime);
}

void entry_1b0a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0a28 inside entry_1b0874 (0x1b0874 - 0x1b0af0)
    ctx->pc = 0x1b0a28;
    entry_1b0874(rdram, ctx, runtime);
}

void entry_1b0a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0a94 inside entry_1b0874 (0x1b0874 - 0x1b0af0)
    ctx->pc = 0x1b0a94;
    entry_1b0874(rdram, ctx, runtime);
}

void entry_1b0af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0af8 inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0af8;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b38 inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b38;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b4c inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b4c;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b60 inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b60;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b64 inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b64;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b68 inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b68;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b6c inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b6c;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b84 inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b84;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0b8c inside entry_1b0af0 (0x1b0af0 - 0x1b0ba0)
    ctx->pc = 0x1b0b8c;
    entry_1b0af0(rdram, ctx, runtime);
}

void entry_1b0c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0c3c inside entry_1b0c34 (0x1b0c34 - 0x1b0c68)
    ctx->pc = 0x1b0c3c;
    entry_1b0c34(rdram, ctx, runtime);
}

void entry_1b0c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0c44 inside entry_1b0c34 (0x1b0c34 - 0x1b0c68)
    ctx->pc = 0x1b0c44;
    entry_1b0c34(rdram, ctx, runtime);
}

void entry_1b0c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0c54 inside entry_1b0c34 (0x1b0c34 - 0x1b0c68)
    ctx->pc = 0x1b0c54;
    entry_1b0c34(rdram, ctx, runtime);
}

void entry_1b0d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0d44 inside entry_1b0cc0 (0x1b0cc0 - 0x1b0e24)
    ctx->pc = 0x1b0d44;
    entry_1b0cc0(rdram, ctx, runtime);
}

void entry_1b0d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0d50 inside entry_1b0cc0 (0x1b0cc0 - 0x1b0e24)
    ctx->pc = 0x1b0d50;
    entry_1b0cc0(rdram, ctx, runtime);
}

void entry_1b0d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0d80 inside entry_1b0cc0 (0x1b0cc0 - 0x1b0e24)
    ctx->pc = 0x1b0d80;
    entry_1b0cc0(rdram, ctx, runtime);
}

void entry_1b0d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0d98 inside entry_1b0cc0 (0x1b0cc0 - 0x1b0e24)
    ctx->pc = 0x1b0d98;
    entry_1b0cc0(rdram, ctx, runtime);
}

void entry_1b0dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0dd0 inside entry_1b0cc0 (0x1b0cc0 - 0x1b0e24)
    ctx->pc = 0x1b0dd0;
    entry_1b0cc0(rdram, ctx, runtime);
}

void entry_1b0e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0e0c inside entry_1b0cc0 (0x1b0cc0 - 0x1b0e24)
    ctx->pc = 0x1b0e0c;
    entry_1b0cc0(rdram, ctx, runtime);
}

void entry_1b0e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0e1c inside entry_1b0cc0 (0x1b0cc0 - 0x1b0e24)
    ctx->pc = 0x1b0e1c;
    entry_1b0cc0(rdram, ctx, runtime);
}

void entry_1b0e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0e84 inside entry_1b0e6c (0x1b0e6c - 0x1b0e8c)
    ctx->pc = 0x1b0e84;
    entry_1b0e6c(rdram, ctx, runtime);
}

void entry_1b0e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0e90 inside entry_1b0e8c (0x1b0e8c - 0x1b0ea8)
    ctx->pc = 0x1b0e90;
    entry_1b0e8c(rdram, ctx, runtime);
}

void entry_1b0e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0e94 inside entry_1b0e8c (0x1b0e8c - 0x1b0ea8)
    ctx->pc = 0x1b0e94;
    entry_1b0e8c(rdram, ctx, runtime);
}

void entry_1b0f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0f60 inside entry_1b0f18 (0x1b0f18 - 0x1b0f70)
    ctx->pc = 0x1b0f60;
    entry_1b0f18(rdram, ctx, runtime);
}

void entry_1b0f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0f64 inside entry_1b0f18 (0x1b0f18 - 0x1b0f70)
    ctx->pc = 0x1b0f64;
    entry_1b0f18(rdram, ctx, runtime);
}

void entry_1b0fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b0fb4 inside entry_1b0fb0 (0x1b0fb0 - 0x1b0fc0)
    ctx->pc = 0x1b0fb4;
    entry_1b0fb0(rdram, ctx, runtime);
}

void entry_1b1020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1020 inside entry_1b1014 (0x1b1014 - 0x1b1050)
    ctx->pc = 0x1b1020;
    entry_1b1014(rdram, ctx, runtime);
}

void entry_1b1024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1024 inside entry_1b1014 (0x1b1014 - 0x1b1050)
    ctx->pc = 0x1b1024;
    entry_1b1014(rdram, ctx, runtime);
}

void entry_1b10d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b10d0 inside entry_1b10a8 (0x1b10a8 - 0x1b1120)
    ctx->pc = 0x1b10d0;
    entry_1b10a8(rdram, ctx, runtime);
}

void entry_1b10e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b10e0 inside entry_1b10a8 (0x1b10a8 - 0x1b1120)
    ctx->pc = 0x1b10e0;
    entry_1b10a8(rdram, ctx, runtime);
}

void entry_1b1128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1128 inside entry_1b1120 (0x1b1120 - 0x1b1158)
    ctx->pc = 0x1b1128;
    entry_1b1120(rdram, ctx, runtime);
}

void entry_1b1130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1130 inside entry_1b1120 (0x1b1120 - 0x1b1158)
    ctx->pc = 0x1b1130;
    entry_1b1120(rdram, ctx, runtime);
}

void entry_1b1134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1134 inside entry_1b1120 (0x1b1120 - 0x1b1158)
    ctx->pc = 0x1b1134;
    entry_1b1120(rdram, ctx, runtime);
}

void entry_1b1140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1140 inside entry_1b1120 (0x1b1120 - 0x1b1158)
    ctx->pc = 0x1b1140;
    entry_1b1120(rdram, ctx, runtime);
}

void entry_1b11d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b11d8 inside entry_1b11b4 (0x1b11b4 - 0x1b1224)
    ctx->pc = 0x1b11d8;
    entry_1b11b4(rdram, ctx, runtime);
}

void entry_1b11f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b11f4 inside entry_1b11b4 (0x1b11b4 - 0x1b1224)
    ctx->pc = 0x1b11f4;
    entry_1b11b4(rdram, ctx, runtime);
}

void entry_1b1210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1210 inside entry_1b11b4 (0x1b11b4 - 0x1b1224)
    ctx->pc = 0x1b1210;
    entry_1b11b4(rdram, ctx, runtime);
}

void entry_1b1358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1358 inside entry_1b124c (0x1b124c - 0x1b137c)
    ctx->pc = 0x1b1358;
    entry_1b124c(rdram, ctx, runtime);
}

void entry_1b1360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1360 inside entry_1b124c (0x1b124c - 0x1b137c)
    ctx->pc = 0x1b1360;
    entry_1b124c(rdram, ctx, runtime);
}

void entry_1b13fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b13fc inside entry_1b137c (0x1b137c - 0x1b141c)
    ctx->pc = 0x1b13fc;
    entry_1b137c(rdram, ctx, runtime);
}

void entry_1b1404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1404 inside entry_1b137c (0x1b137c - 0x1b141c)
    ctx->pc = 0x1b1404;
    entry_1b137c(rdram, ctx, runtime);
}

void entry_1b1408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1408 inside entry_1b137c (0x1b137c - 0x1b141c)
    ctx->pc = 0x1b1408;
    entry_1b137c(rdram, ctx, runtime);
}

void entry_1b140c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b140c inside entry_1b137c (0x1b137c - 0x1b141c)
    ctx->pc = 0x1b140c;
    entry_1b137c(rdram, ctx, runtime);
}

void entry_1b1480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1480 inside SensePrsen__FP5PRSENP7SENSORS (0x1b1438 - 0x1b14d0)
    ctx->pc = 0x1b1480;
    SensePrsen__FP5PRSENP7SENSORS(rdram, ctx, runtime);
}

void entry_1b1498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1498 inside SensePrsen__FP5PRSENP7SENSORS (0x1b1438 - 0x1b14d0)
    ctx->pc = 0x1b1498;
    SensePrsen__FP5PRSENP7SENSORS(rdram, ctx, runtime);
}

void entry_1b14f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b14f8 inside entry_1b14d0 (0x1b14d0 - 0x1b1524)
    ctx->pc = 0x1b14f8;
    entry_1b14d0(rdram, ctx, runtime);
}

void entry_1b1550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1550 inside entry_1b1548 (0x1b1548 - 0x1b155c)
    ctx->pc = 0x1b1550;
    entry_1b1548(rdram, ctx, runtime);
}

void entry_1b1588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1588 inside entry_1b1584 (0x1b1584 - 0x1b15d0)
    ctx->pc = 0x1b1588;
    entry_1b1584(rdram, ctx, runtime);
}

void entry_1b1590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1590 inside entry_1b1584 (0x1b1584 - 0x1b15d0)
    ctx->pc = 0x1b1590;
    entry_1b1584(rdram, ctx, runtime);
}

void entry_1b159c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b159c inside entry_1b1584 (0x1b1584 - 0x1b15d0)
    ctx->pc = 0x1b159c;
    entry_1b1584(rdram, ctx, runtime);
}

void entry_1b1688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1688 inside entry_1b1640 (0x1b1640 - 0x1b1698)
    ctx->pc = 0x1b1688;
    entry_1b1640(rdram, ctx, runtime);
}

void entry_1b168c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b168c inside entry_1b1640 (0x1b1640 - 0x1b1698)
    ctx->pc = 0x1b168c;
    entry_1b1640(rdram, ctx, runtime);
}

void entry_1b16e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b16e0 inside OnPrsenAlarmTriggered__FP5PRSEN (0x1b1698 - 0x1b16f0)
    ctx->pc = 0x1b16e0;
    OnPrsenAlarmTriggered__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b16f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b16f8 inside entry_1b16f0 (0x1b16f0 - 0x1b1704)
    ctx->pc = 0x1b16f8;
    entry_1b16f0(rdram, ctx, runtime);
}

void entry_1b1708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1708 inside entry_1b1704 (0x1b1704 - 0x1b1710)
    ctx->pc = 0x1b1708;
    entry_1b1704(rdram, ctx, runtime);
}

void entry_1b1754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1754 inside SetPrsenSensors__FP5PRSEN7SENSORS (0x1b1710 - 0x1b1774)
    ctx->pc = 0x1b1754;
    SetPrsenSensors__FP5PRSEN7SENSORS(rdram, ctx, runtime);
}

void entry_1b1768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1768 inside SetPrsenSensors__FP5PRSEN7SENSORS (0x1b1710 - 0x1b1774)
    ctx->pc = 0x1b1768;
    SetPrsenSensors__FP5PRSEN7SENSORS(rdram, ctx, runtime);
}

void entry_1b1780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1780 inside entry_1b1774 (0x1b1774 - 0x1b17ec)
    ctx->pc = 0x1b1780;
    entry_1b1774(rdram, ctx, runtime);
}

void entry_1b1788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1788 inside entry_1b1774 (0x1b1774 - 0x1b17ec)
    ctx->pc = 0x1b1788;
    entry_1b1774(rdram, ctx, runtime);
}

void entry_1b1790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1790 inside entry_1b1774 (0x1b1774 - 0x1b17ec)
    ctx->pc = 0x1b1790;
    entry_1b1774(rdram, ctx, runtime);
}

void entry_1b1840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1840 inside entry_1b183c (0x1b183c - 0x1b1848)
    ctx->pc = 0x1b1840;
    entry_1b183c(rdram, ctx, runtime);
}

void entry_1b1864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1864 inside entry_1b1848 (0x1b1848 - 0x1b1898)
    ctx->pc = 0x1b1864;
    entry_1b1848(rdram, ctx, runtime);
}

void entry_1b1880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1880 inside entry_1b1848 (0x1b1848 - 0x1b1898)
    ctx->pc = 0x1b1880;
    entry_1b1848(rdram, ctx, runtime);
}

void entry_1b1884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1884 inside entry_1b1848 (0x1b1848 - 0x1b1898)
    ctx->pc = 0x1b1884;
    entry_1b1848(rdram, ctx, runtime);
}

void entry_1b19b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b19b4 inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b19b4;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b19cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b19cc inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b19cc;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b19d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b19d0 inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b19d0;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b19fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b19fc inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b19fc;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1a14 inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b1a14;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1a28 inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b1a28;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1a4c inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b1a4c;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1a6c inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b1a6c;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1aa8 inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b1aa8;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1aac inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b1aac;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1ab0 inside UpdatePrsenLoopShader__FP5PRSEN (0x1b1898 - 0x1b1ab8)
    ctx->pc = 0x1b1ab0;
    UpdatePrsenLoopShader__FP5PRSEN(rdram, ctx, runtime);
}

void entry_1b1b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1b90 inside entry_1b1b8c (0x1b1b8c - 0x1b1bdc)
    ctx->pc = 0x1b1b90;
    entry_1b1b8c(rdram, ctx, runtime);
}

void entry_1b1be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1be0 inside entry_1b1bdc (0x1b1bdc - 0x1b1bf0)
    ctx->pc = 0x1b1be0;
    entry_1b1bdc(rdram, ctx, runtime);
}

void entry_1b1c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1c4c inside entry_1b1c20 (0x1b1c20 - 0x1b1cf8)
    ctx->pc = 0x1b1c4c;
    entry_1b1c20(rdram, ctx, runtime);
}

void entry_1b1cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1cbc inside entry_1b1c20 (0x1b1c20 - 0x1b1cf8)
    ctx->pc = 0x1b1cbc;
    entry_1b1c20(rdram, ctx, runtime);
}

void entry_1b1d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1d64 inside FShadowRadiusSet__FP6SHADOW (0x1b1d38 - 0x1b1d70)
    ctx->pc = 0x1b1d64;
    FShadowRadiusSet__FP6SHADOW(rdram, ctx, runtime);
}

void entry_1b1d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1d94 inside SetShadowNearRadius__FP6SHADOWf (0x1b1d70 - 0x1b1d9c)
    ctx->pc = 0x1b1d94;
    SetShadowNearRadius__FP6SHADOWf(rdram, ctx, runtime);
}

void entry_1b1dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1dcc inside SetShadowFarRadius__FP6SHADOWf (0x1b1da8 - 0x1b1dd4)
    ctx->pc = 0x1b1dcc;
    SetShadowFarRadius__FP6SHADOWf(rdram, ctx, runtime);
}

void entry_1b1e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1e88 inside entry_1b1e84 (0x1b1e84 - 0x1b1ea0)
    ctx->pc = 0x1b1e88;
    entry_1b1e84(rdram, ctx, runtime);
}

void entry_1b1eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1eac inside entry_1b1ea8 (0x1b1ea8 - 0x1b1ec8)
    ctx->pc = 0x1b1eac;
    entry_1b1ea8(rdram, ctx, runtime);
}

void entry_1b1f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1f70 inside entry_1b1f6c (0x1b1f6c - 0x1b1f88)
    ctx->pc = 0x1b1f70;
    entry_1b1f6c(rdram, ctx, runtime);
}

void entry_1b1f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b1f94 inside entry_1b1f90 (0x1b1f90 - 0x1b1fb0)
    ctx->pc = 0x1b1f94;
    entry_1b1f90(rdram, ctx, runtime);
}

void entry_1b20cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b20cc inside FShadowValid__FP6SHADOWi (0x1b2090 - 0x1b2118)
    ctx->pc = 0x1b20cc;
    FShadowValid__FP6SHADOWi(rdram, ctx, runtime);
}

void entry_1b20d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b20d0 inside FShadowValid__FP6SHADOWi (0x1b2090 - 0x1b2118)
    ctx->pc = 0x1b20d0;
    FShadowValid__FP6SHADOWi(rdram, ctx, runtime);
}

void entry_1b20f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b20f0 inside FShadowValid__FP6SHADOWi (0x1b2090 - 0x1b2118)
    ctx->pc = 0x1b20f0;
    FShadowValid__FP6SHADOWi(rdram, ctx, runtime);
}

void entry_1b210c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b210c inside FShadowValid__FP6SHADOWi (0x1b2090 - 0x1b2118)
    ctx->pc = 0x1b210c;
    FShadowValid__FP6SHADOWi(rdram, ctx, runtime);
}

void entry_1b2138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2138 inside FFilterFastShadows__FPvP2SO (0x1b2118 - 0x1b2140)
    ctx->pc = 0x1b2138;
    FFilterFastShadows__FPvP2SO(rdram, ctx, runtime);
}

void entry_1b21f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b21f0 inside entry_1b21a0 (0x1b21a0 - 0x1b2218)
    ctx->pc = 0x1b21f0;
    entry_1b21a0(rdram, ctx, runtime);
}

void entry_1b2268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2268 inside entry_1b2218 (0x1b2218 - 0x1b2290)
    ctx->pc = 0x1b2268;
    entry_1b2218(rdram, ctx, runtime);
}

void entry_1b22dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b22dc inside entry_1b2290 (0x1b2290 - 0x1b2328)
    ctx->pc = 0x1b22dc;
    entry_1b2290(rdram, ctx, runtime);
}

void entry_1b22fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b22fc inside entry_1b2290 (0x1b2290 - 0x1b2328)
    ctx->pc = 0x1b22fc;
    entry_1b2290(rdram, ctx, runtime);
}

void entry_1b230c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b230c inside entry_1b2290 (0x1b2290 - 0x1b2328)
    ctx->pc = 0x1b230c;
    entry_1b2290(rdram, ctx, runtime);
}

void entry_1b2310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2310 inside entry_1b2290 (0x1b2290 - 0x1b2328)
    ctx->pc = 0x1b2310;
    entry_1b2290(rdram, ctx, runtime);
}

void entry_1b2320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2320 inside entry_1b2290 (0x1b2290 - 0x1b2328)
    ctx->pc = 0x1b2320;
    entry_1b2290(rdram, ctx, runtime);
}

void entry_1b23ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b23ac inside RebuildShadowVifs__FP6SHADOW (0x1b2358 - 0x1b23c0)
    ctx->pc = 0x1b23ac;
    RebuildShadowVifs__FP6SHADOW(rdram, ctx, runtime);
}

void entry_1b23b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b23b0 inside RebuildShadowVifs__FP6SHADOW (0x1b2358 - 0x1b23c0)
    ctx->pc = 0x1b23b0;
    RebuildShadowVifs__FP6SHADOW(rdram, ctx, runtime);
}

void entry_1b2504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2504 inside entry_1b24a4 (0x1b24a4 - 0x1b257c)
    ctx->pc = 0x1b2504;
    entry_1b24a4(rdram, ctx, runtime);
}

void entry_1b25a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b25a0 inside entry_1b257c (0x1b257c - 0x1b25dc)
    ctx->pc = 0x1b25a0;
    entry_1b257c(rdram, ctx, runtime);
}

void entry_1b25b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b25b0 inside entry_1b257c (0x1b257c - 0x1b25dc)
    ctx->pc = 0x1b25b0;
    entry_1b257c(rdram, ctx, runtime);
}

void entry_1b25c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b25c8 inside entry_1b257c (0x1b257c - 0x1b25dc)
    ctx->pc = 0x1b25c8;
    entry_1b257c(rdram, ctx, runtime);
}

void entry_1b25f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b25f0 inside entry_1b25ec (0x1b25ec - 0x1b2640)
    ctx->pc = 0x1b25f0;
    entry_1b25ec(rdram, ctx, runtime);
}

void entry_1b2620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2620 inside entry_1b25ec (0x1b25ec - 0x1b2640)
    ctx->pc = 0x1b2620;
    entry_1b25ec(rdram, ctx, runtime);
}

void entry_1b2624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2624 inside entry_1b25ec (0x1b25ec - 0x1b2640)
    ctx->pc = 0x1b2624;
    entry_1b25ec(rdram, ctx, runtime);
}

void entry_1b2684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2684 inside DrawShadow__FP6SHADOW (0x1b2640 - 0x1b26a4)
    ctx->pc = 0x1b2684;
    DrawShadow__FP6SHADOW(rdram, ctx, runtime);
}

void entry_1b2688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2688 inside DrawShadow__FP6SHADOW (0x1b2640 - 0x1b26a4)
    ctx->pc = 0x1b2688;
    DrawShadow__FP6SHADOW(rdram, ctx, runtime);
}

void entry_1b26b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b26b4 inside entry_1b26a4 (0x1b26a4 - 0x1b26f8)
    ctx->pc = 0x1b26b4;
    entry_1b26a4(rdram, ctx, runtime);
}

void entry_1b26e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b26e4 inside entry_1b26a4 (0x1b26a4 - 0x1b26f8)
    ctx->pc = 0x1b26e4;
    entry_1b26a4(rdram, ctx, runtime);
}

void entry_1b26e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b26e8 inside entry_1b26a4 (0x1b26a4 - 0x1b26f8)
    ctx->pc = 0x1b26e8;
    entry_1b26a4(rdram, ctx, runtime);
}

void entry_1b2730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2730 inside FShadowIntersectsSphere__FP6SHADOWP6VECTORf (0x1b26f8 - 0x1b2790)
    ctx->pc = 0x1b2730;
    FShadowIntersectsSphere__FP6SHADOWP6VECTORf(rdram, ctx, runtime);
}

void entry_1b2734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2734 inside FShadowIntersectsSphere__FP6SHADOWP6VECTORf (0x1b26f8 - 0x1b2790)
    ctx->pc = 0x1b2734;
    FShadowIntersectsSphere__FP6SHADOWP6VECTORf(rdram, ctx, runtime);
}

void entry_1b273c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b273c inside FShadowIntersectsSphere__FP6SHADOWP6VECTORf (0x1b26f8 - 0x1b2790)
    ctx->pc = 0x1b273c;
    FShadowIntersectsSphere__FP6SHADOWP6VECTORf(rdram, ctx, runtime);
}

void entry_1b2744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2744 inside FShadowIntersectsSphere__FP6SHADOWP6VECTORf (0x1b26f8 - 0x1b2790)
    ctx->pc = 0x1b2744;
    FShadowIntersectsSphere__FP6SHADOWP6VECTORf(rdram, ctx, runtime);
}

void entry_1b2784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2784 inside FShadowIntersectsSphere__FP6SHADOWP6VECTORf (0x1b26f8 - 0x1b2790)
    ctx->pc = 0x1b2784;
    FShadowIntersectsSphere__FP6SHADOWP6VECTORf(rdram, ctx, runtime);
}

void entry_1b27d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b27d8 inside FindSwShadows__FP2SWP6VECTORfiPiPP6SHADOW (0x1b2790 - 0x1b27f0)
    ctx->pc = 0x1b27d8;
    FindSwShadows__FP2SWP6VECTORfiPiPP6SHADOW(rdram, ctx, runtime);
}

void entry_1b27dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b27dc inside FindSwShadows__FP2SWP6VECTORfiPiPP6SHADOW (0x1b2790 - 0x1b27f0)
    ctx->pc = 0x1b27dc;
    FindSwShadows__FP2SWP6VECTORfiPiPP6SHADOW(rdram, ctx, runtime);
}

void entry_1b2810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2810 inside entry_1b27f0 (0x1b27f0 - 0x1b2840)
    ctx->pc = 0x1b2810;
    entry_1b27f0(rdram, ctx, runtime);
}

void entry_1b2814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2814 inside entry_1b27f0 (0x1b27f0 - 0x1b2840)
    ctx->pc = 0x1b2814;
    entry_1b27f0(rdram, ctx, runtime);
}

void entry_1b288c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b288c inside entry_1b2888 (0x1b2888 - 0x1b2894)
    ctx->pc = 0x1b288c;
    entry_1b2888(rdram, ctx, runtime);
}

void entry_1b28e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b28e0 inside entry_1b28d8 (0x1b28d8 - 0x1b291c)
    ctx->pc = 0x1b28e0;
    entry_1b28d8(rdram, ctx, runtime);
}

void entry_1b2908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2908 inside entry_1b28d8 (0x1b28d8 - 0x1b291c)
    ctx->pc = 0x1b2908;
    entry_1b28d8(rdram, ctx, runtime);
}

void entry_1b2924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2924 inside entry_1b291c (0x1b291c - 0x1b2968)
    ctx->pc = 0x1b2924;
    entry_1b291c(rdram, ctx, runtime);
}

void entry_1b2950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2950 inside entry_1b291c (0x1b291c - 0x1b2968)
    ctx->pc = 0x1b2950;
    entry_1b291c(rdram, ctx, runtime);
}

void entry_1b29d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b29d4 inside Tex0FromTexIframeCtk__FP3TEXi3CTK (0x1b2988 - 0x1b29e0)
    ctx->pc = 0x1b29d4;
    Tex0FromTexIframeCtk__FP3TEXi3CTK(rdram, ctx, runtime);
}

void entry_1b2af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2af0 inside entry_1b2ad0 (0x1b2ad0 - 0x1b2b2c)
    ctx->pc = 0x1b2af0;
    entry_1b2ad0(rdram, ctx, runtime);
}

void entry_1b2b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2b14 inside entry_1b2ad0 (0x1b2ad0 - 0x1b2b2c)
    ctx->pc = 0x1b2b14;
    entry_1b2ad0(rdram, ctx, runtime);
}

void entry_1b2c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2c20 inside entry_1b2bf8 (0x1b2bf8 - 0x1b2c30)
    ctx->pc = 0x1b2c20;
    entry_1b2bf8(rdram, ctx, runtime);
}

void entry_1b2c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2c50 inside entry_1b2c30 (0x1b2c30 - 0x1b2ca8)
    ctx->pc = 0x1b2c50;
    entry_1b2c30(rdram, ctx, runtime);
}

void entry_1b2c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2c64 inside entry_1b2c30 (0x1b2c30 - 0x1b2ca8)
    ctx->pc = 0x1b2c64;
    entry_1b2c30(rdram, ctx, runtime);
}

void entry_1b2c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2c7c inside entry_1b2c30 (0x1b2c30 - 0x1b2ca8)
    ctx->pc = 0x1b2c7c;
    entry_1b2c30(rdram, ctx, runtime);
}

void entry_1b2d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2d70 inside entry_1b2d44 (0x1b2d44 - 0x1b2d80)
    ctx->pc = 0x1b2d70;
    entry_1b2d44(rdram, ctx, runtime);
}

void entry_1b2da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2da0 inside entry_1b2d80 (0x1b2d80 - 0x1b2df8)
    ctx->pc = 0x1b2da0;
    entry_1b2d80(rdram, ctx, runtime);
}

void entry_1b2db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2db4 inside entry_1b2d80 (0x1b2d80 - 0x1b2df8)
    ctx->pc = 0x1b2db4;
    entry_1b2d80(rdram, ctx, runtime);
}

void entry_1b2dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2dcc inside entry_1b2d80 (0x1b2d80 - 0x1b2df8)
    ctx->pc = 0x1b2dcc;
    entry_1b2d80(rdram, ctx, runtime);
}

void entry_1b2e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2e60 inside entry_1b2e44 (0x1b2e44 - 0x1b2ea8)
    ctx->pc = 0x1b2e60;
    entry_1b2e44(rdram, ctx, runtime);
}

void entry_1b2e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2e7c inside entry_1b2e44 (0x1b2e44 - 0x1b2ea8)
    ctx->pc = 0x1b2e7c;
    entry_1b2e44(rdram, ctx, runtime);
}

void entry_1b2e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2e98 inside entry_1b2e44 (0x1b2e44 - 0x1b2ea8)
    ctx->pc = 0x1b2e98;
    entry_1b2e44(rdram, ctx, runtime);
}

void entry_1b2ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2ecc inside entry_1b2ea8 (0x1b2ea8 - 0x1b2ed4)
    ctx->pc = 0x1b2ecc;
    entry_1b2ea8(rdram, ctx, runtime);
}

void entry_1b2f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2f60 inside entry_1b2f4c (0x1b2f4c - 0x1b2f68)
    ctx->pc = 0x1b2f60;
    entry_1b2f4c(rdram, ctx, runtime);
}

void entry_1b2f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2f98 inside entry_1b2f68 (0x1b2f68 - 0x1b2fb0)
    ctx->pc = 0x1b2f98;
    entry_1b2f68(rdram, ctx, runtime);
}

void entry_1b2fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2fc8 inside entry_1b2fb0 (0x1b2fb0 - 0x1b2fd0)
    ctx->pc = 0x1b2fc8;
    entry_1b2fb0(rdram, ctx, runtime);
}

void entry_1b2fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b2fec inside entry_1b2fd0 (0x1b2fd0 - 0x1b3040)
    ctx->pc = 0x1b2fec;
    entry_1b2fd0(rdram, ctx, runtime);
}

void entry_1b3008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3008 inside entry_1b2fd0 (0x1b2fd0 - 0x1b3040)
    ctx->pc = 0x1b3008;
    entry_1b2fd0(rdram, ctx, runtime);
}

void entry_1b301c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b301c inside entry_1b2fd0 (0x1b2fd0 - 0x1b3040)
    ctx->pc = 0x1b301c;
    entry_1b2fd0(rdram, ctx, runtime);
}

void entry_1b30e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b30e0 inside entry_1b30c8 (0x1b30c8 - 0x1b30fc)
    ctx->pc = 0x1b30e0;
    entry_1b30c8(rdram, ctx, runtime);
}

void entry_1b311c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b311c inside entry_1b3104 (0x1b3104 - 0x1b3134)
    ctx->pc = 0x1b311c;
    entry_1b3104(rdram, ctx, runtime);
}

void entry_1b3148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3148 inside entry_1b3134 (0x1b3134 - 0x1b3160)
    ctx->pc = 0x1b3148;
    entry_1b3134(rdram, ctx, runtime);
}

void entry_1b3174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3174 inside entry_1b3160 (0x1b3160 - 0x1b31cc)
    ctx->pc = 0x1b3174;
    entry_1b3160(rdram, ctx, runtime);
}

void entry_1b31bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b31bc inside entry_1b3160 (0x1b3160 - 0x1b31cc)
    ctx->pc = 0x1b31bc;
    entry_1b3160(rdram, ctx, runtime);
}

void entry_1b31c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b31c0 inside entry_1b3160 (0x1b3160 - 0x1b31cc)
    ctx->pc = 0x1b31c0;
    entry_1b3160(rdram, ctx, runtime);
}

void entry_1b32ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b32ec inside entry_1b32d8 (0x1b32d8 - 0x1b32f4)
    ctx->pc = 0x1b32ec;
    entry_1b32d8(rdram, ctx, runtime);
}

void entry_1b3320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3320 inside entry_1b32f4 (0x1b32f4 - 0x1b3328)
    ctx->pc = 0x1b3320;
    entry_1b32f4(rdram, ctx, runtime);
}

void entry_1b332c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b332c inside entry_1b3328 (0x1b3328 - 0x1b334c)
    ctx->pc = 0x1b332c;
    entry_1b3328(rdram, ctx, runtime);
}

void entry_1b3340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3340 inside entry_1b3328 (0x1b3328 - 0x1b334c)
    ctx->pc = 0x1b3340;
    entry_1b3328(rdram, ctx, runtime);
}

void entry_1b3360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3360 inside entry_1b334c (0x1b334c - 0x1b3380)
    ctx->pc = 0x1b3360;
    entry_1b334c(rdram, ctx, runtime);
}

void entry_1b3394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3394 inside entry_1b3380 (0x1b3380 - 0x1b33a4)
    ctx->pc = 0x1b3394;
    entry_1b3380(rdram, ctx, runtime);
}

void entry_1b33f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b33f0 inside entry_1b33e8 (0x1b33e8 - 0x1b3400)
    ctx->pc = 0x1b33f0;
    entry_1b33e8(rdram, ctx, runtime);
}

void entry_1b34f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b34f4 inside entry_1b34e4 (0x1b34e4 - 0x1b3510)
    ctx->pc = 0x1b34f4;
    entry_1b34e4(rdram, ctx, runtime);
}

void entry_1b3558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3558 inside FillShaders__Fi (0x1b3510 - 0x1b35b8)
    ctx->pc = 0x1b3558;
    FillShaders__Fi(rdram, ctx, runtime);
}

void entry_1b3588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3588 inside FillShaders__Fi (0x1b3510 - 0x1b35b8)
    ctx->pc = 0x1b3588;
    FillShaders__Fi(rdram, ctx, runtime);
}

void entry_1b3640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3640 inside entry_1b3638 (0x1b3638 - 0x1b36a0)
    ctx->pc = 0x1b3640;
    entry_1b3638(rdram, ctx, runtime);
}

void entry_1b3660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3660 inside entry_1b3638 (0x1b3638 - 0x1b36a0)
    ctx->pc = 0x1b3660;
    entry_1b3638(rdram, ctx, runtime);
}

void entry_1b368c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b368c inside entry_1b3638 (0x1b3638 - 0x1b36a0)
    ctx->pc = 0x1b368c;
    entry_1b3638(rdram, ctx, runtime);
}

void entry_1b3698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3698 inside entry_1b3638 (0x1b3638 - 0x1b36a0)
    ctx->pc = 0x1b3698;
    entry_1b3638(rdram, ctx, runtime);
}

void entry_1b36b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b36b8 inside entry_1b36b0 (0x1b36b0 - 0x1b3714)
    ctx->pc = 0x1b36b8;
    entry_1b36b0(rdram, ctx, runtime);
}

void entry_1b36f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b36f0 inside entry_1b36b0 (0x1b36b0 - 0x1b3714)
    ctx->pc = 0x1b36f0;
    entry_1b36b0(rdram, ctx, runtime);
}

void entry_1b3704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3704 inside entry_1b36b0 (0x1b36b0 - 0x1b3714)
    ctx->pc = 0x1b3704;
    entry_1b36b0(rdram, ctx, runtime);
}

void entry_1b373c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b373c inside entry_1b3734 (0x1b3734 - 0x1b378c)
    ctx->pc = 0x1b373c;
    entry_1b3734(rdram, ctx, runtime);
}

void entry_1b3768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3768 inside entry_1b3734 (0x1b3734 - 0x1b378c)
    ctx->pc = 0x1b3768;
    entry_1b3734(rdram, ctx, runtime);
}

void entry_1b377c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b377c inside entry_1b3734 (0x1b3734 - 0x1b378c)
    ctx->pc = 0x1b377c;
    entry_1b3734(rdram, ctx, runtime);
}

void entry_1b37bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b37bc inside entry_1b37b8 (0x1b37b8 - 0x1b37d8)
    ctx->pc = 0x1b37bc;
    entry_1b37b8(rdram, ctx, runtime);
}

void entry_1b38ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b38ac inside entry_1b38a4 (0x1b38a4 - 0x1b38c8)
    ctx->pc = 0x1b38ac;
    entry_1b38a4(rdram, ctx, runtime);
}

void entry_1b3920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3920 inside entry_1b391c (0x1b391c - 0x1b3928)
    ctx->pc = 0x1b3920;
    entry_1b391c(rdram, ctx, runtime);
}

void entry_1b3b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3b3c inside entry_1b3b34 (0x1b3b34 - 0x1b3b54)
    ctx->pc = 0x1b3b3c;
    entry_1b3b34(rdram, ctx, runtime);
}

void entry_1b3b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3b58 inside entry_1b3b54 (0x1b3b54 - 0x1b3b70)
    ctx->pc = 0x1b3b58;
    entry_1b3b54(rdram, ctx, runtime);
}

void entry_1b3ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3ba0 inside entry_1b3b98 (0x1b3b98 - 0x1b3bb8)
    ctx->pc = 0x1b3ba0;
    entry_1b3b98(rdram, ctx, runtime);
}

void entry_1b3bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3bbc inside entry_1b3bb8 (0x1b3bb8 - 0x1b3bd4)
    ctx->pc = 0x1b3bbc;
    entry_1b3bb8(rdram, ctx, runtime);
}

void entry_1b3c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3c4c inside entry_1b3c44 (0x1b3c44 - 0x1b3c58)
    ctx->pc = 0x1b3c4c;
    entry_1b3c44(rdram, ctx, runtime);
}

void entry_1b3c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3c5c inside entry_1b3c58 (0x1b3c58 - 0x1b3c70)
    ctx->pc = 0x1b3c5c;
    entry_1b3c58(rdram, ctx, runtime);
}

void entry_1b3d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3d10 inside entry_1b3d08 (0x1b3d08 - 0x1b3d30)
    ctx->pc = 0x1b3d10;
    entry_1b3d08(rdram, ctx, runtime);
}

void entry_1b3d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3d60 inside entry_1b3d5c (0x1b3d5c - 0x1b3d78)
    ctx->pc = 0x1b3d60;
    entry_1b3d5c(rdram, ctx, runtime);
}

void entry_1b3e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3e2c inside entry_1b3e24 (0x1b3e24 - 0x1b3e38)
    ctx->pc = 0x1b3e2c;
    entry_1b3e24(rdram, ctx, runtime);
}

void entry_1b3e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3e3c inside entry_1b3e38 (0x1b3e38 - 0x1b3e4c)
    ctx->pc = 0x1b3e3c;
    entry_1b3e38(rdram, ctx, runtime);
}

void entry_1b3f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3f00 inside entry_1b3ef8 (0x1b3ef8 - 0x1b3f0c)
    ctx->pc = 0x1b3f00;
    entry_1b3ef8(rdram, ctx, runtime);
}

void entry_1b3f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3f10 inside entry_1b3f0c (0x1b3f0c - 0x1b3f1c)
    ctx->pc = 0x1b3f10;
    entry_1b3f0c(rdram, ctx, runtime);
}

void entry_1b3f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3f34 inside entry_1b3f24 (0x1b3f24 - 0x1b3f48)
    ctx->pc = 0x1b3f34;
    entry_1b3f24(rdram, ctx, runtime);
}

void entry_1b3fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3fc4 inside entry_1b3fb8 (0x1b3fb8 - 0x1b3fcc)
    ctx->pc = 0x1b3fc4;
    entry_1b3fb8(rdram, ctx, runtime);
}

void entry_1b3fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b3fd0 inside entry_1b3fcc (0x1b3fcc - 0x1b3fe4)
    ctx->pc = 0x1b3fd0;
    entry_1b3fcc(rdram, ctx, runtime);
}

void entry_1b4078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4078 inside entry_1b4074 (0x1b4074 - 0x1b40c8)
    ctx->pc = 0x1b4078;
    entry_1b4074(rdram, ctx, runtime);
}

void entry_1b4088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4088 inside entry_1b4074 (0x1b4074 - 0x1b40c8)
    ctx->pc = 0x1b4088;
    entry_1b4074(rdram, ctx, runtime);
}

void entry_1b409c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b409c inside entry_1b4074 (0x1b4074 - 0x1b40c8)
    ctx->pc = 0x1b409c;
    entry_1b4074(rdram, ctx, runtime);
}

void entry_1b41b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b41b0 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b41b0;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b41c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b41c4 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b41c4;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b41f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b41f8 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b41f8;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b421c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b421c inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b421c;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b422c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b422c inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b422c;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4240 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b4240;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4254 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b4254;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4270 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b4270;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b428c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b428c inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b428c;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b42a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b42a4 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b42a4;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b42c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b42c0 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b42c0;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b42d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b42d8 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b42d8;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b42e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b42e0 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b42e0;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4308 inside ConvertRgbToHsv__FP6VECTORT0 (0x1b4188 - 0x1b4330)
    ctx->pc = 0x1b4308;
    ConvertRgbToHsv__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b438c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b438c inside ConvertHsvToRgb__FP6VECTORT0 (0x1b4330 - 0x1b4458)
    ctx->pc = 0x1b438c;
    ConvertHsvToRgb__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4394 inside ConvertHsvToRgb__FP6VECTORT0 (0x1b4330 - 0x1b4458)
    ctx->pc = 0x1b4394;
    ConvertHsvToRgb__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b43c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b43c8 inside ConvertHsvToRgb__FP6VECTORT0 (0x1b4330 - 0x1b4458)
    ctx->pc = 0x1b43c8;
    ConvertHsvToRgb__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4400 inside ConvertHsvToRgb__FP6VECTORT0 (0x1b4330 - 0x1b4458)
    ctx->pc = 0x1b4400;
    ConvertHsvToRgb__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4428 inside ConvertHsvToRgb__FP6VECTORT0 (0x1b4330 - 0x1b4458)
    ctx->pc = 0x1b4428;
    ConvertHsvToRgb__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4440 inside ConvertHsvToRgb__FP6VECTORT0 (0x1b4330 - 0x1b4458)
    ctx->pc = 0x1b4440;
    ConvertHsvToRgb__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1b4560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4560 inside entry_1b4458 (0x1b4458 - 0x1b4580)
    ctx->pc = 0x1b4560;
    entry_1b4458(rdram, ctx, runtime);
}

void entry_1b4564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4564 inside entry_1b4458 (0x1b4458 - 0x1b4580)
    ctx->pc = 0x1b4564;
    entry_1b4458(rdram, ctx, runtime);
}

void entry_1b469c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b469c inside PshdFindShader__F3OID (0x1b4688 - 0x1b46e0)
    ctx->pc = 0x1b469c;
    PshdFindShader__F3OID(rdram, ctx, runtime);
}

void entry_1b46a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b46a4 inside PshdFindShader__F3OID (0x1b4688 - 0x1b46e0)
    ctx->pc = 0x1b46a4;
    PshdFindShader__F3OID(rdram, ctx, runtime);
}

void entry_1b46c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b46c0 inside PshdFindShader__F3OID (0x1b4688 - 0x1b46e0)
    ctx->pc = 0x1b46c0;
    PshdFindShader__F3OID(rdram, ctx, runtime);
}

void entry_1b46d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b46d8 inside PshdFindShader__F3OID (0x1b4688 - 0x1b46e0)
    ctx->pc = 0x1b46d8;
    PshdFindShader__F3OID(rdram, ctx, runtime);
}

void entry_1b4700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4700 inside SetSaiIframe__FP3SAIi (0x1b46e0 - 0x1b4750)
    ctx->pc = 0x1b4700;
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime);
}

void entry_1b4708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4708 inside SetSaiIframe__FP3SAIi (0x1b46e0 - 0x1b4750)
    ctx->pc = 0x1b4708;
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime);
}

void entry_1b4738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4738 inside SetSaiIframe__FP3SAIi (0x1b46e0 - 0x1b4750)
    ctx->pc = 0x1b4738;
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime);
}

void entry_1b4748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4748 inside SetSaiIframe__FP3SAIi (0x1b46e0 - 0x1b4750)
    ctx->pc = 0x1b4748;
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime);
}

void entry_1b4784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4784 inside SetSaiDuDv__FP3SAIff (0x1b4750 - 0x1b47c0)
    ctx->pc = 0x1b4784;
    SetSaiDuDv__FP3SAIff(rdram, ctx, runtime);
}

void entry_1b47a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b47a8 inside SetSaiDuDv__FP3SAIff (0x1b4750 - 0x1b47c0)
    ctx->pc = 0x1b47a8;
    SetSaiDuDv__FP3SAIff(rdram, ctx, runtime);
}

void entry_1b47b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b47b8 inside SetSaiDuDv__FP3SAIff (0x1b4750 - 0x1b47c0)
    ctx->pc = 0x1b47b8;
    SetSaiDuDv__FP3SAIff(rdram, ctx, runtime);
}

void entry_1b47e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b47e8 inside PropagateSais__Fv (0x1b47c0 - 0x1b4830)
    ctx->pc = 0x1b47e8;
    PropagateSais__Fv(rdram, ctx, runtime);
}

void entry_1b47f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b47f8 inside PropagateSais__Fv (0x1b47c0 - 0x1b4830)
    ctx->pc = 0x1b47f8;
    PropagateSais__Fv(rdram, ctx, runtime);
}

void entry_1b4828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4828 inside PropagateSais__Fv (0x1b47c0 - 0x1b4830)
    ctx->pc = 0x1b4828;
    PropagateSais__Fv(rdram, ctx, runtime);
}

void entry_1b4840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4840 inside entry_1b4830 (0x1b4830 - 0x1b4878)
    ctx->pc = 0x1b4840;
    entry_1b4830(rdram, ctx, runtime);
}

void entry_1b4850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4850 inside entry_1b4830 (0x1b4830 - 0x1b4878)
    ctx->pc = 0x1b4850;
    entry_1b4830(rdram, ctx, runtime);
}

void entry_1b48b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b48b8 inside UpdateShaders__Ff (0x1b4878 - 0x1b48cc)
    ctx->pc = 0x1b48b8;
    UpdateShaders__Ff(rdram, ctx, runtime);
}

void entry_1b48f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b48f0 inside entry_1b48ec (0x1b48ec - 0x1b4920)
    ctx->pc = 0x1b48f0;
    entry_1b48ec(rdram, ctx, runtime);
}

void entry_1b4900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4900 inside entry_1b48ec (0x1b48ec - 0x1b4920)
    ctx->pc = 0x1b4900;
    entry_1b48ec(rdram, ctx, runtime);
}

void entry_1b4978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4978 inside CbFromSaak__F4SAAK (0x1b4920 - 0x1b4980)
    ctx->pc = 0x1b4978;
    CbFromSaak__F4SAAK(rdram, ctx, runtime);
}

void entry_1b4a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4a08 inside PvtsaaFromSaak__F4SAAK (0x1b4980 - 0x1b4a10)
    ctx->pc = 0x1b4a08;
    PvtsaaFromSaak__F4SAAK(rdram, ctx, runtime);
}

void entry_1b4a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4a84 inside entry_1b4a80 (0x1b4a80 - 0x1b4aa0)
    ctx->pc = 0x1b4a84;
    entry_1b4a80(rdram, ctx, runtime);
}

void entry_1b4ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4ac4 inside InitSaa__FP3SAAP4SAAF (0x1b4aa0 - 0x1b4ad0)
    ctx->pc = 0x1b4ac4;
    InitSaa__FP3SAAP4SAAF(rdram, ctx, runtime);
}

void entry_1b4afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4afc inside entry_1b4af4 (0x1b4af4 - 0x1b4b08)
    ctx->pc = 0x1b4afc;
    entry_1b4af4(rdram, ctx, runtime);
}

void entry_1b4b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4b2c inside FUpdatableSaa__FP3SAA (0x1b4b08 - 0x1b4b38)
    ctx->pc = 0x1b4b2c;
    FUpdatableSaa__FP3SAA(rdram, ctx, runtime);
}

void entry_1b4b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4b60 inside PsaiFromSaaShd__FP3SAAP3SHD (0x1b4b48 - 0x1b4b68)
    ctx->pc = 0x1b4b60;
    PsaiFromSaaShd__FP3SAAP3SHD(rdram, ctx, runtime);
}

void entry_1b4c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4c20 inside entry_1b4c14 (0x1b4c14 - 0x1b4c30)
    ctx->pc = 0x1b4c20;
    entry_1b4c14(rdram, ctx, runtime);
}

void entry_1b4c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4c80 inside UpdateLoop__FP4LOOPf (0x1b4c30 - 0x1b4cb4)
    ctx->pc = 0x1b4c80;
    UpdateLoop__FP4LOOPf(rdram, ctx, runtime);
}

void entry_1b4ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4ce0 inside entry_1b4cd4 (0x1b4cd4 - 0x1b4cf0)
    ctx->pc = 0x1b4ce0;
    entry_1b4cd4(rdram, ctx, runtime);
}

void entry_1b4d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4d08 inside entry_1b4d04 (0x1b4d04 - 0x1b4d18)
    ctx->pc = 0x1b4d08;
    entry_1b4d04(rdram, ctx, runtime);
}

void entry_1b4d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4d0c inside entry_1b4d04 (0x1b4d04 - 0x1b4d18)
    ctx->pc = 0x1b4d0c;
    entry_1b4d04(rdram, ctx, runtime);
}

void entry_1b4e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4e08 inside entry_1b4dfc (0x1b4dfc - 0x1b4e18)
    ctx->pc = 0x1b4e08;
    entry_1b4dfc(rdram, ctx, runtime);
}

void entry_1b4e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4e68 inside UpdatePingpong__FP8PINGPONGf (0x1b4e18 - 0x1b4ec4)
    ctx->pc = 0x1b4e68;
    UpdatePingpong__FP8PINGPONGf(rdram, ctx, runtime);
}

void entry_1b4ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4ea4 inside UpdatePingpong__FP8PINGPONGf (0x1b4e18 - 0x1b4ec4)
    ctx->pc = 0x1b4ea4;
    UpdatePingpong__FP8PINGPONGf(rdram, ctx, runtime);
}

void entry_1b4ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4ef8 inside entry_1b4eec (0x1b4eec - 0x1b4f08)
    ctx->pc = 0x1b4ef8;
    entry_1b4eec(rdram, ctx, runtime);
}

void entry_1b4f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4f0c inside entry_1b4f08 (0x1b4f08 - 0x1b4f18)
    ctx->pc = 0x1b4f0c;
    entry_1b4f08(rdram, ctx, runtime);
}

void entry_1b4f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4f10 inside entry_1b4f08 (0x1b4f08 - 0x1b4f18)
    ctx->pc = 0x1b4f10;
    entry_1b4f08(rdram, ctx, runtime);
}

void entry_1b4f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4f54 inside UCompletePingpong__FP8PINGPONG (0x1b4f18 - 0x1b4f80)
    ctx->pc = 0x1b4f54;
    UCompletePingpong__FP8PINGPONG(rdram, ctx, runtime);
}

void entry_1b4f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b4f58 inside UCompletePingpong__FP8PINGPONG (0x1b4f18 - 0x1b4f80)
    ctx->pc = 0x1b4f58;
    UCompletePingpong__FP8PINGPONG(rdram, ctx, runtime);
}

void entry_1b500c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b500c inside UpdateShuffle__FP7SHUFFLEf (0x1b4fc0 - 0x1b5014)
    ctx->pc = 0x1b500c;
    UpdateShuffle__FP7SHUFFLEf(rdram, ctx, runtime);
}

void entry_1b5034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5034 inside entry_1b5014 (0x1b5014 - 0x1b5040)
    ctx->pc = 0x1b5034;
    entry_1b5014(rdram, ctx, runtime);
}

void entry_1b5054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5054 inside entry_1b504c (0x1b504c - 0x1b5060)
    ctx->pc = 0x1b5054;
    entry_1b504c(rdram, ctx, runtime);
}

void entry_1b5058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5058 inside entry_1b504c (0x1b504c - 0x1b5060)
    ctx->pc = 0x1b5058;
    entry_1b504c(rdram, ctx, runtime);
}

void entry_1b50a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b50a0 inside entry_1b507c (0x1b507c - 0x1b50ec)
    ctx->pc = 0x1b50a0;
    entry_1b507c(rdram, ctx, runtime);
}

void entry_1b50b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b50b4 inside entry_1b507c (0x1b507c - 0x1b50ec)
    ctx->pc = 0x1b50b4;
    entry_1b507c(rdram, ctx, runtime);
}

void entry_1b50f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b50f0 inside entry_1b50ec (0x1b50ec - 0x1b5108)
    ctx->pc = 0x1b50f0;
    entry_1b50ec(rdram, ctx, runtime);
}

void entry_1b5150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5150 inside entry_1b511c (0x1b511c - 0x1b5160)
    ctx->pc = 0x1b5150;
    entry_1b511c(rdram, ctx, runtime);
}

void entry_1b5154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5154 inside entry_1b511c (0x1b511c - 0x1b5160)
    ctx->pc = 0x1b5154;
    entry_1b511c(rdram, ctx, runtime);
}

void entry_1b51bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b51bc inside NotifyHologramRender__FP8HOLOGRAMP3ALOP3RPL (0x1b5160 - 0x1b51c8)
    ctx->pc = 0x1b51bc;
    NotifyHologramRender__FP8HOLOGRAMP3ALOP3RPL(rdram, ctx, runtime);
}

void entry_1b51f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b51f4 inside entry_1b51f0 (0x1b51f0 - 0x1b5200)
    ctx->pc = 0x1b51f4;
    entry_1b51f0(rdram, ctx, runtime);
}

void entry_1b51f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b51f8 inside entry_1b51f0 (0x1b51f0 - 0x1b5200)
    ctx->pc = 0x1b51f8;
    entry_1b51f0(rdram, ctx, runtime);
}

void entry_1b5338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5338 inside UCompleteScroller__FP8SCROLLER (0x1b5308 - 0x1b5388)
    ctx->pc = 0x1b5338;
    UCompleteScroller__FP8SCROLLER(rdram, ctx, runtime);
}

void entry_1b5340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5340 inside UCompleteScroller__FP8SCROLLER (0x1b5308 - 0x1b5388)
    ctx->pc = 0x1b5340;
    UCompleteScroller__FP8SCROLLER(rdram, ctx, runtime);
}

void entry_1b5374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5374 inside UCompleteScroller__FP8SCROLLER (0x1b5308 - 0x1b5388)
    ctx->pc = 0x1b5374;
    UCompleteScroller__FP8SCROLLER(rdram, ctx, runtime);
}

void entry_1b5380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5380 inside UCompleteScroller__FP8SCROLLER (0x1b5308 - 0x1b5388)
    ctx->pc = 0x1b5380;
    UCompleteScroller__FP8SCROLLER(rdram, ctx, runtime);
}

void entry_1b56a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b56a8 inside entry_1b5694 (0x1b5694 - 0x1b56e4)
    ctx->pc = 0x1b56a8;
    entry_1b5694(rdram, ctx, runtime);
}

void entry_1b56c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b56c0 inside entry_1b5694 (0x1b5694 - 0x1b56e4)
    ctx->pc = 0x1b56c0;
    entry_1b5694(rdram, ctx, runtime);
}

void entry_1b56d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b56d0 inside entry_1b5694 (0x1b5694 - 0x1b56e4)
    ctx->pc = 0x1b56d0;
    entry_1b5694(rdram, ctx, runtime);
}

void entry_1b5740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5740 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5740;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5754 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5754;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5874 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5874;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5898 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5898;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5900 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5900;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5a00 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5a00;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5a0c inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5a0c;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5a1c inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5a1c;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5a74 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5a74;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5a7c inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5a7c;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5a90 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5a90;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5a94 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5a94;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5ab4 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5ab4;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5ac8 inside entry_1b571c (0x1b571c - 0x1b5ae8)
    ctx->pc = 0x1b5ac8;
    entry_1b571c(rdram, ctx, runtime);
}

void entry_1b5b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5b14 inside entry_1b5b10 (0x1b5b10 - 0x1b5b48)
    ctx->pc = 0x1b5b14;
    entry_1b5b10(rdram, ctx, runtime);
}

void entry_1b5b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5b74 inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5b74;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5b8c inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5b8c;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5ba0 inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5ba0;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5bb4 inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5bb4;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5bc8 inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5bc8;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5bdc inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5bdc;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5bf0 inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5bf0;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5c18 inside FUN_001b5b58 (0x1b5b58 - 0x1b5c40)
    ctx->pc = 0x1b5c18;
    FUN_001b5b58(rdram, ctx, runtime);
}

void entry_1b5c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5c78 inside entry_1b5c6c (0x1b5c6c - 0x1b5c88)
    ctx->pc = 0x1b5c78;
    entry_1b5c6c(rdram, ctx, runtime);
}

void entry_1b5cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5cac inside entry_1b5c88 (0x1b5c88 - 0x1b5cd8)
    ctx->pc = 0x1b5cac;
    entry_1b5c88(rdram, ctx, runtime);
}

void entry_1b5d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5d5c inside entry_1b5d3c (0x1b5d3c - 0x1b5d70)
    ctx->pc = 0x1b5d5c;
    entry_1b5d3c(rdram, ctx, runtime);
}

void entry_1b5da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5da0 inside _InitSlotheap__FP8SLOTHEAPii (0x1b5d80 - 0x1b5dd0)
    ctx->pc = 0x1b5da0;
    fn__InitSlotheap__FP8SLOTHEAPii(rdram, ctx, runtime);
}

void entry_1b5dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5dc4 inside _InitSlotheap__FP8SLOTHEAPii (0x1b5d80 - 0x1b5dd0)
    ctx->pc = 0x1b5dc4;
    fn__InitSlotheap__FP8SLOTHEAPii(rdram, ctx, runtime);
}

void entry_1b5eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5eb4 inside PvAllocSlotheapUnsafe__FP8SLOTHEAP (0x1b5ea0 - 0x1b5ec0)
    ctx->pc = 0x1b5eb4;
    PvAllocSlotheapUnsafe__FP8SLOTHEAP(rdram, ctx, runtime);
}

void entry_1b5f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5f3c inside FreeSlotheapPv__FP8SLOTHEAPPv (0x1b5f28 - 0x1b5f48)
    ctx->pc = 0x1b5f3c;
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime);
}

void entry_1b5fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5fb0 inside entry_1b5fa0 (0x1b5fa0 - 0x1b5fc4)
    ctx->pc = 0x1b5fb0;
    entry_1b5fa0(rdram, ctx, runtime);
}

void entry_1b5fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5fe4 inside entry_1b5fd0 (0x1b5fd0 - 0x1b6014)
    ctx->pc = 0x1b5fe4;
    entry_1b5fd0(rdram, ctx, runtime);
}

void entry_1b5ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b5ff8 inside entry_1b5fd0 (0x1b5fd0 - 0x1b6014)
    ctx->pc = 0x1b5ff8;
    entry_1b5fd0(rdram, ctx, runtime);
}

void entry_1b601c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b601c inside entry_1b6014 (0x1b6014 - 0x1b6038)
    ctx->pc = 0x1b601c;
    entry_1b6014(rdram, ctx, runtime);
}

void entry_1b602c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b602c inside entry_1b6014 (0x1b6014 - 0x1b6038)
    ctx->pc = 0x1b602c;
    entry_1b6014(rdram, ctx, runtime);
}

void entry_1b6060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6060 inside entry_1b6048 (0x1b6048 - 0x1b6070)
    ctx->pc = 0x1b6060;
    entry_1b6048(rdram, ctx, runtime);
}

void entry_1b60d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b60d0 inside entry_1b60bc (0x1b60bc - 0x1b60dc)
    ctx->pc = 0x1b60d0;
    entry_1b60bc(rdram, ctx, runtime);
}

void entry_1b60f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b60f8 inside entry_1b60e8 (0x1b60e8 - 0x1b6114)
    ctx->pc = 0x1b60f8;
    entry_1b60e8(rdram, ctx, runtime);
}

void entry_1b616c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b616c inside entry_1b6168 (0x1b6168 - 0x1b61a8)
    ctx->pc = 0x1b616c;
    entry_1b6168(rdram, ctx, runtime);
}

void entry_1b617c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b617c inside entry_1b6168 (0x1b6168 - 0x1b61a8)
    ctx->pc = 0x1b617c;
    entry_1b6168(rdram, ctx, runtime);
}

void entry_1b6218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6218 inside PostSmLoadCallback__FP2SM5MSGIDPv (0x1b61f0 - 0x1b625c)
    ctx->pc = 0x1b6218;
    PostSmLoadCallback__FP2SM5MSGIDPv(rdram, ctx, runtime);
}

void entry_1b6230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6230 inside PostSmLoadCallback__FP2SM5MSGIDPv (0x1b61f0 - 0x1b625c)
    ctx->pc = 0x1b6230;
    PostSmLoadCallback__FP2SM5MSGIDPv(rdram, ctx, runtime);
}

void entry_1b6264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6264 inside entry_1b625c (0x1b625c - 0x1b627c)
    ctx->pc = 0x1b6264;
    entry_1b625c(rdram, ctx, runtime);
}

void entry_1b6268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6268 inside entry_1b625c (0x1b625c - 0x1b627c)
    ctx->pc = 0x1b6268;
    entry_1b625c(rdram, ctx, runtime);
}

void entry_1b626c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b626c inside entry_1b625c (0x1b625c - 0x1b627c)
    ctx->pc = 0x1b626c;
    entry_1b625c(rdram, ctx, runtime);
}

void entry_1b6398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6398 inside PsmaFindSm__FP2SMP3ALO (0x1b6388 - 0x1b63c0)
    ctx->pc = 0x1b6398;
    PsmaFindSm__FP2SMP3ALO(rdram, ctx, runtime);
}

void entry_1b63a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b63a8 inside PsmaFindSm__FP2SMP3ALO (0x1b6388 - 0x1b63c0)
    ctx->pc = 0x1b63a8;
    PsmaFindSm__FP2SMP3ALO(rdram, ctx, runtime);
}

void entry_1b63b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b63b0 inside PsmaFindSm__FP2SMP3ALO (0x1b6388 - 0x1b63c0)
    ctx->pc = 0x1b63b0;
    PsmaFindSm__FP2SMP3ALO(rdram, ctx, runtime);
}

void entry_1b63b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b63b4 inside PsmaFindSm__FP2SMP3ALO (0x1b6388 - 0x1b63c0)
    ctx->pc = 0x1b63b4;
    PsmaFindSm__FP2SMP3ALO(rdram, ctx, runtime);
}

void entry_1b63d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b63d0 inside IsmsFindSmOptional__FP2SM3OID (0x1b63c0 - 0x1b63f8)
    ctx->pc = 0x1b63d0;
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime);
}

void entry_1b63e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b63e4 inside IsmsFindSmOptional__FP2SM3OID (0x1b63c0 - 0x1b63f8)
    ctx->pc = 0x1b63e4;
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime);
}

void entry_1b63f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b63f0 inside IsmsFindSmOptional__FP2SM3OID (0x1b63c0 - 0x1b63f8)
    ctx->pc = 0x1b63f0;
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime);
}

void entry_1b6464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6464 inside entry_1b6460 (0x1b6460 - 0x1b6474)
    ctx->pc = 0x1b6464;
    entry_1b6460(rdram, ctx, runtime);
}

void entry_1b6500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6500 inside entry_1b64f8 (0x1b64f8 - 0x1b6534)
    ctx->pc = 0x1b6500;
    entry_1b64f8(rdram, ctx, runtime);
}

void entry_1b6504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6504 inside entry_1b64f8 (0x1b64f8 - 0x1b6534)
    ctx->pc = 0x1b6504;
    entry_1b64f8(rdram, ctx, runtime);
}

void entry_1b6540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6540 inside entry_1b653c (0x1b653c - 0x1b6554)
    ctx->pc = 0x1b6540;
    entry_1b653c(rdram, ctx, runtime);
}

void entry_1b6544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6544 inside entry_1b653c (0x1b653c - 0x1b6554)
    ctx->pc = 0x1b6544;
    entry_1b653c(rdram, ctx, runtime);
}

void entry_1b6558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6558 inside entry_1b6554 (0x1b6554 - 0x1b6568)
    ctx->pc = 0x1b6558;
    entry_1b6554(rdram, ctx, runtime);
}

void entry_1b6588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6588 inside GetSmaGoal__FP3SMAP3OID (0x1b6568 - 0x1b6598)
    ctx->pc = 0x1b6588;
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime);
}

void entry_1b658c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b658c inside GetSmaGoal__FP3SMAP3OID (0x1b6568 - 0x1b6598)
    ctx->pc = 0x1b658c;
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime);
}

void entry_1b65b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b65b8 inside GetSmaCur__FP3SMAP3OID (0x1b6598 - 0x1b65c8)
    ctx->pc = 0x1b65b8;
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime);
}

void entry_1b65bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b65bc inside GetSmaCur__FP3SMAP3OID (0x1b6598 - 0x1b65c8)
    ctx->pc = 0x1b65bc;
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime);
}

void entry_1b65e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b65e8 inside GetSmaNext__FP3SMAP3OID (0x1b65c8 - 0x1b65f8)
    ctx->pc = 0x1b65e8;
    GetSmaNext__FP3SMAP3OID(rdram, ctx, runtime);
}

void entry_1b65ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b65ec inside GetSmaNext__FP3SMAP3OID (0x1b65c8 - 0x1b65f8)
    ctx->pc = 0x1b65ec;
    GetSmaNext__FP3SMAP3OID(rdram, ctx, runtime);
}

void entry_1b661c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b661c inside entry_1b6618 (0x1b6618 - 0x1b6628)
    ctx->pc = 0x1b661c;
    entry_1b6618(rdram, ctx, runtime);
}

void entry_1b6668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6668 inside entry_1b6644 (0x1b6644 - 0x1b6670)
    ctx->pc = 0x1b6668;
    entry_1b6644(rdram, ctx, runtime);
}

void entry_1b6700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6700 inside entry_1b66d8 (0x1b66d8 - 0x1b671c)
    ctx->pc = 0x1b6700;
    entry_1b66d8(rdram, ctx, runtime);
}

void entry_1b6738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6738 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6738;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b675c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b675c inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b675c;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6770 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6770;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6788 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6788;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b67cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b67cc inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b67cc;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6814 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6814;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6828 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6828;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6848 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6848;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6874 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6874;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6888 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6888;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b68a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b68a4 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b68a4;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b68bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b68bc inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b68bc;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b68d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b68d0 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b68d0;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b68e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b68e4 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b68e4;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b68e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b68e8 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b68e8;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b68f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b68f8 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b68f8;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6908 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6908;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6928 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6928;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6960 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6960;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b6964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6964 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b6964;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b69a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b69a0 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b69a0;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b69a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b69a4 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b69a4;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b69b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b69b8 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b69b8;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b69c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b69c8 inside entry_1b671c (0x1b671c - 0x1b69d4)
    ctx->pc = 0x1b69c8;
    entry_1b671c(rdram, ctx, runtime);
}

void entry_1b69d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b69d8 inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b69d8;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b69f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b69f0 inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b69f0;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b6a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6a20 inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b6a20;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b6a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6a54 inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b6a54;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b6a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6a60 inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b6a60;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b6a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6a70 inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b6a70;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b6a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6a80 inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b6a80;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b6a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6a9c inside entry_1b69d4 (0x1b69d4 - 0x1b6aa8)
    ctx->pc = 0x1b6a9c;
    entry_1b69d4(rdram, ctx, runtime);
}

void entry_1b6ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6ae0 inside entry_1b6aa8 (0x1b6aa8 - 0x1b6b38)
    ctx->pc = 0x1b6ae0;
    entry_1b6aa8(rdram, ctx, runtime);
}

void entry_1b6b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6b08 inside entry_1b6aa8 (0x1b6aa8 - 0x1b6b38)
    ctx->pc = 0x1b6b08;
    entry_1b6aa8(rdram, ctx, runtime);
}

void entry_1b6b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6b0c inside entry_1b6aa8 (0x1b6aa8 - 0x1b6b38)
    ctx->pc = 0x1b6b0c;
    entry_1b6aa8(rdram, ctx, runtime);
}

void entry_1b6b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6b40 inside entry_1b6b38 (0x1b6b38 - 0x1b6b48)
    ctx->pc = 0x1b6b40;
    entry_1b6b38(rdram, ctx, runtime);
}

void entry_1b6b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6b4c inside entry_1b6b48 (0x1b6b48 - 0x1b6bac)
    ctx->pc = 0x1b6b4c;
    entry_1b6b48(rdram, ctx, runtime);
}

void entry_1b6b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6b5c inside entry_1b6b48 (0x1b6b48 - 0x1b6bac)
    ctx->pc = 0x1b6b5c;
    entry_1b6b48(rdram, ctx, runtime);
}

void entry_1b6b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6b78 inside entry_1b6b48 (0x1b6b48 - 0x1b6bac)
    ctx->pc = 0x1b6b78;
    entry_1b6b48(rdram, ctx, runtime);
}

void entry_1b6b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6b88 inside entry_1b6b48 (0x1b6b48 - 0x1b6bac)
    ctx->pc = 0x1b6b88;
    entry_1b6b48(rdram, ctx, runtime);
}

void entry_1b6be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6be4 inside entry_1b6bdc (0x1b6bdc - 0x1b6bec)
    ctx->pc = 0x1b6be4;
    entry_1b6bdc(rdram, ctx, runtime);
}

void entry_1b6bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6bfc inside entry_1b6bf4 (0x1b6bf4 - 0x1b6c10)
    ctx->pc = 0x1b6bfc;
    entry_1b6bf4(rdram, ctx, runtime);
}

void entry_1b6c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6c00 inside entry_1b6bf4 (0x1b6bf4 - 0x1b6c10)
    ctx->pc = 0x1b6c00;
    entry_1b6bf4(rdram, ctx, runtime);
}

void entry_1b6c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6c1c inside entry_1b6c18 (0x1b6c18 - 0x1b6c24)
    ctx->pc = 0x1b6c1c;
    entry_1b6c18(rdram, ctx, runtime);
}

void entry_1b6c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6c38 inside entry_1b6c34 (0x1b6c34 - 0x1b6c68)
    ctx->pc = 0x1b6c38;
    entry_1b6c34(rdram, ctx, runtime);
}

void entry_1b6ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6ce0 inside entry_1b6cdc (0x1b6cdc - 0x1b6cf0)
    ctx->pc = 0x1b6ce0;
    entry_1b6cdc(rdram, ctx, runtime);
}

void entry_1b6d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6d10 inside SkipSma__FP3SMAf (0x1b6cf0 - 0x1b6d1c)
    ctx->pc = 0x1b6d10;
    SkipSma__FP3SMAf(rdram, ctx, runtime);
}

void entry_1b6d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6d64 inside entry_1b6d60 (0x1b6d60 - 0x1b6d78)
    ctx->pc = 0x1b6d64;
    entry_1b6d60(rdram, ctx, runtime);
}

void entry_1b6dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6dc0 inside entry_1b6db0 (0x1b6db0 - 0x1b6dd4)
    ctx->pc = 0x1b6dc0;
    entry_1b6db0(rdram, ctx, runtime);
}

void entry_1b6de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6de0 inside entry_1b6dd4 (0x1b6dd4 - 0x1b6df8)
    ctx->pc = 0x1b6de0;
    entry_1b6dd4(rdram, ctx, runtime);
}

void entry_1b6e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6e58 inside NotifySmaSpliceOnEnterState__FP3SMAii (0x1b6e28 - 0x1b6ebc)
    ctx->pc = 0x1b6e58;
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime);
}

void entry_1b6e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6e60 inside NotifySmaSpliceOnEnterState__FP3SMAii (0x1b6e28 - 0x1b6ebc)
    ctx->pc = 0x1b6e60;
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime);
}

void entry_1b6e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6e84 inside NotifySmaSpliceOnEnterState__FP3SMAii (0x1b6e28 - 0x1b6ebc)
    ctx->pc = 0x1b6e84;
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime);
}

void entry_1b6e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6e8c inside NotifySmaSpliceOnEnterState__FP3SMAii (0x1b6e28 - 0x1b6ebc)
    ctx->pc = 0x1b6e8c;
    NotifySmaSpliceOnEnterState__FP3SMAii(rdram, ctx, runtime);
}

void entry_1b6f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6f18 inside entry_1b6edc (0x1b6edc - 0x1b6f50)
    ctx->pc = 0x1b6f18;
    entry_1b6edc(rdram, ctx, runtime);
}

void entry_1b6f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6f78 inside PostSmartguardLoadFlashlight__FP10SMARTGUARD (0x1b6f50 - 0x1b6f94)
    ctx->pc = 0x1b6f78;
    PostSmartguardLoadFlashlight__FP10SMARTGUARD(rdram, ctx, runtime);
}

void entry_1b6f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6f8c inside PostSmartguardLoadFlashlight__FP10SMARTGUARD (0x1b6f50 - 0x1b6f94)
    ctx->pc = 0x1b6f8c;
    PostSmartguardLoadFlashlight__FP10SMARTGUARD(rdram, ctx, runtime);
}

void entry_1b6f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b6f98 inside entry_1b6f94 (0x1b6f94 - 0x1b6fac)
    ctx->pc = 0x1b6f98;
    entry_1b6f94(rdram, ctx, runtime);
}

void entry_1b7000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7000 inside entry_1b6ff4 (0x1b6ff4 - 0x1b700c)
    ctx->pc = 0x1b7000;
    entry_1b6ff4(rdram, ctx, runtime);
}

void entry_1b701c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b701c inside entry_1b700c (0x1b700c - 0x1b702c)
    ctx->pc = 0x1b701c;
    entry_1b700c(rdram, ctx, runtime);
}

void entry_1b7038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7038 inside entry_1b702c (0x1b702c - 0x1b7040)
    ctx->pc = 0x1b7038;
    entry_1b702c(rdram, ctx, runtime);
}

void entry_1b7090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7090 inside entry_1b7088 (0x1b7088 - 0x1b70b0)
    ctx->pc = 0x1b7090;
    entry_1b7088(rdram, ctx, runtime);
}

void entry_1b7120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7120 inside FUN_001B7100 (0x1b7100 - 0x1b7128)
    ctx->pc = 0x1b7120;
    FUN_001B7100(rdram, ctx, runtime);
}

void entry_1b7170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7170 inside entry_1b7168 (0x1b7168 - 0x1b7198)
    ctx->pc = 0x1b7170;
    entry_1b7168(rdram, ctx, runtime);
}

void entry_1b7180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7180 inside entry_1b7168 (0x1b7168 - 0x1b7198)
    ctx->pc = 0x1b7180;
    entry_1b7168(rdram, ctx, runtime);
}

void entry_1b71ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b71ac inside entry_1b7198 (0x1b7198 - 0x1b71c8)
    ctx->pc = 0x1b71ac;
    entry_1b7198(rdram, ctx, runtime);
}

void entry_1b7224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7224 inside entry_1b721c (0x1b721c - 0x1b7244)
    ctx->pc = 0x1b7224;
    entry_1b721c(rdram, ctx, runtime);
}

void entry_1b722c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b722c inside entry_1b721c (0x1b721c - 0x1b7244)
    ctx->pc = 0x1b722c;
    entry_1b721c(rdram, ctx, runtime);
}

void entry_1b7238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7238 inside entry_1b721c (0x1b721c - 0x1b7244)
    ctx->pc = 0x1b7238;
    entry_1b721c(rdram, ctx, runtime);
}

void entry_1b725c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b725c inside entry_1b7244 (0x1b7244 - 0x1b7280)
    ctx->pc = 0x1b725c;
    entry_1b7244(rdram, ctx, runtime);
}

void entry_1b7260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7260 inside entry_1b7244 (0x1b7244 - 0x1b7280)
    ctx->pc = 0x1b7260;
    entry_1b7244(rdram, ctx, runtime);
}

void entry_1b733c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b733c inside entry_1b7320 (0x1b7320 - 0x1b739c)
    ctx->pc = 0x1b733c;
    entry_1b7320(rdram, ctx, runtime);
}

void entry_1b7358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7358 inside entry_1b7320 (0x1b7320 - 0x1b739c)
    ctx->pc = 0x1b7358;
    entry_1b7320(rdram, ctx, runtime);
}

void entry_1b735c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b735c inside entry_1b7320 (0x1b7320 - 0x1b739c)
    ctx->pc = 0x1b735c;
    entry_1b7320(rdram, ctx, runtime);
}

void entry_1b73a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b73a4 inside entry_1b739c (0x1b739c - 0x1b73ec)
    ctx->pc = 0x1b73a4;
    entry_1b739c(rdram, ctx, runtime);
}

void entry_1b73d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b73d0 inside entry_1b739c (0x1b739c - 0x1b73ec)
    ctx->pc = 0x1b73d0;
    entry_1b739c(rdram, ctx, runtime);
}

void entry_1b73f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b73f4 inside entry_1b73ec (0x1b73ec - 0x1b73fc)
    ctx->pc = 0x1b73f4;
    entry_1b73ec(rdram, ctx, runtime);
}

void entry_1b7400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7400 inside entry_1b73fc (0x1b73fc - 0x1b740c)
    ctx->pc = 0x1b7400;
    entry_1b73fc(rdram, ctx, runtime);
}

void entry_1b7404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7404 inside entry_1b73fc (0x1b73fc - 0x1b740c)
    ctx->pc = 0x1b7404;
    entry_1b73fc(rdram, ctx, runtime);
}

void entry_1b7444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7444 inside entry_1b740c (0x1b740c - 0x1b744c)
    ctx->pc = 0x1b7444;
    entry_1b740c(rdram, ctx, runtime);
}

void entry_1b7480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7480 inside entry_1b7474 (0x1b7474 - 0x1b74cc)
    ctx->pc = 0x1b7480;
    entry_1b7474(rdram, ctx, runtime);
}

void entry_1b74b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b74b4 inside entry_1b7474 (0x1b7474 - 0x1b74cc)
    ctx->pc = 0x1b74b4;
    entry_1b7474(rdram, ctx, runtime);
}

void entry_1b74b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b74b8 inside entry_1b7474 (0x1b7474 - 0x1b74cc)
    ctx->pc = 0x1b74b8;
    entry_1b7474(rdram, ctx, runtime);
}

void entry_1b74bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b74bc inside entry_1b7474 (0x1b7474 - 0x1b74cc)
    ctx->pc = 0x1b74bc;
    entry_1b7474(rdram, ctx, runtime);
}

void entry_1b7518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7518 inside entry_1b74e8 (0x1b74e8 - 0x1b752c)
    ctx->pc = 0x1b7518;
    entry_1b74e8(rdram, ctx, runtime);
}

void entry_1b755c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b755c inside entry_1b752c (0x1b752c - 0x1b7588)
    ctx->pc = 0x1b755c;
    entry_1b752c(rdram, ctx, runtime);
}

void entry_1b7590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7590 inside entry_1b7588 (0x1b7588 - 0x1b75b8)
    ctx->pc = 0x1b7590;
    entry_1b7588(rdram, ctx, runtime);
}

void entry_1b7594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7594 inside entry_1b7588 (0x1b7588 - 0x1b75b8)
    ctx->pc = 0x1b7594;
    entry_1b7588(rdram, ctx, runtime);
}

void entry_1b75c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b75c0 inside entry_1b75b8 (0x1b75b8 - 0x1b75c8)
    ctx->pc = 0x1b75c0;
    entry_1b75b8(rdram, ctx, runtime);
}

void entry_1b75d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b75d0 inside entry_1b75c8 (0x1b75c8 - 0x1b7608)
    ctx->pc = 0x1b75d0;
    entry_1b75c8(rdram, ctx, runtime);
}

void entry_1b75d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b75d4 inside entry_1b75c8 (0x1b75c8 - 0x1b7608)
    ctx->pc = 0x1b75d4;
    entry_1b75c8(rdram, ctx, runtime);
}

void entry_1b75d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b75d8 inside entry_1b75c8 (0x1b75c8 - 0x1b7608)
    ctx->pc = 0x1b75d8;
    entry_1b75c8(rdram, ctx, runtime);
}

void entry_1b768c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b768c inside entry_1b7664 (0x1b7664 - 0x1b7704)
    ctx->pc = 0x1b768c;
    entry_1b7664(rdram, ctx, runtime);
}

void entry_1b76b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b76b0 inside entry_1b7664 (0x1b7664 - 0x1b7704)
    ctx->pc = 0x1b76b0;
    entry_1b7664(rdram, ctx, runtime);
}

void entry_1b76b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b76b8 inside entry_1b7664 (0x1b7664 - 0x1b7704)
    ctx->pc = 0x1b76b8;
    entry_1b7664(rdram, ctx, runtime);
}

void entry_1b76e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b76e0 inside entry_1b7664 (0x1b7664 - 0x1b7704)
    ctx->pc = 0x1b76e0;
    entry_1b7664(rdram, ctx, runtime);
}

void entry_1b76fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b76fc inside entry_1b7664 (0x1b7664 - 0x1b7704)
    ctx->pc = 0x1b76fc;
    entry_1b7664(rdram, ctx, runtime);
}

void entry_1b7734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7734 inside entry_1b771c (0x1b771c - 0x1b7790)
    ctx->pc = 0x1b7734;
    entry_1b771c(rdram, ctx, runtime);
}

void entry_1b773c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b773c inside entry_1b771c (0x1b771c - 0x1b7790)
    ctx->pc = 0x1b773c;
    entry_1b771c(rdram, ctx, runtime);
}

void entry_1b7754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7754 inside entry_1b771c (0x1b771c - 0x1b7790)
    ctx->pc = 0x1b7754;
    entry_1b771c(rdram, ctx, runtime);
}

void entry_1b7770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7770 inside entry_1b771c (0x1b771c - 0x1b7790)
    ctx->pc = 0x1b7770;
    entry_1b771c(rdram, ctx, runtime);
}

void entry_1b7774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7774 inside entry_1b771c (0x1b771c - 0x1b7790)
    ctx->pc = 0x1b7774;
    entry_1b771c(rdram, ctx, runtime);
}

void entry_1b777c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b777c inside entry_1b771c (0x1b771c - 0x1b7790)
    ctx->pc = 0x1b777c;
    entry_1b771c(rdram, ctx, runtime);
}

void entry_1b77c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b77c4 inside entry_1b77a4 (0x1b77a4 - 0x1b77e4)
    ctx->pc = 0x1b77c4;
    entry_1b77a4(rdram, ctx, runtime);
}

void entry_1b77cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b77cc inside entry_1b77a4 (0x1b77a4 - 0x1b77e4)
    ctx->pc = 0x1b77cc;
    entry_1b77a4(rdram, ctx, runtime);
}

void entry_1b77f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b77f0 inside entry_1b77ec (0x1b77ec - 0x1b7818)
    ctx->pc = 0x1b77f0;
    entry_1b77ec(rdram, ctx, runtime);
}

void entry_1b77f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b77f4 inside entry_1b77ec (0x1b77ec - 0x1b7818)
    ctx->pc = 0x1b77f4;
    entry_1b77ec(rdram, ctx, runtime);
}

void entry_1b784c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b784c inside entry_1b7844 (0x1b7844 - 0x1b7860)
    ctx->pc = 0x1b784c;
    entry_1b7844(rdram, ctx, runtime);
}

void entry_1b7850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7850 inside entry_1b7844 (0x1b7844 - 0x1b7860)
    ctx->pc = 0x1b7850;
    entry_1b7844(rdram, ctx, runtime);
}

void entry_1b78a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b78a8 inside SgasGetSmartguard__FP10SMARTGUARD (0x1b7860 - 0x1b78c0)
    ctx->pc = 0x1b78a8;
    SgasGetSmartguard__FP10SMARTGUARD(rdram, ctx, runtime);
}

void entry_1b78b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b78b0 inside SgasGetSmartguard__FP10SMARTGUARD (0x1b7860 - 0x1b78c0)
    ctx->pc = 0x1b78b0;
    SgasGetSmartguard__FP10SMARTGUARD(rdram, ctx, runtime);
}

void entry_1b78b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b78b4 inside SgasGetSmartguard__FP10SMARTGUARD (0x1b7860 - 0x1b78c0)
    ctx->pc = 0x1b78b4;
    SgasGetSmartguard__FP10SMARTGUARD(rdram, ctx, runtime);
}

void entry_1b790c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b790c inside entry_1b78e4 (0x1b78e4 - 0x1b7920)
    ctx->pc = 0x1b790c;
    entry_1b78e4(rdram, ctx, runtime);
}

void entry_1b7910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7910 inside entry_1b78e4 (0x1b78e4 - 0x1b7920)
    ctx->pc = 0x1b7910;
    entry_1b78e4(rdram, ctx, runtime);
}

void entry_1b7954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7954 inside entry_1b794c (0x1b794c - 0x1b7968)
    ctx->pc = 0x1b7954;
    entry_1b794c(rdram, ctx, runtime);
}

void entry_1b7a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7a64 inside entry_1b7a44 (0x1b7a44 - 0x1b7a78)
    ctx->pc = 0x1b7a64;
    entry_1b7a44(rdram, ctx, runtime);
}

void entry_1b7a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7a68 inside entry_1b7a44 (0x1b7a44 - 0x1b7a78)
    ctx->pc = 0x1b7a68;
    entry_1b7a44(rdram, ctx, runtime);
}

void entry_1b7b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7b54 inside entry_1b7b4c (0x1b7b4c - 0x1b7b5c)
    ctx->pc = 0x1b7b54;
    entry_1b7b4c(rdram, ctx, runtime);
}

void entry_1b7bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7bf4 inside entry_1b7bf0 (0x1b7bf0 - 0x1b7bfc)
    ctx->pc = 0x1b7bf4;
    entry_1b7bf0(rdram, ctx, runtime);
}

void entry_1b7c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7c28 inside entry_1b7c24 (0x1b7c24 - 0x1b7c40)
    ctx->pc = 0x1b7c28;
    entry_1b7c24(rdram, ctx, runtime);
}

void entry_1b7c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7c88 inside entry_1b7c80 (0x1b7c80 - 0x1b7c94)
    ctx->pc = 0x1b7c88;
    entry_1b7c80(rdram, ctx, runtime);
}

void entry_1b7c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7c98 inside entry_1b7c94 (0x1b7c94 - 0x1b7cd4)
    ctx->pc = 0x1b7c98;
    entry_1b7c94(rdram, ctx, runtime);
}

void entry_1b7cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7cec inside entry_1b7ce8 (0x1b7ce8 - 0x1b7d00)
    ctx->pc = 0x1b7cec;
    entry_1b7ce8(rdram, ctx, runtime);
}

void entry_1b7d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7d80 inside DisplaceSo__FP2SOi (0x1b7d00 - 0x1b7da8)
    ctx->pc = 0x1b7d80;
    DisplaceSo__FP2SOi(rdram, ctx, runtime);
}

void entry_1b7db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7db8 inside entry_1b7da8 (0x1b7da8 - 0x1b7e24)
    ctx->pc = 0x1b7db8;
    entry_1b7da8(rdram, ctx, runtime);
}

void entry_1b7e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7e10 inside entry_1b7da8 (0x1b7da8 - 0x1b7e24)
    ctx->pc = 0x1b7e10;
    entry_1b7da8(rdram, ctx, runtime);
}

void entry_1b7eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7eb4 inside entry_1b7ea4 (0x1b7ea4 - 0x1b7f10)
    ctx->pc = 0x1b7eb4;
    entry_1b7ea4(rdram, ctx, runtime);
}

void entry_1b7ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7ef0 inside entry_1b7ea4 (0x1b7ea4 - 0x1b7f10)
    ctx->pc = 0x1b7ef0;
    entry_1b7ea4(rdram, ctx, runtime);
}

void entry_1b7f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7f14 inside entry_1b7f10 (0x1b7f10 - 0x1b7f50)
    ctx->pc = 0x1b7f14;
    entry_1b7f10(rdram, ctx, runtime);
}

void entry_1b7f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7f28 inside entry_1b7f10 (0x1b7f10 - 0x1b7f50)
    ctx->pc = 0x1b7f28;
    entry_1b7f10(rdram, ctx, runtime);
}

void entry_1b7f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7f54 inside entry_1b7f50 (0x1b7f50 - 0x1b7f78)
    ctx->pc = 0x1b7f54;
    entry_1b7f50(rdram, ctx, runtime);
}

void entry_1b7f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7f58 inside entry_1b7f50 (0x1b7f50 - 0x1b7f78)
    ctx->pc = 0x1b7f58;
    entry_1b7f50(rdram, ctx, runtime);
}

void entry_1b7ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b7ff0 inside ImpactSo__FP2SOi (0x1b7f78 - 0x1b8018)
    ctx->pc = 0x1b7ff0;
    ImpactSo__FP2SOi(rdram, ctx, runtime);
}

void entry_1b8028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8028 inside entry_1b8018 (0x1b8018 - 0x1b80a8)
    ctx->pc = 0x1b8028;
    entry_1b8018(rdram, ctx, runtime);
}

void entry_1b8080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8080 inside entry_1b8018 (0x1b8018 - 0x1b80a8)
    ctx->pc = 0x1b8080;
    entry_1b8018(rdram, ctx, runtime);
}

void entry_1b80b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b80b8 inside entry_1b80a8 (0x1b80a8 - 0x1b8110)
    ctx->pc = 0x1b80b8;
    entry_1b80a8(rdram, ctx, runtime);
}

void entry_1b80f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b80f0 inside entry_1b80a8 (0x1b80a8 - 0x1b8110)
    ctx->pc = 0x1b80f0;
    entry_1b80a8(rdram, ctx, runtime);
}

void entry_1b8114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8114 inside entry_1b8110 (0x1b8110 - 0x1b8148)
    ctx->pc = 0x1b8114;
    entry_1b8110(rdram, ctx, runtime);
}

void entry_1b8128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8128 inside entry_1b8110 (0x1b8110 - 0x1b8148)
    ctx->pc = 0x1b8128;
    entry_1b8110(rdram, ctx, runtime);
}

void entry_1b81c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b81c8 inside PivotSo__FP2SOi (0x1b8148 - 0x1b8220)
    ctx->pc = 0x1b81c8;
    PivotSo__FP2SOi(rdram, ctx, runtime);
}

void entry_1b8230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8230 inside entry_1b8220 (0x1b8220 - 0x1b82dc)
    ctx->pc = 0x1b8230;
    entry_1b8220(rdram, ctx, runtime);
}

void entry_1b828c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b828c inside entry_1b8220 (0x1b8220 - 0x1b82dc)
    ctx->pc = 0x1b828c;
    entry_1b8220(rdram, ctx, runtime);
}

void entry_1b8360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8360 inside entry_1b8350 (0x1b8350 - 0x1b83b8)
    ctx->pc = 0x1b8360;
    entry_1b8350(rdram, ctx, runtime);
}

void entry_1b8398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8398 inside entry_1b8350 (0x1b8350 - 0x1b83b8)
    ctx->pc = 0x1b8398;
    entry_1b8350(rdram, ctx, runtime);
}

void entry_1b83bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b83bc inside entry_1b83b8 (0x1b83b8 - 0x1b83f8)
    ctx->pc = 0x1b83bc;
    entry_1b83b8(rdram, ctx, runtime);
}

void entry_1b83d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b83d0 inside entry_1b83b8 (0x1b83b8 - 0x1b83f8)
    ctx->pc = 0x1b83d0;
    entry_1b83b8(rdram, ctx, runtime);
}

void entry_1b83fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b83fc inside entry_1b83f8 (0x1b83f8 - 0x1b8420)
    ctx->pc = 0x1b83fc;
    entry_1b83f8(rdram, ctx, runtime);
}

void entry_1b8400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8400 inside entry_1b83f8 (0x1b83f8 - 0x1b8420)
    ctx->pc = 0x1b8400;
    entry_1b83f8(rdram, ctx, runtime);
}

void entry_1b84d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b84d8 inside ExtendSoBounds__FP2SOP6VECTORf (0x1b8420 - 0x1b8540)
    ctx->pc = 0x1b84d8;
    ExtendSoBounds__FP2SOP6VECTORf(rdram, ctx, runtime);
}

void entry_1b84f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b84f0 inside ExtendSoBounds__FP2SOP6VECTORf (0x1b8420 - 0x1b8540)
    ctx->pc = 0x1b84f0;
    ExtendSoBounds__FP2SOP6VECTORf(rdram, ctx, runtime);
}

void entry_1b84f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b84f4 inside ExtendSoBounds__FP2SOP6VECTORf (0x1b8420 - 0x1b8540)
    ctx->pc = 0x1b84f4;
    ExtendSoBounds__FP2SOP6VECTORf(rdram, ctx, runtime);
}

void entry_1b8534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8534 inside ExtendSoBounds__FP2SOP6VECTORf (0x1b8420 - 0x1b8540)
    ctx->pc = 0x1b8534;
    ExtendSoBounds__FP2SOP6VECTORf(rdram, ctx, runtime);
}

void entry_1b8580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8580 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8580;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b85e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b85e0 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b85e0;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b85f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b85f8 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b85f8;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8610 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8610;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8620 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8620;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8638 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8638;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b863c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b863c inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b863c;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8660 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8660;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b86a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b86a0 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b86a0;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b86a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b86a4 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b86a4;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b86ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b86ac inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b86ac;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b86dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b86dc inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b86dc;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8728 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8728;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8744 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8744;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8790 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8790;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b87d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b87d0 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b87d0;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8808 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8808;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8810 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8810;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8814 inside UpdateSoBounds__FP2SO (0x1b8540 - 0x1b8820)
    ctx->pc = 0x1b8814;
    UpdateSoBounds__FP2SO(rdram, ctx, runtime);
}

void entry_1b8850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8850 inside UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3 (0x1b8820 - 0x1b8960)
    ctx->pc = 0x1b8850;
    UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_1b8898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8898 inside UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3 (0x1b8820 - 0x1b8960)
    ctx->pc = 0x1b8898;
    UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_1b88b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b88b0 inside UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3 (0x1b8820 - 0x1b8960)
    ctx->pc = 0x1b88b0;
    UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_1b8958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8958 inside UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3 (0x1b8820 - 0x1b8960)
    ctx->pc = 0x1b8958;
    UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_1b8a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8a3c inside FIgnoreSoIntersection__FP2SOT0 (0x1b8a08 - 0x1b8a48)
    ctx->pc = 0x1b8a3c;
    FIgnoreSoIntersection__FP2SOT0(rdram, ctx, runtime);
}

void entry_1b8a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8a78 inside UpdateSoImpacts__FP2SO (0x1b8a48 - 0x1b8ab4)
    ctx->pc = 0x1b8a78;
    UpdateSoImpacts__FP2SO(rdram, ctx, runtime);
}

void entry_1b8a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8a90 inside UpdateSoImpacts__FP2SO (0x1b8a48 - 0x1b8ab4)
    ctx->pc = 0x1b8a90;
    UpdateSoImpacts__FP2SO(rdram, ctx, runtime);
}

void entry_1b8aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8aa8 inside UpdateSoImpacts__FP2SO (0x1b8a48 - 0x1b8ab4)
    ctx->pc = 0x1b8aa8;
    UpdateSoImpacts__FP2SO(rdram, ctx, runtime);
}

void entry_1b8adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8adc inside entry_1b8ad8 (0x1b8ad8 - 0x1b8b30)
    ctx->pc = 0x1b8adc;
    entry_1b8ad8(rdram, ctx, runtime);
}

void entry_1b8af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8af0 inside entry_1b8ad8 (0x1b8ad8 - 0x1b8b30)
    ctx->pc = 0x1b8af0;
    entry_1b8ad8(rdram, ctx, runtime);
}

void entry_1b8b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8b08 inside entry_1b8ad8 (0x1b8ad8 - 0x1b8b30)
    ctx->pc = 0x1b8b08;
    entry_1b8ad8(rdram, ctx, runtime);
}

void entry_1b8b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8b14 inside entry_1b8ad8 (0x1b8ad8 - 0x1b8b30)
    ctx->pc = 0x1b8b14;
    entry_1b8ad8(rdram, ctx, runtime);
}

void entry_1b8bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8bf4 inside AdjustSoXpLocal__FP2SOP2XPi (0x1b8b90 - 0x1b8cb0)
    ctx->pc = 0x1b8bf4;
    AdjustSoXpLocal__FP2SOP2XPi(rdram, ctx, runtime);
}

void entry_1b8c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8c0c inside AdjustSoXpLocal__FP2SOP2XPi (0x1b8b90 - 0x1b8cb0)
    ctx->pc = 0x1b8c0c;
    AdjustSoXpLocal__FP2SOP2XPi(rdram, ctx, runtime);
}

void entry_1b8c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8c3c inside AdjustSoXpLocal__FP2SOP2XPi (0x1b8b90 - 0x1b8cb0)
    ctx->pc = 0x1b8c3c;
    AdjustSoXpLocal__FP2SOP2XPi(rdram, ctx, runtime);
}

void entry_1b8c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8c5c inside AdjustSoXpLocal__FP2SOP2XPi (0x1b8b90 - 0x1b8cb0)
    ctx->pc = 0x1b8c5c;
    AdjustSoXpLocal__FP2SOP2XPi(rdram, ctx, runtime);
}

void entry_1b8cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8cb4 inside entry_1b8cb0 (0x1b8cb0 - 0x1b8d2c)
    ctx->pc = 0x1b8cb4;
    entry_1b8cb0(rdram, ctx, runtime);
}

void entry_1b8cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8cd8 inside entry_1b8cb0 (0x1b8cb0 - 0x1b8d2c)
    ctx->pc = 0x1b8cd8;
    entry_1b8cb0(rdram, ctx, runtime);
}

void entry_1b8cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8cf4 inside entry_1b8cb0 (0x1b8cb0 - 0x1b8d2c)
    ctx->pc = 0x1b8cf4;
    entry_1b8cb0(rdram, ctx, runtime);
}

void entry_1b8d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8d04 inside entry_1b8cb0 (0x1b8cb0 - 0x1b8d2c)
    ctx->pc = 0x1b8d04;
    entry_1b8cb0(rdram, ctx, runtime);
}

void entry_1b8d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8d58 inside entry_1b8d2c (0x1b8d2c - 0x1b8de8)
    ctx->pc = 0x1b8d58;
    entry_1b8d2c(rdram, ctx, runtime);
}

void entry_1b8d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8d70 inside entry_1b8d2c (0x1b8d2c - 0x1b8de8)
    ctx->pc = 0x1b8d70;
    entry_1b8d2c(rdram, ctx, runtime);
}

void entry_1b8d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8d90 inside entry_1b8d2c (0x1b8d2c - 0x1b8de8)
    ctx->pc = 0x1b8d90;
    entry_1b8d2c(rdram, ctx, runtime);
}

void entry_1b8db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8db4 inside entry_1b8d2c (0x1b8d2c - 0x1b8de8)
    ctx->pc = 0x1b8db4;
    entry_1b8d2c(rdram, ctx, runtime);
}

void entry_1b8e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8e40 inside entry_1b8de8 (0x1b8de8 - 0x1b8e70)
    ctx->pc = 0x1b8e40;
    entry_1b8de8(rdram, ctx, runtime);
}

void entry_1b8ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8ebc inside entry_1b8e70 (0x1b8e70 - 0x1b8f98)
    ctx->pc = 0x1b8ebc;
    entry_1b8e70(rdram, ctx, runtime);
}

void entry_1b8ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8ee4 inside entry_1b8e70 (0x1b8e70 - 0x1b8f98)
    ctx->pc = 0x1b8ee4;
    entry_1b8e70(rdram, ctx, runtime);
}

void entry_1b8ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8ef8 inside entry_1b8e70 (0x1b8e70 - 0x1b8f98)
    ctx->pc = 0x1b8ef8;
    entry_1b8e70(rdram, ctx, runtime);
}

void entry_1b8f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8f14 inside entry_1b8e70 (0x1b8e70 - 0x1b8f98)
    ctx->pc = 0x1b8f14;
    entry_1b8e70(rdram, ctx, runtime);
}

void entry_1b8f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8f18 inside entry_1b8e70 (0x1b8e70 - 0x1b8f98)
    ctx->pc = 0x1b8f18;
    entry_1b8e70(rdram, ctx, runtime);
}

void entry_1b8f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8f48 inside entry_1b8e70 (0x1b8e70 - 0x1b8f98)
    ctx->pc = 0x1b8f48;
    entry_1b8e70(rdram, ctx, runtime);
}

void entry_1b8f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8f84 inside entry_1b8e70 (0x1b8e70 - 0x1b8f98)
    ctx->pc = 0x1b8f84;
    entry_1b8e70(rdram, ctx, runtime);
}

void entry_1b8fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8fac inside entry_1b8f98 (0x1b8f98 - 0x1b8fe0)
    ctx->pc = 0x1b8fac;
    entry_1b8f98(rdram, ctx, runtime);
}

void entry_1b8fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b8fb0 inside entry_1b8f98 (0x1b8f98 - 0x1b8fe0)
    ctx->pc = 0x1b8fb0;
    entry_1b8f98(rdram, ctx, runtime);
}

void entry_1b90e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b90e8 inside AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f (0x1b9058 - 0x1b9198)
    ctx->pc = 0x1b90e8;
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime);
}

void entry_1b9174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9174 inside AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f (0x1b9058 - 0x1b9198)
    ctx->pc = 0x1b9174;
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime);
}

void entry_1b9190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9190 inside AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f (0x1b9058 - 0x1b9198)
    ctx->pc = 0x1b9190;
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime);
}

void entry_1b925c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b925c inside entry_1b9208 (0x1b9208 - 0x1b9310)
    ctx->pc = 0x1b925c;
    entry_1b9208(rdram, ctx, runtime);
}

void entry_1b92e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b92e8 inside entry_1b9208 (0x1b9208 - 0x1b9310)
    ctx->pc = 0x1b92e8;
    entry_1b9208(rdram, ctx, runtime);
}

void entry_1b9308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9308 inside entry_1b9208 (0x1b9208 - 0x1b9310)
    ctx->pc = 0x1b9308;
    entry_1b9208(rdram, ctx, runtime);
}

void entry_1b9394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9394 inside entry_1b9390 (0x1b9390 - 0x1b93b4)
    ctx->pc = 0x1b9394;
    entry_1b9390(rdram, ctx, runtime);
}

void entry_1b93a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b93a0 inside entry_1b9390 (0x1b9390 - 0x1b93b4)
    ctx->pc = 0x1b93a0;
    entry_1b9390(rdram, ctx, runtime);
}

void entry_1b93c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b93c4 inside entry_1b93b4 (0x1b93b4 - 0x1b93d8)
    ctx->pc = 0x1b93c4;
    entry_1b93b4(rdram, ctx, runtime);
}

void entry_1b94e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b94e0 inside entry_1b94dc (0x1b94dc - 0x1b94f0)
    ctx->pc = 0x1b94e0;
    entry_1b94dc(rdram, ctx, runtime);
}

void entry_1b9548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9548 inside DiscardSoXps__FP2SO (0x1b94f0 - 0x1b95b8)
    ctx->pc = 0x1b9548;
    DiscardSoXps__FP2SO(rdram, ctx, runtime);
}

void entry_1b9568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9568 inside DiscardSoXps__FP2SO (0x1b94f0 - 0x1b95b8)
    ctx->pc = 0x1b9568;
    DiscardSoXps__FP2SO(rdram, ctx, runtime);
}

void entry_1b9594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9594 inside DiscardSoXps__FP2SO (0x1b94f0 - 0x1b95b8)
    ctx->pc = 0x1b9594;
    DiscardSoXps__FP2SO(rdram, ctx, runtime);
}

void entry_1b95a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b95a4 inside DiscardSoXps__FP2SO (0x1b94f0 - 0x1b95b8)
    ctx->pc = 0x1b95a4;
    DiscardSoXps__FP2SO(rdram, ctx, runtime);
}

void entry_1b95c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b95c8 inside entry_1b95b8 (0x1b95b8 - 0x1b9648)
    ctx->pc = 0x1b95c8;
    entry_1b95b8(rdram, ctx, runtime);
}

void entry_1b95d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b95d8 inside entry_1b95b8 (0x1b95b8 - 0x1b9648)
    ctx->pc = 0x1b95d8;
    entry_1b95b8(rdram, ctx, runtime);
}

void entry_1b9600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9600 inside entry_1b95b8 (0x1b95b8 - 0x1b9648)
    ctx->pc = 0x1b9600;
    entry_1b95b8(rdram, ctx, runtime);
}

void entry_1b9618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9618 inside entry_1b95b8 (0x1b95b8 - 0x1b9648)
    ctx->pc = 0x1b9618;
    entry_1b95b8(rdram, ctx, runtime);
}

void entry_1b9624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9624 inside entry_1b95b8 (0x1b95b8 - 0x1b9648)
    ctx->pc = 0x1b9624;
    entry_1b95b8(rdram, ctx, runtime);
}

void entry_1b963c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b963c inside entry_1b95b8 (0x1b95b8 - 0x1b9648)
    ctx->pc = 0x1b963c;
    entry_1b95b8(rdram, ctx, runtime);
}

void entry_1b964c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b964c inside entry_1b9648 (0x1b9648 - 0x1b9680)
    ctx->pc = 0x1b964c;
    entry_1b9648(rdram, ctx, runtime);
}

void entry_1b9754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9754 inside entry_1b9750 (0x1b9750 - 0x1b975c)
    ctx->pc = 0x1b9754;
    entry_1b9750(rdram, ctx, runtime);
}

void entry_1b9770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9770 inside entry_1b975c (0x1b975c - 0x1b9788)
    ctx->pc = 0x1b9770;
    entry_1b975c(rdram, ctx, runtime);
}

void entry_1b9790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9790 inside entry_1b9788 (0x1b9788 - 0x1b97a0)
    ctx->pc = 0x1b9790;
    entry_1b9788(rdram, ctx, runtime);
}

void entry_1b9794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9794 inside entry_1b9788 (0x1b9788 - 0x1b97a0)
    ctx->pc = 0x1b9794;
    entry_1b9788(rdram, ctx, runtime);
}

void entry_1b97a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b97a4 inside entry_1b97a0 (0x1b97a0 - 0x1b97c4)
    ctx->pc = 0x1b97a4;
    entry_1b97a0(rdram, ctx, runtime);
}

void entry_1b97ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b97ac inside entry_1b97a0 (0x1b97a0 - 0x1b97c4)
    ctx->pc = 0x1b97ac;
    entry_1b97a0(rdram, ctx, runtime);
}

void entry_1b97b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b97b0 inside entry_1b97a0 (0x1b97a0 - 0x1b97c4)
    ctx->pc = 0x1b97b0;
    entry_1b97a0(rdram, ctx, runtime);
}

void entry_1b982c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b982c inside entry_1b9828 (0x1b9828 - 0x1b9834)
    ctx->pc = 0x1b982c;
    entry_1b9828(rdram, ctx, runtime);
}

void entry_1b9888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9888 inside TranslateSoToPosSafe__FP2SOP6VECTORT1 (0x1b9860 - 0x1b989c)
    ctx->pc = 0x1b9888;
    TranslateSoToPosSafe__FP2SOP6VECTORT1(rdram, ctx, runtime);
}

void entry_1b98c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b98c0 inside entry_1b98a8 (0x1b98a8 - 0x1b9938)
    ctx->pc = 0x1b98c0;
    entry_1b98a8(rdram, ctx, runtime);
}

void entry_1b98d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b98d8 inside entry_1b98a8 (0x1b98a8 - 0x1b9938)
    ctx->pc = 0x1b98d8;
    entry_1b98a8(rdram, ctx, runtime);
}

void entry_1b98f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b98f8 inside entry_1b98a8 (0x1b98a8 - 0x1b9938)
    ctx->pc = 0x1b98f8;
    entry_1b98a8(rdram, ctx, runtime);
}

void entry_1b9908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9908 inside entry_1b98a8 (0x1b98a8 - 0x1b9938)
    ctx->pc = 0x1b9908;
    entry_1b98a8(rdram, ctx, runtime);
}

void entry_1b9920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9920 inside entry_1b98a8 (0x1b98a8 - 0x1b9938)
    ctx->pc = 0x1b9920;
    entry_1b98a8(rdram, ctx, runtime);
}

void entry_1b99c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b99c4 inside entry_1b995c (0x1b995c - 0x1b99dc)
    ctx->pc = 0x1b99c4;
    entry_1b995c(rdram, ctx, runtime);
}

void entry_1b99e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b99e0 inside entry_1b99dc (0x1b99dc - 0x1b99f0)
    ctx->pc = 0x1b99e0;
    entry_1b99dc(rdram, ctx, runtime);
}

void entry_1b9a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9a78 inside entry_1b9a0c (0x1b9a0c - 0x1b9a90)
    ctx->pc = 0x1b9a78;
    entry_1b9a0c(rdram, ctx, runtime);
}

void entry_1b9a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9a94 inside entry_1b9a90 (0x1b9a90 - 0x1b9aa8)
    ctx->pc = 0x1b9a94;
    entry_1b9a90(rdram, ctx, runtime);
}

void entry_1b9b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9b08 inside SetSoConstraints__FP2SO2CTP6VECTORT1T2 (0x1b9ae0 - 0x1b9b44)
    ctx->pc = 0x1b9b08;
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime);
}

void entry_1b9b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9b18 inside SetSoConstraints__FP2SO2CTP6VECTORT1T2 (0x1b9ae0 - 0x1b9b44)
    ctx->pc = 0x1b9b18;
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime);
}

void entry_1b9b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9b34 inside SetSoConstraints__FP2SO2CTP6VECTORT1T2 (0x1b9ae0 - 0x1b9b44)
    ctx->pc = 0x1b9b34;
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime);
}

void entry_1b9b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9b48 inside entry_1b9b44 (0x1b9b44 - 0x1b9b50)
    ctx->pc = 0x1b9b48;
    entry_1b9b44(rdram, ctx, runtime);
}

void entry_1b9c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9c20 inside entry_1b9c1c (0x1b9c1c - 0x1b9c40)
    ctx->pc = 0x1b9c20;
    entry_1b9c1c(rdram, ctx, runtime);
}

void entry_1b9c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9c48 inside entry_1b9c40 (0x1b9c40 - 0x1b9c50)
    ctx->pc = 0x1b9c48;
    entry_1b9c40(rdram, ctx, runtime);
}

void entry_1b9e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9e58 inside entry_1b9e54 (0x1b9e54 - 0x1b9f00)
    ctx->pc = 0x1b9e58;
    entry_1b9e54(rdram, ctx, runtime);
}

void entry_1b9edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9edc inside entry_1b9e54 (0x1b9e54 - 0x1b9f00)
    ctx->pc = 0x1b9edc;
    entry_1b9e54(rdram, ctx, runtime);
}

void entry_1b9ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9ee0 inside entry_1b9e54 (0x1b9e54 - 0x1b9f00)
    ctx->pc = 0x1b9ee0;
    entry_1b9e54(rdram, ctx, runtime);
}

void entry_1b9ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1b9ff0 inside entry_1b9fdc (0x1b9fdc - 0x1ba00c)
    ctx->pc = 0x1b9ff0;
    entry_1b9fdc(rdram, ctx, runtime);
}

void entry_1ba030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba030 inside entry_1ba028 (0x1ba028 - 0x1ba068)
    ctx->pc = 0x1ba030;
    entry_1ba028(rdram, ctx, runtime);
}

void entry_1ba03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba03c inside entry_1ba028 (0x1ba028 - 0x1ba068)
    ctx->pc = 0x1ba03c;
    entry_1ba028(rdram, ctx, runtime);
}

void entry_1ba040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba040 inside entry_1ba028 (0x1ba028 - 0x1ba068)
    ctx->pc = 0x1ba040;
    entry_1ba028(rdram, ctx, runtime);
}

void entry_1ba0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba0a8 inside PsoFirstSoTouching__FP2SO (0x1ba068 - 0x1ba0d4)
    ctx->pc = 0x1ba0a8;
    PsoFirstSoTouching__FP2SO(rdram, ctx, runtime);
}

void entry_1ba0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba0b8 inside PsoFirstSoTouching__FP2SO (0x1ba068 - 0x1ba0d4)
    ctx->pc = 0x1ba0b8;
    PsoFirstSoTouching__FP2SO(rdram, ctx, runtime);
}

void entry_1ba0ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba0ec inside entry_1ba0d4 (0x1ba0d4 - 0x1ba130)
    ctx->pc = 0x1ba0ec;
    entry_1ba0d4(rdram, ctx, runtime);
}

void entry_1ba0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba0fc inside entry_1ba0d4 (0x1ba0d4 - 0x1ba130)
    ctx->pc = 0x1ba0fc;
    entry_1ba0d4(rdram, ctx, runtime);
}

void entry_1ba108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba108 inside entry_1ba0d4 (0x1ba0d4 - 0x1ba130)
    ctx->pc = 0x1ba108;
    entry_1ba0d4(rdram, ctx, runtime);
}

void entry_1ba31c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba31c inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba31c;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba334 inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba334;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba348 inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba348;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba37c inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba37c;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba380 inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba380;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba3a4 inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba3a4;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba3d8 inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba3d8;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba3dc inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba3dc;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba404 inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba404;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba40c inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba40c;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba424 inside ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22 (0x1ba2e8 - 0x1ba430)
    ctx->pc = 0x1ba424;
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime);
}

void entry_1ba460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba460 inside ApplyConstr__FP6CONSTRP6VECTORN21 (0x1ba430 - 0x1ba500)
    ctx->pc = 0x1ba460;
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime);
}

void entry_1ba478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba478 inside ApplyConstr__FP6CONSTRP6VECTORN21 (0x1ba430 - 0x1ba500)
    ctx->pc = 0x1ba478;
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime);
}

void entry_1ba48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba48c inside ApplyConstr__FP6CONSTRP6VECTORN21 (0x1ba430 - 0x1ba500)
    ctx->pc = 0x1ba48c;
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime);
}

void entry_1ba4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba4b0 inside ApplyConstr__FP6CONSTRP6VECTORN21 (0x1ba430 - 0x1ba500)
    ctx->pc = 0x1ba4b0;
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime);
}

void entry_1ba4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba4d8 inside ApplyConstr__FP6CONSTRP6VECTORN21 (0x1ba430 - 0x1ba500)
    ctx->pc = 0x1ba4d8;
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime);
}

void entry_1ba4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba4e0 inside ApplyConstr__FP6CONSTRP6VECTORN21 (0x1ba430 - 0x1ba500)
    ctx->pc = 0x1ba4e0;
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime);
}

void entry_1ba4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba4f8 inside ApplyConstr__FP6CONSTRP6VECTORN21 (0x1ba430 - 0x1ba500)
    ctx->pc = 0x1ba4f8;
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime);
}

void entry_1ba578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba578 inside RemoveSoXa__FP2SOP2XA (0x1ba550 - 0x1ba5a0)
    ctx->pc = 0x1ba578;
    RemoveSoXa__FP2SOP2XA(rdram, ctx, runtime);
}

void entry_1ba594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba594 inside RemoveSoXa__FP2SOP2XA (0x1ba550 - 0x1ba5a0)
    ctx->pc = 0x1ba594;
    RemoveSoXa__FP2SOP2XA(rdram, ctx, runtime);
}

void entry_1ba598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba598 inside RemoveSoXa__FP2SOP2XA (0x1ba550 - 0x1ba5a0)
    ctx->pc = 0x1ba598;
    RemoveSoXa__FP2SOP2XA(rdram, ctx, runtime);
}

void entry_1ba6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba6dc inside entry_1ba68c (0x1ba68c - 0x1ba770)
    ctx->pc = 0x1ba6dc;
    entry_1ba68c(rdram, ctx, runtime);
}

void entry_1ba6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba6e8 inside entry_1ba68c (0x1ba68c - 0x1ba770)
    ctx->pc = 0x1ba6e8;
    entry_1ba68c(rdram, ctx, runtime);
}

void entry_1ba6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba6ec inside entry_1ba68c (0x1ba68c - 0x1ba770)
    ctx->pc = 0x1ba6ec;
    entry_1ba68c(rdram, ctx, runtime);
}

void entry_1ba714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba714 inside entry_1ba68c (0x1ba68c - 0x1ba770)
    ctx->pc = 0x1ba714;
    entry_1ba68c(rdram, ctx, runtime);
}

void entry_1ba718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba718 inside entry_1ba68c (0x1ba68c - 0x1ba770)
    ctx->pc = 0x1ba718;
    entry_1ba68c(rdram, ctx, runtime);
}

void entry_1ba7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba7fc inside entry_1ba7c0 (0x1ba7c0 - 0x1ba870)
    ctx->pc = 0x1ba7fc;
    entry_1ba7c0(rdram, ctx, runtime);
}

void entry_1ba800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba800 inside entry_1ba7c0 (0x1ba7c0 - 0x1ba870)
    ctx->pc = 0x1ba800;
    entry_1ba7c0(rdram, ctx, runtime);
}

void entry_1ba828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba828 inside entry_1ba7c0 (0x1ba7c0 - 0x1ba870)
    ctx->pc = 0x1ba828;
    entry_1ba7c0(rdram, ctx, runtime);
}

void entry_1ba880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba880 inside entry_1ba870 (0x1ba870 - 0x1ba8cc)
    ctx->pc = 0x1ba880;
    entry_1ba870(rdram, ctx, runtime);
}

void entry_1ba908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba908 inside entry_1ba8f8 (0x1ba8f8 - 0x1ba954)
    ctx->pc = 0x1ba908;
    entry_1ba8f8(rdram, ctx, runtime);
}

void entry_1ba968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ba968 inside entry_1ba954 (0x1ba954 - 0x1ba9b0)
    ctx->pc = 0x1ba968;
    entry_1ba954(rdram, ctx, runtime);
}

void entry_1baaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1baaf4 inside entry_1baa84 (0x1baa84 - 0x1bab2c)
    ctx->pc = 0x1baaf4;
    entry_1baa84(rdram, ctx, runtime);
}

void entry_1bab30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bab30 inside entry_1bab2c (0x1bab2c - 0x1babbc)
    ctx->pc = 0x1bab30;
    entry_1bab2c(rdram, ctx, runtime);
}

void entry_1babc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1babc4 inside entry_1babbc (0x1babbc - 0x1babe4)
    ctx->pc = 0x1babc4;
    entry_1babbc(rdram, ctx, runtime);
}

void entry_1babc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1babc8 inside entry_1babbc (0x1babbc - 0x1babe4)
    ctx->pc = 0x1babc8;
    entry_1babbc(rdram, ctx, runtime);
}

void entry_1babe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1babe8 inside entry_1babe4 (0x1babe4 - 0x1bac28)
    ctx->pc = 0x1babe8;
    entry_1babe4(rdram, ctx, runtime);
}

void entry_1bad10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bad10 inside entry_1baca0 (0x1baca0 - 0x1bad24)
    ctx->pc = 0x1bad10;
    entry_1baca0(rdram, ctx, runtime);
}

void entry_1bad28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bad28 inside entry_1bad24 (0x1bad24 - 0x1bad34)
    ctx->pc = 0x1bad28;
    entry_1bad24(rdram, ctx, runtime);
}

void entry_1bada0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bada0 inside entry_1bad8c (0x1bad8c - 0x1badb4)
    ctx->pc = 0x1bada0;
    entry_1bad8c(rdram, ctx, runtime);
}

void entry_1badd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1badd4 inside entry_1badc0 (0x1badc0 - 0x1bade0)
    ctx->pc = 0x1badd4;
    entry_1badc0(rdram, ctx, runtime);
}

void entry_1badf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1badf8 inside entry_1badec (0x1badec - 0x1bae00)
    ctx->pc = 0x1badf8;
    entry_1badec(rdram, ctx, runtime);
}

void entry_1bae1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bae1c inside entry_1bae00 (0x1bae00 - 0x1bae28)
    ctx->pc = 0x1bae1c;
    entry_1bae00(rdram, ctx, runtime);
}

void entry_1bae48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bae48 inside entry_1bae34 (0x1bae34 - 0x1bae5c)
    ctx->pc = 0x1bae48;
    entry_1bae34(rdram, ctx, runtime);
}

void entry_1bae7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bae7c inside entry_1bae68 (0x1bae68 - 0x1bae9c)
    ctx->pc = 0x1bae7c;
    entry_1bae68(rdram, ctx, runtime);
}

void entry_1baea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1baea8 inside entry_1bae9c (0x1bae9c - 0x1baeb0)
    ctx->pc = 0x1baea8;
    entry_1bae9c(rdram, ctx, runtime);
}

void entry_1baed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1baed4 inside entry_1baeb0 (0x1baeb0 - 0x1baee0)
    ctx->pc = 0x1baed4;
    entry_1baeb0(rdram, ctx, runtime);
}

void entry_1baed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1baed8 inside entry_1baeb0 (0x1baeb0 - 0x1baee0)
    ctx->pc = 0x1baed8;
    entry_1baeb0(rdram, ctx, runtime);
}

void entry_1baf48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1baf48 inside entry_1baee0 (0x1baee0 - 0x1baf58)
    ctx->pc = 0x1baf48;
    entry_1baee0(rdram, ctx, runtime);
}

void entry_1baf60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1baf60 inside entry_1baf58 (0x1baf58 - 0x1baf68)
    ctx->pc = 0x1baf60;
    entry_1baf58(rdram, ctx, runtime);
}

void entry_1bafbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bafbc inside entry_1bafb8 (0x1bafb8 - 0x1bafe0)
    ctx->pc = 0x1bafbc;
    entry_1bafb8(rdram, ctx, runtime);
}

void entry_1bb248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb248 inside entry_1bb238 (0x1bb238 - 0x1bb268)
    ctx->pc = 0x1bb248;
    entry_1bb238(rdram, ctx, runtime);
}

void entry_1bb278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb278 inside entry_1bb268 (0x1bb268 - 0x1bb290)
    ctx->pc = 0x1bb278;
    entry_1bb268(rdram, ctx, runtime);
}

void entry_1bb2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb2b0 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb2b0;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb2d8 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb2d8;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb2f8 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb2f8;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb318 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb318;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb328 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb328;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb34c inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb34c;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb350 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb350;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb358 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb358;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb364 inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb364;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb36c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb36c inside PxpFindSoGround__FP2SOT0Pi (0x1bb290 - 0x1bb378)
    ctx->pc = 0x1bb36c;
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime);
}

void entry_1bb4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb4e8 inside RebuildSoPhysHook__FP2SO (0x1bb4a0 - 0x1bb520)
    ctx->pc = 0x1bb4e8;
    RebuildSoPhysHook__FP2SO(rdram, ctx, runtime);
}

void entry_1bb4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb4f8 inside RebuildSoPhysHook__FP2SO (0x1bb4a0 - 0x1bb520)
    ctx->pc = 0x1bb4f8;
    RebuildSoPhysHook__FP2SO(rdram, ctx, runtime);
}

void entry_1bb508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb508 inside RebuildSoPhysHook__FP2SO (0x1bb4a0 - 0x1bb520)
    ctx->pc = 0x1bb508;
    RebuildSoPhysHook__FP2SO(rdram, ctx, runtime);
}

void entry_1bb524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb524 inside entry_1bb520 (0x1bb520 - 0x1bb540)
    ctx->pc = 0x1bb524;
    entry_1bb520(rdram, ctx, runtime);
}

void entry_1bb530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb530 inside entry_1bb520 (0x1bb520 - 0x1bb540)
    ctx->pc = 0x1bb530;
    entry_1bb520(rdram, ctx, runtime);
}

void entry_1bb548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb548 inside PsoFindSoPhysHook__FP2SOi (0x1bb540 - 0x1bb580)
    ctx->pc = 0x1bb548;
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime);
}

void entry_1bb560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb560 inside PsoFindSoPhysHook__FP2SOi (0x1bb540 - 0x1bb580)
    ctx->pc = 0x1bb560;
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime);
}

void entry_1bb574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb574 inside PsoFindSoPhysHook__FP2SOi (0x1bb540 - 0x1bb580)
    ctx->pc = 0x1bb574;
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime);
}

void entry_1bb5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb5b8 inside RecalcSoLocked__FP2SO (0x1bb580 - 0x1bb680)
    ctx->pc = 0x1bb5b8;
    RecalcSoLocked__FP2SO(rdram, ctx, runtime);
}

void entry_1bb624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb624 inside RecalcSoLocked__FP2SO (0x1bb580 - 0x1bb680)
    ctx->pc = 0x1bb624;
    RecalcSoLocked__FP2SO(rdram, ctx, runtime);
}

void entry_1bb628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb628 inside RecalcSoLocked__FP2SO (0x1bb580 - 0x1bb680)
    ctx->pc = 0x1bb628;
    RecalcSoLocked__FP2SO(rdram, ctx, runtime);
}

void entry_1bb668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb668 inside RecalcSoLocked__FP2SO (0x1bb580 - 0x1bb680)
    ctx->pc = 0x1bb668;
    RecalcSoLocked__FP2SO(rdram, ctx, runtime);
}

void entry_1bb690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb690 inside entry_1bb680 (0x1bb680 - 0x1bb6f4)
    ctx->pc = 0x1bb690;
    entry_1bb680(rdram, ctx, runtime);
}

void entry_1bb698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb698 inside entry_1bb680 (0x1bb680 - 0x1bb6f4)
    ctx->pc = 0x1bb698;
    entry_1bb680(rdram, ctx, runtime);
}

void entry_1bb6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb6f8 inside entry_1bb6f4 (0x1bb6f4 - 0x1bb710)
    ctx->pc = 0x1bb6f8;
    entry_1bb6f4(rdram, ctx, runtime);
}

void entry_1bb750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb750 inside FGetSoContactList__FP2SOPv (0x1bb710 - 0x1bb79c)
    ctx->pc = 0x1bb750;
    FGetSoContactList__FP2SOPv(rdram, ctx, runtime);
}

void entry_1bb760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb760 inside FGetSoContactList__FP2SOPv (0x1bb710 - 0x1bb79c)
    ctx->pc = 0x1bb760;
    FGetSoContactList__FP2SOPv(rdram, ctx, runtime);
}

void entry_1bb7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb7c0 inside entry_1bb7b0 (0x1bb7b0 - 0x1bb800)
    ctx->pc = 0x1bb7c0;
    entry_1bb7b0(rdram, ctx, runtime);
}

void entry_1bb7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb7cc inside entry_1bb7b0 (0x1bb7b0 - 0x1bb800)
    ctx->pc = 0x1bb7cc;
    entry_1bb7b0(rdram, ctx, runtime);
}

void entry_1bb7d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb7d4 inside entry_1bb7b0 (0x1bb7b0 - 0x1bb800)
    ctx->pc = 0x1bb7d4;
    entry_1bb7b0(rdram, ctx, runtime);
}

void entry_1bb7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb7d8 inside entry_1bb7b0 (0x1bb7b0 - 0x1bb800)
    ctx->pc = 0x1bb7d8;
    entry_1bb7b0(rdram, ctx, runtime);
}

void entry_1bb850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb850 inside GetSoContacts__FP2SOPiPPP2SO (0x1bb800 - 0x1bb878)
    ctx->pc = 0x1bb850;
    GetSoContacts__FP2SOPiPPP2SO(rdram, ctx, runtime);
}

void entry_1bb858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb858 inside GetSoContacts__FP2SOPiPPP2SO (0x1bb800 - 0x1bb878)
    ctx->pc = 0x1bb858;
    GetSoContacts__FP2SOPiPPP2SO(rdram, ctx, runtime);
}

void entry_1bb88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb88c inside entry_1bb878 (0x1bb878 - 0x1bb89c)
    ctx->pc = 0x1bb88c;
    entry_1bb878(rdram, ctx, runtime);
}

void entry_1bb894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb894 inside entry_1bb878 (0x1bb878 - 0x1bb89c)
    ctx->pc = 0x1bb894;
    entry_1bb878(rdram, ctx, runtime);
}

void entry_1bb8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb8b8 inside entry_1bb89c (0x1bb89c - 0x1bb8e4)
    ctx->pc = 0x1bb8b8;
    entry_1bb89c(rdram, ctx, runtime);
}

void entry_1bb8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb8c8 inside entry_1bb89c (0x1bb89c - 0x1bb8e4)
    ctx->pc = 0x1bb8c8;
    entry_1bb89c(rdram, ctx, runtime);
}

void entry_1bb918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb918 inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb918;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb934 inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb934;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb93c inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb93c;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb940 inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb940;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb944 inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb944;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb948 inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb948;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb954 inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb954;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb95c inside entry_1bb8e4 (0x1bb8e4 - 0x1bb9a0)
    ctx->pc = 0x1bb95c;
    entry_1bb8e4(rdram, ctx, runtime);
}

void entry_1bb9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb9b0 inside FSoInStsoList__FP4STSOP2SO (0x1bb9a0 - 0x1bb9d0)
    ctx->pc = 0x1bb9b0;
    FSoInStsoList__FP4STSOP2SO(rdram, ctx, runtime);
}

void entry_1bb9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb9c0 inside FSoInStsoList__FP4STSOP2SO (0x1bb9a0 - 0x1bb9d0)
    ctx->pc = 0x1bb9c0;
    FSoInStsoList__FP4STSOP2SO(rdram, ctx, runtime);
}

void entry_1bb9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bb9c8 inside FSoInStsoList__FP4STSOP2SO (0x1bb9a0 - 0x1bb9d0)
    ctx->pc = 0x1bb9c8;
    FSoInStsoList__FP4STSOP2SO(rdram, ctx, runtime);
}

void entry_1bba10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bba10 inside GenerateSoSpliceTouchingEvents__FP2SO (0x1bb9d0 - 0x1bba5c)
    ctx->pc = 0x1bba10;
    GenerateSoSpliceTouchingEvents__FP2SO(rdram, ctx, runtime);
}

void entry_1bba20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bba20 inside GenerateSoSpliceTouchingEvents__FP2SO (0x1bb9d0 - 0x1bba5c)
    ctx->pc = 0x1bba20;
    GenerateSoSpliceTouchingEvents__FP2SO(rdram, ctx, runtime);
}

void entry_1bba80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bba80 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bba80;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bba8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bba8c inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bba8c;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bba98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bba98 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bba98;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bbaa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbaa8 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bbaa8;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bbab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbab8 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bbab8;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bbad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbad0 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bbad0;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bbb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbb10 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bbb10;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bbb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbb24 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bbb24;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bbb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbb34 inside entry_1bba7c (0x1bba7c - 0x1bbb54)
    ctx->pc = 0x1bbb34;
    entry_1bba7c(rdram, ctx, runtime);
}

void entry_1bbb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbb58 inside entry_1bbb54 (0x1bbb54 - 0x1bbb6c)
    ctx->pc = 0x1bbb58;
    entry_1bbb54(rdram, ctx, runtime);
}

void entry_1bbb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbb64 inside entry_1bbb54 (0x1bbb54 - 0x1bbb6c)
    ctx->pc = 0x1bbb64;
    entry_1bbb54(rdram, ctx, runtime);
}

void entry_1bbb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbb88 inside entry_1bbb6c (0x1bbb6c - 0x1bbbd0)
    ctx->pc = 0x1bbb88;
    entry_1bbb6c(rdram, ctx, runtime);
}

void entry_1bbb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbb98 inside entry_1bbb6c (0x1bbb6c - 0x1bbbd0)
    ctx->pc = 0x1bbb98;
    entry_1bbb6c(rdram, ctx, runtime);
}

void entry_1bbbec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbbec inside entry_1bbbd0 (0x1bbbd0 - 0x1bbc30)
    ctx->pc = 0x1bbbec;
    entry_1bbbd0(rdram, ctx, runtime);
}

void entry_1bbbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbbf4 inside entry_1bbbd0 (0x1bbbd0 - 0x1bbc30)
    ctx->pc = 0x1bbbf4;
    entry_1bbbd0(rdram, ctx, runtime);
}

void entry_1bbc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbc00 inside entry_1bbbd0 (0x1bbbd0 - 0x1bbc30)
    ctx->pc = 0x1bbc00;
    entry_1bbbd0(rdram, ctx, runtime);
}

void entry_1bbc0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbc0c inside entry_1bbbd0 (0x1bbbd0 - 0x1bbc30)
    ctx->pc = 0x1bbc0c;
    entry_1bbbd0(rdram, ctx, runtime);
}

void entry_1bbcc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbcc8 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbcc8;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbce0 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbce0;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbd10 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbd10;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbd40 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbd40;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbd5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbd5c inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbd5c;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbd68 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbd68;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbd90 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbd90;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbdc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbdc0 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbdc0;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbdd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbdd8 inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbdd8;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbe8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbe8c inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbe8c;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbe9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbe9c inside entry_1bbcb0 (0x1bbcb0 - 0x1bbea4)
    ctx->pc = 0x1bbe9c;
    entry_1bbcb0(rdram, ctx, runtime);
}

void entry_1bbea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbea8 inside entry_1bbea4 (0x1bbea4 - 0x1bbeb8)
    ctx->pc = 0x1bbea8;
    entry_1bbea4(rdram, ctx, runtime);
}

void entry_1bbf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbf08 inside ProjectSoLvo__FP2SOf (0x1bbeb8 - 0x1bc088)
    ctx->pc = 0x1bbf08;
    ProjectSoLvo__FP2SOf(rdram, ctx, runtime);
}

void entry_1bbf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbf70 inside ProjectSoLvo__FP2SOf (0x1bbeb8 - 0x1bc088)
    ctx->pc = 0x1bbf70;
    ProjectSoLvo__FP2SOf(rdram, ctx, runtime);
}

void entry_1bbf8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbf8c inside ProjectSoLvo__FP2SOf (0x1bbeb8 - 0x1bc088)
    ctx->pc = 0x1bbf8c;
    ProjectSoLvo__FP2SOf(rdram, ctx, runtime);
}

void entry_1bbfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bbfb0 inside ProjectSoLvo__FP2SOf (0x1bbeb8 - 0x1bc088)
    ctx->pc = 0x1bbfb0;
    ProjectSoLvo__FP2SOf(rdram, ctx, runtime);
}

void entry_1bc07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc07c inside ProjectSoLvo__FP2SOf (0x1bbeb8 - 0x1bc088)
    ctx->pc = 0x1bc07c;
    ProjectSoLvo__FP2SOf(rdram, ctx, runtime);
}

void entry_1bc188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc188 inside entry_1bc12c (0x1bc12c - 0x1bc1cc)
    ctx->pc = 0x1bc188;
    entry_1bc12c(rdram, ctx, runtime);
}

void entry_1bc194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc194 inside entry_1bc12c (0x1bc12c - 0x1bc1cc)
    ctx->pc = 0x1bc194;
    entry_1bc12c(rdram, ctx, runtime);
}

void entry_1bc3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc3b8 inside entry_1bc3a0 (0x1bc3a0 - 0x1bc460)
    ctx->pc = 0x1bc3b8;
    entry_1bc3a0(rdram, ctx, runtime);
}

void entry_1bc3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc3e4 inside entry_1bc3a0 (0x1bc3a0 - 0x1bc460)
    ctx->pc = 0x1bc3e4;
    entry_1bc3a0(rdram, ctx, runtime);
}

void entry_1bc3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc3f0 inside entry_1bc3a0 (0x1bc3a0 - 0x1bc460)
    ctx->pc = 0x1bc3f0;
    entry_1bc3a0(rdram, ctx, runtime);
}

void entry_1bc528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc528 inside FUN_001bc4d8 (0x1bc4d8 - 0x1bc5ac)
    ctx->pc = 0x1bc528;
    FUN_001bc4d8(rdram, ctx, runtime);
}

void entry_1bc540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc540 inside FUN_001bc4d8 (0x1bc4d8 - 0x1bc5ac)
    ctx->pc = 0x1bc540;
    FUN_001bc4d8(rdram, ctx, runtime);
}

void entry_1bc558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc558 inside FUN_001bc4d8 (0x1bc4d8 - 0x1bc5ac)
    ctx->pc = 0x1bc558;
    FUN_001bc4d8(rdram, ctx, runtime);
}

void entry_1bc594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc594 inside FUN_001bc4d8 (0x1bc4d8 - 0x1bc5ac)
    ctx->pc = 0x1bc594;
    FUN_001bc4d8(rdram, ctx, runtime);
}

void entry_1bc5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc5a4 inside FUN_001bc4d8 (0x1bc4d8 - 0x1bc5ac)
    ctx->pc = 0x1bc5a4;
    FUN_001bc4d8(rdram, ctx, runtime);
}

void entry_1bc5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc5bc inside entry_1bc5ac (0x1bc5ac - 0x1bc644)
    ctx->pc = 0x1bc5bc;
    entry_1bc5ac(rdram, ctx, runtime);
}

void entry_1bc5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc5e8 inside entry_1bc5ac (0x1bc5ac - 0x1bc644)
    ctx->pc = 0x1bc5e8;
    entry_1bc5ac(rdram, ctx, runtime);
}

void entry_1bc5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc5fc inside entry_1bc5ac (0x1bc5ac - 0x1bc644)
    ctx->pc = 0x1bc5fc;
    entry_1bc5ac(rdram, ctx, runtime);
}

void entry_1bc610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc610 inside entry_1bc5ac (0x1bc5ac - 0x1bc644)
    ctx->pc = 0x1bc610;
    entry_1bc5ac(rdram, ctx, runtime);
}

void entry_1bc614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc614 inside entry_1bc5ac (0x1bc5ac - 0x1bc644)
    ctx->pc = 0x1bc614;
    entry_1bc5ac(rdram, ctx, runtime);
}

void entry_1bc620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc620 inside entry_1bc5ac (0x1bc5ac - 0x1bc644)
    ctx->pc = 0x1bc620;
    entry_1bc5ac(rdram, ctx, runtime);
}

void entry_1bc63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc63c inside entry_1bc5ac (0x1bc5ac - 0x1bc644)
    ctx->pc = 0x1bc63c;
    entry_1bc5ac(rdram, ctx, runtime);
}

void entry_1bc6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc6d8 inside FUN_001bc670 (0x1bc670 - 0x1bc6f4)
    ctx->pc = 0x1bc6d8;
    FUN_001bc670(rdram, ctx, runtime);
}

void entry_1bc6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc6e0 inside FUN_001bc670 (0x1bc670 - 0x1bc6f4)
    ctx->pc = 0x1bc6e0;
    FUN_001bc670(rdram, ctx, runtime);
}

void entry_1bc704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc704 inside entry_1bc6f4 (0x1bc6f4 - 0x1bc710)
    ctx->pc = 0x1bc704;
    entry_1bc6f4(rdram, ctx, runtime);
}

void entry_1bc7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc7b0 inside RenumberSo__FP2SOPiPP2SO (0x1bc760 - 0x1bc7d0)
    ctx->pc = 0x1bc7b0;
    RenumberSo__FP2SOPiPP2SO(rdram, ctx, runtime);
}

void entry_1bc7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc7e0 inside entry_1bc7d0 (0x1bc7d0 - 0x1bc7f8)
    ctx->pc = 0x1bc7e0;
    entry_1bc7d0(rdram, ctx, runtime);
}

void entry_1bc860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc860 inside PropagateSoForce__FP2SOiP2XPiP2DZP2FX (0x1bc828 - 0x1bc8d0)
    ctx->pc = 0x1bc860;
    PropagateSoForce__FP2SOiP2XPiP2DZP2FX(rdram, ctx, runtime);
}

void entry_1bc880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc880 inside PropagateSoForce__FP2SOiP2XPiP2DZP2FX (0x1bc828 - 0x1bc8d0)
    ctx->pc = 0x1bc880;
    PropagateSoForce__FP2SOiP2XPiP2DZP2FX(rdram, ctx, runtime);
}

void entry_1bc890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc890 inside PropagateSoForce__FP2SOiP2XPiP2DZP2FX (0x1bc828 - 0x1bc8d0)
    ctx->pc = 0x1bc890;
    PropagateSoForce__FP2SOiP2XPiP2DZP2FX(rdram, ctx, runtime);
}

void entry_1bc928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc928 inside entry_1bc924 (0x1bc924 - 0x1bc978)
    ctx->pc = 0x1bc928;
    entry_1bc924(rdram, ctx, runtime);
}

void entry_1bc95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc95c inside entry_1bc924 (0x1bc924 - 0x1bc978)
    ctx->pc = 0x1bc95c;
    entry_1bc924(rdram, ctx, runtime);
}

void entry_1bc9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bc9d8 inside DistributeSoEffects__FP2SOiiPP2SOP2FX (0x1bc978 - 0x1bca0c)
    ctx->pc = 0x1bc9d8;
    DistributeSoEffects__FP2SOiiPP2SOP2FX(rdram, ctx, runtime);
}

void entry_1bca44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bca44 inside entry_1bca0c (0x1bca0c - 0x1bca60)
    ctx->pc = 0x1bca44;
    entry_1bca0c(rdram, ctx, runtime);
}

void entry_1bcae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcae4 inside entry_1bca78 (0x1bca78 - 0x1bcc88)
    ctx->pc = 0x1bcae4;
    entry_1bca78(rdram, ctx, runtime);
}

void entry_1bcb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcb88 inside entry_1bca78 (0x1bca78 - 0x1bcc88)
    ctx->pc = 0x1bcb88;
    entry_1bca78(rdram, ctx, runtime);
}

void entry_1bcb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcb98 inside entry_1bca78 (0x1bca78 - 0x1bcc88)
    ctx->pc = 0x1bcb98;
    entry_1bca78(rdram, ctx, runtime);
}

void entry_1bcc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcc98 inside entry_1bcc88 (0x1bcc88 - 0x1bcd00)
    ctx->pc = 0x1bcc98;
    entry_1bcc88(rdram, ctx, runtime);
}

void entry_1bcc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcc9c inside entry_1bcc88 (0x1bcc88 - 0x1bcd00)
    ctx->pc = 0x1bcc9c;
    entry_1bcc88(rdram, ctx, runtime);
}

void entry_1bccb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bccb8 inside entry_1bcc88 (0x1bcc88 - 0x1bcd00)
    ctx->pc = 0x1bccb8;
    entry_1bcc88(rdram, ctx, runtime);
}

void entry_1bccc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bccc8 inside entry_1bcc88 (0x1bcc88 - 0x1bcd00)
    ctx->pc = 0x1bccc8;
    entry_1bcc88(rdram, ctx, runtime);
}

void entry_1bcd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcd68 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcd68;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcd98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcd98 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcd98;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcd9c inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcd9c;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcdd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcdd0 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcdd0;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcde0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcde0 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcde0;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcdec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcdec inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcdec;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcdf4 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcdf4;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bce20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bce20 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bce20;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bce5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bce5c inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bce5c;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bce80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bce80 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bce80;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bce9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bce9c inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bce9c;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcea4 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bcea4;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bceac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bceac inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bceac;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bceb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bceb4 inside SolveSwGroup__FP2SWiPP2SOiPP2XPfi (0x1bcd00 - 0x1bcebc)
    ctx->pc = 0x1bceb4;
    SolveSwGroup__FP2SWiPP2SOiPP2XPfi(rdram, ctx, runtime);
}

void entry_1bcf18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcf18 inside entry_1bcefc (0x1bcefc - 0x1bcf2c)
    ctx->pc = 0x1bcf18;
    entry_1bcefc(rdram, ctx, runtime);
}

void entry_1bcf60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcf60 inside entry_1bcf50 (0x1bcf50 - 0x1bcf98)
    ctx->pc = 0x1bcf60;
    entry_1bcf50(rdram, ctx, runtime);
}

void entry_1bcf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcf70 inside entry_1bcf50 (0x1bcf50 - 0x1bcf98)
    ctx->pc = 0x1bcf70;
    entry_1bcf50(rdram, ctx, runtime);
}

void entry_1bcf8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcf8c inside entry_1bcf50 (0x1bcf50 - 0x1bcf98)
    ctx->pc = 0x1bcf8c;
    entry_1bcf50(rdram, ctx, runtime);
}

void entry_1bcfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcfb8 inside entry_1bcf98 (0x1bcf98 - 0x1bd010)
    ctx->pc = 0x1bcfb8;
    entry_1bcf98(rdram, ctx, runtime);
}

void entry_1bcff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcff0 inside entry_1bcf98 (0x1bcf98 - 0x1bd010)
    ctx->pc = 0x1bcff0;
    entry_1bcf98(rdram, ctx, runtime);
}

void entry_1bcff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bcff8 inside entry_1bcf98 (0x1bcf98 - 0x1bd010)
    ctx->pc = 0x1bcff8;
    entry_1bcf98(rdram, ctx, runtime);
}

void entry_1bd004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd004 inside entry_1bcf98 (0x1bcf98 - 0x1bd010)
    ctx->pc = 0x1bd004;
    entry_1bcf98(rdram, ctx, runtime);
}

void entry_1bd008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd008 inside entry_1bcf98 (0x1bcf98 - 0x1bd010)
    ctx->pc = 0x1bd008;
    entry_1bcf98(rdram, ctx, runtime);
}

void entry_1bd020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd020 inside entry_1bd010 (0x1bd010 - 0x1bd08c)
    ctx->pc = 0x1bd020;
    entry_1bd010(rdram, ctx, runtime);
}

void entry_1bd040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd040 inside entry_1bd010 (0x1bd010 - 0x1bd08c)
    ctx->pc = 0x1bd040;
    entry_1bd010(rdram, ctx, runtime);
}

void entry_1bd06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd06c inside entry_1bd010 (0x1bd010 - 0x1bd08c)
    ctx->pc = 0x1bd06c;
    entry_1bd010(rdram, ctx, runtime);
}

void entry_1bd074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd074 inside entry_1bd010 (0x1bd010 - 0x1bd08c)
    ctx->pc = 0x1bd074;
    entry_1bd010(rdram, ctx, runtime);
}

void entry_1bd080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd080 inside entry_1bd010 (0x1bd010 - 0x1bd08c)
    ctx->pc = 0x1bd080;
    entry_1bd010(rdram, ctx, runtime);
}

void entry_1bd0bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd0bc inside entry_1bd0b8 (0x1bd0b8 - 0x1bd0f4)
    ctx->pc = 0x1bd0bc;
    entry_1bd0b8(rdram, ctx, runtime);
}

void entry_1bd0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd0d8 inside entry_1bd0b8 (0x1bd0b8 - 0x1bd0f4)
    ctx->pc = 0x1bd0d8;
    entry_1bd0b8(rdram, ctx, runtime);
}

void entry_1bd130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd130 inside entry_1bd118 (0x1bd118 - 0x1bd148)
    ctx->pc = 0x1bd130;
    entry_1bd118(rdram, ctx, runtime);
}

void entry_1bd154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd154 inside entry_1bd148 (0x1bd148 - 0x1bd164)
    ctx->pc = 0x1bd154;
    entry_1bd148(rdram, ctx, runtime);
}

void entry_1bd168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd168 inside entry_1bd164 (0x1bd164 - 0x1bd17c)
    ctx->pc = 0x1bd168;
    entry_1bd164(rdram, ctx, runtime);
}

void entry_1bd1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd1a0 inside entry_1bd18c (0x1bd18c - 0x1bd1ec)
    ctx->pc = 0x1bd1a0;
    entry_1bd18c(rdram, ctx, runtime);
}

void entry_1bd1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd1e0 inside entry_1bd18c (0x1bd18c - 0x1bd1ec)
    ctx->pc = 0x1bd1e0;
    entry_1bd18c(rdram, ctx, runtime);
}

void entry_1bd21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd21c inside entry_1bd218 (0x1bd218 - 0x1bd2c4)
    ctx->pc = 0x1bd21c;
    entry_1bd218(rdram, ctx, runtime);
}

void entry_1bd240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd240 inside entry_1bd218 (0x1bd218 - 0x1bd2c4)
    ctx->pc = 0x1bd240;
    entry_1bd218(rdram, ctx, runtime);
}

void entry_1bd260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd260 inside entry_1bd218 (0x1bd218 - 0x1bd2c4)
    ctx->pc = 0x1bd260;
    entry_1bd218(rdram, ctx, runtime);
}

void entry_1bd2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd2e0 inside entry_1bd2c4 (0x1bd2c4 - 0x1bd2ec)
    ctx->pc = 0x1bd2e0;
    entry_1bd2c4(rdram, ctx, runtime);
}

void entry_1bd31c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd31c inside entry_1bd318 (0x1bd318 - 0x1bd35c)
    ctx->pc = 0x1bd31c;
    entry_1bd318(rdram, ctx, runtime);
}

void entry_1bd338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd338 inside entry_1bd318 (0x1bd318 - 0x1bd35c)
    ctx->pc = 0x1bd338;
    entry_1bd318(rdram, ctx, runtime);
}

void entry_1bd33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd33c inside entry_1bd318 (0x1bd318 - 0x1bd35c)
    ctx->pc = 0x1bd33c;
    entry_1bd318(rdram, ctx, runtime);
}

void entry_1bd394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd394 inside entry_1bd38c (0x1bd38c - 0x1bd3b8)
    ctx->pc = 0x1bd394;
    entry_1bd38c(rdram, ctx, runtime);
}

void entry_1bd3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd3bc inside entry_1bd3b8 (0x1bd3b8 - 0x1bd400)
    ctx->pc = 0x1bd3bc;
    entry_1bd3b8(rdram, ctx, runtime);
}

void entry_1bd3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd3d0 inside entry_1bd3b8 (0x1bd3b8 - 0x1bd400)
    ctx->pc = 0x1bd3d0;
    entry_1bd3b8(rdram, ctx, runtime);
}

void entry_1bd408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd408 inside entry_1bd400 (0x1bd400 - 0x1bd420)
    ctx->pc = 0x1bd408;
    entry_1bd400(rdram, ctx, runtime);
}

void entry_1bd424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd424 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd424;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd440 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd440;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd474 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd474;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd488 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd488;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd4a8 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd4a8;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd4d4 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd4d4;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd4f0 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd4f0;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd514 inside entry_1bd420 (0x1bd420 - 0x1bd51c)
    ctx->pc = 0x1bd514;
    entry_1bd420(rdram, ctx, runtime);
}

void entry_1bd520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd520 inside entry_1bd51c (0x1bd51c - 0x1bd558)
    ctx->pc = 0x1bd520;
    entry_1bd51c(rdram, ctx, runtime);
}

void entry_1bd570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd570 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd570;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd590 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd590;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd5b0 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd5b0;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd5d0 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd5d0;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd5f0 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd5f0;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd610 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd610;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd614 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd614;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd620 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd620;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd62c inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd62c;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd650 inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd650;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd66c inside CpxpBuildXpArray__FiPP2SOiPP2XP (0x1bd558 - 0x1bd678)
    ctx->pc = 0x1bd66c;
    CpxpBuildXpArray__FiPP2SOiPP2XP(rdram, ctx, runtime);
}

void entry_1bd6a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd6a0 inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd6a0;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd6e0 inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd6e0;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd714 inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd714;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd71c inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd71c;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd728 inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd728;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd72c inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd72c;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd734 inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd734;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd768 inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd768;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd784 inside BuildContactGroup__FP2SOPiPP2SOT1T2 (0x1bd678 - 0x1bd790)
    ctx->pc = 0x1bd784;
    BuildContactGroup__FP2SOPiPP2SOT1T2(rdram, ctx, runtime);
}

void entry_1bd80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd80c inside SplitSoFreeze__FP2SOi (0x1bd790 - 0x1bd888)
    ctx->pc = 0x1bd80c;
    SplitSoFreeze__FP2SOi(rdram, ctx, runtime);
}

void entry_1bd910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd910 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd910;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bd940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd940 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd940;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bd974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd974 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd974;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bd978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd978 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd978;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bd998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd998 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd998;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bd9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd9a8 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd9a8;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bd9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd9b0 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd9b0;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bd9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bd9e0 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bd9e0;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bda18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bda18 inside entry_1bd8f4 (0x1bd8f4 - 0x1bda24)
    ctx->pc = 0x1bda18;
    entry_1bd8f4(rdram, ctx, runtime);
}

void entry_1bdac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdac4 inside entry_1bdaa8 (0x1bdaa8 - 0x1bdadc)
    ctx->pc = 0x1bdac4;
    entry_1bdaa8(rdram, ctx, runtime);
}

void entry_1bdae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdae4 inside entry_1bdadc (0x1bdadc - 0x1bdaec)
    ctx->pc = 0x1bdae4;
    entry_1bdadc(rdram, ctx, runtime);
}

void entry_1bdb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdb10 inside entry_1bdaec (0x1bdaec - 0x1bdb48)
    ctx->pc = 0x1bdb10;
    entry_1bdaec(rdram, ctx, runtime);
}

void entry_1bdb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdb2c inside entry_1bdaec (0x1bdaec - 0x1bdb48)
    ctx->pc = 0x1bdb2c;
    entry_1bdaec(rdram, ctx, runtime);
}

void entry_1bdb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdb70 inside entry_1bdb48 (0x1bdb48 - 0x1bdbf4)
    ctx->pc = 0x1bdb70;
    entry_1bdb48(rdram, ctx, runtime);
}

void entry_1bdb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdb8c inside entry_1bdb48 (0x1bdb48 - 0x1bdbf4)
    ctx->pc = 0x1bdb8c;
    entry_1bdb48(rdram, ctx, runtime);
}

void entry_1bdba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdba8 inside entry_1bdb48 (0x1bdb48 - 0x1bdbf4)
    ctx->pc = 0x1bdba8;
    entry_1bdb48(rdram, ctx, runtime);
}

void entry_1bdbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdbe8 inside entry_1bdb48 (0x1bdb48 - 0x1bdbf4)
    ctx->pc = 0x1bdbe8;
    entry_1bdb48(rdram, ctx, runtime);
}

void entry_1bdc0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdc0c inside entry_1bdbf4 (0x1bdbf4 - 0x1bdc38)
    ctx->pc = 0x1bdc0c;
    entry_1bdbf4(rdram, ctx, runtime);
}

void entry_1bdc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdc20 inside entry_1bdbf4 (0x1bdbf4 - 0x1bdc38)
    ctx->pc = 0x1bdc20;
    entry_1bdbf4(rdram, ctx, runtime);
}

void entry_1bdc50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdc50 inside entry_1bdc38 (0x1bdc38 - 0x1bdc9c)
    ctx->pc = 0x1bdc50;
    entry_1bdc38(rdram, ctx, runtime);
}

void entry_1bdc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdc90 inside entry_1bdc38 (0x1bdc38 - 0x1bdc9c)
    ctx->pc = 0x1bdc90;
    entry_1bdc38(rdram, ctx, runtime);
}

void entry_1bdcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdcb4 inside entry_1bdc9c (0x1bdc9c - 0x1bdd00)
    ctx->pc = 0x1bdcb4;
    entry_1bdc9c(rdram, ctx, runtime);
}

void entry_1bdcc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdcc8 inside entry_1bdc9c (0x1bdc9c - 0x1bdd00)
    ctx->pc = 0x1bdcc8;
    entry_1bdc9c(rdram, ctx, runtime);
}

void entry_1bdccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdccc inside entry_1bdc9c (0x1bdc9c - 0x1bdd00)
    ctx->pc = 0x1bdccc;
    entry_1bdc9c(rdram, ctx, runtime);
}

void entry_1bddc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bddc8 inside entry_1bdd6c (0x1bdd6c - 0x1bde08)
    ctx->pc = 0x1bddc8;
    entry_1bdd6c(rdram, ctx, runtime);
}

void entry_1bddf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bddf0 inside entry_1bdd6c (0x1bdd6c - 0x1bde08)
    ctx->pc = 0x1bddf0;
    entry_1bdd6c(rdram, ctx, runtime);
}

void entry_1bde0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bde0c inside entry_1bde08 (0x1bde08 - 0x1bde78)
    ctx->pc = 0x1bde0c;
    entry_1bde08(rdram, ctx, runtime);
}

void entry_1bde20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bde20 inside entry_1bde08 (0x1bde08 - 0x1bde78)
    ctx->pc = 0x1bde20;
    entry_1bde08(rdram, ctx, runtime);
}

void entry_1bde2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bde2c inside entry_1bde08 (0x1bde08 - 0x1bde78)
    ctx->pc = 0x1bde2c;
    entry_1bde08(rdram, ctx, runtime);
}

void entry_1bde38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bde38 inside entry_1bde08 (0x1bde08 - 0x1bde78)
    ctx->pc = 0x1bde38;
    entry_1bde08(rdram, ctx, runtime);
}

void entry_1bdeb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdeb0 inside entry_1bde78 (0x1bde78 - 0x1bdf74)
    ctx->pc = 0x1bdeb0;
    entry_1bde78(rdram, ctx, runtime);
}

void entry_1bded4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bded4 inside entry_1bde78 (0x1bde78 - 0x1bdf74)
    ctx->pc = 0x1bded4;
    entry_1bde78(rdram, ctx, runtime);
}

void entry_1bdedc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdedc inside entry_1bde78 (0x1bde78 - 0x1bdf74)
    ctx->pc = 0x1bdedc;
    entry_1bde78(rdram, ctx, runtime);
}

void entry_1bdf10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdf10 inside entry_1bde78 (0x1bde78 - 0x1bdf74)
    ctx->pc = 0x1bdf10;
    entry_1bde78(rdram, ctx, runtime);
}

void entry_1bdf34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdf34 inside entry_1bde78 (0x1bde78 - 0x1bdf74)
    ctx->pc = 0x1bdf34;
    entry_1bde78(rdram, ctx, runtime);
}

void entry_1bdf3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdf3c inside entry_1bde78 (0x1bde78 - 0x1bdf74)
    ctx->pc = 0x1bdf3c;
    entry_1bde78(rdram, ctx, runtime);
}

void entry_1bdf58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdf58 inside entry_1bde78 (0x1bde78 - 0x1bdf74)
    ctx->pc = 0x1bdf58;
    entry_1bde78(rdram, ctx, runtime);
}

void entry_1bdf84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdf84 inside entry_1bdf74 (0x1bdf74 - 0x1bdfa0)
    ctx->pc = 0x1bdf84;
    entry_1bdf74(rdram, ctx, runtime);
}

void entry_1bdfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdfb0 inside entry_1bdfa0 (0x1bdfa0 - 0x1bdfb8)
    ctx->pc = 0x1bdfb0;
    entry_1bdfa0(rdram, ctx, runtime);
}

void entry_1bdfcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdfcc inside entry_1bdfc8 (0x1bdfc8 - 0x1be034)
    ctx->pc = 0x1bdfcc;
    entry_1bdfc8(rdram, ctx, runtime);
}

void entry_1bdfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdfdc inside entry_1bdfc8 (0x1bdfc8 - 0x1be034)
    ctx->pc = 0x1bdfdc;
    entry_1bdfc8(rdram, ctx, runtime);
}

void entry_1bdfe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdfe0 inside entry_1bdfc8 (0x1bdfc8 - 0x1be034)
    ctx->pc = 0x1bdfe0;
    entry_1bdfc8(rdram, ctx, runtime);
}

void entry_1bdfec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bdfec inside entry_1bdfc8 (0x1bdfc8 - 0x1be034)
    ctx->pc = 0x1bdfec;
    entry_1bdfc8(rdram, ctx, runtime);
}

void entry_1be010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be010 inside entry_1bdfc8 (0x1bdfc8 - 0x1be034)
    ctx->pc = 0x1be010;
    entry_1bdfc8(rdram, ctx, runtime);
}

void entry_1be02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be02c inside entry_1bdfc8 (0x1bdfc8 - 0x1be034)
    ctx->pc = 0x1be02c;
    entry_1bdfc8(rdram, ctx, runtime);
}

void entry_1be080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be080 inside SwapEntries__FPviii (0x1be068 - 0x1be0a8)
    ctx->pc = 0x1be080;
    SwapEntries__FPviii(rdram, ctx, runtime);
}

void entry_1be0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be0a0 inside SwapEntries__FPviii (0x1be068 - 0x1be0a8)
    ctx->pc = 0x1be0a0;
    SwapEntries__FPviii(rdram, ctx, runtime);
}

void entry_1be0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be0f8 inside HeapSort__FPviiPFPvPv_i (0x1be0a8 - 0x1be118)
    ctx->pc = 0x1be0f8;
    HeapSort__FPviiPFPvPv_i(rdram, ctx, runtime);
}

void entry_1be108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be108 inside HeapSort__FPviiPFPvPv_i (0x1be0a8 - 0x1be118)
    ctx->pc = 0x1be108;
    HeapSort__FPviiPFPvPv_i(rdram, ctx, runtime);
}

void entry_1be128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be128 inside entry_1be118 (0x1be118 - 0x1be164)
    ctx->pc = 0x1be128;
    entry_1be118(rdram, ctx, runtime);
}

void entry_1be148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be148 inside entry_1be118 (0x1be118 - 0x1be164)
    ctx->pc = 0x1be148;
    entry_1be118(rdram, ctx, runtime);
}

void entry_1be16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be16c inside entry_1be164 (0x1be164 - 0x1be180)
    ctx->pc = 0x1be16c;
    entry_1be164(rdram, ctx, runtime);
}

void entry_1be1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be1b8 inside entry_1be198 (0x1be198 - 0x1be1e8)
    ctx->pc = 0x1be1b8;
    entry_1be198(rdram, ctx, runtime);
}

void entry_1be244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be244 inside entry_1be238 (0x1be238 - 0x1be268)
    ctx->pc = 0x1be244;
    entry_1be238(rdram, ctx, runtime);
}

void entry_1be2bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be2bc inside SbpEnsureBank__Fi (0x1be268 - 0x1be2e0)
    ctx->pc = 0x1be2bc;
    SbpEnsureBank__Fi(rdram, ctx, runtime);
}

void entry_1be2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be2d8 inside SbpEnsureBank__Fi (0x1be268 - 0x1be2e0)
    ctx->pc = 0x1be2d8;
    SbpEnsureBank__Fi(rdram, ctx, runtime);
}

void entry_1be310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be310 inside entry_1be30c (0x1be30c - 0x1be318)
    ctx->pc = 0x1be310;
    entry_1be30c(rdram, ctx, runtime);
}

void entry_1be33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be33c inside entry_1be338 (0x1be338 - 0x1be344)
    ctx->pc = 0x1be33c;
    entry_1be338(rdram, ctx, runtime);
}

void entry_1be364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be364 inside entry_1be344 (0x1be344 - 0x1be398)
    ctx->pc = 0x1be364;
    entry_1be344(rdram, ctx, runtime);
}

void entry_1be384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be384 inside entry_1be344 (0x1be344 - 0x1be398)
    ctx->pc = 0x1be384;
    entry_1be344(rdram, ctx, runtime);
}

void entry_1be390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be390 inside entry_1be344 (0x1be344 - 0x1be398)
    ctx->pc = 0x1be390;
    entry_1be344(rdram, ctx, runtime);
}

void entry_1be410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be410 inside entry_1be3d0 (0x1be3d0 - 0x1be430)
    ctx->pc = 0x1be410;
    entry_1be3d0(rdram, ctx, runtime);
}

void entry_1be448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be448 inside entry_1be430 (0x1be430 - 0x1be4a8)
    ctx->pc = 0x1be448;
    entry_1be430(rdram, ctx, runtime);
}

void entry_1be44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be44c inside entry_1be430 (0x1be430 - 0x1be4a8)
    ctx->pc = 0x1be44c;
    entry_1be430(rdram, ctx, runtime);
}

void entry_1be450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be450 inside entry_1be430 (0x1be430 - 0x1be4a8)
    ctx->pc = 0x1be450;
    entry_1be430(rdram, ctx, runtime);
}

void entry_1be464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be464 inside entry_1be430 (0x1be430 - 0x1be4a8)
    ctx->pc = 0x1be464;
    entry_1be430(rdram, ctx, runtime);
}

void entry_1be468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be468 inside entry_1be430 (0x1be430 - 0x1be4a8)
    ctx->pc = 0x1be468;
    entry_1be430(rdram, ctx, runtime);
}

void entry_1be470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be470 inside entry_1be430 (0x1be430 - 0x1be4a8)
    ctx->pc = 0x1be470;
    entry_1be430(rdram, ctx, runtime);
}

void entry_1be478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be478 inside entry_1be430 (0x1be430 - 0x1be4a8)
    ctx->pc = 0x1be478;
    entry_1be430(rdram, ctx, runtime);
}

void entry_1be5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be5b4 inside entry_1be5b0 (0x1be5b0 - 0x1be5d8)
    ctx->pc = 0x1be5b4;
    entry_1be5b0(rdram, ctx, runtime);
}

void entry_1be644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be644 inside entry_1be640 (0x1be640 - 0x1be64c)
    ctx->pc = 0x1be644;
    entry_1be640(rdram, ctx, runtime);
}

void entry_1be6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be6f0 inside entry_1be6ec (0x1be6ec - 0x1be708)
    ctx->pc = 0x1be6f0;
    entry_1be6ec(rdram, ctx, runtime);
}

void entry_1be764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be764 inside entry_1be760 (0x1be760 - 0x1be76c)
    ctx->pc = 0x1be764;
    entry_1be760(rdram, ctx, runtime);
}

void entry_1be798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be798 inside entry_1be76c (0x1be76c - 0x1be7c8)
    ctx->pc = 0x1be798;
    entry_1be76c(rdram, ctx, runtime);
}

void entry_1be850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be850 inside entry_1be84c (0x1be84c - 0x1be860)
    ctx->pc = 0x1be850;
    entry_1be84c(rdram, ctx, runtime);
}

void entry_1be8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be8c0 inside RefreshPambVolPan__FP3AMB (0x1be860 - 0x1be8ec)
    ctx->pc = 0x1be8c0;
    RefreshPambVolPan__FP3AMB(rdram, ctx, runtime);
}

void entry_1be8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be8e4 inside RefreshPambVolPan__FP3AMB (0x1be860 - 0x1be8ec)
    ctx->pc = 0x1be8e4;
    RefreshPambVolPan__FP3AMB(rdram, ctx, runtime);
}

void entry_1be91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be91c inside FUN_001be8f8 (0x1be8f8 - 0x1be948)
    ctx->pc = 0x1be91c;
    FUN_001be8f8(rdram, ctx, runtime);
}

void entry_1be970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be970 inside entry_1be96c (0x1be96c - 0x1be980)
    ctx->pc = 0x1be970;
    entry_1be96c(rdram, ctx, runtime);
}

void entry_1be9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be9d8 inside entry_1be9cc (0x1be9cc - 0x1bea04)
    ctx->pc = 0x1be9d8;
    entry_1be9cc(rdram, ctx, runtime);
}

void entry_1be9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be9e0 inside entry_1be9cc (0x1be9cc - 0x1bea04)
    ctx->pc = 0x1be9e0;
    entry_1be9cc(rdram, ctx, runtime);
}

void entry_1be9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1be9fc inside entry_1be9cc (0x1be9cc - 0x1bea04)
    ctx->pc = 0x1be9fc;
    entry_1be9cc(rdram, ctx, runtime);
}

void entry_1bea14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bea14 inside entry_1bea04 (0x1bea04 - 0x1bea28)
    ctx->pc = 0x1bea14;
    entry_1bea04(rdram, ctx, runtime);
}

void entry_1beab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beab0 inside entry_1beaa4 (0x1beaa4 - 0x1beac8)
    ctx->pc = 0x1beab0;
    entry_1beaa4(rdram, ctx, runtime);
}

void entry_1beaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beaf4 inside entry_1beae4 (0x1beae4 - 0x1beb10)
    ctx->pc = 0x1beaf4;
    entry_1beae4(rdram, ctx, runtime);
}

void entry_1beb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beb04 inside entry_1beae4 (0x1beae4 - 0x1beb10)
    ctx->pc = 0x1beb04;
    entry_1beae4(rdram, ctx, runtime);
}

void entry_1beb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beb40 inside entry_1beb38 (0x1beb38 - 0x1bebb0)
    ctx->pc = 0x1beb40;
    entry_1beb38(rdram, ctx, runtime);
}

void entry_1beb6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beb6c inside entry_1beb38 (0x1beb38 - 0x1bebb0)
    ctx->pc = 0x1beb6c;
    entry_1beb38(rdram, ctx, runtime);
}

void entry_1beb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beb88 inside entry_1beb38 (0x1beb38 - 0x1bebb0)
    ctx->pc = 0x1beb88;
    entry_1beb38(rdram, ctx, runtime);
}

void entry_1beb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beb9c inside entry_1beb38 (0x1beb38 - 0x1bebb0)
    ctx->pc = 0x1beb9c;
    entry_1beb38(rdram, ctx, runtime);
}

void entry_1beba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beba8 inside entry_1beb38 (0x1beb38 - 0x1bebb0)
    ctx->pc = 0x1beba8;
    entry_1beb38(rdram, ctx, runtime);
}

void entry_1bebc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bebc8 inside entry_1bebb8 (0x1bebb8 - 0x1bebd0)
    ctx->pc = 0x1bebc8;
    entry_1bebb8(rdram, ctx, runtime);
}

void entry_1bebec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bebec inside entry_1bebdc (0x1bebdc - 0x1bec24)
    ctx->pc = 0x1bebec;
    entry_1bebdc(rdram, ctx, runtime);
}

void entry_1bec0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bec0c inside entry_1bebdc (0x1bebdc - 0x1bec24)
    ctx->pc = 0x1bec0c;
    entry_1bebdc(rdram, ctx, runtime);
}

void entry_1bec40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bec40 inside entry_1bec3c (0x1bec3c - 0x1bec58)
    ctx->pc = 0x1bec40;
    entry_1bec3c(rdram, ctx, runtime);
}

void entry_1bec80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bec80 inside entry_1bec6c (0x1bec6c - 0x1bec88)
    ctx->pc = 0x1bec80;
    entry_1bec6c(rdram, ctx, runtime);
}

void entry_1beca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beca4 inside entry_1bec90 (0x1bec90 - 0x1becd4)
    ctx->pc = 0x1beca4;
    entry_1bec90(rdram, ctx, runtime);
}

void entry_1bece8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bece8 inside entry_1becd4 (0x1becd4 - 0x1becf8)
    ctx->pc = 0x1bece8;
    entry_1becd4(rdram, ctx, runtime);
}

void entry_1becec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1becec inside entry_1becd4 (0x1becd4 - 0x1becf8)
    ctx->pc = 0x1becec;
    entry_1becd4(rdram, ctx, runtime);
}

void entry_1bee98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bee98 inside KillExcitement__Fv (0x1bee48 - 0x1beea0)
    ctx->pc = 0x1bee98;
    KillExcitement__Fv(rdram, ctx, runtime);
}

void entry_1beebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1beebc inside entry_1beea0 (0x1beea0 - 0x1beec4)
    ctx->pc = 0x1beebc;
    entry_1beea0(rdram, ctx, runtime);
}

void entry_1bef44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bef44 inside entry_1bef24 (0x1bef24 - 0x1bef88)
    ctx->pc = 0x1bef44;
    entry_1bef24(rdram, ctx, runtime);
}

void entry_1bef68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bef68 inside entry_1bef24 (0x1bef24 - 0x1bef88)
    ctx->pc = 0x1bef68;
    entry_1bef24(rdram, ctx, runtime);
}

void entry_1bef70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bef70 inside entry_1bef24 (0x1bef24 - 0x1bef88)
    ctx->pc = 0x1bef70;
    entry_1bef24(rdram, ctx, runtime);
}

void entry_1bef74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bef74 inside entry_1bef24 (0x1bef24 - 0x1bef88)
    ctx->pc = 0x1bef74;
    entry_1bef24(rdram, ctx, runtime);
}

void entry_1befd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1befd8 inside entry_1befc8 (0x1befc8 - 0x1bf048)
    ctx->pc = 0x1befd8;
    entry_1befc8(rdram, ctx, runtime);
}

void entry_1bf000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf000 inside entry_1befc8 (0x1befc8 - 0x1bf048)
    ctx->pc = 0x1bf000;
    entry_1befc8(rdram, ctx, runtime);
}

void entry_1bf014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf014 inside entry_1befc8 (0x1befc8 - 0x1bf048)
    ctx->pc = 0x1bf014;
    entry_1befc8(rdram, ctx, runtime);
}

void entry_1bf02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf02c inside entry_1befc8 (0x1befc8 - 0x1bf048)
    ctx->pc = 0x1bf02c;
    entry_1befc8(rdram, ctx, runtime);
}

void entry_1bf094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf094 inside entry_1bf084 (0x1bf084 - 0x1bf0a4)
    ctx->pc = 0x1bf094;
    entry_1bf084(rdram, ctx, runtime);
}

void entry_1bf0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf0c0 inside entry_1bf0b8 (0x1bf0b8 - 0x1bf0d8)
    ctx->pc = 0x1bf0c0;
    entry_1bf0b8(rdram, ctx, runtime);
}

void entry_1bf0c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf0c4 inside entry_1bf0b8 (0x1bf0b8 - 0x1bf0d8)
    ctx->pc = 0x1bf0c4;
    entry_1bf0b8(rdram, ctx, runtime);
}

void entry_1bf11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf11c inside entry_1bf118 (0x1bf118 - 0x1bf130)
    ctx->pc = 0x1bf11c;
    entry_1bf118(rdram, ctx, runtime);
}

void entry_1bf224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf224 inside CalculateVolPan__FfP6VECTORPfT2fff (0x1bf200 - 0x1bf2e0)
    ctx->pc = 0x1bf224;
    CalculateVolPan__FfP6VECTORPfT2fff(rdram, ctx, runtime);
}

void entry_1bf2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf2d0 inside CalculateVolPan__FfP6VECTORPfT2fff (0x1bf200 - 0x1bf2e0)
    ctx->pc = 0x1bf2d0;
    CalculateVolPan__FfP6VECTORPfT2fff(rdram, ctx, runtime);
}

void entry_1bf2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf2d8 inside CalculateVolPan__FfP6VECTORPfT2fff (0x1bf200 - 0x1bf2e0)
    ctx->pc = 0x1bf2d8;
    CalculateVolPan__FfP6VECTORPfT2fff(rdram, ctx, runtime);
}

void entry_1bf40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf40c inside entry_1bf400 (0x1bf400 - 0x1bf428)
    ctx->pc = 0x1bf40c;
    entry_1bf400(rdram, ctx, runtime);
}

void entry_1bf414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf414 inside entry_1bf400 (0x1bf400 - 0x1bf428)
    ctx->pc = 0x1bf414;
    entry_1bf400(rdram, ctx, runtime);
}

void entry_1bf558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf558 inside entry_1bf550 (0x1bf550 - 0x1bf578)
    ctx->pc = 0x1bf558;
    entry_1bf550(rdram, ctx, runtime);
}

void entry_1bf55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf55c inside entry_1bf550 (0x1bf550 - 0x1bf578)
    ctx->pc = 0x1bf55c;
    entry_1bf550(rdram, ctx, runtime);
}

void entry_1bf5c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf5c4 inside entry_1bf5a4 (0x1bf5a4 - 0x1bf5e0)
    ctx->pc = 0x1bf5c4;
    entry_1bf5a4(rdram, ctx, runtime);
}

void entry_1bf5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf5c8 inside entry_1bf5a4 (0x1bf5a4 - 0x1bf5e0)
    ctx->pc = 0x1bf5c8;
    entry_1bf5a4(rdram, ctx, runtime);
}

void entry_1bf5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf5cc inside entry_1bf5a4 (0x1bf5a4 - 0x1bf5e0)
    ctx->pc = 0x1bf5cc;
    entry_1bf5a4(rdram, ctx, runtime);
}

void entry_1bf68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf68c inside entry_1bf684 (0x1bf684 - 0x1bf6b8)
    ctx->pc = 0x1bf68c;
    entry_1bf684(rdram, ctx, runtime);
}

void entry_1bf698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf698 inside entry_1bf684 (0x1bf684 - 0x1bf6b8)
    ctx->pc = 0x1bf698;
    entry_1bf684(rdram, ctx, runtime);
}

void entry_1bf748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf748 inside RemoveAmb__FP3AMB (0x1bf728 - 0x1bf764)
    ctx->pc = 0x1bf748;
    RemoveAmb__FP3AMB(rdram, ctx, runtime);
}

void entry_1bf7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf7b4 inside entry_1bf7ac (0x1bf7ac - 0x1bf7e0)
    ctx->pc = 0x1bf7b4;
    entry_1bf7ac(rdram, ctx, runtime);
}

void entry_1bf850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf850 inside SetPambFrq__FP3AMBf (0x1bf7f8 - 0x1bf878)
    ctx->pc = 0x1bf850;
    SetPambFrq__FP3AMBf(rdram, ctx, runtime);
}

void entry_1bf884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf884 inside entry_1bf878 (0x1bf878 - 0x1bf8d4)
    ctx->pc = 0x1bf884;
    entry_1bf878(rdram, ctx, runtime);
}

void entry_1bf8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf8cc inside entry_1bf878 (0x1bf878 - 0x1bf8d4)
    ctx->pc = 0x1bf8cc;
    entry_1bf878(rdram, ctx, runtime);
}

void entry_1bf8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf8d8 inside entry_1bf8d4 (0x1bf8d4 - 0x1bf8e8)
    ctx->pc = 0x1bf8d8;
    entry_1bf8d4(rdram, ctx, runtime);
}

void entry_1bf8dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf8dc inside entry_1bf8d4 (0x1bf8d4 - 0x1bf8e8)
    ctx->pc = 0x1bf8dc;
    entry_1bf8d4(rdram, ctx, runtime);
}

void entry_1bf9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bf9c8 inside entry_1bf9a4 (0x1bf9a4 - 0x1bfa08)
    ctx->pc = 0x1bf9c8;
    entry_1bf9a4(rdram, ctx, runtime);
}

void entry_1bfa28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfa28 inside entry_1bfa08 (0x1bfa08 - 0x1bfab4)
    ctx->pc = 0x1bfa28;
    entry_1bfa08(rdram, ctx, runtime);
}

void entry_1bfa34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfa34 inside entry_1bfa08 (0x1bfa08 - 0x1bfab4)
    ctx->pc = 0x1bfa34;
    entry_1bfa08(rdram, ctx, runtime);
}

void entry_1bfa54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfa54 inside entry_1bfa08 (0x1bfa08 - 0x1bfab4)
    ctx->pc = 0x1bfa54;
    entry_1bfa08(rdram, ctx, runtime);
}

void entry_1bfa60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfa60 inside entry_1bfa08 (0x1bfa08 - 0x1bfab4)
    ctx->pc = 0x1bfa60;
    entry_1bfa08(rdram, ctx, runtime);
}

void entry_1bfa70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfa70 inside entry_1bfa08 (0x1bfa08 - 0x1bfab4)
    ctx->pc = 0x1bfa70;
    entry_1bfa08(rdram, ctx, runtime);
}

void entry_1bfa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfa90 inside entry_1bfa08 (0x1bfa08 - 0x1bfab4)
    ctx->pc = 0x1bfa90;
    entry_1bfa08(rdram, ctx, runtime);
}

void entry_1bfa98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfa98 inside entry_1bfa08 (0x1bfa08 - 0x1bfab4)
    ctx->pc = 0x1bfa98;
    entry_1bfa08(rdram, ctx, runtime);
}

void entry_1bfb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfb40 inside entry_1bfb24 (0x1bfb24 - 0x1bfbac)
    ctx->pc = 0x1bfb40;
    entry_1bfb24(rdram, ctx, runtime);
}

void entry_1bfb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfb68 inside entry_1bfb24 (0x1bfb24 - 0x1bfbac)
    ctx->pc = 0x1bfb68;
    entry_1bfb24(rdram, ctx, runtime);
}

void entry_1bfbd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfbd8 inside entry_1bfbd0 (0x1bfbd0 - 0x1bfbf8)
    ctx->pc = 0x1bfbd8;
    entry_1bfbd0(rdram, ctx, runtime);
}

void entry_1bfbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfbe0 inside entry_1bfbd0 (0x1bfbd0 - 0x1bfbf8)
    ctx->pc = 0x1bfbe0;
    entry_1bfbd0(rdram, ctx, runtime);
}

void entry_1bfbe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfbe4 inside entry_1bfbd0 (0x1bfbd0 - 0x1bfbf8)
    ctx->pc = 0x1bfbe4;
    entry_1bfbd0(rdram, ctx, runtime);
}

void entry_1bfcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfcb8 inside entry_1bfca8 (0x1bfca8 - 0x1bfcd8)
    ctx->pc = 0x1bfcb8;
    entry_1bfca8(rdram, ctx, runtime);
}

void entry_1bfd7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfd7c inside StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9 (0x1bfcd8 - 0x1bfd84)
    ctx->pc = 0x1bfd7c;
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime);
}

void entry_1bfd8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfd8c inside entry_1bfd84 (0x1bfd84 - 0x1bfdfc)
    ctx->pc = 0x1bfd8c;
    entry_1bfd84(rdram, ctx, runtime);
}

void entry_1bfd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfd90 inside entry_1bfd84 (0x1bfd84 - 0x1bfdfc)
    ctx->pc = 0x1bfd90;
    entry_1bfd84(rdram, ctx, runtime);
}

void entry_1bfda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfda8 inside entry_1bfd84 (0x1bfd84 - 0x1bfdfc)
    ctx->pc = 0x1bfda8;
    entry_1bfd84(rdram, ctx, runtime);
}

void entry_1bfdcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfdcc inside entry_1bfd84 (0x1bfd84 - 0x1bfdfc)
    ctx->pc = 0x1bfdcc;
    entry_1bfd84(rdram, ctx, runtime);
}

void entry_1bfe44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfe44 inside entry_1bfe1c (0x1bfe1c - 0x1bfe84)
    ctx->pc = 0x1bfe44;
    entry_1bfe1c(rdram, ctx, runtime);
}

void entry_1bfe6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfe6c inside entry_1bfe1c (0x1bfe1c - 0x1bfe84)
    ctx->pc = 0x1bfe6c;
    entry_1bfe1c(rdram, ctx, runtime);
}

void entry_1bfe94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfe94 inside entry_1bfe84 (0x1bfe84 - 0x1bfe9c)
    ctx->pc = 0x1bfe94;
    entry_1bfe84(rdram, ctx, runtime);
}

void entry_1bff20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bff20 inside entry_1bff0c (0x1bff0c - 0x1bff28)
    ctx->pc = 0x1bff20;
    entry_1bff0c(rdram, ctx, runtime);
}

void entry_1bff30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bff30 inside entry_1bff28 (0x1bff28 - 0x1bff38)
    ctx->pc = 0x1bff30;
    entry_1bff28(rdram, ctx, runtime);
}

void entry_1bff8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bff8c inside entry_1bff88 (0x1bff88 - 0x1bffc8)
    ctx->pc = 0x1bff8c;
    entry_1bff88(rdram, ctx, runtime);
}

void entry_1bfff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1bfff8 inside FUN_001BFFC8 (0x1bffc8 - 0x1c0000)
    ctx->pc = 0x1bfff8;
    FUN_001BFFC8(rdram, ctx, runtime);
}

