// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1a0008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0008: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a000c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0010: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0014: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a001c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0020; return;
}


// Function: TouchFlake__FP5FLAKEi
// Address: 0x1a0020 - 0x1a0034

void entry_1a0034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0034: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0038: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSpark__FP5SPARKP6VECTORfP2SO
// Address: 0x1a0040 - 0x1a0054

void entry_1a0054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0054: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1a0058: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a005c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a0060: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a0064: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a0068: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x1a006c: 0x24845c50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23632));
    // 0x1a0070: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x1a0074: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1a0078: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a007c: 0x8c621cf8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 7416)));
    // 0x1a0080: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0084: 0xae020020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    // 0x1a0088: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a008c: 0xe6000120
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 288), *(uint32_t*)&val); }
    // 0x1a0090: 0x7e030040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 3));
    // 0x1a0094: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0098: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderSpark__FP5SPARKP2CM
// Address: 0x1a00a0 - 0x1a0194

void entry_1a0194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0194) {
        switch (ctx->pc) {
            case 0x1a019c: ctx->pc = 0; goto label_1a019c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0194: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A01AC; return;
    }
label_1a019c:
    // 0x1a019c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a01a0: 0xc049a2e
    SET_GPR_U32(ctx, 31, 0x1a01a8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 128));
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime); return;
}


// Function: entry_1a01a8
// Address: 0x1a01a8 - 0x1a01b8

void entry_1a01a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a01a8) {
        switch (ctx->pc) {
            case 0x1a01ac: ctx->pc = 0; goto label_1a01ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a01a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a01ac:
    // 0x1a01ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a01b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a01b8; return;
}


// Function: InitBurst__FP5BURSTP6VECTORfP2SO
// Address: 0x1a01b8 - 0x1a01dc

void entry_1a01dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a01dc: 0x26320030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 48));
    // 0x1a01e0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a01e4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a01e8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a01ec: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a01f0: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1a01f4: 0xe620001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 28), *(uint32_t*)&val); }
    // 0x1a01f8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a01fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a0200: 0x2610b560
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294948192));
    // 0x1a0204: 0x8c621cfc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 7420)));
    // 0x1a0208: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1a0210);
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1a0210
// Address: 0x1a0210 - 0x1a0220

void entry_1a0210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0210: 0x7bb10000
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0214: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a0218: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1a0220);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0220
// Address: 0x1a0220 - 0x1a022c

void entry_1a0220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0220: 0x7ba50010
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0224: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1a022c);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a022c
// Address: 0x1a022c - 0x1a0238

void entry_1a022c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a022c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a0230: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1a0238);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0238
// Address: 0x1a0238 - 0x1a0258

void entry_1a0238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0238: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a023c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a0240: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a0244: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a0248: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1a024c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0254: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0258; return;
}


// Function: InitTrail__FP5TRAILP6VECTORfP2SO
// Address: 0x1a0258 - 0x1a027c

void entry_1a027c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a027c: 0x26120030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 48));
    // 0x1a0280: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a0284: 0x3c01c170
    SET_GPR_U32(ctx, 1, ((uint32_t)49520 << 16));
    // 0x1a0288: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a028c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a0290: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a0294: 0x2463b570
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294948208));
    // 0x1a0298: 0x3c013eb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16051 << 16));
    // 0x1a029c: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1a02a0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a02a4: 0x8c821d04
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 7428)));
    // 0x1a02a8: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x1a02ac: 0xe60000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 176), *(uint32_t*)&val); }
    // 0x1a02b0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a02b4: 0xae020020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    // 0x1a02b8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a02bc: 0x2631b580
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294948224));
    // 0x1a02c0: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a02c4: 0xe601001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x1a02c8: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1a02d0);
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 2));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1a02d0
// Address: 0x1a02d0 - 0x1a02e0

void entry_1a02d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a02d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a02d4: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a02d8: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1a02e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a02e0
// Address: 0x1a02e0 - 0x1a02ec

void entry_1a02e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a02e0: 0x7ba50010
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a02e4: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1a02ec);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a02ec
// Address: 0x1a02ec - 0x1a02f8

void entry_1a02ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a02ec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a02f0: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1a02f8);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a02f8
// Address: 0x1a02f8 - 0x1a0318

void entry_1a02f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a02f8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a02fc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a0300: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a0304: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a0308: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1a030c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0314: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0318; return;
}


// Function: OnTrailRemove__FP5TRAIL
// Address: 0x1a0318 - 0x1a032c

void entry_1a032c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a032c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0330: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetTrailTrls__FP5TRAIL4TRLSPv
// Address: 0x1a0338 - 0x1a0390

void entry_1a0390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0390) {
        switch (ctx->pc) {
            case 0x1a03a4: ctx->pc = 0; goto label_1a03a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0390: 0x56200013
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 17));
        ctx->pc = 0x1A03E0; return;
    }
    // 0x1a0398: 0x8e030124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 292)));
    // 0x1a039c: 0x1000000e
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A03D8; return;
    }
label_1a03a4:
    // 0x1a03a4: 0x3c05001a
    SET_GPR_U32(ctx, 5, ((uint32_t)26 << 16));
    // 0x1a03a8: 0x24a50950
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 2384));
    // 0x1a03ac: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a03b0: 0x8c620078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 120)));
    // 0x1a03b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a03bc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a03bc
// Address: 0x1a03bc - 0x1a043c

void entry_1a03bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a03bc) {
        switch (ctx->pc) {
            case 0x1a03d4: ctx->pc = 0; goto label_1a03d4;
            case 0x1a03d8: ctx->pc = 0; goto label_1a03d8;
            case 0x1a03e0: ctx->pc = 0; goto label_1a03e0;
            case 0x1a0404: ctx->pc = 0; goto label_1a0404;
            case 0x1a0414: ctx->pc = 0; goto label_1a0414;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a03bc: 0x56200008
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 17));
        goto label_1a03e0;
    }
    // 0x1a03c4: 0x52400003
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 296)));
        goto label_1a03d4;
    }
    // 0x1a03cc: 0x10000002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a03d8;
    }
label_1a03d4:
    // 0x1a03d4: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
label_1a03d8:
    // 0x1a03d8: 0x7e020090
    WRITE128(ADD32(GPR_U32(ctx, 16), 144), GPR_VEC(ctx, 2));
    // 0x1a03dc: 0xae110120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 17));
label_1a03e0:
    // 0x1a03e0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a03e4: 0x1222000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_1a0414;
    }
    // 0x1a03ec: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_1a0404;
    }
    // 0x1a03f4: 0x12200021
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A047C; return;
    }
    // 0x1a03fc: 0x10000023
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A048C; return;
    }
label_1a0404:
    // 0x1a0404: 0x1222000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A0444; return;
    }
    // 0x1a040c: 0x1000001f
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A048C; return;
    }
label_1a0414:
    // 0x1a0414: 0x7a420080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 128)));
    // 0x1a0418: 0x3c05001a
    SET_GPR_U32(ctx, 5, ((uint32_t)26 << 16));
    // 0x1a041c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a0420: 0x24a50950
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 2384));
    // 0x1a0424: 0x7e020080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), GPR_VEC(ctx, 2));
    // 0x1a0428: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a042c: 0x7a4200a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1a0430: 0xae120124
    WRITE32(ADD32(GPR_U32(ctx, 16), 292), GPR_U32(ctx, 18));
    // 0x1a0434: 0xc067e46
    SET_GPR_U32(ctx, 31, 0x1a043c);
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), GPR_VEC(ctx, 2));
    SubscribeRipStruct__FP3RIPPFPv5MSGIDPv_vPv(rdram, ctx, runtime); return;
}


// Function: entry_1a043c
// Address: 0x1a043c - 0x1a0474

void entry_1a043c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a043c) {
        switch (ctx->pc) {
            case 0x1a0444: ctx->pc = 0; goto label_1a0444;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a043c: 0x10000012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A0488; return;
    }
label_1a0444:
    // 0x1a0444: 0x7a420140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1a0448: 0x3c05001a
    SET_GPR_U32(ctx, 5, ((uint32_t)26 << 16));
    // 0x1a044c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a0450: 0x24a50950
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 2384));
    // 0x1a0454: 0x7e020080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), GPR_VEC(ctx, 2));
    // 0x1a0458: 0x7a420150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1a045c: 0xae120128
    WRITE32(ADD32(GPR_U32(ctx, 16), 296), GPR_U32(ctx, 18));
    // 0x1a0460: 0x7e0200a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), GPR_VEC(ctx, 2));
    // 0x1a0464: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a0468: 0x8c620074
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 116)));
    // 0x1a046c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a0474);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a0474
// Address: 0x1a0474 - 0x1a04a0

void entry_1a0474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0474) {
        switch (ctx->pc) {
            case 0x1a047c: ctx->pc = 0; goto label_1a047c;
            case 0x1a0484: ctx->pc = 0; goto label_1a0484;
            case 0x1a0488: ctx->pc = 0; goto label_1a0488;
            case 0x1a048c: ctx->pc = 0; goto label_1a048c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0474: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a0488;
    }
label_1a047c:
    // 0x1a047c: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a0480: 0xfa0100a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), _mm_castps_si128(ctx->vu0_vf[1]));
label_1a0484:
    // 0x1a0484: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1a0488:
    // 0x1a0488: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a048c:
    // 0x1a048c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0490: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0494: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a049c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a04a0; return;
}


// Function: DetachTrail__FP5TRAIL
// Address: 0x1a04a0 - 0x1a04c0

void entry_1a04c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a04c0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a04c4: 0x1220003b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A05B4; return;
    }
    // 0x1a04cc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a04d0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a04d4: 0x26050080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 128));
    // 0x1a04d8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a04dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a04e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a04e4
// Address: 0x1a04e4 - 0x1a059c

void entry_1a04e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a04e4) {
        switch (ctx->pc) {
            case 0x1a0588: ctx->pc = 0; goto label_1a0588;
            case 0x1a0590: ctx->pc = 0; goto label_1a0590;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a04e4: 0x8e030020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1a04e8: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a04ec: 0xae230020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 3));
    // 0x1a04f0: 0xc60000b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 176)); ctx->f[0] = *(float*)&val; }
    // 0x1a04f4: 0xe62000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 176), *(uint32_t*)&val); }
    // 0x1a04f8: 0x7a020040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1a04fc: 0x7e220040
    WRITE128(ADD32(GPR_U32(ctx, 17), 64), GPR_VEC(ctx, 2));
    // 0x1a0500: 0xc600001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[0] = *(float*)&val; }
    // 0x1a0504: 0xe620001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 28), *(uint32_t*)&val); }
    // 0x1a0508: 0x8e020120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a050c: 0x5444001e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 48)));
        goto label_1a0588;
    }
    // 0x1a0514: 0x8e060124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 292)));
    // 0x1a0518: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1a051c: 0xc6000018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1a0520: 0xc4c60018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 24)); ctx->f[6] = *(float*)&val; }
    // 0x1a0524: 0x24c20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 48));
    // 0x1a0528: 0xc4c7001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 28)); ctx->f[7] = *(float*)&val; }
    // 0x1a052c: 0x46060001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[6]);
    // 0x1a0530: 0xc4450008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[5] = *(float*)&val; }
    // 0x1a0534: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1a0538: 0xc462185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[2] = *(float*)&val; }
    // 0x1a053c: 0x46070203
    if (ctx->f[7] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[8] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[8] = ctx->f[0] / ctx->f[7];
    // 0x1a0540: 0xc4c40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 48)); ctx->f[4] = *(float*)&val; }
    // 0x1a0544: 0x46061081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[6]);
    // 0x1a0548: 0xc6010030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[1] = *(float*)&val; }
    // 0x1a054c: 0x46054002
    ctx->f[0] = FPU_MUL_S(ctx->f[8], ctx->f[5]);
    // 0x1a0550: 0x46001800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1a0554: 0x46004002
    ctx->f[0] = FPU_MUL_S(ctx->f[8], ctx->f[0]);
    // 0x1a0558: 0x46071203
    if (ctx->f[7] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[8] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[8] = ctx->f[2] / ctx->f[7];
    // 0x1a055c: 0x46002000
    ctx->f[0] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x1a0560: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1a0564: 0x46054142
    ctx->f[5] = FPU_MUL_S(ctx->f[8], ctx->f[5]);
    // 0x1a0568: 0x460518c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[5]);
    // 0x1a056c: 0x460340c2
    ctx->f[3] = FPU_MUL_S(ctx->f[8], ctx->f[3]);
    // 0x1a0570: 0x46032100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[3]);
    // 0x1a0574: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x1a0578: 0x46000807
    ctx->f[0] = FPU_NEG_S(ctx->f[1]);
    // 0x1a057c: 0xe6210030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    // 0x1a0580: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 52), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a0590;
    }
label_1a0588:
    // 0x1a0588: 0x7e220030
    WRITE128(ADD32(GPR_U32(ctx, 17), 48), GPR_VEC(ctx, 2));
    // 0x1a058c: 0x8e060128
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 296)));
label_1a0590:
    // 0x1a0590: 0x8e050120
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a0594: 0xc0680ce
    SET_GPR_U32(ctx, 31, 0x1a059c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetTrailTrls__FP5TRAIL4TRLSPv(rdram, ctx, runtime); return;
}


// Function: entry_1a059c
// Address: 0x1a059c - 0x1a05ac

void entry_1a059c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a059c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a05a0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a05a4: 0xc0680ce
    SET_GPR_U32(ctx, 31, 0x1a05ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetTrailTrls__FP5TRAIL4TRLSPv(rdram, ctx, runtime); return;
}


// Function: entry_1a05ac
// Address: 0x1a05ac - 0x1a05c4

void entry_1a05ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a05ac) {
        switch (ctx->pc) {
            case 0x1a05b4: ctx->pc = 0; goto label_1a05b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a05ac: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A05C8; return;
    }
label_1a05b4:
    // 0x1a05b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a05b8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a05bc: 0xc0680ce
    SET_GPR_U32(ctx, 31, 0x1a05c4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTrailTrls__FP5TRAIL4TRLSPv(rdram, ctx, runtime); return;
}


// Function: entry_1a05c4
// Address: 0x1a05c4 - 0x1a05d8

void entry_1a05c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a05c4) {
        switch (ctx->pc) {
            case 0x1a05c8: ctx->pc = 0; goto label_1a05c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a05c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a05c8:
    // 0x1a05c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a05cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a05d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectTrailTransform__FP5TRAILf
// Address: 0x1a05d8 - 0x1a06f8

void entry_1a06f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a06f8) {
        switch (ctx->pc) {
            case 0x1a0700: ctx->pc = 0; goto label_1a0700;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a06f8: 0x10000014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A074C; return;
    }
label_1a0700:
    // 0x1a0700: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a0704: 0xd8810080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 128)));
    // 0x1a0708: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a070c: 0x3c01441c
    SET_GPR_U32(ctx, 1, ((uint32_t)17436 << 16));
    // 0x1a0710: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1a0714: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a0718: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a071c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a0720: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a0724: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a0728: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a072c: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1a0730: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a0734: 0x0
    // NOP
    // 0x1a0738: 0x45000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A074C; return;
    }
    // 0x1a0740: 0xc068128
    SET_GPR_U32(ctx, 31, 0x1a0748);
    DetachTrail__FP5TRAIL(rdram, ctx, runtime); return;
}


// Function: entry_1a0748
// Address: 0x1a0748 - 0x1a0758

void entry_1a0748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0748) {
        switch (ctx->pc) {
            case 0x1a074c: ctx->pc = 0; goto label_1a074c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0748: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a074c:
    // 0x1a074c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0754: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0758; return;
}


// Function: RenderTrail__FP5TRAILP2CM
// Address: 0x1a0758 - 0x1a0784

void entry_1a0784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0784) {
        switch (ctx->pc) {
            case 0x1a078c: ctx->pc = 0; goto label_1a078c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0784: 0x1000006c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A0938; return;
    }
label_1a078c:
    // 0x1a078c: 0xc46c02a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 680)); ctx->f[12] = *(float*)&val; }
    // 0x1a0790: 0x4be00153
    // Unhandled VU0 Special1 function: 0x13
    // 0x1a0794: 0xda020080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1a0798: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a079c: 0xda210040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x1a07a0: 0x4be111ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a07a4: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x1a07a8: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a07ac: 0xda230050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1a07b0: 0xda220060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 96)));
    // 0x1a07b4: 0xda210070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 112)));
    // 0x1a07b8: 0x4be619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1a07bc: 0x4be610bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1a07c0: 0x4be608be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[6] = READ32(addr); }
    // 0x1a07c4: 0x4be428fc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1a07c8: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a07cc: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a07d0: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a07d4: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a07d8: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x1a07dc: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x1a07e0: 0x14400007
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A0800; return;
    }
    // 0x1a07e8: 0xc46d0080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 128)); ctx->f[13] = *(float*)&val; }
    // 0x1a07ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a07f0: 0x48253000
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1a07f4: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x1a07fc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_1a07fc
// Address: 0x1a07fc - 0x1a0924

void entry_1a07fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a07fc) {
        switch (ctx->pc) {
            case 0x1a0800: ctx->pc = 0; goto label_1a0800;
            case 0x1a0860: ctx->pc = 0; goto label_1a0860;
            case 0x1a0870: ctx->pc = 0; goto label_1a0870;
            case 0x1a08d8: ctx->pc = 0; goto label_1a08d8;
            case 0x1a08e8: ctx->pc = 0; goto label_1a08e8;
            case 0x1a08f4: ctx->pc = 0; goto label_1a08f4;
            case 0x1a08fc: ctx->pc = 0; goto label_1a08fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a07fc: 0x2202b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1a0800:
    // 0x1a0800: 0x1080004c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1a0934(rdram, ctx, runtime); return;
    }
    // 0x1a0808: 0xc6000018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1a080c: 0xc442185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[2] = *(float*)&val; }
    // 0x1a0810: 0x26030040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 64));
    // 0x1a0814: 0xc603001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[3] = *(float*)&val; }
    // 0x1a0818: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a081c: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1a0820: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a0824: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a0828: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1a082c: 0xc6040040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[4] = *(float*)&val; }
    // 0x1a0830: 0x460310c3
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[3] = ctx->f[2] / ctx->f[3];
    // 0x1a0834: 0xc48d5c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[13] = *(float*)&val; }
    // 0x1a0838: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1a083c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a0840: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1a0844: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x1a0848: 0x460d2034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a084c: 0x0
    // NOP
    // 0x1a0850: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a0860;
    }
    // 0x1a0858: 0x10000005
    ctx->f[4] = FPU_MOV_S(ctx->f[13]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a0870;
    }
label_1a0860:
    // 0x1a0860: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a0864: 0x0
    // NOP
    // 0x1a0868: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[4] = FPU_MOV_S(ctx->f[2]);
        goto label_1a0870;
    }
label_1a0870:
    // 0x1a0870: 0x26020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 48));
    // 0x1a0874: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a0878: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a087c: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1a0880: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a0884: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a0888: 0x46042834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a088c: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1a0890: 0xc6020030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[2] = *(float*)&val; }
    // 0x1a0894: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a0898: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1a089c: 0x45000023
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A092C; return;
    }
    // 0x1a08a4: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a08a8: 0x0
    // NOP
    // 0x1a08ac: 0x4500001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A092C; return;
    }
    // 0x1a08b4: 0x8e030120
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a08b8: 0x1062000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a08e8;
    }
    // 0x1a08c0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a08d8;
    }
    // 0x1a08c8: 0x5060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 144));
        goto label_1a08fc;
    }
    // 0x1a08d0: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a08fc;
    }
label_1a08d8:
    // 0x1a08d8: 0x10620006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a08f4;
    }
    // 0x1a08e0: 0x14620006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1a08fc;
    }
label_1a08e8:
    // 0x1a08e8: 0x8e020124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 292)));
    // 0x1a08ec: 0x10000003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 128));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a08fc;
    }
label_1a08f4:
    // 0x1a08f4: 0x8e020128
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 296)));
    // 0x1a08f8: 0x24520140
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 320));
label_1a08fc:
    // 0x1a08fc: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1a0900: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a0904: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a0908: 0xc7ad0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    // 0x1a090c: 0x26060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 128));
    // 0x1a0910: 0x460c0302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x1a0914: 0x8e040020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1a0918: 0x460d2342
    ctx->f[13] = FPU_MUL_S(ctx->f[4], ctx->f[13]);
    // 0x1a091c: 0xc049a2e
    SET_GPR_U32(ctx, 31, 0x1a0924);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime); return;
}


// Function: entry_1a0924
// Address: 0x1a0924 - 0x1a0934

void entry_1a0924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0924) {
        switch (ctx->pc) {
            case 0x1a092c: ctx->pc = 0; goto label_1a092c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0924: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A0938; return;
    }
label_1a092c:
    // 0x1a092c: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a0934);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a0934
// Address: 0x1a0934 - 0x1a0950

void entry_1a0934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0934) {
        switch (ctx->pc) {
            case 0x1a0938: ctx->pc = 0; goto label_1a0938;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0934: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1a0938:
    // 0x1a0938: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a093c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a0940: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a0944: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a094c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0950; return;
}


// Function: HandleTrailMessage__FP5TRAIL5MSGIDPv
// Address: 0x1a0950 - 0x1a099c

void entry_1a099c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a099c) {
        switch (ctx->pc) {
            case 0x1a09a4: ctx->pc = 0; goto label_1a09a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a099c: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A09B4; return;
    }
label_1a09a4:
    // 0x1a09a4: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x1a09a8: 0xc0680ce
    SET_GPR_U32(ctx, 31, 0x1a09b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTrailTrls__FP5TRAIL4TRLSPv(rdram, ctx, runtime); return;
}


// Function: entry_1a09b0
// Address: 0x1a09b0 - 0x1a09c0

void entry_1a09b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a09b0) {
        switch (ctx->pc) {
            case 0x1a09b4: ctx->pc = 0; goto label_1a09b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a09b0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a09b4:
    // 0x1a09b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a09bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a09c0; return;
}


// Function: InitFireball__FP8FIREBALLP6VECTORfP2SO
// Address: 0x1a09c0 - 0x1a09ec

void entry_1a09ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a09ec: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a09f0: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1a09f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a09f8: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a09fc: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1a0a00: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a0a04: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a0a08: 0x8c621d08
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 7432)));
    // 0x1a0a0c: 0x2610b590
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294948240));
    // 0x1a0a10: 0xe640001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 28), *(uint32_t*)&val); }
    // 0x1a0a14: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1a0a1c);
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 2));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1a0a1c
// Address: 0x1a0a1c - 0x1a0a2c

void entry_1a0a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0a1c: 0x7bb10000
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0a20: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a0a24: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1a0a2c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0a2c
// Address: 0x1a0a2c - 0x1a0a38

void entry_1a0a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0a2c: 0x7ba50010
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0a30: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1a0a38);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0a38
// Address: 0x1a0a38 - 0x1a0a44

void entry_1a0a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0a38: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a0a3c: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1a0a44);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0a44
// Address: 0x1a0a44 - 0x1a0a78

void entry_1a0a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0a44: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a0a48: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a0a4c: 0x2463b5a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294948256));
    // 0x1a0a50: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a0a54: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a0a58: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a0a5c: 0x7e420040
    WRITE128(ADD32(GPR_U32(ctx, 18), 64), GPR_VEC(ctx, 2));
    // 0x1a0a60: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a0a64: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a0a68: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1a0a6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0a74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0a78; return;
}


// Function: UpdateFireball__FP8FIREBALLf
// Address: 0x1a0a78 - 0x1a0a94

void entry_1a0a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0a94: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a0a98: 0xc6020018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[2] = *(float*)&val; }
    // 0x1a0a9c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1a0aa0: 0x3c013e19
    SET_GPR_U32(ctx, 1, ((uint32_t)15897 << 16));
    // 0x1a0aa4: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1a0aa8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1a0aac: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1a0ab0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1a0ab4: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1a0ab8: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a0abc: 0x0
    // NOP
    // 0x1a0ac0: 0x45000012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A0B0C; return;
    }
    // 0x1a0ac8: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a0acc: 0x0
    // NOP
    // 0x1a0ad0: 0x4500000e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A0B0C; return;
    }
    // 0x1a0ad8: 0xc6000038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[0] = *(float*)&val; }
    // 0x1a0adc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a0ae0: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x1a0ae8);
    ctx->f[20] = FPU_NEG_S(ctx->f[0]);
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_1a0ae8
// Address: 0x1a0ae8 - 0x1a0b08

void entry_1a0ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0ae8: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a0b08(rdram, ctx, runtime); return;
    }
    // 0x1a0af0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a0af4: 0x26050080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 128));
    // 0x1a0af8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a0afc: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a0b00: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a0b08);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a0b08
// Address: 0x1a0b08 - 0x1a0b20

void entry_1a0b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0b08) {
        switch (ctx->pc) {
            case 0x1a0b0c: ctx->pc = 0; goto label_1a0b0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0b08: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a0b0c:
    // 0x1a0b0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0b10: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1a0b14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0b1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0b20; return;
}


// Function: InitSmokecloud__FP10SMOKECLOUDP6VECTORfP2SO
// Address: 0x1a0b20 - 0x1a0b34

void entry_1a0b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0b34: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a0b38: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1a0b3c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1a0b40: 0x8c455710
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a0b44: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a0b48: 0xc6000030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1a0b4c: 0x2463b5b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294948272));
    // 0x1a0b50: 0x8ca21d0c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 7436)));
    // 0x1a0b54: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a0b58: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1a0b5c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a0b60: 0x2484b5c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294948288));
    // 0x1a0b64: 0xe602001c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x1a0b68: 0xae020020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    // 0x1a0b6c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1a0b70: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1a0b74: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1a0b78: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a0b7c: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1a0b80: 0x7e020040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 2));
    // 0x1a0b84: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0b88: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a0b8c: 0xe60200b0
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 176), *(uint32_t*)&val); }
    // 0x1a0b90: 0x7e0300c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), GPR_VEC(ctx, 3));
    // 0x1a0b94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0b98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSmoketrail__FP10SMOKETRAILP6VECTORfP2SO
// Address: 0x1a0ba0 - 0x1a0bc4

void entry_1a0bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0bc4: 0x26120030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 48));
    // 0x1a0bc8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a0bcc: 0x3c01c170
    SET_GPR_U32(ctx, 1, ((uint32_t)49520 << 16));
    // 0x1a0bd0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a0bd4: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a0bd8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a0bdc: 0x2463b5d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294948304));
    // 0x1a0be0: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x1a0be4: 0x8c821d10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 7440)));
    // 0x1a0be8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a0bec: 0xe60000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 176), *(uint32_t*)&val); }
    // 0x1a0bf0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a0bf4: 0xae020020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    // 0x1a0bf8: 0x2631b5e0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294948320));
    // 0x1a0bfc: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a0c00: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1a0c08);
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 2));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1a0c08
// Address: 0x1a0c08 - 0x1a0c18

void entry_1a0c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0c08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0c0c: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a0c10: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1a0c18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0c18
// Address: 0x1a0c18 - 0x1a0c24

void entry_1a0c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0c18: 0x7ba50010
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0c1c: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1a0c24);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0c24
// Address: 0x1a0c24 - 0x1a0c30

void entry_1a0c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0c24: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a0c28: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1a0c30);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0c30
// Address: 0x1a0c30 - 0x1a0c50

void entry_1a0c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0c30: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a0c34: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a0c38: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a0c3c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a0c40: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1a0c44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0c4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0c50; return;
}


// Function: InitDebris__FP6DEBRISP6VECTORfP2SO
// Address: 0x1a0c50 - 0x1a0c64

void entry_1a0c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0c64: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a0c68: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a0c6c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a0c70: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a0c74: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0c78: 0x8c831cec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 7404)));
    // 0x1a0c7c: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x1a0c80: 0xae030020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 3));
    // 0x1a0c84: 0x78821ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 7904)));
    // 0x1a0c88: 0x7e0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), GPR_VEC(ctx, 2));
    // 0x1a0c8c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0c90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSmack__FP5SMACKP6VECTORfP2SO
// Address: 0x1a0c98 - 0x1a0cbc

void entry_1a0cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0cbc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a0cc0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a0cc4: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1a0cc8: 0x26260120
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 288));
    // 0x1a0ccc: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1a0cd4);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 304)));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1a0cd4
// Address: 0x1a0cd4 - 0x1a0ce0

void entry_1a0cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0cd4: 0xc60c0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[12] = *(float*)&val; }
    // 0x1a0cd8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a0ce0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a0ce0
// Address: 0x1a0ce0 - 0x1a0cf0

void entry_1a0ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0ce0: 0xc60c0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 36)); ctx->f[12] = *(float*)&val; }
    // 0x1a0ce4: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1a0ce8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a0cf0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a0cf0
// Address: 0x1a0cf0 - 0x1a0d00

void entry_1a0cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0cf0: 0xc60c0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 40)); ctx->f[12] = *(float*)&val; }
    // 0x1a0cf4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1a0cf8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a0d00);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a0d00
// Address: 0x1a0d00 - 0x1a0d60

void entry_1a0d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0d00: 0x4404a800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[21]);
    // 0x1a0d04: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1a0d08: 0x70642488
    SET_GPR_VEC(ctx, 4, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x1a0d0c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a0d10: 0x70642389
    SET_GPR_VEC(ctx, 4, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x1a0d14: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a0d18: 0xc440b5f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948336)); ctx->f[0] = *(float*)&val; }
    // 0x1a0d1c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a0d20: 0x7e2400a0
    WRITE128(ADD32(GPR_U32(ctx, 17), 160), GPR_VEC(ctx, 4));
    // 0x1a0d24: 0x24635c50
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23632));
    // 0x1a0d28: 0xe620001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 28), *(uint32_t*)&val); }
    // 0x1a0d2c: 0x7fa40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 4));
    // 0x1a0d30: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a0d34: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a0d38: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x1a0d3c: 0x7e220040
    WRITE128(ADD32(GPR_U32(ctx, 17), 64), GPR_VEC(ctx, 2));
    // 0x1a0d40: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1a0d44: 0x7a030050
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1a0d48: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0d4c: 0x7e230030
    WRITE128(ADD32(GPR_U32(ctx, 17), 48), GPR_VEC(ctx, 3));
    // 0x1a0d50: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a0d54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0d5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0d60; return;
}


// Function: ProjectSmackTransform__FP5SMACKf
// Address: 0x1a0d60 - 0x1a0dbc

void entry_1a0dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0dbc: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0dc0: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1a0dc4: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a0dc8: 0x26060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 128));
    // 0x1a0dcc: 0x8ca41990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 6544)));
    // 0x1a0dd0: 0x7e030120
    WRITE128(ADD32(GPR_U32(ctx, 16), 288), GPR_VEC(ctx, 3));
    // 0x1a0dd4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a0dd8: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x1a0de0);
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), GPR_VEC(ctx, 2));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_1a0de0
// Address: 0x1a0de0 - 0x1a0df0

void entry_1a0de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0de0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a0de4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a0de8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderSmack__FP5SMACKP2CM
// Address: 0x1a0df0 - 0x1a0e2c

void entry_1a0e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0e2c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a0e30: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1a0e34: 0x26650080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 128));
    // 0x1a0e38: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1a0e40);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1a0e40
// Address: 0x1a0e40 - 0x1a0e54

void entry_1a0e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0e40: 0x27b200d0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1a0e44: 0x27a50170
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 368));
    // 0x1a0e48: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a0e4c: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1a0e54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a0e54
// Address: 0x1a0e54 - 0x1a0e80

void entry_1a0e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0e54: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a0e58: 0xc6210018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1a0e5c: 0xc454185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[20] = *(float*)&val; }
    // 0x1a0e60: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a0e64: 0xc620001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[0] = *(float*)&val; }
    // 0x1a0e68: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1a0e6c: 0x4601a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x1a0e70: 0xc7ac0170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[12] = *(float*)&val; }
    // 0x1a0e74: 0x4600a503
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[0];
    // 0x1a0e78: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1a0e80);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a0e80
// Address: 0x1a0e80 - 0x1a0ea4

void entry_1a0e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0e80: 0x4614a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[20]);
    // 0x1a0e84: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1a0e88: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a0e8c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a0e90: 0x8e240130
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x1a0e94: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1a0e98: 0x460ca302
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    // 0x1a0e9c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1a0ea4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 64));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a0ea4
// Address: 0x1a0ea4 - 0x1a0f60

void entry_1a0ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0ea4: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a0ea8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a0eac: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a0eb0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a0eb4: 0xdba60050
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a0eb8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a0ebc: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a0ec0: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1a0ec4: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a0ec8: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a0ecc: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a0ed0: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a0ed4: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a0ed8: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a0edc: 0x4bc1204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a0ee0: 0xdba50090
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a0ee4: 0x4bc519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1a0ee8: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a0eec: 0x4bc520ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a0ef0: 0xda870020
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x1a0ef4: 0xda240050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1a0ef8: 0x4bc711bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1a0efc: 0x4bc708bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1a0f00: 0x4bc719ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a0f04: 0xda850010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x1a0f08: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1a0f0c: 0x4bc408bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a0f10: 0x4bc4190a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a0f14: 0x4bc511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1a0f18: 0x4bc508bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a0f1c: 0x4bc5194a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a0f20: 0xfba20140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a0f24: 0xfba10150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a0f28: 0xfba30160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a0f2c: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a0f30: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a0f34: 0xfba700c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1a0f38: 0xfba20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a0f3c: 0xfba10120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a0f40: 0xfba30130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a0f44: 0xfba40140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a0f48: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a0f4c: 0xfba50150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a0f50: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a0f54: 0xfba70160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1a0f58: 0xc067d88
    SET_GPR_U32(ctx, 31, 0x1a0f60);
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[7]));
    FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a0f60
// Address: 0x1a0f60 - 0x1a0f88

void entry_1a0f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0f60: 0x7bbf01d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1a0f64: 0x7bb401c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1a0f68: 0x7bb301b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1a0f6c: 0x7bb201a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1a0f70: 0x7bb10190
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1a0f74: 0x7bb00180
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1a0f78: 0xc7b401e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[20] = *(float*)&val; }
    // 0x1a0f7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 496));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0f84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0f88; return;
}


// Function: UpdateSmack__FP5SMACKf
// Address: 0x1a0f88 - 0x1a0fc4

void entry_1a0fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0fc4: 0x8e030130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 304)));
    // 0x1a0fc8: 0x8c620060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 96)));
    // 0x1a0fcc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a0fd4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 308)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a0fd4
// Address: 0x1a0fd4 - 0x1a0fe8

void entry_1a0fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a0fd4) {
        switch (ctx->pc) {
            case 0x1a0fd8: ctx->pc = 0; goto label_1a0fd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a0fd4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a0fd8:
    // 0x1a0fd8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a0fdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a0fe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a0fe8; return;
}


// Function: InitOrbit__FP5ORBITP6VECTORfP2SO
// Address: 0x1a0fe8 - 0x1a0ffc

void entry_1a0ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a0ffc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a1000: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1a1004: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a1008: 0x24425c50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23632));
    // 0x1a100c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a1010: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a1014: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x1a1018: 0x7e030040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 3));
    // 0x1a101c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a1020: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001A1028
// Address: 0x1a1028 - 0x1a1030

void entry_1a11ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a11ec) {
        switch (ctx->pc) {
            case 0x1a12d4: ctx->pc = 0; goto label_1a12d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a11ec: 0xda250050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1a11f0: 0x26230050
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 80));
    // 0x1a11f4: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a11f8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a11fc: 0xdba60010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a1200: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a1204: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a1208: 0x4bc519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1a120c: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a1210: 0x4bc521ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1214: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1a1218: 0xfba70060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1a121c: 0xfba70090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1a1220: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1a1224: 0xd8610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1a1228: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a122c: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a1230: 0x4bc1204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1234: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1238: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a123c: 0xd8620020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1a1240: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a1244: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a1248: 0x4bc220ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a124c: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1250: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1254: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1258: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a125c: 0xfba70030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1a1260: 0xd8820080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 128)));
    // 0x1a1264: 0x4bc2296a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a1268: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a126c: 0x4b05283d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a1270: 0x4b05094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1274: 0x48222800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a1278: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a127c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1280: 0x45000014
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a12d4;
    }
    // 0x1a1288: 0x4bc238aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1a128c: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a1290: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a1294: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1298: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a129c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a12a0: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a12a4: 0x0
    // NOP
    // 0x1a12a8: 0x4500000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a12d4;
    }
    // 0x1a12b0: 0xc6220018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[2] = *(float*)&val; }
    // 0x1a12b4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1a12b8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a12bc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a12c0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1a12c4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a12c8: 0x0
    // NOP
    // 0x1a12cc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1a12d4;
    }
label_1a12d4:
    // 0x1a12d4: 0x10a00024
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A1368; return;
    }
    // 0x1a12dc: 0xda220080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x1a12e0: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a12e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a12e8: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a12ec: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a12f0: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a12f4: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a12f8: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a12fc: 0x8e220120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x1a1300: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a1304: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1a1308: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a130c: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x1a1314);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_1a1314
// Address: 0x1a1314 - 0x1a133c

void entry_1a1314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1314: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a1318: 0x1200000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A1348; return;
    }
    // 0x1a1320: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a1324: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a1328: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a132c: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1a1330: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a1334: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a133c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a133c
// Address: 0x1a133c - 0x1a1360

void entry_1a133c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a133c) {
        switch (ctx->pc) {
            case 0x1a1348: ctx->pc = 0; goto label_1a1348;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a133c: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1a1340: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a1344: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
label_1a1348:
    // 0x1a1348: 0x8e220124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 292)));
    // 0x1a134c: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1a1350: 0x1c400005
    WRITE32(ADD32(GPR_U32(ctx, 17), 292), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x1A1368; return;
    }
    // 0x1a1358: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a1360);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a1360
// Address: 0x1a1360 - 0x1a1398

void entry_1a1360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a1360) {
        switch (ctx->pc) {
            case 0x1a1368: ctx->pc = 0; goto label_1a1368;
            case 0x1a1384: ctx->pc = 0; goto label_1a1384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a1360: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a1384;
    }
label_1a1368:
    // 0x1a1368: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a136c: 0x7ba40040
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a1370: 0x7ba30050
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a1374: 0x7e220050
    WRITE128(ADD32(GPR_U32(ctx, 17), 80), GPR_VEC(ctx, 2));
    // 0x1a1378: 0x7e230070
    WRITE128(ADD32(GPR_U32(ctx, 17), 112), GPR_VEC(ctx, 3));
    // 0x1a137c: 0x7e240060
    WRITE128(ADD32(GPR_U32(ctx, 17), 96), GPR_VEC(ctx, 4));
    // 0x1a1380: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1a1384:
    // 0x1a1384: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1a1388: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a138c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a1394: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a1398; return;
}


// Function: RenderOrbit__FP5ORBITP2CM
// Address: 0x1a1398 - 0x1a1404

void entry_1a1404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1404: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a1408: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitRay__FP3RAYP6VECTORfP2SO
// Address: 0x1a1410 - 0x1a1424

void entry_1a1424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1424: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a1428: 0x3c013e19
    SET_GPR_U32(ctx, 1, ((uint32_t)15897 << 16));
    // 0x1a142c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1a1430: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a1434: 0x8c625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x1a1438: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a143c: 0x8c441d28
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7464)));
    // 0x1a1440: 0xe6000120
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 288), *(uint32_t*)&val); }
    // 0x1a1444: 0xae040020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 4));
    // 0x1a1448: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a144c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a1454: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a1458; return;
}


// Function: InitRose__FP4ROSEP6VECTORfP2SO
// Address: 0x1a1458 - 0x1a146c

void entry_1a146c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a146c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a1470: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a1474: 0x8c625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x1a1478: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a147c: 0x8c441d28
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7464)));
    // 0x1a1480: 0xae050128
    WRITE32(ADD32(GPR_U32(ctx, 16), 296), GPR_U32(ctx, 5));
    // 0x1a1484: 0xae040020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 4));
    // 0x1a1488: 0xae050120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 5));
    // 0x1a148c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a1490: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectRoseTransform__FP4ROSEf
// Address: 0x1a1498 - 0x1a14a0

void entry_1a15a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a15a8) {
        switch (ctx->pc) {
            case 0x1a15b0: ctx->pc = 0; goto label_1a15b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a15a8: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A15CC; return;
    }
label_1a15b0:
    // 0x1a15b0: 0xc06877c
    SET_GPR_U32(ctx, 31, 0x1a15b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime); return;
}


// Function: entry_1a15b8
// Address: 0x1a15b8 - 0x1a15c8

void entry_1a15b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a15b8) {
        switch (ctx->pc) {
            case 0x1a15c0: ctx->pc = 0; goto label_1a15c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a15b8: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A15CC; return;
    }
label_1a15c0:
    // 0x1a15c0: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a15c8);
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a15c8
// Address: 0x1a15c8 - 0x1a15d8

void entry_1a15c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a15c8) {
        switch (ctx->pc) {
            case 0x1a15cc: ctx->pc = 0; goto label_1a15cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a15c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a15cc:
    // 0x1a15cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a15d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a15d8; return;
}


// Function: RenderRose__FP4ROSEP2CM
// Address: 0x1a15d8 - 0x1a170c

void entry_1a170c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a170c) {
        switch (ctx->pc) {
            case 0x1a1768: ctx->pc = 0; goto label_1a1768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a170c: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a1710: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a1714: 0x2841018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a1718: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a171c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a1720: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a1724: 0x5d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1a1728: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x1a172c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a1730: 0xc45ac9b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294953396)); ctx->f[26] = *(float*)&val; }
    // 0x1a1734: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a1738: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1a173c: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a1740: 0x7c830020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
    // 0x1a1744: 0xe7a00c44
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 3140), *(uint32_t*)&val); }
    // 0x1a1748: 0x1a800077
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 3136), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x1A1928; return;
    }
    // 0x1a1750: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a1754: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a1758: 0x247eb660
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 3), 4294948448));
    // 0x1a175c: 0x2457b640
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 4294948416));
    // 0x1a1760: 0x26760040
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 19), 64));
    // 0x1a1764: 0x26720030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 48));
label_1a1768:
    // 0x1a1768: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a176c: 0x2221818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a1770: 0x7d8021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 29)));
    // 0x1a1774: 0xda010040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1a1778: 0xda020010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1a177c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a1780: 0xfba10c50
    WRITE128(ADD32(GPR_U32(ctx, 29), 3152), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1784: 0xc7ac0c54
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3156)); ctx->f[12] = *(float*)&val; }
    // 0x1a1788: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a1790);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3152)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a1790
// Address: 0x1a1790 - 0x1a1b1c

void entry_1a1790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a1790) {
        switch (ctx->pc) {
            case 0x1a17f4: ctx->pc = 0; goto label_1a17f4;
            case 0x1a1808: ctx->pc = 0; goto label_1a1808;
            case 0x1a1850: ctx->pc = 0; goto label_1a1850;
            case 0x1a1864: ctx->pc = 0; goto label_1a1864;
            case 0x1a18d8: ctx->pc = 0; goto label_1a18d8;
            case 0x1a18ec: ctx->pc = 0; goto label_1a18ec;
            case 0x1a1928: ctx->pc = 0; goto label_1a1928;
            case 0x1a1970: ctx->pc = 0; goto label_1a1970;
            case 0x1a1990: ctx->pc = 0; goto label_1a1990;
            case 0x1a19b0: ctx->pc = 0; goto label_1a19b0;
            case 0x1a1a24: ctx->pc = 0; goto label_1a1a24;
            case 0x1a1a34: ctx->pc = 0; goto label_1a1a34;
            case 0x1a1a44: ctx->pc = 0; goto label_1a1a44;
            case 0x1a1a68: ctx->pc = 0; goto label_1a1a68;
            case 0x1a1a80: ctx->pc = 0; goto label_1a1a80;
            case 0x1a1a84: ctx->pc = 0; goto label_1a1a84;
            case 0x1a1a8c: ctx->pc = 0; goto label_1a1a8c;
            case 0x1a1a9c: ctx->pc = 0; goto label_1a1a9c;
            case 0x1a1ab8: ctx->pc = 0; goto label_1a1ab8;
            case 0x1a1b08: ctx->pc = 0; goto label_1a1b08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a1790: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1a1794: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a1798: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a179c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a17a0: 0xc6040018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[4] = *(float*)&val; }
    // 0x1a17a4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a17a8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a17ac: 0x24635c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23648));
    // 0x1a17b0: 0xe6000020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    // 0x1a17b4: 0xc6c20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1a17b8: 0xc6c10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a17bc: 0x4602b882
    ctx->f[2] = FPU_MUL_S(ctx->f[23], ctx->f[2]);
    // 0x1a17c0: 0xc6a001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 484)); ctx->f[0] = *(float*)&val; }
    // 0x1a17c4: 0xc6630040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 64)); ctx->f[3] = *(float*)&val; }
    // 0x1a17c8: 0x460401e8
    ctx->f[7] = std::max(ctx->f[0], ctx->f[4]);
    // 0x1a17cc: 0xc4455c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x1a17d0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1a17d4: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x1a17d8: 0x46011800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1a17dc: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a17e0: 0x0
    // NOP
    // 0x1a17e4: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[6] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a17f4;
    }
    // 0x1a17ec: 0x10000006
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a1808;
    }
label_1a17f4:
    // 0x1a17f4: 0x46003034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a17f8: 0x0
    // NOP
    // 0x1a17fc: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a1808;
    }
    // 0x1a1804: 0x460030c6
    ctx->f[3] = FPU_MOV_S(ctx->f[6]);
label_1a1808:
    // 0x1a1808: 0xc7c00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a180c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a1810: 0xc7c10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a1814: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a1818: 0x46003802
    ctx->f[0] = FPU_MUL_S(ctx->f[7], ctx->f[0]);
    // 0x1a181c: 0xc442b660
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948448)); ctx->f[2] = *(float*)&val; }
    // 0x1a1820: 0xc464b670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294948464)); ctx->f[4] = *(float*)&val; }
    // 0x1a1824: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1a1828: 0x2442b670
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294948464));
    // 0x1a182c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a1830: 0x46013842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x1a1834: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1a1838: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a183c: 0x0
    // NOP
    // 0x1a1840: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a1850;
    }
    // 0x1a1848: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a1864;
    }
label_1a1850:
    // 0x1a1850: 0x46022834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1854: 0x0
    // NOP
    // 0x1a1858: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a1864;
    }
    // 0x1a1860: 0x46002806
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
label_1a1864:
    // 0x1a1864: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1a1868: 0xc7a10c40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3136)); ctx->f[1] = *(float*)&val; }
    // 0x1a186c: 0xc6e20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1a1870: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a1874: 0xc6e30004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1a1878: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a187c: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1a1880: 0x46023882
    ctx->f[2] = FPU_MUL_S(ctx->f[7], ctx->f[2]);
    // 0x1a1884: 0xe7a00c40
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 3136), *(uint32_t*)&val); }
    // 0x1a1888: 0xc464b640
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294948416)); ctx->f[4] = *(float*)&val; }
    // 0x1a188c: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1a1890: 0xc6410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a1894: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a1898: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a189c: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x1a18a0: 0xc445b650
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948432)); ctx->f[5] = *(float*)&val; }
    // 0x1a18a4: 0x460338c2
    ctx->f[3] = FPU_MUL_S(ctx->f[7], ctx->f[3]);
    // 0x1a18a8: 0xc6620030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 48)); ctx->f[2] = *(float*)&val; }
    // 0x1a18ac: 0x2463b650
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294948432));
    // 0x1a18b0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a18b4: 0xc4660004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[6] = *(float*)&val; }
    // 0x1a18b8: 0x46032040
    ctx->f[1] = FPU_ADD_S(ctx->f[4], ctx->f[3]);
    // 0x1a18bc: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1a18c0: 0x46050834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a18c4: 0x0
    // NOP
    // 0x1a18c8: 0x45000003
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a18d8;
    }
    // 0x1a18d0: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a18ec;
    }
label_1a18d8:
    // 0x1a18d8: 0x46013034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a18dc: 0x0
    // NOP
    // 0x1a18e0: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a18ec;
    }
    // 0x1a18e8: 0x46003006
    ctx->f[0] = FPU_MOV_S(ctx->f[6]);
label_1a18ec:
    // 0x1a18ec: 0xdba10c50
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3152)));
    // 0x1a18f0: 0x46001042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1a18f4: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a18f8: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a18fc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1a1900: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a1904: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a1908: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a190c: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x1a1910: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1914: 0x461a0ea9
    ctx->f[26] = std::min(ctx->f[1], ctx->f[26]);
    // 0x1a1918: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1a191c: 0xe6000024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x1a1920: 0x1440ff91
    ctx->f[27] = FPU_ADD_S(ctx->f[27], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A1768; return;
    }
label_1a1928:
    // 0x1a1928: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a192c: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a1930: 0x2841018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a1934: 0x5d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1a1938: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x1a193c: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a1940: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1a1944: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a1948: 0x1a800019
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_1a19b0;
    }
    // 0x1a1950: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a1954: 0x44802000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 0);
    // 0x1a1958: 0xc442b630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948400)); ctx->f[2] = *(float*)&val; }
    // 0x1a195c: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1a1960: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1a1964: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a1968: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1a196c: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1a1970:
    // 0x1a1970: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a1974: 0xc6010050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[1] = *(float*)&val; }
    // 0x1a1978: 0xc6000020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[0] = *(float*)&val; }
    // 0x1a197c: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1a1980: 0x46040036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1984: 0x0
    // NOP
    // 0x1a1988: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
        goto label_1a1990;
    }
label_1a1990:
    // 0x1a1990: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1a1994: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1a1998: 0x26020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 48));
    // 0x1a199c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1a19a0: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1a19a4: 0x4600dec0
    ctx->f[27] = FPU_ADD_S(ctx->f[27], ctx->f[0]);
    // 0x1a19a8: 0x1620fff1
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_1a1970;
    }
label_1a19b0:
    // 0x1a19b0: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a19b4: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a19b8: 0x2841018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a19bc: 0x8e650128
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 296)));
    // 0x1a19c0: 0x5d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1a19c4: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x1a19c8: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a19cc: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1a19d0: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a19d4: 0x4a1001b
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_1a1a44;
    }
    // 0x1a19dc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a19e0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a19e4: 0x2443b680
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294948480));
    // 0x1a19e8: 0xc442b680
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948480)); ctx->f[2] = *(float*)&val; }
    // 0x1a19ec: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a19f0: 0x2482b690
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294948496));
    // 0x1a19f4: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a19f8: 0x4601d842
    ctx->f[1] = FPU_MUL_S(ctx->f[27], ctx->f[1]);
    // 0x1a19fc: 0xc483b690
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294948496)); ctx->f[3] = *(float*)&val; }
    // 0x1a1a00: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a1a04: 0x4600d802
    ctx->f[0] = FPU_MUL_S(ctx->f[27], ctx->f[0]);
    // 0x1a1a08: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1a1a0c: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1a10: 0x0
    // NOP
    // 0x1a1a14: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a1a24;
    }
    // 0x1a1a1c: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a1a34;
    }
label_1a1a24:
    // 0x1a1a24: 0x46022034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1a28: 0x0
    // NOP
    // 0x1a1a2c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[4]);
        goto label_1a1a34;
    }
label_1a1a34:
    // 0x1a1a34: 0x46001024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[2]);
    // 0x1a1a38: 0xe6600128
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 296), *(uint32_t*)&val); }
    // 0x1a1a3c: 0x10000010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a1a80;
    }
label_1a1a44:
    // 0x1a1a44: 0x1a800011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_1a1a8c;
    }
    // 0x1a1a4c: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x1a1a50: 0x8e63012c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 300)));
    // 0x1a1a54: 0x1043000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 20)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_1a1a84;
    }
    // 0x1a1a5c: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1a1a60: 0x27a3002c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 44));
    // 0x1a1a64: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_1a1a68:
    // 0x1a1a68: 0x94102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 20)));
    // 0x1a1a6c: 0x10400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a1a8c;
    }
    // 0x1a1a74: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a1a78: 0x5445fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1a1a68;
    }
label_1a1a80:
    // 0x1a1a80: 0x94102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 20)));
label_1a1a84:
    // 0x1a1a84: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 292)); ctx->f[0] = *(float*)&val; }
        goto label_1a1a9c;
    }
label_1a1a8c:
    // 0x1a1a8c: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x1a1a90: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a1a94: 0xae62012c
    WRITE32(ADD32(GPR_U32(ctx, 19), 300), GPR_U32(ctx, 2));
    // 0x1a1a98: 0xc6600124
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 292)); ctx->f[0] = *(float*)&val; }
label_1a1a9c:
    // 0x1a1a9c: 0xc6610128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 296)); ctx->f[1] = *(float*)&val; }
    // 0x1a1aa0: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1a1aa4: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a1aa8: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x1a1aac: 0x1a8000ba
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[22] = ctx->f[0] / ctx->f[1];
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x1A1D98; return;
    }
    // 0x1a1ab4: 0x0
    // NOP
label_1a1ab8:
    // 0x1a1ab8: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a1abc: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1a1ac0: 0x821818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a1ac4: 0x263e0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1a1ac8: 0x7d8021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 29)));
    // 0x1a1acc: 0xc6000024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 36)); ctx->f[0] = *(float*)&val; }
    // 0x1a1ad0: 0x4600b541
    ctx->f[21] = FPU_SUB_S(ctx->f[22], ctx->f[0]);
    // 0x1a1ad4: 0x4614a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1ad8: 0x0
    // NOP
    // 0x1a1adc: 0x45000050
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 4), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A1C20; return;
    }
    // 0x1a1ae4: 0x4615b601
    ctx->f[24] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    // 0x1a1ae8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a1aec: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1a1af0: 0x26b203a0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 21), 928));
    // 0x1a1af4: 0x27b10c00
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 3072));
    // 0x1a1af8: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x1a1afc: 0x4600a646
    ctx->f[25] = FPU_MOV_S(ctx->f[20]);
    // 0x1a1b00: 0x4614b000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x1a1b04: 0x0
    // NOP
label_1a1b08:
    // 0x1a1b08: 0xc60c0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[12] = *(float*)&val; }
    // 0x1a1b0c: 0x27a50c60
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 3168));
    // 0x1a1b10: 0x26e48d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 4294937856));
    // 0x1a1b14: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1a1b1c);
    if (ctx->f[24] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[23] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[23] = ctx->f[0] / ctx->f[24];
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a1b1c
// Address: 0x1a1b1c - 0x1a1be4

void entry_1a1b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1b1c: 0x461ae802
    ctx->f[0] = FPU_MUL_S(ctx->f[29], ctx->f[26]);
    // 0x1a1b20: 0xda460010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1a1b24: 0xda440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1a1b28: 0x27a40c50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 3152));
    // 0x1a1b2c: 0xdaa103a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 928)));
    // 0x1a1b30: 0x27a50c90
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 3216));
    // 0x1a1b34: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a1b38: 0x27a60cc0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 3264));
    // 0x1a1b3c: 0x48a34000
    ctx->vu0_vf[8] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1a1b40: 0x4617e001
    ctx->f[0] = FPU_SUB_S(ctx->f[28], ctx->f[23]);
    // 0x1a1b44: 0x4402b800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[23]);
    // 0x1a1b48: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a1b4c: 0x48a24800
    ctx->vu0_vf[9] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a1b50: 0x4403d000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[26]);
    // 0x1a1b54: 0x70631c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1a1b58: 0x70631488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1a1b5c: 0xdba20c60
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3168)));
    // 0x1a1b60: 0xdba30c80
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3200)));
    // 0x1a1b64: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a1b68: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a1b6c: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1b70: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a1b74: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a1b78: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1b7c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a1b80: 0xdba50c70
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3184)));
    // 0x1a1b84: 0x48a33800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1a1b88: 0xfba20cd0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3280), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a1b8c: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1a1b90: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a1b94: 0x4bc5204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1b98: 0xfba70cd0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3280), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1a1b9c: 0xfba20c90
    WRITE128(ADD32(GPR_U32(ctx, 29), 3216), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a1ba0: 0xfba10ca0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3232), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1ba4: 0xfba20d00
    WRITE128(ADD32(GPR_U32(ctx, 29), 3328), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a1ba8: 0xfba10d10
    WRITE128(ADD32(GPR_U32(ctx, 29), 3344), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1bac: 0xfba10ce0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3296), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1bb0: 0xfba30d20
    WRITE128(ADD32(GPR_U32(ctx, 29), 3360), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1bb4: 0xfba30cf0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3312), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1bb8: 0xfba30cb0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3248), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1bbc: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a1bc0: 0xfba90cd0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3280), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x1a1bc4: 0xda010030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1a1bc8: 0x4be711bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1a1bcc: 0x4be908bc
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x1a1bd0: 0x4be819c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1bd4: 0x7fa20cc0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3264), GPR_VEC(ctx, 2));
    // 0x1a1bd8: 0xfba70c50
    WRITE128(ADD32(GPR_U32(ctx, 29), 3152), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1a1bdc: 0xc062304
    SET_GPR_U32(ctx, 31, 0x1a1be4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 3280), _mm_castps_si128(ctx->vu0_vf[8]));
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1a1be4
// Address: 0x1a1be4 - 0x1a1bfc

void entry_1a1be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1be4: 0x8e640020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1a1be8: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1a1bec: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a1bf0: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x1a1bf4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a1bfc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a1bfc
// Address: 0x1a1bfc - 0x1a1c94

void entry_1a1bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a1bfc) {
        switch (ctx->pc) {
            case 0x1a1c20: ctx->pc = 0; goto label_1a1c20;
            case 0x1a1c60: ctx->pc = 0; goto label_1a1c60;
            case 0x1a1c80: ctx->pc = 0; goto label_1a1c80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a1bfc: 0xc6600128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 296)); ctx->f[0] = *(float*)&val; }
    // 0x1a1c00: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1a1c04: 0x4600d803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[27] * 0.0f); } else ctx->f[0] = ctx->f[27] / ctx->f[0];
    // 0x1a1c08: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1a1c0c: 0x4614a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x1a1c10: 0x46190834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[25])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1c14: 0x0
    // NOP
    // 0x1a1c18: 0x4503ffbb
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
        ctx->pc = 0x1A1B08; return;
    }
label_1a1c20:
    // 0x1a1c20: 0x4614ad80
    ctx->f[22] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x1a1c24: 0xc6000028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1a1c28: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1a1c2c: 0x4600b541
    ctx->f[21] = FPU_SUB_S(ctx->f[22], ctx->f[0]);
    // 0x1a1c30: 0x4614a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1c34: 0x0
    // NOP
    // 0x1a1c38: 0x4500004e
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 3072));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A1D74; return;
    }
    // 0x1a1c40: 0x4615b641
    ctx->f[25] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    // 0x1a1c44: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1a1c48: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a1c4c: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1a1c50: 0x4600a606
    ctx->f[24] = FPU_MOV_S(ctx->f[20]);
    // 0x1a1c54: 0x26b203a0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 21), 928));
    // 0x1a1c58: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x1a1c5c: 0xc6000050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[0] = *(float*)&val; }
label_1a1c60:
    // 0x1a1c60: 0x4614b040
    ctx->f[1] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x1a1c64: 0xc6020020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[2] = *(float*)&val; }
    // 0x1a1c68: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1a1c6c: 0x46180036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1c70: 0x0
    // NOP
    // 0x1a1c74: 0x45000002
    if (ctx->f[25] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[23] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[23] = ctx->f[1] / ctx->f[25];
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a1c80;
    }
    // 0x1a1c7c: 0x461c0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[28]);
label_1a1c80:
    // 0x1a1c80: 0x4600bb02
    ctx->f[12] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1a1c84: 0x27a50c60
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 3168));
    // 0x1a1c88: 0x26e48d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 4294937856));
    // 0x1a1c8c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1a1c94);
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[12]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a1c94
// Address: 0x1a1c94 - 0x1a1d38

void entry_1a1c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1c94: 0xda460010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1a1c98: 0x461ae802
    ctx->f[0] = FPU_MUL_S(ctx->f[29], ctx->f[26]);
    // 0x1a1c9c: 0xda450020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1a1ca0: 0x27a40c50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 3152));
    // 0x1a1ca4: 0xdaa403a0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 928)));
    // 0x1a1ca8: 0x27a50c90
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 3216));
    // 0x1a1cac: 0xdba10c60
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3168)));
    // 0x1a1cb0: 0x27a60cc0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 3264));
    // 0x1a1cb4: 0xdba30c70
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3184)));
    // 0x1a1cb8: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a1cbc: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a1cc0: 0x4bc1284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1cc4: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a1cc8: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a1ccc: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1cd0: 0xdba20c80
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3200)));
    // 0x1a1cd4: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a1cd8: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a1cdc: 0x4bc2290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1ce0: 0xfba10cd0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3280), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1ce4: 0xfba10c90
    WRITE128(ADD32(GPR_U32(ctx, 29), 3216), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1ce8: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a1cec: 0xfba30ca0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3232), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1cf0: 0xfba10d00
    WRITE128(ADD32(GPR_U32(ctx, 29), 3328), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1cf4: 0xfba30d10
    WRITE128(ADD32(GPR_U32(ctx, 29), 3344), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1cf8: 0xfba30ce0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3296), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a1cfc: 0xfba40d20
    WRITE128(ADD32(GPR_U32(ctx, 29), 3360), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a1d00: 0xfba40cf0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3312), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a1d04: 0xfba40cb0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3248), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a1d08: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a1d0c: 0x48a23800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a1d10: 0x4403d000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[26]);
    // 0x1a1d14: 0xda010030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1a1d18: 0x70631c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1a1d1c: 0x70631488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1a1d20: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a1d24: 0x4be72048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a1d28: 0x7fa20cc0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3264), GPR_VEC(ctx, 2));
    // 0x1a1d2c: 0xfba10c50
    WRITE128(ADD32(GPR_U32(ctx, 29), 3152), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a1d30: 0xc062304
    SET_GPR_U32(ctx, 31, 0x1a1d38);
    WRITE128(ADD32(GPR_U32(ctx, 29), 3280), _mm_castps_si128(ctx->vu0_vf[7]));
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1a1d38
// Address: 0x1a1d38 - 0x1a1d50

void entry_1a1d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1d38: 0x8e640020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1a1d3c: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1a1d40: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a1d44: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x1a1d48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a1d50);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a1d50
// Address: 0x1a1d50 - 0x1a1df0

void entry_1a1d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a1d50) {
        switch (ctx->pc) {
            case 0x1a1d74: ctx->pc = 0; goto label_1a1d74;
            case 0x1a1d88: ctx->pc = 0; goto label_1a1d88;
            case 0x1a1d98: ctx->pc = 0; goto label_1a1d98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a1d50: 0xc6600128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 296)); ctx->f[0] = *(float*)&val; }
    // 0x1a1d54: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1a1d58: 0x4600d803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[27] * 0.0f); } else ctx->f[0] = ctx->f[27] / ctx->f[0];
    // 0x1a1d5c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1a1d60: 0x4614a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x1a1d64: 0x46180834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a1d68: 0x0
    // NOP
    // 0x1a1d6c: 0x4503ffbc
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1A1C60; return;
    }
label_1a1d74:
    // 0x1a1d74: 0x2d4001a
    { int32_t divisor = GPR_S32(ctx, 20); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 22) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 20) % divisor); } else { ctx->lo = (GPR_S32(ctx,22) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,20); } }
    // 0x1a1d78: 0x3c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1a1d7c: 0x4614ad80
    ctx->f[22] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x1a1d80: 0x52800001
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1a1d88;
    }
label_1a1d88:
    // 0x1a1d88: 0x234182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x1a1d8c: 0x1010
    SET_GPR_U32(ctx, 2, ctx->hi);
    // 0x1a1d90: 0x1460ff49
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A1AB8; return;
    }
label_1a1d98:
    // 0x1a1d98: 0x7bbf0dc0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 3520)));
    // 0x1a1d9c: 0x7bbe0db0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 3504)));
    // 0x1a1da0: 0x7bb70da0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 3488)));
    // 0x1a1da4: 0x7bb60d90
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 3472)));
    // 0x1a1da8: 0x7bb50d80
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 3456)));
    // 0x1a1dac: 0x7bb40d70
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 3440)));
    // 0x1a1db0: 0x7bb30d60
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 3424)));
    // 0x1a1db4: 0x7bb20d50
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 3408)));
    // 0x1a1db8: 0x7bb10d40
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 3392)));
    // 0x1a1dbc: 0x7bb00d30
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 3376)));
    // 0x1a1dc0: 0xc7bd0e18
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3608)); ctx->f[29] = *(float*)&val; }
    // 0x1a1dc4: 0xc7bc0e10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3600)); ctx->f[28] = *(float*)&val; }
    // 0x1a1dc8: 0xc7bb0e08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3592)); ctx->f[27] = *(float*)&val; }
    // 0x1a1dcc: 0xc7ba0e00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3584)); ctx->f[26] = *(float*)&val; }
    // 0x1a1dd0: 0xc7b90df8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3576)); ctx->f[25] = *(float*)&val; }
    // 0x1a1dd4: 0xc7b80df0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3568)); ctx->f[24] = *(float*)&val; }
    // 0x1a1dd8: 0xc7b70de8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3560)); ctx->f[23] = *(float*)&val; }
    // 0x1a1ddc: 0xc7b60de0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3552)); ctx->f[22] = *(float*)&val; }
    // 0x1a1de0: 0xc7b50dd8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3544)); ctx->f[21] = *(float*)&val; }
    // 0x1a1de4: 0xc7b40dd0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3536)); ctx->f[20] = *(float*)&val; }
    // 0x1a1de8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 3616));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetRoseRoses__FP4ROSE5ROSES
// Address: 0x1a1df0 - 0x1a1f18

void entry_1a1f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1f6c: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1a1f70: 0xc062178
    SET_GPR_U32(ctx, 31, 0x1a1f78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadIdentityMatrix4__FP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1a1f78
// Address: 0x1a1f78 - 0x1a1fc0

void entry_1a1f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1f78: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a1f7c: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a1f80: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1a1f84: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1a1f88: 0x27a50090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1a1f8c: 0xc4600040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1a1f90: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1a1f94: 0xe7a00030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x1a1f98: 0xc4610044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 68)); ctx->f[1] = *(float*)&val; }
    // 0x1a1f9c: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1a1fa0: 0xe7a10034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    // 0x1a1fa4: 0xc4600048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1a1fa8: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1a1fac: 0xe7a00038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    // 0x1a1fb0: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1a1fb4: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a1fb8: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x1a1fc0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a1fc0
// Address: 0x1a1fc0 - 0x1a2024

void entry_1a1fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a1fc0: 0xc7a200a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[2] = *(float*)&val; }
    // 0x1a1fc4: 0x27a40100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1a1fc8: 0xc7a100a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[1] = *(float*)&val; }
    // 0x1a1fcc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a1fd0: 0xc7a000a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[0] = *(float*)&val; }
    // 0x1a1fd4: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x1a1fd8: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1a1fdc: 0xc7a800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[8] = *(float*)&val; }
    // 0x1a1fe0: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1a1fe4: 0xc7a600b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 180)); ctx->f[6] = *(float*)&val; }
    // 0x1a1fe8: 0xc7a700b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[7] = *(float*)&val; }
    // 0x1a1fec: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a1ff0: 0xc7a30090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[3] = *(float*)&val; }
    // 0x1a1ff4: 0xc7a40094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[4] = *(float*)&val; }
    // 0x1a1ff8: 0xc7a50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[5] = *(float*)&val; }
    // 0x1a1ffc: 0xe7a20040
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x1a2000: 0xe7a10050
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1a2004: 0xe7a00060
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x1a2008: 0xe7a80044
    { float val = ctx->f[8]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
    // 0x1a200c: 0xe7a60054
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x1a2010: 0xe7a70064
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 29), 100), *(uint32_t*)&val); }
    // 0x1a2014: 0xe7a30048
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 72), *(uint32_t*)&val); }
    // 0x1a2018: 0xe7a40058
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x1a201c: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x1a2024);
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1a2024
// Address: 0x1a2024 - 0x1a2054

void entry_1a2024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2024: 0x7ba80100
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1a2028: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a202c: 0x7ba70110
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1a2030: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a2034: 0x7ba30120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1a2038: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1a203c: 0x7ba20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1a2040: 0x7fa800c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 8));
    // 0x1a2044: 0x7fa700d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 7));
    // 0x1a2048: 0x7fa300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 3));
    // 0x1a204c: 0xc06881c
    SET_GPR_U32(ctx, 31, 0x1a2054);
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 2));
    ChpBuildConvexHullXY__FP7MATRIX4iP2HP(rdram, ctx, runtime); return;
}


// Function: entry_1a2054
// Address: 0x1a2054 - 0x1a2070

void entry_1a2054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2054: 0x7bbf0180
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1a2058: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1a205c: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1a2060: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1a2064: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1a2068: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChpBuildConvexHullXY__FP7MATRIX4iP2HP
// Address: 0x1a2070 - 0x1a20d8

void entry_1a20d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a20d8) {
        switch (ctx->pc) {
            case 0x1a2104: ctx->pc = 0; goto label_1a2104;
            case 0x1a2118: ctx->pc = 0; goto label_1a2118;
            case 0x1a2180: ctx->pc = 0; goto label_1a2180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a20d8: 0xc6020018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[2] = *(float*)&val; }
    // 0x1a20dc: 0xc6010014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1a20e0: 0xc6000010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1a20e4: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x1a20e8: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1a20ec: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a20f0: 0xe6010014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x1a20f4: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a2104;
    }
    // 0x1a20fc: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    // 0x1a2100: 0x220a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1a2104:
    // 0x1a2104: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1a2108: 0x26050030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 48));
    // 0x1a210c: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x1a2110: 0x1440ffeb
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 48));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A20C0; return;
    }
label_1a2118:
    // 0x1a2118: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a211c: 0x7a470000
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a2120: 0x2a41018
    { int64_t result = (int64_t)GPR_S32(ctx, 21) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a2124: 0x7a460010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1a2128: 0x7a450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1a212c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a2130: 0x7fa70000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 7));
    // 0x1a2134: 0x234402a
    SET_GPR_U32(ctx, 8, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x1a2138: 0x7fa60010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 6));
    // 0x1a213c: 0x26550030
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 18), 48));
    // 0x1a2140: 0x522021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1a2144: 0x2693ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 20), 4294967295));
    // 0x1a2148: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a214c: 0x7fa50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 5));
    // 0x1a2150: 0x7e430000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 3));
    // 0x1a2154: 0x78820010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1a2158: 0x7e420010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 2));
    // 0x1a215c: 0x78830020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1a2160: 0x7e430020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 3));
    // 0x1a2164: 0x7c850020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 5));
    // 0x1a2168: 0x7c870000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 7));
    // 0x1a216c: 0x11000010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 6));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A21B0; return;
    }
    // 0x1a2174: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1a2178: 0x260882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a217c: 0x0
    // NOP
label_1a2180:
    // 0x1a2180: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a2184: 0xda420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1a2188: 0xda010010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1a218c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1a2190: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a2194: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a2198: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1a219c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a21a4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a21a4
// Address: 0x1a21a4 - 0x1a21cc

void entry_1a21a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a21a4) {
        switch (ctx->pc) {
            case 0x1a21b0: ctx->pc = 0; goto label_1a21b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a21a4: 0xe6000020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    // 0x1a21a8: 0x1620fff5
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 48));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2180; return;
    }
label_1a21b0:
    // 0x1a21b0: 0x3c07001a
    SET_GPR_U32(ctx, 7, ((uint32_t)26 << 16));
    // 0x1a21b4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a21b8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1a21bc: 0x24e71f18
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 7960));
    // 0x1a21c0: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a21c4: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x1a21cc);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_1a21cc
// Address: 0x1a21cc - 0x1a22c8

void entry_1a21cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a21cc) {
        switch (ctx->pc) {
            case 0x1a21e8: ctx->pc = 0; goto label_1a21e8;
            case 0x1a2210: ctx->pc = 0; goto label_1a2210;
            case 0x1a2260: ctx->pc = 0; goto label_1a2260;
            case 0x1a2264: ctx->pc = 0; goto label_1a2264;
            case 0x1a2288: ctx->pc = 0; goto label_1a2288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a21cc: 0x1a80002e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_1a2288;
    }
    // 0x1a21d4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a21d8: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1a21dc: 0x24478d20
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1a21e0: 0x26460060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 96));
    // 0x1a21e4: 0x0
    // NOP
label_1a21e8:
    // 0x1a21e8: 0x2281818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a21ec: 0x26240001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1a21f0: 0xa6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1a21f4: 0x1440001a
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a2260;
    }
    // 0x1a21fc: 0xd8e50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1a2200: 0xda040010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1a2204: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1a2208: 0xd8a3ffb0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 4294967216)));
    // 0x1a220c: 0x0
    // NOP
label_1a2210:
    // 0x1a2210: 0xd8a1ffe0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 4294967264)));
    // 0x1a2214: 0x4be320ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a2218: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a221c: 0x4bc50afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x1a2220: 0x4bc1286e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2224: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a2228: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a222c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a2230: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a2234: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2238: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a223c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a2240: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a2244: 0x0
    // NOP
    // 0x1a2248: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1a2264;
    }
    // 0x1a2250: 0x24a5ffd0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967248));
    // 0x1a2254: 0xa6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1a2258: 0x5040ffed
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 4294967216)));
        goto label_1a2210;
    }
label_1a2260:
    // 0x1a2260: 0x7a030000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 0)));
label_1a2264:
    // 0x1a2264: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1a2268: 0x234202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x1a226c: 0x7ca30000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 3));
    // 0x1a2270: 0x7a020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1a2274: 0x7ca20010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 2));
    // 0x1a2278: 0x7a030020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1a227c: 0x7ca30020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 3));
    // 0x1a2280: 0x1480ffd9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 48));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1a21e8;
    }
label_1a2288:
    // 0x1a2288: 0x3c03aaaa
    SET_GPR_U32(ctx, 3, ((uint32_t)43690 << 16));
    // 0x1a228c: 0xb21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 18)));
    // 0x1a2290: 0x3463aaab
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 43691));
    // 0x1a2294: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a2298: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a229c: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a22a0: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a22a4: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a22a8: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a22ac: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a22b0: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x1a22b4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a22b8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a22bc: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1a22c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostFlyingEmit__FP6FLYINGP5EMITB
// Address: 0x1a22c8 - 0x1a22e0

void entry_1a2354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2354: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2358: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a235c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a2360: 0xc067d88
    SET_GPR_U32(ctx, 31, 0x1a2368);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 128));
    FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a2368
// Address: 0x1a2368 - 0x1a2380

void entry_1a2368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2368: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a236c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a2370: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a2374: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a2378: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CreateStuck__FP3RIPP3ALOP2SOP6VECTORT3PP5STUCK
// Address: 0x1a2380 - 0x1a23d8

void entry_1a23d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a23d8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a23dc: 0x12200076
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A25B8; return;
    }
    // 0x1a23e4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a23e8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a23ec: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1a23f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1a23f4
// Address: 0x1a23f4 - 0x1a244c

void entry_1a23f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a23f4: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1a23f8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a23fc: 0xc6020018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[2] = *(float*)&val; }
    // 0x1a2400: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1a2404: 0x26030030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 48));
    // 0x1a2408: 0xc603001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[3] = *(float*)&val; }
    // 0x1a240c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1a2410: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a2414: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1a2418: 0xc6140030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1a241c: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1a2420: 0x3c013fb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16307 << 16));
    // 0x1a2424: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1a2428: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a242c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1a2430: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1a2434: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a2438: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1a243c: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1a2440: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1a2444: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a244c);
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a244c
// Address: 0x1a244c - 0x1a246c

void entry_1a244c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a244c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a2450: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a2454: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1a2458: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a245c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a2460: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2464: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a246c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a246c
// Address: 0x1a246c - 0x1a24b0

void entry_1a246c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a246c: 0x4600a507
    ctx->f[20] = FPU_NEG_S(ctx->f[20]);
    // 0x1a2470: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1a2474: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a2478: 0xae340020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 20));
    // 0x1a247c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a2480: 0xe620001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 28), *(uint32_t*)&val); }
    // 0x1a2484: 0x24508d20
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1a2488: 0xe6340038
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 56), *(uint32_t*)&val); }
    // 0x1a248c: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1a2490: 0xae350120
    WRITE32(ADD32(GPR_U32(ctx, 17), 288), GPR_U32(ctx, 21));
    // 0x1a2494: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a2498: 0x24c68d00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937856));
    // 0x1a249c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a24a0: 0x7a620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1a24a4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a24a8: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x1a24b0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_1a24b0
// Address: 0x1a24b0 - 0x1a24cc

void entry_1a24b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a24b0: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1a24b4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a24b8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a24bc: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1a24c0: 0xe7b50044
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
    // 0x1a24c4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a24cc);
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a24cc
// Address: 0x1a24cc - 0x1a24dc

void entry_1a24cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a24cc: 0xe7a00048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 72), *(uint32_t*)&val); }
    // 0x1a24d0: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1a24d4: 0xc062288
    SET_GPR_U32(ctx, 31, 0x1a24dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a24dc
// Address: 0x1a24dc - 0x1a2580

void entry_1a24dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a24dc: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a24e0: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a24e4: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a24e8: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a24ec: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a24f0: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1a24f4: 0x4bc510bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a24f8: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a24fc: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a2500: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a2504: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a2508: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a250c: 0x4bc621bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1a2510: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1a2514: 0x4bc6090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2518: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a251c: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a2520: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a2524: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a2528: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a252c: 0xfba400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a2530: 0xfa250050
    WRITE128(ADD32(GPR_U32(ctx, 17), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a2534: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1a2538: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1a253c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a2540: 0x7ba20090
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a2544: 0x7e220060
    WRITE128(ADD32(GPR_U32(ctx, 17), 96), GPR_VEC(ctx, 2));
    // 0x1a2548: 0x7ba300a0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a254c: 0x7e230070
    WRITE128(ADD32(GPR_U32(ctx, 17), 112), GPR_VEC(ctx, 3));
    // 0x1a2550: 0xc6600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a2554: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1a2558: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a255c: 0x0
    // NOP
    // 0x1a2560: 0x45000015
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A25B8; return;
    }
    // 0x1a2568: 0x7a620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1a256c: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1a2570: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1a2574: 0x7fa20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    // 0x1a2578: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x1a2580);
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a2580
// Address: 0x1a2580 - 0x1a25f0

void entry_1a2580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2580) {
        switch (ctx->pc) {
            case 0x1a25b8: ctx->pc = 0; goto label_1a25b8;
            case 0x1a25c0: ctx->pc = 0; goto label_1a25c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2580: 0x3c01c248
    SET_GPR_U32(ctx, 1, ((uint32_t)49736 << 16));
    // 0x1a2584: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a2588: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a258c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a2590: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a2594: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a2598: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a259c: 0x4be51098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a25a0: 0xdba100b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1a25a4: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a25a8: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a25ac: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a25b0: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a25b4: 0xfa2200a0
    WRITE128(ADD32(GPR_U32(ctx, 17), 160), _mm_castps_si128(ctx->vu0_vf[2]));
label_1a25b8:
    // 0x1a25b8: 0x56c00001
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 17));
        goto label_1a25c0;
    }
label_1a25c0:
    // 0x1a25c0: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1a25c4: 0x7bb60140
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1a25c8: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1a25cc: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1a25d0: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1a25d4: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1a25d8: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1a25dc: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1a25e0: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x1a25e4: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x1a25e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 368));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FBounceFlying__FP6FLYINGP2SOP6VECTORT2
// Address: 0x1a25f0 - 0x1a263c

void entry_1a263c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a263c: 0x14400013
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A268C; return;
    }
    // 0x1a2644: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1a2648: 0x2e020004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 4));
    // 0x1a264c: 0x1440fff8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2630; return;
    }
    // 0x1a2654: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a2658: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a2660);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 31));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a2660
// Address: 0x1a2660 - 0x1a2680

void entry_1a2660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2660: 0x14400007
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1a2680(rdram, ctx, runtime); return;
    }
    // 0x1a2668: 0x8e650120
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 288)));
    // 0x1a266c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1a2670: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1a2674: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a2678: 0xc0688e0
    SET_GPR_U32(ctx, 31, 0x1a2680);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CreateStuck__FP3RIPP3ALOP2SOP6VECTORT3PP5STUCK(rdram, ctx, runtime); return;
}


// Function: entry_1a2680
// Address: 0x1a2680 - 0x1a2688

void entry_1a2680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2680: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a2688);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a2688
// Address: 0x1a2688 - 0x1a26b0

void entry_1a2688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2688) {
        switch (ctx->pc) {
            case 0x1a268c: ctx->pc = 0; goto label_1a268c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2688: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1a268c:
    // 0x1a268c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a2690: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a2694: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a2698: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a269c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a26a0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a26a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a26a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateStuck__FP5STUCKf
// Address: 0x1a26b0 - 0x1a26c4

void entry_1a26c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a26c4: 0x8e040120
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a26c8: 0x10800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A26EC; return;
    }
    // 0x1a26d0: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1a26d8);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a26d8
// Address: 0x1a26d8 - 0x1a26e8

void entry_1a26d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a26d8: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A26EC; return;
    }
    // 0x1a26e0: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a26e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a26e8
// Address: 0x1a26e8 - 0x1a26f8

void entry_1a26e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a26e8) {
        switch (ctx->pc) {
            case 0x1a26ec: ctx->pc = 0; goto label_1a26ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a26e8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a26ec:
    // 0x1a26ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a26f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderStuck__FP5STUCKP2CM
// Address: 0x1a26f8 - 0x1a2728

void entry_1a2728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2728: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a272c: 0x8e040120
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a2730: 0x26060050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1a2734: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2738: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1a2740);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1a2740
// Address: 0x1a2740 - 0x1a2754

void entry_1a2740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2740: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a2744: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a2748: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a274c: 0xc067d88
    SET_GPR_U32(ctx, 31, 0x1a2754);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a2754
// Address: 0x1a2754 - 0x1a2770

void entry_1a2754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2754: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a2758: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a275c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a2760: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a2764: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a276c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a2770; return;
}


// Function: PostLeafEmit__FP4LEAFP5EMITB
// Address: 0x1a2770 - 0x1a27ac

void entry_1a27ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a27ac: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1a27b0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1a27b4: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1a27b8: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x1a27bc: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1a27c0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a27c8);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a27c8
// Address: 0x1a27c8 - 0x1a27e0

void entry_1a27c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a27c8: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x1a27cc: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1a27d0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a27d4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1a27d8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a27e0);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a27e0
// Address: 0x1a27e0 - 0x1a280c

void entry_1a27e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a27e0: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x1a27e4: 0x26050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1a27e8: 0x4402b000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[22]);
    // 0x1a27ec: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1a27f0: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1a27f4: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a27f8: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1a27fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a2800: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1a2804: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x1a280c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a280c
// Address: 0x1a280c - 0x1a2830

void entry_1a280c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a280c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a2810: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a2814: 0xc7b70058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[23] = *(float*)&val; }
    // 0x1a2818: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x1a281c: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x1a2820: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1a2824: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a282c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a2830; return;
}


// Function: ProjectLeafTransform__FP4LEAFf
// Address: 0x1a2830 - 0x1a28dc

void entry_1a28dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a28dc: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a28e0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a28e4: 0xdba60010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a28e8: 0x262400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 160));
    // 0x1a28ec: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a28f0: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1a28f4: 0xda2100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 160)));
    // 0x1a28f8: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1a28fc: 0xda240050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1a2900: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a2904: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a2908: 0x4bc1284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a290c: 0xfa2100a0
    WRITE128(ADD32(GPR_U32(ctx, 17), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a2910: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1a2914: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a2918: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a291c: 0xc63500b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 176)); ctx->f[21] = *(float*)&val; }
    // 0x1a2920: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a2924: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a2928: 0xda020010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1a292c: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a2930: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a2934: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2938: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a293c: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a2940: 0xda010020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1a2944: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a2948: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a294c: 0x4bc128ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2950: 0xfa220060
    WRITE128(ADD32(GPR_U32(ctx, 17), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a2954: 0xfa230070
    WRITE128(ADD32(GPR_U32(ctx, 17), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a2958: 0xae2000b0
    WRITE32(ADD32(GPR_U32(ctx, 17), 176), GPR_U32(ctx, 0));
    // 0x1a295c: 0xfa240050
    WRITE128(ADD32(GPR_U32(ctx, 17), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a2960: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a2964: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1a296c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1a296c
// Address: 0x1a296c - 0x1a2a48

void entry_1a296c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a296c) {
        switch (ctx->pc) {
            case 0x1a29c4: ctx->pc = 0; goto label_1a29c4;
            case 0x1a29d4: ctx->pc = 0; goto label_1a29d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a296c: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a2970: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1a2974: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a2978: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a297c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a2980: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x1a2984: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a2988: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a298c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a2990: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a2994: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2998: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a299c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a29a0: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a29a4: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a29a8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a29ac: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a29b0: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a29c4;
    }
    // 0x1a29b8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a29bc: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a29d4;
    }
label_1a29c4:
    // 0x1a29c4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a29c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a29cc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1a29d0: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_1a29d4:
    // 0x1a29d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a29d8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a29dc: 0xc440b6e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948584)); ctx->f[0] = *(float*)&val; }
    // 0x1a29e0: 0x48251000
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a29e4: 0xc462b6ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294948588)); ctx->f[2] = *(float*)&val; }
    // 0x1a29e8: 0x44852000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 5);
    // 0x1a29ec: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1a29f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a29f4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1a29f8: 0x46022101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[2]);
    // 0x1a29fc: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a2a00: 0x4614a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x1a2a04: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a2a08: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x1a2a0c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a2a10: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2a14: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1a2a18: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1a2a1c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1a2a20: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1a2a24: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a2a28: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1a2a2c: 0x48a50800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x1a2a30: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a2a34: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a2a38: 0x4be32088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2a3c: 0xfa2200a0
    WRITE128(ADD32(GPR_U32(ctx, 17), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a2a40: 0xc067ce4
    SET_GPR_U32(ctx, 31, 0x1a2a48);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    ProjectRipTransform__FP3RIPf(rdram, ctx, runtime); return;
}


// Function: entry_1a2a48
// Address: 0x1a2a48 - 0x1a2a68

void entry_1a2a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2a48: 0xe63500b0
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 17), 176), *(uint32_t*)&val); }
    // 0x1a2a4c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1a2a50: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a2a54: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a2a58: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x1a2a5c: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1a2a60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FBounceLeaf__FP4LEAFP2SOP6VECTORT2
// Address: 0x1a2a68 - 0x1a2a9c

void entry_1a2a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2a9c: 0x14400017
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2AFC; return;
    }
    // 0x1a2aa4: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1a2aa8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a2ab0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a2ab0
// Address: 0x1a2ab0 - 0x1a2ad4

void entry_1a2ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2ab0: 0x14400012
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2AFC; return;
    }
    // 0x1a2ab8: 0x8e250020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1a2abc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a2ac0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a2ac4: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a2ac8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2acc: 0xc0688e0
    SET_GPR_U32(ctx, 31, 0x1a2ad4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CreateStuck__FP3RIPP3ALOP2SOP6VECTORT3PP5STUCK(rdram, ctx, runtime); return;
}


// Function: entry_1a2ad4
// Address: 0x1a2ad4 - 0x1a2af0

void entry_1a2ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2ad4: 0x8fa60000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a2ad8: 0x10c00005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 80));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1a2af0(rdram, ctx, runtime); return;
    }
    // 0x1a2ae0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a2ae4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a2ae8: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1a2af0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1a2af0
// Address: 0x1a2af0 - 0x1a2af8

void entry_1a2af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2af0: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a2af8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a2af8
// Address: 0x1a2af8 - 0x1a2b18

void entry_1a2af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2af8) {
        switch (ctx->pc) {
            case 0x1a2afc: ctx->pc = 0; goto label_1a2afc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2af8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1a2afc:
    // 0x1a2afc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a2b00: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a2b04: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a2b08: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a2b0c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a2b10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFilterFlameObjects__FPvP2SO
// Address: 0x1a2b18 - 0x1a2b48

void entry_1a2c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2c64: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a2c68: 0x3c08001a
    SET_GPR_U32(ctx, 8, ((uint32_t)26 << 16));
    // 0x1a2c6c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a2c70: 0x25082b18
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 11032));
    // 0x1a2c74: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2c78: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a2c7c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a2c80: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a2c84: 0x27aa0090
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1a2c88: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1a2c90);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 148));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1a2c90
// Address: 0x1a2c90 - 0x1a2cac

void entry_1a2c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2c90: 0x8fa70090
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a2c94: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a2c98: 0x8fa80094
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 148)));
    // 0x1a2c9c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a2ca0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a2ca4: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1a2cac);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1a2cac
// Address: 0x1a2cac - 0x1a2cc0

void entry_1a2cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2cac) {
        switch (ctx->pc) {
            case 0x1a2cb8: ctx->pc = 0; goto label_1a2cb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2cac: 0x10400002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a2cb8;
    }
    // 0x1a2cb4: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
label_1a2cb8:
    // 0x1a2cb8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1a2cc0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 48));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1a2cc0
// Address: 0x1a2cc0 - 0x1a2ccc

void entry_1a2cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2cc0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a2cc4: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1a2ccc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1a2ccc
// Address: 0x1a2ccc - 0x1a2cdc

void entry_1a2ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2ccc: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a2cd0: 0x27a400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1a2cd4: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1a2cdc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a2cdc
// Address: 0x1a2cdc - 0x1a2ce8

void entry_1a2cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2cdc: 0x7ba500b0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1a2ce0: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1a2ce8);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a2ce8
// Address: 0x1a2ce8 - 0x1a2cf4

void entry_1a2ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2ce8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2cec: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1a2cf4);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a2cf4
// Address: 0x1a2cf4 - 0x1a2d00

void entry_1a2cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2cf4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1a2cf8: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x1a2d00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 80));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a2d00
// Address: 0x1a2d00 - 0x1a2d30

void entry_1a2d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2d00: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a2d04: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1a2d08: 0xfa4100a0
    WRITE128(ADD32(GPR_U32(ctx, 18), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a2d0c: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1a2d10: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1a2d14: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1a2d18: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1a2d1c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a2d20: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x1a2d24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a2d2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a2d30; return;
}


// Function: PostBulletEmit__FP6BULLETP5EMITB
// Address: 0x1a2d30 - 0x1a2d5c

void entry_1a2d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2d5c: 0xae0000b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 176), GPR_U32(ctx, 0));
    // 0x1a2d60: 0xae000110
    WRITE32(ADD32(GPR_U32(ctx, 16), 272), GPR_U32(ctx, 0));
    // 0x1a2d64: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a2d68: 0x8e2201f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 500)));
    // 0x1a2d6c: 0xae020120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 2));
    // 0x1a2d70: 0x8e2301f0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 496)));
    // 0x1a2d74: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a2d78: 0xae030124
    WRITE32(ADD32(GPR_U32(ctx, 16), 292), GPR_U32(ctx, 3));
    // 0x1a2d7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a2d80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderBullet__FP6BULLETP2CM
// Address: 0x1a2d88 - 0x1a2e28

void entry_1a2e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2e28) {
        switch (ctx->pc) {
            case 0x1a2e30: ctx->pc = 0; goto label_1a2e30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2e28: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2E58; return;
    }
label_1a2e30:
    // 0x1a2e30: 0x260400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 160));
    // 0x1a2e34: 0x26250080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 128));
    // 0x1a2e38: 0xc0626c6
    SET_GPR_U32(ctx, 31, 0x1a2e40);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    BuildOrthonormalMatrixY__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a2e40
// Address: 0x1a2e40 - 0x1a2e54

void entry_1a2e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2e40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a2e44: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a2e48: 0x24860080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 128));
    // 0x1a2e4c: 0xc067d88
    SET_GPR_U32(ctx, 31, 0x1a2e54);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a2e54
// Address: 0x1a2e54 - 0x1a2e68

void entry_1a2e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2e54) {
        switch (ctx->pc) {
            case 0x1a2e58: ctx->pc = 0; goto label_1a2e58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2e54: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1a2e58:
    // 0x1a2e58: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a2e5c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a2e60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FBounceBullet__FP6BULLETP2SOP6VECTORT2
// Address: 0x1a2e68 - 0x1a2eb0

void entry_1a2eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2eb0: 0x7a230000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a2eb4: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1a2eb8: 0x7a0200a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x1a2ebc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a2ec0: 0x8e07000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1a2ec4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a2ec8: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x1a2ecc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a2ed0: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1a2ed4: 0xafb20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 18));
    // 0x1a2ed8: 0xafa70000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 7));
    // 0x1a2edc: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x1a2ee4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 8));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a2ee4
// Address: 0x1a2ee4 - 0x1a2f10

void entry_1a2ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2ee4) {
        switch (ctx->pc) {
            case 0x1a2eec: ctx->pc = 0; goto label_1a2eec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2ee4: 0x1440003b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2FD4; return;
    }
label_1a2eec:
    // 0x1a2eec: 0x8e020120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a2ef0: 0x10400038
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2FD4; return;
    }
    // 0x1a2ef8: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a2efc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a2f00: 0x3c01c3c8
    SET_GPR_U32(ctx, 1, ((uint32_t)50120 << 16));
    // 0x1a2f04: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1a2f08: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x1a2f10);
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), GPR_VEC(ctx, 2));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a2f10
// Address: 0x1a2f10 - 0x1a2f70

void entry_1a2f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2f10: 0x3c0143c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17352 << 16));
    // 0x1a2f14: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1a2f18: 0xda0100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x1a2f1c: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a2f20: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a2f24: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a2f28: 0x4be1222a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a2f2c: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1a2f30: 0x4be119ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a2f34: 0x4be111aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a2f38: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1a2f3c: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2f40: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1a2f44: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2f48: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1a2f4c: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2f50: 0x3c01bf73
    SET_GPR_U32(ctx, 1, ((uint32_t)49011 << 16));
    // 0x1a2f54: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1a2f58: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a2f5c: 0x3c01bf59
    SET_GPR_U32(ctx, 1, ((uint32_t)48985 << 16));
    // 0x1a2f60: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1a2f64: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a2f68: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a2f70);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a2f70
// Address: 0x1a2f70 - 0x1a2f88

void entry_1a2f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2f70: 0xc7a10030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[1] = *(float*)&val; }
    // 0x1a2f74: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1a2f78: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1a2f7c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1a2f80: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a2f88);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a2f88
// Address: 0x1a2f88 - 0x1a2fa0

void entry_1a2f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a2f88: 0xc7a10034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1a2f8c: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1a2f90: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1a2f94: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a2f98: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a2fa0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a2fa0
// Address: 0x1a2fa0 - 0x1a2fdc

void entry_1a2fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2fa0) {
        switch (ctx->pc) {
            case 0x1a2fd4: ctx->pc = 0; goto label_1a2fd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2fa0: 0xc7a10038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[1] = *(float*)&val; }
    // 0x1a2fa4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a2fa8: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a2fac: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a2fb0: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a2fb4: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a2fb8: 0xe7a10038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    // 0x1a2fbc: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a2fc0: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a2fc4: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a2fc8: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a2fcc: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A2FE0; return;
    }
label_1a2fd4:
    // 0x1a2fd4: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a2fdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a2fdc
// Address: 0x1a2fdc - 0x1a3008

void entry_1a2fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a2fdc) {
        switch (ctx->pc) {
            case 0x1a2fe0: ctx->pc = 0; goto label_1a2fe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a2fdc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1a2fe0:
    // 0x1a2fe0: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a2fe4: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a2fe8: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a2fec: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a2ff0: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a2ff4: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1a2ff8: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1a2ffc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a3004: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a3008; return;
}


// Function: PostShrapnelEmit__FP8SHRAPNELP5EMITB
// Address: 0x1a3008 - 0x1a3038

void entry_1a3038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3038) {
        switch (ctx->pc) {
            case 0x1a30cc: ctx->pc = 0; goto label_1a30cc;
            case 0x1a30dc: ctx->pc = 0; goto label_1a30dc;
            case 0x1a30f0: ctx->pc = 0; goto label_1a30f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3038: 0xc621001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[1] = *(float*)&val; }
    // 0x1a303c: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1a3040: 0xda2100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 160)));
    // 0x1a3044: 0x24a4b700
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294948608));
    // 0x1a3048: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1a304c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3050: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a3054: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3058: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a305c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3060: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a3064: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a3068: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a306c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a3070: 0xe621001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 28), *(uint32_t*)&val); }
    // 0x1a3074: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1a3078: 0x24435c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1a307c: 0xc60001f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 496)); ctx->f[0] = *(float*)&val; }
    // 0x1a3080: 0xe6200120
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 288), *(uint32_t*)&val); }
    // 0x1a3084: 0xc60101f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 500)); ctx->f[1] = *(float*)&val; }
    // 0x1a3088: 0xe6210124
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 292), *(uint32_t*)&val); }
    // 0x1a308c: 0xc60001f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 504)); ctx->f[0] = *(float*)&val; }
    // 0x1a3090: 0xe6200128
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 296), *(uint32_t*)&val); }
    // 0x1a3094: 0xc4800008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a3098: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a309c: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1a30a0: 0xc4a2b700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4294948608)); ctx->f[2] = *(float*)&val; }
    // 0x1a30a4: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1a30a8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a30ac: 0x460118c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1a30b0: 0x46031080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[3]);
    // 0x1a30b4: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a30b8: 0x0
    // NOP
    // 0x1a30bc: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a30cc;
    }
    // 0x1a30c4: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a30dc;
    }
label_1a30cc:
    // 0x1a30cc: 0x46022834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a30d0: 0x0
    // NOP
    // 0x1a30d4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[5]);
        goto label_1a30dc;
    }
label_1a30dc:
    // 0x1a30dc: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1a30e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a30e4: 0x26300100
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 256));
    // 0x1a30e8: 0x24110002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a30ec: 0x46001502
    ctx->f[20] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
label_1a30f0:
    // 0x1a30f0: 0x4600a307
    ctx->f[12] = FPU_NEG_S(ctx->f[20]);
    // 0x1a30f4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1a30f8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a3100);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a3100
// Address: 0x1a3100 - 0x1a3128

void entry_1a3100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3100: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1a3104: 0x621fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x1A30F0; return;
    }
    // 0x1a310c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a3110: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3114: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3118: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1a311c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a3124: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a3128; return;
}


// Function: FBounceShrapnel__FP8SHRAPNELP2SOP6VECTORT2
// Address: 0x1a3128 - 0x1a315c

void entry_1a315c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a315c: 0x14400008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A3180; return;
    }
    // 0x1a3164: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a3168: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a316c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a3170: 0xc067b56
    SET_GPR_U32(ctx, 31, 0x1a3178);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FBounceRip__FP3RIPP2SOP6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1a3178
// Address: 0x1a3178 - 0x1a31a0

void entry_1a3178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3178) {
        switch (ctx->pc) {
            case 0x1a3180: ctx->pc = 0; goto label_1a3180;
            case 0x1a3184: ctx->pc = 0; goto label_1a3184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3178: 0x10000002
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a3184;
    }
label_1a3180:
    // 0x1a3180: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1a3184:
    // 0x1a3184: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a3188: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a318c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3190: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3194: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a319c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a31a0; return;
}


// Function: RenderShrapnel__FP8SHRAPNELP2CM
// Address: 0x1a31a0 - 0x1a31e4

void entry_1a31e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a31e4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a31e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitGlint__FP5GLINTP6VECTORfP2SO
// Address: 0x1a31f0 - 0x1a3204

void entry_1a3204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3204: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a3208: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a320c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a3210: 0x8c465710
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a3214: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a3218: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x1a321c: 0x2463b710
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294948624));
    // 0x1a3220: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a3224: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3228: 0x8cc51d30
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 7472)));
    // 0x1a322c: 0x2484b720
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294948640));
    // 0x1a3230: 0xae050020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 5));
    // 0x1a3234: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a3238: 0x7e020040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 2));
    // 0x1a323c: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a3240: 0x7e030030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    // 0x1a3244: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3248: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderGlint__FP5GLINTP2CM
// Address: 0x1a3250 - 0x1a3288

void entry_1a3288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3288: 0x8e1002a8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 680)));
    // 0x1a328c: 0x4be00153
    // Unhandled VU0 Special1 function: 0x13
    // 0x1a3290: 0xda420040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x1a3294: 0x48b03000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x1a3298: 0xdba70000
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a329c: 0xda440050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x1a32a0: 0x4be238ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1a32a4: 0xda430060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 96)));
    // 0x1a32a8: 0xda410070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 112)));
    // 0x1a32ac: 0x4be221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a32b0: 0x4be218bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a32b4: 0x4be208be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1a32b8: 0x4be628fc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1a32bc: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a32c0: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a32c4: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a32c8: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a32cc: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x1a32d0: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x1a32d4: 0x10400005
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[6]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A32EC; return;
    }
    // 0x1a32dc: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a32e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a32e4
// Address: 0x1a32e4 - 0x1a3314

void entry_1a32e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a32e4) {
        switch (ctx->pc) {
            case 0x1a32ec: ctx->pc = 0; goto label_1a32ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a32e4: 0x100000a6
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A3580; return;
    }
label_1a32ec:
    // 0x1a32ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a32f0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1a32f4: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1a32f8: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x1a32fc: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a3300: 0x27a60060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1a3304: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1a3308: 0x4be7086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a330c: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1a3314);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a3314
// Address: 0x1a3314 - 0x1a34ec

void entry_1a3314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3314) {
        switch (ctx->pc) {
            case 0x1a33cc: ctx->pc = 0; goto label_1a33cc;
            case 0x1a33e0: ctx->pc = 0; goto label_1a33e0;
            case 0x1a3438: ctx->pc = 0; goto label_1a3438;
            case 0x1a344c: ctx->pc = 0; goto label_1a344c;
            case 0x1a3494: ctx->pc = 0; goto label_1a3494;
            case 0x1a34a4: ctx->pc = 0; goto label_1a34a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3314: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3318: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a331c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3320: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a3324: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3328: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a332c: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a3330: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3334: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a3338: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a333c: 0xc6220018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[2] = *(float*)&val; }
    // 0x1a3340: 0x3c013a83
    SET_GPR_U32(ctx, 1, ((uint32_t)14979 << 16));
    // 0x1a3344: 0x3421126f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4719));
    // 0x1a3348: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1a334c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a3350: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a3354: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1a3358: 0x46030202
    ctx->f[8] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1a335c: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1a3360: 0x24a2b740
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4294948672));
    // 0x1a3364: 0xc623001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[3] = *(float*)&val; }
    // 0x1a3368: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1a336c: 0x26230030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 48));
    // 0x1a3370: 0x460309c3
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[7] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[7] = ctx->f[1] / ctx->f[3];
    // 0x1a3374: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a3378: 0x46024082
    ctx->f[2] = FPU_MUL_S(ctx->f[8], ctx->f[2]);
    // 0x1a337c: 0xc4630008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1a3380: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a3384: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a3388: 0xc4a4b740
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4294948672)); ctx->f[4] = *(float*)&val; }
    // 0x1a338c: 0x2482b750
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294948688));
    // 0x1a3390: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1a3394: 0xc485b750
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294948688)); ctx->f[5] = *(float*)&val; }
    // 0x1a3398: 0xc6220030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 48)); ctx->f[2] = *(float*)&val; }
    // 0x1a339c: 0x460338c2
    ctx->f[3] = FPU_MUL_S(ctx->f[7], ctx->f[3]);
    // 0x1a33a0: 0xc4460004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[6] = *(float*)&val; }
    // 0x1a33a4: 0x46004002
    ctx->f[0] = FPU_MUL_S(ctx->f[8], ctx->f[0]);
    // 0x1a33a8: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1a33ac: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x1a33b0: 0x46013842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x1a33b4: 0x46052034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a33b8: 0x0
    // NOP
    // 0x1a33bc: 0x45000003
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a33cc;
    }
    // 0x1a33c4: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a33e0;
    }
label_1a33cc:
    // 0x1a33cc: 0x46043034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a33d0: 0x0
    // NOP
    // 0x1a33d4: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a33e0;
    }
    // 0x1a33dc: 0x46003006
    ctx->f[0] = FPU_MOV_S(ctx->f[6]);
label_1a33e0:
    // 0x1a33e0: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1a33e4: 0x26240040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 64));
    // 0x1a33e8: 0xc6220040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[2] = *(float*)&val; }
    // 0x1a33ec: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a33f0: 0x70631c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1a33f4: 0x70631488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x1a33f8: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1a33fc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a3400: 0xc4645c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1a3404: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a3408: 0x24635c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23648));
    // 0x1a340c: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a3410: 0x46013842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x1a3414: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a3418: 0x46003802
    ctx->f[0] = FPU_MUL_S(ctx->f[7], ctx->f[0]);
    // 0x1a341c: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1a3420: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3424: 0x0
    // NOP
    // 0x1a3428: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a3438;
    }
    // 0x1a3430: 0x10000006
    ctx->f[5] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a344c;
    }
label_1a3438:
    // 0x1a3438: 0x46021834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a343c: 0x0
    // NOP
    // 0x1a3440: 0x45000002
    ctx->f[5] = FPU_MOV_S(ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a344c;
    }
    // 0x1a3448: 0x46001946
    ctx->f[5] = FPU_MOV_S(ctx->f[3]);
label_1a344c:
    // 0x1a344c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a3450: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a3454: 0x2443b760
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294948704));
    // 0x1a3458: 0xc442b760
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948704)); ctx->f[2] = *(float*)&val; }
    // 0x1a345c: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a3460: 0x2482b770
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294948720));
    // 0x1a3464: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a3468: 0x46014042
    ctx->f[1] = FPU_MUL_S(ctx->f[8], ctx->f[1]);
    // 0x1a346c: 0xc483b770
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294948720)); ctx->f[3] = *(float*)&val; }
    // 0x1a3470: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a3474: 0x46004002
    ctx->f[0] = FPU_MUL_S(ctx->f[8], ctx->f[0]);
    // 0x1a3478: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1a347c: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3480: 0x0
    // NOP
    // 0x1a3484: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a3494;
    }
    // 0x1a348c: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a34a4;
    }
label_1a3494:
    // 0x1a3494: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3498: 0x0
    // NOP
    // 0x1a349c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[4]);
        goto label_1a34a4;
    }
label_1a34a4:
    // 0x1a34a4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a34a8: 0x46002882
    ctx->f[2] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x1a34ac: 0x2443b730
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294948656));
    // 0x1a34b0: 0xc443b730
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948656)); ctx->f[3] = *(float*)&val; }
    // 0x1a34b4: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a34b8: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1a34bc: 0xc46c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1a34c0: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1a34c4: 0x46003802
    ctx->f[0] = FPU_MUL_S(ctx->f[7], ctx->f[0]);
    // 0x1a34c8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a34cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a34d0: 0x24848d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937856));
    // 0x1a34d4: 0xe7a20100
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1a34d8: 0xe7a10104
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 260), *(uint32_t*)&val); }
    // 0x1a34dc: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1a34e0: 0x460c3b02
    ctx->f[12] = FPU_MUL_S(ctx->f[7], ctx->f[12]);
    // 0x1a34e4: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1a34ec);
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[12]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a34ec
// Address: 0x1a34ec - 0x1a3564

void entry_1a34ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a34ec: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a34f0: 0x27b000c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1a34f4: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a34f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a34fc: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a3500: 0x27a50090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1a3504: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a3508: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1a350c: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a3510: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a3514: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a3518: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a351c: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1a3520: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a3524: 0x4bc4110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3528: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a352c: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1a3530: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a3534: 0x4bc5104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3538: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a353c: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a3540: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3544: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a3548: 0xfba30150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a354c: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a3550: 0xfba40160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a3554: 0xfba40130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a3558: 0xfba10170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a355c: 0xc062304
    SET_GPR_U32(ctx, 31, 0x1a3564);
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1a3564
// Address: 0x1a3564 - 0x1a357c

void entry_1a3564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3564: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1a3568: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a356c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a3570: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x1a3574: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a357c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a357c
// Address: 0x1a357c - 0x1a3598

void entry_1a357c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a357c) {
        switch (ctx->pc) {
            case 0x1a3580: ctx->pc = 0; goto label_1a3580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a357c: 0x7bbf01b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 432)));
label_1a3580:
    // 0x1a3580: 0x7bb201a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1a3584: 0x7bb10190
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1a3588: 0x7bb00180
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1a358c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a3594: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a3598; return;
}


// Function: InitMatch__FP5MATCHP6VECTORfP2SO
// Address: 0x1a3598 - 0x1a35b4

void entry_1a35b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a35b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a35b8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a35bc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a35c0: 0x24425c50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23632));
    // 0x1a35c4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a35c8: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1a35cc: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a35d0: 0xe6140030
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x1a35d4: 0xae000038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 0));
    // 0x1a35d8: 0x7e030040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 3));
    // 0x1a35dc: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1a35e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a35e4: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1a35e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LaunchMatch__FP5MATCH
// Address: 0x1a35f0 - 0x1a3650

void entry_1a3650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3650: 0xc641001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[1] = *(float*)&val; }
    // 0x1a3654: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1a3658: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a365c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a3660: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a3664: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x1a3668: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1a366c: 0x26450050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 80));
    // 0x1a3670: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1a3674: 0xda410080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 128)));
    // 0x1a3678: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1a367c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3680: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a3684: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3688: 0xda4100c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 192)));
    // 0x1a368c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a3690: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a3694: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1a3698: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a369c: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a36a0: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a36a4: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a36a8: 0xfa4200a0
    WRITE128(ADD32(GPR_U32(ctx, 18), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a36ac: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1a36b4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1a36b4
// Address: 0x1a36b4 - 0x1a36c4

void entry_1a36b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a36b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a36b8: 0x26450130
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 304));
    // 0x1a36bc: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1a36c4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 288));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a36c4
// Address: 0x1a36c4 - 0x1a3714

void entry_1a36c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a36c4) {
        switch (ctx->pc) {
            case 0x1a36ec: ctx->pc = 0; goto label_1a36ec;
            case 0x1a36fc: ctx->pc = 0; goto label_1a36fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a36c4: 0xc6410130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 304)); ctx->f[1] = *(float*)&val; }
    // 0x1a36c8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1a36cc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a36d0: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a36ec;
    }
    // 0x1a36d8: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1a36dc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a36e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a36e4: 0x10000005
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a36fc;
    }
label_1a36ec:
    // 0x1a36ec: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1a36f0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a36f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a36f8: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
label_1a36fc:
    // 0x1a36fc: 0xe6400130
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 304), *(uint32_t*)&val); }
    // 0x1a3700: 0x8e440134
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 308)));
    // 0x1a3704: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a3708: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a370c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3714);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3714
// Address: 0x1a3714 - 0x1a3730

void entry_1a3714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3714: 0xae400134
    WRITE32(ADD32(GPR_U32(ctx, 18), 308), GPR_U32(ctx, 0));
    // 0x1a3718: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1a371c: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a3720: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a3724: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a3728: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectMatchTransform__FP5MATCHf
// Address: 0x1a3730 - 0x1a37a4

void entry_1a37a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a37a4: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1a37a8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a37ac: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a37b0: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x1a37b4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a37b8: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1a37bc: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1a37c0: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a37c4: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1a37c8: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a37cc: 0x48a23800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a37d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a37d4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a37d8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1a37dc: 0x26040080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 128));
    // 0x1a37e0: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a37e4: 0x260500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 160));
    // 0x1a37e8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a37ec: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a37f0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a37f4: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1a37f8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a37fc: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1a3800: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a3804: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a3808: 0x27a90030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1a380c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a3810: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a3814: 0xda020080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1a3818: 0xda0100c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 192)));
    // 0x1a381c: 0x4be2212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a3820: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1a3824: 0x4be70858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3828: 0xda0200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x1a382c: 0x4be321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a3830: 0x4be610bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1a3834: 0x4be508c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3838: 0xfba500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a383c: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a3840: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x1a3848);
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[7]));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_1a3848
// Address: 0x1a3848 - 0x1a3864

void entry_1a3848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3848: 0xc60c0130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 304)); ctx->f[12] = *(float*)&val; }
    // 0x1a384c: 0x26040120
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 288));
    // 0x1a3850: 0xc600001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[0] = *(float*)&val; }
    // 0x1a3854: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1a3858: 0x46146302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    // 0x1a385c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1a3864);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a3864
// Address: 0x1a3864 - 0x1a38f0

void entry_1a3864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3864) {
        switch (ctx->pc) {
            case 0x1a38d4: ctx->pc = 0; goto label_1a38d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3864: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a3868: 0xdba60080
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a386c: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a3870: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a3874: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a3878: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a387c: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a3880: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3884: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a3888: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1a388c: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1a3890: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3894: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a3898: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1a389c: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a38a0: 0x4bc4104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a38a4: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a38a8: 0x7e020080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), GPR_VEC(ctx, 2));
    // 0x1a38ac: 0xfa010070
    WRITE128(ADD32(GPR_U32(ctx, 16), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a38b0: 0x7e0300a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), GPR_VEC(ctx, 3));
    // 0x1a38b4: 0xfa030050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a38b8: 0xfa050060
    WRITE128(ADD32(GPR_U32(ctx, 16), 96), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a38bc: 0xfba300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a38c0: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a38c4: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a38c8: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a38cc: 0xfba10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a38d0: 0xfba100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
label_1a38d4:
    // 0x1a38d4: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1a38d8: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1a38dc: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1a38e0: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1a38e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a38ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a38f0; return;
}


// Function: UpdateMatch__FP5MATCHf
// Address: 0x1a38f0 - 0x1a393c

void entry_1a393c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a393c) {
        switch (ctx->pc) {
            case 0x1a3940: ctx->pc = 0; goto label_1a3940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a393c: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
label_1a3940:
    // 0x1a3940: 0xc6020018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[2] = *(float*)&val; }
    // 0x1a3944: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a3948: 0xc601001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[1] = *(float*)&val; }
    // 0x1a394c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1a3950: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3954: 0x0
    // NOP
    // 0x1a3958: 0x45000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A3980; return;
    }
    // 0x1a3960: 0x8e040020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1a3964: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a3968: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1a396c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3974);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3974
// Address: 0x1a3974 - 0x1a397c

void entry_1a3974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3974: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x1a397c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_1a397c
// Address: 0x1a397c - 0x1a3990

void entry_1a397c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a397c) {
        switch (ctx->pc) {
            case 0x1a3980: ctx->pc = 0; goto label_1a3980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a397c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a3980:
    // 0x1a3980: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3984: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3988: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderMatch__FP5MATCHP2CM
// Address: 0x1a3990 - 0x1a39bc

void entry_1a39bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a39bc) {
        switch (ctx->pc) {
            case 0x1a39c0: ctx->pc = 0; goto label_1a39c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a39bc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a39c0:
    // 0x1a39c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostRemitEmit__FP5REMITP5EMITB
// Address: 0x1a39c8 - 0x1a39f8

void entry_1a39f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a39f8: 0xae220120
    WRITE32(ADD32(GPR_U32(ctx, 17), 288), GPR_U32(ctx, 2));
    // 0x1a39fc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a3a00: 0xc60001f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 500)); ctx->f[0] = *(float*)&val; }
    // 0x1a3a04: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3a08: 0xe6200124
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 292), *(uint32_t*)&val); }
    // 0x1a3a0c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3a10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateRemit__FP5REMITf
// Address: 0x1a3a18 - 0x1a3a38

void entry_1a3a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3a38) {
        switch (ctx->pc) {
            case 0x1a3a78: ctx->pc = 0; goto label_1a3a78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3a38: 0x8e020120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a3a3c: 0x1040001d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A3AB4; return;
    }
    // 0x1a3a44: 0xc6000124
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 292)); ctx->f[0] = *(float*)&val; }
    // 0x1a3a48: 0xc6010128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 296)); ctx->f[1] = *(float*)&val; }
    // 0x1a3a4c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1a3a50: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a3a54: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1a3a58: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a3a5c: 0x46011036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3a60: 0x0
    // NOP
    // 0x1a3a64: 0x45000013
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 296), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A3AB4; return;
    }
    // 0x1a3a6c: 0x46001506
    ctx->f[20] = FPU_MOV_S(ctx->f[2]);
    // 0x1a3a70: 0x24110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1a3a74: 0x0
    // NOP
label_1a3a78:
    // 0x1a3a78: 0x7a020080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1a3a7c: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x1a3a80: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1a3a84: 0x8e040120
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x1a3a88: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a3a8c: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1a3a90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3a98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3a98
// Address: 0x1a3a98 - 0x1a3ac8

void entry_1a3a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3a98) {
        switch (ctx->pc) {
            case 0x1a3ab4: ctx->pc = 0; goto label_1a3ab4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3a98: 0xc6000128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 296)); ctx->f[0] = *(float*)&val; }
    // 0x1a3a9c: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1a3aa0: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3aa4: 0x0
    // NOP
    // 0x1a3aa8: 0x4501fff3
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 296), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A3A78; return;
    }
    // 0x1a3ab0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1a3ab4:
    // 0x1a3ab4: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a3ab8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a3abc: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1a3ac0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001A3AC8
// Address: 0x1a3ac8 - 0x1a3ae0

void entry_1a3af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3af4: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x1a3af8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a3afc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a3b00: 0xae020614
    WRITE32(ADD32(GPR_U32(ctx, 16), 1556), GPR_U32(ctx, 2));
    // 0x1a3b04: 0xe6000628
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1576), *(uint32_t*)&val); }
    // 0x1a3b08: 0xae020610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 2));
    // 0x1a3b0c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3b10: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3b14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a3b1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a3b20; return;
}


// Function: LoadRovFromBrx__FP3ROVP18CBinaryInputStream
// Address: 0x1a3b20 - 0x1a3b34

void entry_1a3b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3b34: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a3b38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3b3c: 0x24c6b778
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948728));
    // 0x1a3b40: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1a3b48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1a3b48
// Address: 0x1a3b48 - 0x1a3b58

void entry_1a3b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3b48: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3b4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3b50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostRovLoad__FP3ROV
// Address: 0x1a3b58 - 0x1a3b6c

void entry_1a3b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3b6c: 0x8e020678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1656)));
    // 0x1a3b70: 0x1040002a
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A3C1C; return;
    }
    // 0x1a3b78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3b7c: 0x24c6b790
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948752));
    // 0x1a3b80: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1a3b88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1a3b88
// Address: 0x1a3b88 - 0x1a3ba0

void entry_1a3b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3b88: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3b8c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a3b90: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a3b94: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a3b98: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a3ba0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a3ba0
// Address: 0x1a3ba0 - 0x1a3bb8

void entry_1a3ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3ba0: 0x8e040640
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1600)));
    // 0x1a3ba4: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A3BBC; return;
    }
    // 0x1a3bac: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a3bb0: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1a3bb8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1a3bb8
// Address: 0x1a3bb8 - 0x1a3bd4

void entry_1a3bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3bb8) {
        switch (ctx->pc) {
            case 0x1a3bbc: ctx->pc = 0; goto label_1a3bbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3bb8: 0xae020644
    WRITE32(ADD32(GPR_U32(ctx, 16), 1604), GPR_U32(ctx, 2));
label_1a3bbc:
    // 0x1a3bbc: 0x8e040650
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x1a3bc0: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A3BD8; return;
    }
    // 0x1a3bc8: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a3bcc: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1a3bd4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1a3bd4
// Address: 0x1a3bd4 - 0x1a3bf8

void entry_1a3bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3bd4) {
        switch (ctx->pc) {
            case 0x1a3bd8: ctx->pc = 0; goto label_1a3bd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3bd4: 0xae020654
    WRITE32(ADD32(GPR_U32(ctx, 16), 1620), GPR_U32(ctx, 2));
label_1a3bd8:
    // 0x1a3bd8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a3bdc: 0x8e070664
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1636)));
    // 0x1a3be0: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1a3be4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a3be8: 0x24060050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1a3bec: 0x24080003
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a3bf0: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1a3bf8);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 1644));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a3bf8
// Address: 0x1a3bf8 - 0x1a3c08

void entry_1a3bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3bf8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3bfc: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a3c00: 0xc06901c
    SET_GPR_U32(ctx, 31, 0x1a3c08);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1640), GPR_U32(ctx, 2));
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime); return;
}


// Function: entry_1a3c08
// Address: 0x1a3c08 - 0x1a3c14

void entry_1a3c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3c08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3c0c: 0xc0690b2
    SET_GPR_U32(ctx, 31, 0x1a3c14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRovRovts__FP3ROV5ROVTS(rdram, ctx, runtime); return;
}


// Function: entry_1a3c14
// Address: 0x1a3c14 - 0x1a3c2c

void entry_1a3c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3c14) {
        switch (ctx->pc) {
            case 0x1a3c1c: ctx->pc = 0; goto label_1a3c1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3c14: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A3C30; return;
    }
label_1a3c1c:
    // 0x1a3c1c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a3c20: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a3c24: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3c2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3c2c
// Address: 0x1a3c2c - 0x1a3c40

void entry_1a3c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3c2c) {
        switch (ctx->pc) {
            case 0x1a3c30: ctx->pc = 0; goto label_1a3c30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3c2c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a3c30:
    // 0x1a3c30: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3c34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a3c3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a3c40; return;
}


// Function: UpdateRovActive__FP3ROVP3JOYf
// Address: 0x1a3c40 - 0x1a3c6c

void entry_1a3c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3c6c) {
        switch (ctx->pc) {
            case 0x1a3c74: ctx->pc = 0; goto label_1a3c74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3c6c: 0xae200684
    WRITE32(ADD32(GPR_U32(ctx, 17), 1668), GPR_U32(ctx, 0));
    // 0x1a3c70: 0xae200688
    WRITE32(ADD32(GPR_U32(ctx, 17), 1672), GPR_U32(ctx, 0));
label_1a3c74:
    // 0x1a3c74: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3c78: 0xc068fd0
    SET_GPR_U32(ctx, 31, 0x1a3c80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ReadRovJoystick__FP3ROVP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1a3c80
// Address: 0x1a3c80 - 0x1a3ca0

void entry_1a3c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3c80: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1a3c84: 0xc620061c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1564)); ctx->f[0] = *(float*)&val; }
    // 0x1a3c88: 0x26240630
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1584));
    // 0x1a3c8c: 0xc62d0628
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1576)); ctx->f[13] = *(float*)&val; }
    // 0x1a3c90: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1a3c94: 0xc62c0618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1560)); ctx->f[12] = *(float*)&val; }
    // 0x1a3c98: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1a3ca0);
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[13]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1a3ca0
// Address: 0x1a3ca0 - 0x1a3cd4

void entry_1a3ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3ca0: 0x8e23064c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1612)));
    // 0x1a3ca4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a3ca8: 0x2447c9c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4294953408));
    // 0x1a3cac: 0x68e40007
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1a3cb0: 0x6ce40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1a3cb4: 0x8ce50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x1a3cb8: 0xb3a40037
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a3cbc: 0xb7a40030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a3cc0: 0xafa50038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 5));
    // 0x1a3cc4: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1a3cc8: 0xc46d0110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 272)); ctx->f[13] = *(float*)&val; }
    // 0x1a3ccc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a3cd4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 276)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a3cd4
// Address: 0x1a3cd4 - 0x1a3cf0

void entry_1a3cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3cd4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a3cd8: 0xc62d0620
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1568)); ctx->f[13] = *(float*)&val; }
    // 0x1a3cdc: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x1a3ce0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3ce4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a3ce8: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x1a3cf0);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1a3cf0
// Address: 0x1a3cf0 - 0x1a3d00

void entry_1a3cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3cf0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1a3cf4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a3cf8: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1a3d00);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a3d00
// Address: 0x1a3d00 - 0x1a3d14

void entry_1a3d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3d00: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a3d04: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a3d08: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a3d0c: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1a3d14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1a3d14
// Address: 0x1a3d14 - 0x1a3d28

void entry_1a3d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3d14: 0x8e24064c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1612)));
    // 0x1a3d18: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a3d1c: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1a3d20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3d28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3d28
// Address: 0x1a3d28 - 0x1a3d40

void entry_1a3d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3d28: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a3d2c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a3d30: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a3d34: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1a3d38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateRov__FP3ROVf
// Address: 0x1a3d40 - 0x1a3d5c

void entry_1a3d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3d5c: 0xc04a08c
    SET_GPR_U32(ctx, 31, 0x1a3d64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FDrivenAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a3d64
// Address: 0x1a3d64 - 0x1a3d88

void entry_1a3d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3d64: 0x1040005e
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a3ee0(rdram, ctx, runtime); return;
    }
    // 0x1a3d6c: 0x8e0401ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 492)));
    // 0x1a3d70: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a3d74: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a3d78: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a3d7c: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1a3d80: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3d88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3d88
// Address: 0x1a3d88 - 0x1a3e20

void entry_1a3d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3d88) {
        switch (ctx->pc) {
            case 0x1a3dfc: ctx->pc = 0; goto label_1a3dfc;
            case 0x1a3e08: ctx->pc = 0; goto label_1a3e08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3d88: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x1a3d8c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a3d90: 0x54620043
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1A3EA0; return;
    }
    // 0x1a3d98: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1a3d9c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a3da0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3da4: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1a3da8: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a3dac: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a3db0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a3db4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a3db8: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a3dbc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a3dc0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3dc4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3dc8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a3dcc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a3dd0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a3dd4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a3dd8: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a3ddc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a3de0: 0x4483a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 3);
    // 0x1a3de4: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3de8: 0x0
    // NOP
    // 0x1a3dec: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a3dfc;
    }
    // 0x1a3df4: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a3e08;
    }
label_1a3dfc:
    // 0x1a3dfc: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a3e00: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a3e04: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1a3e08:
    // 0x1a3e08: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a3e0c: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1a3e10: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a3e14: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a3e18: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1a3e20);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1a3e20
// Address: 0x1a3e20 - 0x1a3e60

void entry_1a3e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3e20: 0x8e02021c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 540)));
    // 0x1a3e24: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1a3e28: 0xc46e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x1a3e2c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1a3e30: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1a3e34: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1a3e38: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a3e3c: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1a3e40: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1a3e44: 0xe7a20050
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1a3e48: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a3e4c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a3e50: 0xe7a10054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x1a3e54: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a3e58: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1a3e60);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1a3e60
// Address: 0x1a3e60 - 0x1a3eb0

void entry_1a3e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3e60) {
        switch (ctx->pc) {
            case 0x1a3ea0: ctx->pc = 0; goto label_1a3ea0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3e60: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a3e64: 0x8fa30070
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a3e68: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a3e6c: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1a3e70: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1a3e74: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a3e78: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a3e7c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a3e80: 0x4be41848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3e84: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a3e88: 0x4be51888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a3e8c: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a3e90: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a3e94: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a3e98: 0xfba50060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1a3e9c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1a3ea0:
    // 0x1a3ea0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a3ea4: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1a3ea8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3eb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3eb0
// Address: 0x1a3eb0 - 0x1a3ec4

void entry_1a3eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3eb0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a3eb4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a3eb8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1a3ebc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a3ec4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a3ec4
// Address: 0x1a3ec4 - 0x1a3ed0

void entry_1a3ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3ec4: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1a3ec8: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a3ed0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a3ed0
// Address: 0x1a3ed0 - 0x1a3ee0

void entry_1a3ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3ed0) {
        switch (ctx->pc) {
            case 0x1a3ed8: ctx->pc = 0; goto label_1a3ed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3ed0: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1560), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a3ee0(rdram, ctx, runtime); return;
    }
label_1a3ed8:
    // 0x1a3ed8: 0xc06901c
    SET_GPR_U32(ctx, 31, 0x1a3ee0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime); return;
}


// Function: entry_1a3ee0
// Address: 0x1a3ee0 - 0x1a3ee8

void entry_1a3ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3ee0: 0xc068ff8
    SET_GPR_U32(ctx, 31, 0x1a3ee8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RovsNextRov__FP3ROV(rdram, ctx, runtime); return;
}


// Function: entry_1a3ee8
// Address: 0x1a3ee8 - 0x1a3f08

void entry_1a3ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3ee8) {
        switch (ctx->pc) {
            case 0x1a3f00: ctx->pc = 0; goto label_1a3f00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3ee8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a3eec: 0x8e020610
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x1a3ef0: 0x14a2fff9
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A3ED8; return;
    }
    // 0x1a3ef8: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a3f08(rdram, ctx, runtime); return;
    }
label_1a3f00:
    // 0x1a3f00: 0xc0690b2
    SET_GPR_U32(ctx, 31, 0x1a3f08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetRovRovts__FP3ROV5ROVTS(rdram, ctx, runtime); return;
}


// Function: entry_1a3f08
// Address: 0x1a3f08 - 0x1a3f10

void entry_1a3f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3f08: 0xc069096
    SET_GPR_U32(ctx, 31, 0x1a3f10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RovtsNextRov__FP3ROV(rdram, ctx, runtime); return;
}


// Function: entry_1a3f10
// Address: 0x1a3f10 - 0x1a3f28

void entry_1a3f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3f10: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a3f14: 0x8e020614
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x1a3f18: 0x14a2fff9
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A3F00; return;
    }
    // 0x1a3f20: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1a3f28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a3f28
// Address: 0x1a3f28 - 0x1a3f40

void entry_1a3f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3f28: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a3f2c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a3f30: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a3f34: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1a3f38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReadRovJoystick__FP3ROVP3JOY
// Address: 0x1a3f40 - 0x1a3f88

void entry_1a3f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a3f88) {
        switch (ctx->pc) {
            case 0x1a3f8c: ctx->pc = 0; goto label_1a3f8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a3f88: 0xc6000048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[0] = *(float*)&val; }
label_1a3f8c:
    // 0x1a3f8c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1a3f90: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1a3f94: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1a3f98: 0xe620061c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1564), *(uint32_t*)&val); }
    // 0x1a3f9c: 0xc601007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 124)); ctx->f[1] = *(float*)&val; }
    // 0x1a3fa0: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a3fa4: 0x0
    // NOP
    // 0x1a3fa8: 0x45000006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1a3fc4(rdram, ctx, runtime); return;
    }
    // 0x1a3fb0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a3fb4: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1a3fb8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a3fbc: 0xc0513fe
    SET_GPR_U32(ctx, 31, 0x1a3fc4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 1568));
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime); return;
}


// Function: entry_1a3fc4
// Address: 0x1a3fc4 - 0x1a3fe0

void entry_1a3fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a3fc4: 0xc600007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 124)); ctx->f[0] = *(float*)&val; }
    // 0x1a3fc8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a3fcc: 0xe6200624
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1572), *(uint32_t*)&val); }
    // 0x1a3fd0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a3fd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a3fd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RovsNextRov__FP3ROV
// Address: 0x1a3fe0 - 0x1a4070

void entry_1a4124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4124) {
        switch (ctx->pc) {
            case 0x1a4128: ctx->pc = 0; goto label_1a4128;
            case 0x1a4138: ctx->pc = 0; goto label_1a4138;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4124: 0x8e420668
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1640)));
label_1a4128:
    // 0x1a4128: 0x18400010
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1A416C; return;
    }
    // 0x1a4130: 0x2650066c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1644));
    // 0x1a4134: 0x0
    // NOP
label_1a4138:
    // 0x1a4138: 0x12800005
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4150; return;
    }
    // 0x1a4140: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x1a4148);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1a4148
// Address: 0x1a4148 - 0x1a4158

void entry_1a4148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4148) {
        switch (ctx->pc) {
            case 0x1a4150: ctx->pc = 0; goto label_1a4150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4148: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1640)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A415C; return;
    }
label_1a4150:
    // 0x1a4150: 0xc0557e8
    SET_GPR_U32(ctx, 31, 0x1a4158);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    UnpauseEmitter__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1a4158
// Address: 0x1a4158 - 0x1a4188

void entry_1a4158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4158) {
        switch (ctx->pc) {
            case 0x1a415c: ctx->pc = 0; goto label_1a415c;
            case 0x1a416c: ctx->pc = 0; goto label_1a416c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4158: 0x8e420668
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1640)));
label_1a415c:
    // 0x1a415c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1a4160: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1a4164: 0x1440fff4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4138; return;
    }
label_1a416c:
    // 0x1a416c: 0x8e440644
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1604)));
    // 0x1a4170: 0x10800009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1a4198(rdram, ctx, runtime); return;
    }
    // 0x1a4178: 0x16e20005
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4190; return;
    }
    // 0x1a4180: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1a4188);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1a4188
// Address: 0x1a4188 - 0x1a4198

void entry_1a4188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4188) {
        switch (ctx->pc) {
            case 0x1a4190: ctx->pc = 0; goto label_1a4190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4188: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a4198(rdram, ctx, runtime); return;
    }
label_1a4190:
    // 0x1a4190: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1a4198);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1a4198
// Address: 0x1a4198 - 0x1a41bc

void entry_1a4198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4198: 0x12a00008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        entry_1a41bc(rdram, ctx, runtime); return;
    }
    // 0x1a41a0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a41a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a41a8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a41ac: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a41b0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a41b4: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1a41bc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 1668));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1a41bc
// Address: 0x1a41bc - 0x1a41dc

void entry_1a41bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a41bc: 0x8e440648
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1608)));
    // 0x1a41c0: 0x10800008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A41E4; return;
    }
    // 0x1a41c8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a41cc: 0x12c20018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4230; return;
    }
    // 0x1a41d4: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x1a41dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_1a41dc
// Address: 0x1a41dc - 0x1a422c

void entry_1a41dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a41dc) {
        switch (ctx->pc) {
            case 0x1a41e4: ctx->pc = 0; goto label_1a41e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a41dc: 0xae400648
    WRITE32(ADD32(GPR_U32(ctx, 18), 1608), GPR_U32(ctx, 0));
    // 0x1a41e0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1a41e4:
    // 0x1a41e4: 0x12c20011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 2)) {
        entry_1a422c(rdram, ctx, runtime); return;
    }
    // 0x1a41ec: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a41f0: 0x3c01461c
    SET_GPR_U32(ctx, 1, ((uint32_t)17948 << 16));
    // 0x1a41f4: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1a41f8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a41fc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a4200: 0x3c0145bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17851 << 16));
    // 0x1a4204: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a4208: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a420c: 0x26450648
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1608));
    // 0x1a4210: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a4214: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a4218: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a421c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a4220: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4224: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a422c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a422c
// Address: 0x1a422c - 0x1a4258

void entry_1a422c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a422c) {
        switch (ctx->pc) {
            case 0x1a4230: ctx->pc = 0; goto label_1a4230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a422c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1a4230:
    // 0x1a4230: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a4234: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a4238: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a423c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a4240: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a4244: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a4248: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a424c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a4250: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RovtsNextRov__FP3ROV
// Address: 0x1a4258 - 0x1a42c8

void entry_1a4330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4330) {
        switch (ctx->pc) {
            case 0x1a4338: ctx->pc = 0; goto label_1a4338;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4330: 0x10000004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1624)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4344; return;
    }
label_1a4338:
    // 0x1a4338: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1a4340);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1a4340
// Address: 0x1a4340 - 0x1a4360

void entry_1a4340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4340) {
        switch (ctx->pc) {
            case 0x1a4344: ctx->pc = 0; goto label_1a4344;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4340: 0x8e040658
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1624)));
label_1a4344:
    // 0x1a4344: 0x10800008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4368; return;
    }
    // 0x1a434c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a4350: 0x12220018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A43B4; return;
    }
    // 0x1a4358: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x1a4360);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_1a4360
// Address: 0x1a4360 - 0x1a43b0

void entry_1a4360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4360) {
        switch (ctx->pc) {
            case 0x1a4368: ctx->pc = 0; goto label_1a4368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4360: 0xae000658
    WRITE32(ADD32(GPR_U32(ctx, 16), 1624), GPR_U32(ctx, 0));
    // 0x1a4364: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1a4368:
    // 0x1a4368: 0x12220011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        entry_1a43b0(rdram, ctx, runtime); return;
    }
    // 0x1a4370: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a4374: 0x3c01461c
    SET_GPR_U32(ctx, 1, ((uint32_t)17948 << 16));
    // 0x1a4378: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1a437c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a4380: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a4384: 0x3c0145bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17851 << 16));
    // 0x1a4388: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a438c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a4390: 0x26050658
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1624));
    // 0x1a4394: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a4398: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a439c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a43a0: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a43a4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a43a8: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a43b0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a43b0
// Address: 0x1a43b0 - 0x1a43c8

void entry_1a43b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a43b0) {
        switch (ctx->pc) {
            case 0x1a43b4: ctx->pc = 0; goto label_1a43b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a43b0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a43b4:
    // 0x1a43b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a43b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a43bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a43c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a43c8; return;
}


// Function: HandleRovMessage__FP3ROV5MSGIDPv
// Address: 0x1a43c8 - 0x1a43ec

void entry_1a43ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a43ec) {
        switch (ctx->pc) {
            case 0x1a4420: ctx->pc = 0; goto label_1a4420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a43ec: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1a43f0: 0x12020032
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A44BC; return;
    }
    // 0x1a43f8: 0x16020035
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A44D0; return;
    }
    // 0x1a4400: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1a4404: 0x24020295
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 661));
    // 0x1a4408: 0x10c20005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 662));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_1a4420;
    }
    // 0x1a4410: 0x10c20017
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 338));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4470; return;
    }
    // 0x1a4418: 0x1000002e
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A44D4; return;
    }
label_1a4420:
    // 0x1a4420: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a4424: 0x24040152
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 338));
    // 0x1a4428: 0x3c01463b
    SET_GPR_U32(ctx, 1, ((uint32_t)17979 << 16));
    // 0x1a442c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a4430: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a4434: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4438: 0x3c0145fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17914 << 16));
    // 0x1a443c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a4440: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4444: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a4448: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a444c: 0x26470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1a4450: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a4454: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4458: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a4460);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a4460
// Address: 0x1a4460 - 0x1a4468

void entry_1a4460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4460: 0xc0557e8
    SET_GPR_U32(ctx, 31, 0x1a4468);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1628)));
    UnpauseEmitter__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1a4468
// Address: 0x1a4468 - 0x1a44ac

void entry_1a4468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4468) {
        switch (ctx->pc) {
            case 0x1a4470: ctx->pc = 0; goto label_1a4470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4468: 0x10000019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A44D0; return;
    }
label_1a4470:
    // 0x1a4470: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a4474: 0x3c01463b
    SET_GPR_U32(ctx, 1, ((uint32_t)17979 << 16));
    // 0x1a4478: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a447c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a4480: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4484: 0x3c0145fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17914 << 16));
    // 0x1a4488: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a448c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4490: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a4494: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a4498: 0x26470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1a449c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a44a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a44a4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a44ac);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a44ac
// Address: 0x1a44ac - 0x1a44b4

void entry_1a44ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a44ac: 0xc0557e8
    SET_GPR_U32(ctx, 31, 0x1a44b4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1632)));
    UnpauseEmitter__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1a44b4
// Address: 0x1a44b4 - 0x1a44e8

void entry_1a44b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a44b4) {
        switch (ctx->pc) {
            case 0x1a44bc: ctx->pc = 0; goto label_1a44bc;
            case 0x1a44d0: ctx->pc = 0; goto label_1a44d0;
            case 0x1a44d4: ctx->pc = 0; goto label_1a44d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a44b4: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a44d0;
    }
label_1a44bc:
    // 0x1a44bc: 0x8e420684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1668)));
    // 0x1a44c0: 0x16220003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_1a44d0;
    }
    // 0x1a44c8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a44cc: 0xae420688
    WRITE32(ADD32(GPR_U32(ctx, 18), 1672), GPR_U32(ctx, 2));
label_1a44d0:
    // 0x1a44d0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a44d4:
    // 0x1a44d4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a44d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a44dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a44e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a44e8; return;
}


// Function: PresetRovAccel__FP3ROVf
// Address: 0x1a44e8 - 0x1a44fc

void entry_1a44fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a44fc: 0xc60c0618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1560)); ctx->f[12] = *(float*)&val; }
    // 0x1a4500: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1a4504: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1a450c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a450c
// Address: 0x1a450c - 0x1a4528

void entry_1a450c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a450c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a4510: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a4514: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x1a4518: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a451c: 0x24c6b7d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948824));
    // 0x1a4520: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1a4528);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1a4528
// Address: 0x1a4528 - 0x1a4538

void entry_1a4528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4528: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a452c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a4530: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustRovXpVelocity__FP3ROVP2XPi
// Address: 0x1a4538 - 0x1a455c

void entry_1a455c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a455c) {
        switch (ctx->pc) {
            case 0x1a45a0: ctx->pc = 0; goto label_1a45a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a455c: 0x14400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a45a0;
    }
    // 0x1a4564: 0xda040630
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1584)));
    // 0x1a4568: 0x121180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 6));
    // 0x1a456c: 0xda220080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x1a4570: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1a4574: 0x4bc2206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a4578: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a457c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a4580: 0x4b01284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a4584: 0xd8430030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1a4588: 0x4be11058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a458c: 0x4be1212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a4590: 0x4be418ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a4594: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1a4598: 0xf8430030
    WRITE128(ADD32(GPR_U32(ctx, 2), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a459c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1a45a0:
    // 0x1a45a0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a45a4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a45a8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a45ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a45b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a45b8; return;
}


// Function: AdjustRovNewXp__FP3ROVP2XPi
// Address: 0x1a45b8 - 0x1a45cc

void entry_1a45cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a45cc) {
        switch (ctx->pc) {
            case 0x1a4604: ctx->pc = 0; goto label_1a4604;
            case 0x1a4608: ctx->pc = 0; goto label_1a4608;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a45cc: 0x1440000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a4604;
    }
    // 0x1a45d4: 0xc6010088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 136)); ctx->f[1] = *(float*)&val; }
    // 0x1a45d8: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1a45dc: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1a45e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a45e4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a45e8: 0x0
    // NOP
    // 0x1a45ec: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        goto label_1a4608;
    }
    // 0x1a45f4: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x1a45f8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a45fc: 0xe6000094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    // 0x1a4600: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a4604:
    // 0x1a4604: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a4608:
    // 0x1a4608: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PropagateRovForce__FP3ROViP2XPiP2DZP2FX
// Address: 0x1a4610 - 0x1a4684

void entry_1a4684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4684: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1104), GPR_U32(ctx, 23));
        ctx->pc = 0x1A46A4; return;
    }
    // 0x1a468c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a4690: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a4698);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a4698
// Address: 0x1a4698 - 0x1a46d0

void entry_1a4698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4698) {
        switch (ctx->pc) {
            case 0x1a46a4: ctx->pc = 0; goto label_1a46a4;
            case 0x1a46b4: ctx->pc = 0; goto label_1a46b4;
            case 0x1a46b8: ctx->pc = 0; goto label_1a46b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4698: 0x10400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a46b8;
    }
    // 0x1a46a0: 0xae170450
    WRITE32(ADD32(GPR_U32(ctx, 16), 1104), GPR_U32(ctx, 23));
label_1a46a4:
    // 0x1a46a4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a46a8: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1a46ac: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a46b0: 0x7e030440
    WRITE128(ADD32(GPR_U32(ctx, 16), 1088), GPR_VEC(ctx, 3));
label_1a46b4:
    // 0x1a46b4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1a46b8:
    // 0x1a46b8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a46bc: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1a46c0: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1a46c4: 0x2c0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1a46c8: 0xc06f20a
    SET_GPR_U32(ctx, 31, 0x1a46d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PropagateSoForce__FP2SOiP2XPiP2DZP2FX(rdram, ctx, runtime); return;
}


// Function: entry_1a46d0
// Address: 0x1a46d0 - 0x1a4710

void entry_1a46d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a46d0: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a46d4: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a46d8: 0x7e020440
    WRITE128(ADD32(GPR_U32(ctx, 16), 1088), GPR_VEC(ctx, 2));
    // 0x1a46dc: 0x7e030450
    WRITE128(ADD32(GPR_U32(ctx, 16), 1104), GPR_VEC(ctx, 3));
    // 0x1a46e0: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a46e4: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a46e8: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a46ec: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a46f0: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a46f4: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a46f8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a46fc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a4700: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a4704: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a470c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a4710; return;
}


// Function: FIsRovSoundBase__FP3ROV
// Address: 0x1a4710 - 0x1a4718

void entry_1a472c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a472c: 0x2604035c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 860));
    // 0x1a4730: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a4738);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1440));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a4738
// Address: 0x1a4738 - 0x1a4744

void entry_1a4738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4738: 0x26040368
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 872));
    // 0x1a473c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a4744);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1440));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a4744
// Address: 0x1a4744 - 0x1a4750

void entry_1a4744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4744: 0x26040374
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 884));
    // 0x1a4748: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a4750);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1440));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a4750
// Address: 0x1a4750 - 0x1a475c

void entry_1a4750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4750: 0x26040384
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 900));
    // 0x1a4754: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a475c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1456));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a475c
// Address: 0x1a475c - 0x1a4768

void entry_1a475c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a475c: 0x26040390
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 912));
    // 0x1a4760: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a4768);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1456));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a4768
// Address: 0x1a4768 - 0x1a4774

void entry_1a4768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4768: 0x260403a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 928));
    // 0x1a476c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a4774);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1384));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a4774
// Address: 0x1a4774 - 0x1a4780

void entry_1a4774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4774: 0x260403ac
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 940));
    // 0x1a4778: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a4780);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1384));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a4780
// Address: 0x1a4780 - 0x1a47e0

void entry_1a4780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4780) {
        switch (ctx->pc) {
            case 0x1a47b4: ctx->pc = 0; goto label_1a47b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4780: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a4784: 0x24040028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1a4788: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1a478c: 0xae0403b8
    WRITE32(ADD32(GPR_U32(ctx, 16), 952), GPR_U32(ctx, 4));
    // 0x1a4790: 0x2463c9d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294953424));
    // 0x1a4794: 0xae020650
    WRITE32(ADD32(GPR_U32(ctx, 16), 1616), GPR_U32(ctx, 2));
    // 0x1a4798: 0xae0202d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 2));
    // 0x1a479c: 0x246500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 192));
    // 0x1a47a0: 0xae0202d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 724), GPR_U32(ctx, 2));
    // 0x1a47a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a47a8: 0xae0202d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 2));
    // 0x1a47ac: 0xae0202dc
    WRITE32(ADD32(GPR_U32(ctx, 16), 732), GPR_U32(ctx, 2));
    // 0x1a47b0: 0xae02064c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1612), GPR_U32(ctx, 2));
label_1a47b4:
    // 0x1a47b4: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a47b8: 0x78660010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1a47bc: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x1a47c0: 0x7c860010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 6));
    // 0x1a47c4: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1a47c8: 0x1465fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        goto label_1a47b4;
    }
    // 0x1a47d0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a47d4: 0x260403e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 992));
    // 0x1a47d8: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1a47e0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 192));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1a47e0
// Address: 0x1a47e0 - 0x1a47f0

void entry_1a47e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a47e0: 0x260404a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1184));
    // 0x1a47e4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a47e8: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1a47f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 192));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1a47f0
// Address: 0x1a47f0 - 0x1a4858

void entry_1a47f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a47f0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a47f4: 0x3c01450f
    SET_GPR_U32(ctx, 1, ((uint32_t)17679 << 16));
    // 0x1a47f8: 0x3421c000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49152));
    // 0x1a47fc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1a4800: 0x24425c50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23632));
    // 0x1a4804: 0x3c0144bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17595 << 16));
    // 0x1a4808: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a480c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a4810: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a4814: 0x3c013fba
    SET_GPR_U32(ctx, 1, ((uint32_t)16314 << 16));
    // 0x1a4818: 0x3421e148
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 57672));
    // 0x1a481c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1a4820: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1a4824: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a4828: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a482c: 0x7e0303d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 976), GPR_VEC(ctx, 3));
    // 0x1a4830: 0xe6000350
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 848), *(uint32_t*)&val); }
    // 0x1a4834: 0xe6030348
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 840), *(uint32_t*)&val); }
    // 0x1a4838: 0xe6010344
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 836), *(uint32_t*)&val); }
    // 0x1a483c: 0xe602034c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 844), *(uint32_t*)&val); }
    // 0x1a4840: 0xae000340
    WRITE32(ADD32(GPR_U32(ctx, 16), 832), GPR_U32(ctx, 0));
    // 0x1a4844: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1a4848: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a484c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a4854: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a4858; return;
}


// Function: SetRobCollectible__FP3ROB3OID
// Address: 0x1a4858 - 0x1a4860

void entry_1a48f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a48f4: 0xc069226
    SET_GPR_U32(ctx, 31, 0x1a48fc);
    RobkCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1a48fc
// Address: 0x1a48fc - 0x1a4920

void entry_1a48fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a48fc: 0x8e43064c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1612)));
    // 0x1a4900: 0x1462007f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4B00; return;
    }
    // 0x1a4908: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1a490c: 0x8e4502d8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x1a4910: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1a4914: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a4918: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a4920);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a4920
// Address: 0x1a4920 - 0x1a4938

void entry_1a4920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4920: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1a4924: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a4928: 0xae420354
    WRITE32(ADD32(GPR_U32(ctx, 18), 852), GPR_U32(ctx, 2));
    // 0x1a492c: 0xac520678
    WRITE32(ADD32(GPR_U32(ctx, 2), 1656), GPR_U32(ctx, 18));
    // 0x1a4930: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a4938);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a4938
// Address: 0x1a4938 - 0x1a4950

void entry_1a4938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4938: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a493c: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1a4940: 0xae320558
    WRITE32(ADD32(GPR_U32(ctx, 17), 1368), GPR_U32(ctx, 18));
    // 0x1a4944: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a4948: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a4950);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 724)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a4950
// Address: 0x1a4950 - 0x1a4970

void entry_1a4950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4950: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a4954: 0xae720558
    WRITE32(ADD32(GPR_U32(ctx, 19), 1368), GPR_U32(ctx, 18));
    // 0x1a4958: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a495c: 0x8e4502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1a4960: 0x10a20005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4978; return;
    }
    // 0x1a4968: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a4970);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a4970
// Address: 0x1a4970 - 0x1a49bc

void entry_1a4970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4970) {
        switch (ctx->pc) {
            case 0x1a4978: ctx->pc = 0; goto label_1a4978;
            case 0x1a49a0: ctx->pc = 0; goto label_1a49a0;
            case 0x1a49b0: ctx->pc = 0; goto label_1a49b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4970: 0xae420358
    WRITE32(ADD32(GPR_U32(ctx, 18), 856), GPR_U32(ctx, 2));
    // 0x1a4974: 0xac520558
    WRITE32(ADD32(GPR_U32(ctx, 2), 1368), GPR_U32(ctx, 18));
label_1a4978:
    // 0x1a4978: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a497c: 0xc64003e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 996)); ctx->f[0] = *(float*)&val; }
    // 0x1a4980: 0x44901000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 16);
    // 0x1a4984: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1a4988: 0xc64104a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1188)); ctx->f[1] = *(float*)&val; }
    // 0x1a498c: 0x46000868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[0]);
    // 0x1a4990: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a4994: 0x0
    // NOP
    // 0x1a4998: 0x45020018
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1028)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1A49FC; return;
    }
label_1a49a0:
    // 0x1a49a0: 0x16000003
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1a49b0;
    }
    // 0x1a49a8: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a49bc(rdram, ctx, runtime); return;
    }
label_1a49b0:
    // 0x1a49b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a49b4: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x1a49bc);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a49bc
// Address: 0x1a49bc - 0x1a49c8

void entry_1a49bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a49bc: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a49c0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a49c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 884));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a49c8
// Address: 0x1a49c8 - 0x1a4a34

void entry_1a49c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a49c8) {
        switch (ctx->pc) {
            case 0x1a49fc: ctx->pc = 0; goto label_1a49fc;
            case 0x1a4a18: ctx->pc = 0; goto label_1a4a18;
            case 0x1a4a28: ctx->pc = 0; goto label_1a4a28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a49c8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1a49cc: 0x44901000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 16);
    // 0x1a49d0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1a49d4: 0xc64103e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 996)); ctx->f[1] = *(float*)&val; }
    // 0x1a49d8: 0xc64004a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1188)); ctx->f[0] = *(float*)&val; }
    // 0x1a49dc: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1a49e0: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a49e4: 0x4501ffee
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A49A0; return;
    }
    // 0x1a49ec: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a49f0: 0xc6400404
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1028)); ctx->f[0] = *(float*)&val; }
    // 0x1a49f4: 0x44901000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 16);
    // 0x1a49f8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
label_1a49fc:
    // 0x1a49fc: 0xc64104c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1220)); ctx->f[1] = *(float*)&val; }
    // 0x1a4a00: 0x46000868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[0]);
    // 0x1a4a04: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a4a08: 0x0
    // NOP
    // 0x1a4a0c: 0x45020016
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 736)));
        ctx->pc = 0x1A4A68; return;
    }
    // 0x1a4a14: 0x0
    // NOP
label_1a4a18:
    // 0x1a4a18: 0x16000003
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1a4a28;
    }
    // 0x1a4a20: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a4a34(rdram, ctx, runtime); return;
    }
label_1a4a28:
    // 0x1a4a28: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a4a2c: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x1a4a34);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a4a34
// Address: 0x1a4a34 - 0x1a4a40

void entry_1a4a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4a34: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a4a38: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a4a40);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 912));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a4a40
// Address: 0x1a4a40 - 0x1a4aa0

void entry_1a4a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4a40) {
        switch (ctx->pc) {
            case 0x1a4a68: ctx->pc = 0; goto label_1a4a68;
            case 0x1a4a80: ctx->pc = 0; goto label_1a4a80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4a40: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1a4a44: 0x44901000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 16);
    // 0x1a4a48: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1a4a4c: 0xc6410404
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1028)); ctx->f[1] = *(float*)&val; }
    // 0x1a4a50: 0xc64004c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1220)); ctx->f[0] = *(float*)&val; }
    // 0x1a4a54: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1a4a58: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a4a5c: 0x4501ffee
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A4A18; return;
    }
    // 0x1a4a64: 0x8e4202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 736)));
label_1a4a68:
    // 0x1a4a68: 0x18400024
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1A4AFC; return;
    }
    // 0x1a4a70: 0x265e02e4
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 18), 740));
    // 0x1a4a74: 0x265703a0
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 18), 928));
    // 0x1a4a78: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1a4a7c: 0x0
    // NOP
label_1a4a80:
    // 0x1a4a80: 0x8ec45710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    // 0x1a4a84: 0x3c21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 2)));
    // 0x1a4a88: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x1a4a8c: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a4a90: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a4a94: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a4a98: 0xc056866
    SET_GPR_U32(ctx, 31, 0x1a4aa0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjects__FP2SWi3OIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a4aa0
// Address: 0x1a4aa0 - 0x1a4acc

void entry_1a4aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4aa0) {
        switch (ctx->pc) {
            case 0x1a4ab0: ctx->pc = 0; goto label_1a4ab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4aa0: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4aa4: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a4aa8: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4aac: 0x26150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 16), 1));
label_1a4ab0:
    // 0x1a4ab0: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x1a4ab4: 0x10400008
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4AD8; return;
    }
    // 0x1a4abc: 0x24050044
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1a4ac0: 0x3a28021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1a4ac4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a4acc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a4acc
// Address: 0x1a4acc - 0x1a4aec

void entry_1a4acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4acc) {
        switch (ctx->pc) {
            case 0x1a4ad8: ctx->pc = 0; goto label_1a4ad8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4acc: 0x1040fff8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4AB0; return;
    }
    // 0x1a4ad4: 0x8e130000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1a4ad8:
    // 0x1a4ad8: 0xae720558
    WRITE32(ADD32(GPR_U32(ctx, 19), 1368), GPR_U32(ctx, 18));
    // 0x1a4adc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a4ae0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1a4ae4: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a4aec);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a4aec
// Address: 0x1a4aec - 0x1a4b30

void entry_1a4aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4aec) {
        switch (ctx->pc) {
            case 0x1a4afc: ctx->pc = 0; goto label_1a4afc;
            case 0x1a4b00: ctx->pc = 0; goto label_1a4b00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4aec: 0x8e4202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 736)));
    // 0x1a4af0: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1a4af4: 0x1440ffe2
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4A80; return;
    }
label_1a4afc:
    // 0x1a4afc: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_1a4b00:
    // 0x1a4b00: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a4b04: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a4b08: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a4b0c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a4b10: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a4b14: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a4b18: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a4b1c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a4b20: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a4b24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a4b2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a4b30; return;
}


// Function: PostRobLoad__FP3ROB
// Address: 0x1a4b30 - 0x1a4b44

void entry_1a4b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4b44: 0xc069226
    SET_GPR_U32(ctx, 31, 0x1a4b4c);
    RobkCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1a4b4c
// Address: 0x1a4b4c - 0x1a4b68

void entry_1a4b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4b4c: 0x8e03064c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1612)));
    // 0x1a4b50: 0x10620007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4B70; return;
    }
    // 0x1a4b58: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a4b5c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a4b60: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a4b68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a4b68
// Address: 0x1a4b68 - 0x1a4c2c

void entry_1a4b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4b68) {
        switch (ctx->pc) {
            case 0x1a4b70: ctx->pc = 0; goto label_1a4b70;
            case 0x1a4bbc: ctx->pc = 0; goto label_1a4bbc;
            case 0x1a4bd0: ctx->pc = 0; goto label_1a4bd0;
            case 0x1a4bf0: ctx->pc = 0; goto label_1a4bf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4b68: 0x10000034
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4C3C; return;
    }
label_1a4b70:
    // 0x1a4b70: 0x260303d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 976));
    // 0x1a4b74: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1a4b78: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1a4b7c: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1a4b80: 0x24a25c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 23648));
    // 0x1a4b84: 0xc481000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 12)); ctx->f[1] = *(float*)&val; }
    // 0x1a4b88: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a4b8c: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1a4b90: 0xc60303d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 976)); ctx->f[3] = *(float*)&val; }
    // 0x1a4b94: 0xc4a45c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1a4b98: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1a4b9c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1a4ba0: 0x46011840
    ctx->f[1] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1a4ba4: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a4ba8: 0x0
    // NOP
    // 0x1a4bac: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a4bbc;
    }
    // 0x1a4bb4: 0x10000006
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a4bd0;
    }
label_1a4bbc:
    // 0x1a4bbc: 0x46012834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a4bc0: 0x0
    // NOP
    // 0x1a4bc4: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a4bd0;
    }
    // 0x1a4bcc: 0x460028c6
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
label_1a4bd0:
    // 0x1a4bd0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a4bd4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a4bd8: 0x260503e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 992));
    // 0x1a4bdc: 0x260404a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1184));
    // 0x1a4be0: 0x26030560
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 1376));
    // 0x1a4be4: 0x46030081
    ctx->f[2] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1a4be8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a4bec: 0x0
    // NOP
label_1a4bf0:
    // 0x1a4bf0: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1a4bf4: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1a4bf8: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1a4bfc: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1a4c00: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1a4c04: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1a4c08: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1a4c0c: 0x2cc20030
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 48));
    // 0x1a4c10: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a4c14: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1a4c18: 0x1440fff5
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a4bf0;
    }
    // 0x1a4c20: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a4c24: 0xc0695d8
    SET_GPR_U32(ctx, 31, 0x1a4c2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime); return;
}


// Function: entry_1a4c2c
// Address: 0x1a4c2c - 0x1a4c38

void entry_1a4c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4c2c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a4c30: 0xc0693bc
    SET_GPR_U32(ctx, 31, 0x1a4c38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRobRobs__FP3ROB4ROBS(rdram, ctx, runtime); return;
}


// Function: entry_1a4c38
// Address: 0x1a4c38 - 0x1a4c48

void entry_1a4c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4c38) {
        switch (ctx->pc) {
            case 0x1a4c3c: ctx->pc = 0; goto label_1a4c3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4c38: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a4c3c:
    // 0x1a4c3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a4c40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateRob__FP3ROBf
// Address: 0x1a4c48 - 0x1a4c60

void entry_1a4c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4c60) {
        switch (ctx->pc) {
            case 0x1a4c68: ctx->pc = 0; goto label_1a4c68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4c60: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a4c70(rdram, ctx, runtime); return;
    }
label_1a4c68:
    // 0x1a4c68: 0xc0693bc
    SET_GPR_U32(ctx, 31, 0x1a4c70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetRobRobs__FP3ROB4ROBS(rdram, ctx, runtime); return;
}


// Function: entry_1a4c70
// Address: 0x1a4c70 - 0x1a4c78

void entry_1a4c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4c70: 0xc069370
    SET_GPR_U32(ctx, 31, 0x1a4c78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RobsNextRob__FP3ROB(rdram, ctx, runtime); return;
}


// Function: entry_1a4c78
// Address: 0x1a4c78 - 0x1a4ce0

void entry_1a4c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4c78: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a4c7c: 0x8e020650
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x1a4c80: 0x14a2fff9
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 7));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4C68; return;
    }
    // 0x1a4c88: 0x1040002f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a4d48(rdram, ctx, runtime); return;
    }
    // 0x1a4c90: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1a4c94: 0x2442ca90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953616));
    // 0x1a4c98: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1a4c9c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a4ca0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1a4ca8: 0x8e0203bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 956)));
    // 0x1a4cac: 0x8e0303b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 952)));
    // 0x1a4cb0: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1a4cb4: 0x1040000a
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a4ce0(rdram, ctx, runtime); return;
    }
    // 0x1a4cbc: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x1a4cc0: 0xc6010634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1588)); ctx->f[1] = *(float*)&val; }
    // 0x1a4cc4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a4cc8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a4ccc: 0x0
    // NOP
    // 0x1a4cd0: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1600)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x1A4CEC; return;
    }
    // 0x1a4cd8: 0xc069448
    SET_GPR_U32(ctx, 31, 0x1a4ce0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddRobRoc__FP3ROB(rdram, ctx, runtime); return;
}


// Function: entry_1a4ce0
// Address: 0x1a4ce0 - 0x1a4d04

void entry_1a4ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4ce0) {
        switch (ctx->pc) {
            case 0x1a4cec: ctx->pc = 0; goto label_1a4cec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4ce0: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x1a4ce4: 0xc6010640
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1600)); ctx->f[1] = *(float*)&val; }
    // 0x1a4ce8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
label_1a4cec:
    // 0x1a4cec: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a4cf0: 0x0
    // NOP
    // 0x1a4cf4: 0x45000015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A4D4C; return;
    }
    // 0x1a4cfc: 0xc06953e
    SET_GPR_U32(ctx, 31, 0x1a4d04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddRobRoh__FP3ROB(rdram, ctx, runtime); return;
}


// Function: entry_1a4d04
// Address: 0x1a4d04 - 0x1a4d48

void entry_1a4d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4d04) {
        switch (ctx->pc) {
            case 0x1a4d3c: ctx->pc = 0; goto label_1a4d3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4d04: 0x10000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4D4C; return;
    }
    // 0x1a4d0c: 0x8e050358
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 856)));
    // 0x1a4d10: 0x10a0000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4D4C; return;
    }
    // 0x1a4d18: 0x8ca20550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 1360)));
    // 0x1a4d1c: 0x1440000c
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4D50; return;
    }
    // 0x1a4d24: 0x8e040658
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1624)));
    // 0x1a4d28: 0x10800004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1a4d3c;
    }
    // 0x1a4d30: 0x8c8302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 724)));
    // 0x1a4d34: 0x10620007
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4D54; return;
    }
label_1a4d3c:
    // 0x1a4d3c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a4d40: 0xc069e66
    SET_GPR_U32(ctx, 31, 0x1a4d48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetRopRops__FP3ROP4ROPS(rdram, ctx, runtime); return;
}


// Function: entry_1a4d48
// Address: 0x1a4d48 - 0x1a4d60

void entry_1a4d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4d48) {
        switch (ctx->pc) {
            case 0x1a4d4c: ctx->pc = 0; goto label_1a4d4c;
            case 0x1a4d50: ctx->pc = 0; goto label_1a4d50;
            case 0x1a4d54: ctx->pc = 0; goto label_1a4d54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4d48: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a4d4c:
    // 0x1a4d4c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a4d50:
    // 0x1a4d50: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a4d54:
    // 0x1a4d54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a4d5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a4d60; return;
}


// Function: FUN_001a4d60
// Address: 0x1a4d60 - 0x1a4d80

void FUN_001a4d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4d60: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1a4d64: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a4d68: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1a4d6c: 0x8c830650
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1616)));
    // 0x1a4d70: 0x14620004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A4D84; return;
    }
    // 0x1a4d78: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1a4d80);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1a4d80
// Address: 0x1a4d80 - 0x1a4d9c

void entry_1a4d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4d80) {
        switch (ctx->pc) {
            case 0x1a4d84: ctx->pc = 0; goto label_1a4d84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4d80: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1a4d84:
    // 0x1a4d84: 0x10800007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4DA4; return;
    }
    // 0x1a4d8c: 0x8c83d0c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955208)));
    // 0x1a4d90: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1a4d94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a4d9c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955208));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a4d9c
// Address: 0x1a4d9c - 0x1a4db4

void entry_1a4d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4d9c) {
        switch (ctx->pc) {
            case 0x1a4da4: ctx->pc = 0; goto label_1a4da4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4d9c: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A4DB8; return;
    }
label_1a4da4:
    // 0x1a4da4: 0x8c83d0c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955208)));
    // 0x1a4da8: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1a4dac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a4db4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955208));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a4db4
// Address: 0x1a4db4 - 0x1a4dc0

void entry_1a4db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4db4) {
        switch (ctx->pc) {
            case 0x1a4db8: ctx->pc = 0; goto label_1a4db8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4db4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a4db8:
    // 0x1a4db8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RobsNextRob__FP3ROB
// Address: 0x1a4dc0 - 0x1a4ef0

void entry_1a4f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a4f84) {
        switch (ctx->pc) {
            case 0x1a4f88: ctx->pc = 0; goto label_1a4f88;
            case 0x1a4f8c: ctx->pc = 0; goto label_1a4f8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a4f84: 0xae020658
    WRITE32(ADD32(GPR_U32(ctx, 16), 1624), GPR_U32(ctx, 2));
label_1a4f88:
    // 0x1a4f88: 0x8e030658
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1624)));
label_1a4f8c:
    // 0x1a4f8c: 0x1060005f
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1a510c(rdram, ctx, runtime); return;
    }
    // 0x1a4f94: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a4f98: 0x24a501f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 504));
    // 0x1a4f9c: 0xa8a30327
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 807); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1a4fa0: 0xb8a30324
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 804); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1a4fa4: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x1a4fac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1a4fac
// Address: 0x1a4fac - 0x1a4fd8

void entry_1a4fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4fac: 0x10000058
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5110; return;
    }
    // 0x1a4fb4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a4fb8: 0x260403c4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 964));
    // 0x1a4fbc: 0x2442d0c8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955208));
    // 0x1a4fc0: 0x260303b8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 952));
    // 0x1a4fc4: 0xac430268
    WRITE32(ADD32(GPR_U32(ctx, 2), 616), GPR_U32(ctx, 3));
    // 0x1a4fc8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a4fcc: 0xac440264
    WRITE32(ADD32(GPR_U32(ctx, 2), 612), GPR_U32(ctx, 4));
    // 0x1a4fd0: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x1a4fd8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_1a4fd8
// Address: 0x1a4fd8 - 0x1a4ff4

void entry_1a4fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4fd8: 0x1000004d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5110; return;
    }
    // 0x1a4fe0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1a4fe4: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x1a4fe8: 0x2406033d
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 829));
    // 0x1a4fec: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1a4ff4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a4ff4
// Address: 0x1a4ff4 - 0x1a5014

void entry_1a4ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a4ff4: 0x10400007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1624), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a5014(rdram, ctx, runtime); return;
    }
    // 0x1a4ffc: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1a5000: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a5004: 0x24a501f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 504));
    // 0x1a5008: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x1a500c: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x1a5014);
    WRITE32(ADD32(GPR_U32(ctx, 5), 804), GPR_U32(ctx, 2));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1a5014
// Address: 0x1a5014 - 0x1a5030

void entry_1a5014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5014) {
        switch (ctx->pc) {
            case 0x1a5028: ctx->pc = 0; goto label_1a5028;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5014: 0x8e100384
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 900)));
    // 0x1a5018: 0x12000008
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A503C; return;
    }
    // 0x1a5020: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a5024: 0x0
    // NOP
label_1a5028:
    // 0x1a5028: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a5030);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a5030
// Address: 0x1a5030 - 0x1a5044

void entry_1a5030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5030) {
        switch (ctx->pc) {
            case 0x1a503c: ctx->pc = 0; goto label_1a503c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5030: 0x8e1005b0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1456)));
    // 0x1a5034: 0x1600fffc
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5028; return;
    }
label_1a503c:
    // 0x1a503c: 0xc0547f2
    SET_GPR_U32(ctx, 31, 0x1a5044);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 7920));
    OnDifficultyCollectKey__FP10DIFFICULTY(rdram, ctx, runtime); return;
}


// Function: entry_1a5044
// Address: 0x1a5044 - 0x1a5060

void entry_1a5044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5044: 0x10000032
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5110; return;
    }
    // 0x1a504c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1a5050: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x1a5054: 0x2406033e
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 830));
    // 0x1a5058: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1a5060);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a5060
// Address: 0x1a5060 - 0x1a5080

void entry_1a5060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5060: 0x10400007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1624), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a5080(rdram, ctx, runtime); return;
    }
    // 0x1a5068: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1a506c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a5070: 0x24a501f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 504));
    // 0x1a5074: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x1a5078: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x1a5080);
    WRITE32(ADD32(GPR_U32(ctx, 5), 804), GPR_U32(ctx, 2));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1a5080
// Address: 0x1a5080 - 0x1a50ac

void entry_1a5080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5080) {
        switch (ctx->pc) {
            case 0x1a5090: ctx->pc = 0; goto label_1a5090;
            case 0x1a50a4: ctx->pc = 0; goto label_1a50a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5080: 0x8e100384
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 900)));
    // 0x1a5084: 0x1200000c
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A50B8; return;
    }
    // 0x1a508c: 0x8e02055c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
label_1a5090:
    // 0x1a5090: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a50a4;
    }
    // 0x1a5098: 0x8c420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1a509c: 0x50500004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1456)));
        ctx->pc = 0x1A50B0; return;
    }
label_1a50a4:
    // 0x1a50a4: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a50ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a50ac
// Address: 0x1a50ac - 0x1a50c8

void entry_1a50ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a50ac) {
        switch (ctx->pc) {
            case 0x1a50b0: ctx->pc = 0; goto label_1a50b0;
            case 0x1a50b8: ctx->pc = 0; goto label_1a50b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a50ac: 0x8e1005b0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1456)));
label_1a50b0:
    // 0x1a50b0: 0x5600fff7
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
        ctx->pc = 0x1A5090; return;
    }
label_1a50b8:
    // 0x1a50b8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a50bc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a50c0: 0xc054788
    SET_GPR_U32(ctx, 31, 0x1a50c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 7920));
    OnDifficultyPlayerDeath(rdram, ctx, runtime); return;
}


// Function: entry_1a50c8
// Address: 0x1a50c8 - 0x1a50e4

void entry_1a50c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a50c8: 0x10000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5110; return;
    }
    // 0x1a50d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a50d4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a50d8: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x1a50dc: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1a50e4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 26));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1a50e4
// Address: 0x1a50e4 - 0x1a50f8

void entry_1a50e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a50e4: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5110; return;
    }
    // 0x1a50ec: 0x8e040354
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 852)));
    // 0x1a50f0: 0xc06901c
    SET_GPR_U32(ctx, 31, 0x1a50f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime); return;
}


// Function: entry_1a50f8
// Address: 0x1a50f8 - 0x1a510c

void entry_1a50f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a50f8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a50fc: 0x8c83ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294962288)));
    // 0x1a5100: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1a5104: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a510c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294962288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a510c
// Address: 0x1a510c - 0x1a5120

void entry_1a510c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a510c) {
        switch (ctx->pc) {
            case 0x1a5110: ctx->pc = 0; goto label_1a5110;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a510c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1a5110:
    // 0x1a5110: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a5114: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5118: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddRobRoc__FP3ROB
// Address: 0x1a5120 - 0x1a518c

void entry_1a518c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a518c: 0xc6610340
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 832)); ctx->f[1] = *(float*)&val; }
    // 0x1a5190: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1a5194: 0xc64c03d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 976)); ctx->f[12] = *(float*)&val; }
    // 0x1a5198: 0xc66d0344
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 836)); ctx->f[13] = *(float*)&val; }
    // 0x1a519c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a51a4);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a51a4
// Address: 0x1a51a4 - 0x1a51ac

void entry_1a51a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a51a4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1a51ac);
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1a51ac
// Address: 0x1a51ac - 0x1a51c4

void entry_1a51ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a51ac: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a51b0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1a51b4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1a51b8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a51bc: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1a51c4);
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1a51c4
// Address: 0x1a51c4 - 0x1a53dc

void entry_1a51c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a51c4) {
        switch (ctx->pc) {
            case 0x1a522c: ctx->pc = 0; goto label_1a522c;
            case 0x1a5234: ctx->pc = 0; goto label_1a5234;
            case 0x1a5250: ctx->pc = 0; goto label_1a5250;
            case 0x1a528c: ctx->pc = 0; goto label_1a528c;
            case 0x1a52a0: ctx->pc = 0; goto label_1a52a0;
            case 0x1a52ac: ctx->pc = 0; goto label_1a52ac;
            case 0x1a52c0: ctx->pc = 0; goto label_1a52c0;
            case 0x1a530c: ctx->pc = 0; goto label_1a530c;
            case 0x1a5318: ctx->pc = 0; goto label_1a5318;
            case 0x1a5320: ctx->pc = 0; goto label_1a5320;
            case 0x1a532c: ctx->pc = 0; goto label_1a532c;
            case 0x1a5338: ctx->pc = 0; goto label_1a5338;
            case 0x1a5380: ctx->pc = 0; goto label_1a5380;
            case 0x1a5388: ctx->pc = 0; goto label_1a5388;
            case 0x1a5394: ctx->pc = 0; goto label_1a5394;
            case 0x1a53a0: ctx->pc = 0; goto label_1a53a0;
            case 0x1a53ac: ctx->pc = 0; goto label_1a53ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a51c4: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a51c8: 0xc661034c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 844)); ctx->f[1] = *(float*)&val; }
    // 0x1a51cc: 0xda620330
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 816)));
    // 0x1a51d0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1a51d4: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1a51d8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a51dc: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a51e0: 0x12000014
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1a5234;
    }
    // 0x1a51e8: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1a51ec: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a51f0: 0xc60003d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 976)); ctx->f[0] = *(float*)&val; }
    // 0x1a51f4: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a51f8: 0xc64103d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 976)); ctx->f[1] = *(float*)&val; }
    // 0x1a51fc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5200: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5204: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5208: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a520c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a5210: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a5214: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a5218: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1a521c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a5220: 0x0
    // NOP
    // 0x1a5224: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1a522c;
    }
label_1a522c:
    // 0x1a522c: 0x5440005c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_1a53a0;
    }
label_1a5234:
    // 0x1a5234: 0x8e620384
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 900)));
    // 0x1a5238: 0x5040001c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 860)));
        goto label_1a52ac;
    }
    // 0x1a5240: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5244: 0xc64203d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 976)); ctx->f[2] = *(float*)&val; }
    // 0x1a5248: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1a524c: 0x0
    // NOP
label_1a5250:
    // 0x1a5250: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a5254: 0xc44103d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 976)); ctx->f[1] = *(float*)&val; }
    // 0x1a5258: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a525c: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5260: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5264: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5268: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a526c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a5270: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1a5274: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a5278: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1a527c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a5280: 0x0
    // NOP
    // 0x1a5284: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1a528c;
    }
label_1a528c:
    // 0x1a528c: 0x14600004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1a52a0;
    }
    // 0x1a5294: 0x8c4205b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 1456)));
    // 0x1a5298: 0x5440ffed
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
        goto label_1a5250;
    }
label_1a52a0:
    // 0x1a52a0: 0x5440003f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_1a53a0;
    }
    // 0x1a52a8: 0x8e63035c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 860)));
label_1a52ac:
    // 0x1a52ac: 0x5060001f
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 872)));
        goto label_1a532c;
    }
    // 0x1a52b4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a52b8: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1a52bc: 0x0
    // NOP
label_1a52c0:
    // 0x1a52c0: 0x54400015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 1440)));
        goto label_1a5318;
    }
    // 0x1a52c8: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1a52cc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a52d0: 0xc64103d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 976)); ctx->f[1] = *(float*)&val; }
    // 0x1a52d4: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a52d8: 0xc46203d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 976)); ctx->f[2] = *(float*)&val; }
    // 0x1a52dc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a52e0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a52e4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a52e8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a52ec: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a52f0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1a52f4: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a52f8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1a52fc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a5300: 0x0
    // NOP
    // 0x1a5304: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1a530c;
    }
label_1a530c:
    // 0x1a530c: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a5320;
    }
    // 0x1a5314: 0x8c6305a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 1440)));
label_1a5318:
    // 0x1a5318: 0x5460ffe9
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
        goto label_1a52c0;
    }
label_1a5320:
    // 0x1a5320: 0x5460001f
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_1a53a0;
    }
    // 0x1a5328: 0x8e630368
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 872)));
label_1a532c:
    // 0x1a532c: 0x1060001f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 8));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a53ac;
    }
    // 0x1a5334: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a5338:
    // 0x1a5338: 0x10720013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 18)) {
        goto label_1a5388;
    }
    // 0x1a5340: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1a5344: 0xc64103d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 976)); ctx->f[1] = *(float*)&val; }
    // 0x1a5348: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a534c: 0xc46203d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 976)); ctx->f[2] = *(float*)&val; }
    // 0x1a5350: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5354: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a5358: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a535c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a5360: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a5364: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1a5368: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a536c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1a5370: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a5374: 0x0
    // NOP
    // 0x1a5378: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1a5380;
    }
label_1a5380:
    // 0x1a5380: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a5394;
    }
label_1a5388:
    // 0x1a5388: 0x8c6305a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 1440)));
    // 0x1a538c: 0x1460ffea
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1a5338;
    }
label_1a5394:
    // 0x1a5394: 0x10600005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 8));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a53ac;
    }
    // 0x1a539c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_1a53a0:
    // 0x1a53a0: 0x2a220008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 8));
    // 0x1a53a4: 0x1440ff74
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5178; return;
    }
label_1a53ac:
    // 0x1a53ac: 0x10400049
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A54D4; return;
    }
    // 0x1a53b4: 0x8e6303bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 956)));
    // 0x1a53b8: 0x8e620380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 896)));
    // 0x1a53bc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1a53c0: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1a53c4: 0xae6303bc
    WRITE32(ADD32(GPR_U32(ctx, 19), 956), GPR_U32(ctx, 3));
    // 0x1a53c8: 0xae620380
    WRITE32(ADD32(GPR_U32(ctx, 19), 896), GPR_U32(ctx, 2));
    // 0x1a53cc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a53d0: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1a53d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a53dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a53dc
// Address: 0x1a53dc - 0x1a53f8

void entry_1a53dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a53dc: 0xc6600350
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 848)); ctx->f[0] = *(float*)&val; }
    // 0x1a53e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a53e4: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1a53e8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a53ec: 0x8c430084
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 132)));
    // 0x1a53f0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a53f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a53f8
// Address: 0x1a53f8 - 0x1a5410

void entry_1a53f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a53f8: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1a53fc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a5400: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a5404: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a5408: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a5410);
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a5410
// Address: 0x1a5410 - 0x1a5428

void entry_1a5410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5410: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1a5414: 0x26318d20
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294937888));
    // 0x1a5418: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1a541c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a5420: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1a5428);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a5428
// Address: 0x1a5428 - 0x1a543c

void entry_1a5428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5428: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a542c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a5430: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1a5434: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a543c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a543c
// Address: 0x1a543c - 0x1a5458

void entry_1a543c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a543c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a5440: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1a5444: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1a5448: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a544c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1a5450: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5458);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5458
// Address: 0x1a5458 - 0x1a546c

void entry_1a5458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5458: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a545c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a5460: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1a5464: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a546c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a546c
// Address: 0x1a546c - 0x1a5484

void entry_1a546c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a546c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a5470: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a5474: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5478: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a547c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a5484);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a5484
// Address: 0x1a5484 - 0x1a5490

void entry_1a5484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5484: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a5488: 0xc069d20
    SET_GPR_U32(ctx, 31, 0x1a5490);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRocRocs__FP3ROC4ROCS(rdram, ctx, runtime); return;
}


// Function: entry_1a5490
// Address: 0x1a5490 - 0x1a549c

void entry_1a5490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5490: 0x26640374
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 884));
    // 0x1a5494: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a549c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a549c
// Address: 0x1a549c - 0x1a54a8

void entry_1a549c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a549c: 0x26640368
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 872));
    // 0x1a54a0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a54a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a54a8
// Address: 0x1a54a8 - 0x1a54b4

void entry_1a54a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a54a8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a54ac: 0xc06988e
    SET_GPR_U32(ctx, 31, 0x1a54b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FChooseRobRoh__FP3ROBP3ROC(rdram, ctx, runtime); return;
}


// Function: entry_1a54b4
// Address: 0x1a54b4 - 0x1a54c0

void entry_1a54b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a54b4: 0xc66c062c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1580)); ctx->f[12] = *(float*)&val; }
    // 0x1a54b8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a54c0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1584)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a54c0
// Address: 0x1a54c0 - 0x1a54f8

void entry_1a54c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a54c0) {
        switch (ctx->pc) {
            case 0x1a54d0: ctx->pc = 0; goto label_1a54d0;
            case 0x1a54d4: ctx->pc = 0; goto label_1a54d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a54c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a54c4: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a54c8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a54cc: 0xe6610634
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 1588), *(uint32_t*)&val); }
label_1a54d0:
    // 0x1a54d0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1a54d4:
    // 0x1a54d4: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a54d8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a54dc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a54e0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a54e4: 0xc7b600b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[22] = *(float*)&val; }
    // 0x1a54e8: 0xc7b500a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[21] = *(float*)&val; }
    // 0x1a54ec: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1a54f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddRobRoh__FP3ROB
// Address: 0x1a54f8 - 0x1a5560

void entry_1a5560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5560: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a5564: 0x10a00070
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5728; return;
    }
    // 0x1a556c: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1a5570: 0x8c44b314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294947604)));
    // 0x1a5574: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1a5578: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a557c: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1a5580: 0xafa4000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 4));
    // 0x1a5584: 0x261403ac
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 940));
    // 0x1a5588: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a558c: 0xafb20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
    // 0x1a5590: 0xafb20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 18));
    // 0x1a5594: 0x26150390
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 16), 912));
    // 0x1a5598: 0xac5db314
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294947604), GPR_U32(ctx, 29));
    // 0x1a559c: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x1a55a4);
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 900));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1a55a4
// Address: 0x1a55a4 - 0x1a55e4

void entry_1a55a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a55a4) {
        switch (ctx->pc) {
            case 0x1a55b8: ctx->pc = 0; goto label_1a55b8;
            case 0x1a55d8: ctx->pc = 0; goto label_1a55d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a55a4: 0x26170638
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 16), 1592));
    // 0x1a55a8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a55ac: 0x440000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_S32(ctx, 2) < 0) {
        goto label_1a55d8;
    }
    // 0x1a55b4: 0x8fa60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_1a55b8:
    // 0x1a55b8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1a55bc: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a55c0: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1a55c4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a55c8: 0x60982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1a55cc: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1a55d0: 0x481fff9
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1a55b8;
    }
label_1a55d8:
    // 0x1a55d8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a55dc: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a55e4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a55e4
// Address: 0x1a55e4 - 0x1a55f4

void entry_1a55e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a55e4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1a55e8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1a55ec: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a55f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a55f4
// Address: 0x1a55f4 - 0x1a5608

void entry_1a55f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a55f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a55f8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1a55fc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1a5600: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a5608);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5608
// Address: 0x1a5608 - 0x1a5614

void entry_1a5608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5608: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a560c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5614);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5614
// Address: 0x1a5614 - 0x1a5634

void entry_1a5614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5614: 0xae330560
    WRITE32(ADD32(GPR_U32(ctx, 17), 1376), GPR_U32(ctx, 19));
    // 0x1a5618: 0x8e02039c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 924)));
    // 0x1a561c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1a5620: 0xae02039c
    WRITE32(ADD32(GPR_U32(ctx, 16), 924), GPR_U32(ctx, 2));
    // 0x1a5624: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a5628: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1a562c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5634);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5634
// Address: 0x1a5634 - 0x1a5648

void entry_1a5634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5634: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a5638: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a563c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1a5640: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5648);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 320));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5648
// Address: 0x1a5648 - 0x1a565c

void entry_1a5648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5648: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a564c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a5650: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1a5654: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a565c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 272));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a565c
// Address: 0x1a565c - 0x1a5668

void entry_1a565c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a565c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a5660: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a5668);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a5668
// Address: 0x1a5668 - 0x1a5674

void entry_1a5668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5668: 0x8e240560
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x1a566c: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x1a5674);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_1a5674
// Address: 0x1a5674 - 0x1a5690

void entry_1a5674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5674: 0xc6000644
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1604)); ctx->f[0] = *(float*)&val; }
    // 0x1a5678: 0xe6200564
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1380), *(uint32_t*)&val); }
    // 0x1a567c: 0xc6010648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1608)); ctx->f[1] = *(float*)&val; }
    // 0x1a5680: 0xe6210568
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1384), *(uint32_t*)&val); }
    // 0x1a5684: 0xc6ed0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1a5688: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a5690);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a5690
// Address: 0x1a5690 - 0x1a56e0

void entry_1a5690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5690: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a5694: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1a5698: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a569c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a56a0: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1a56a4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1a56a8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a56ac: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a56b0: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a56b4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a56b8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a56bc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a56c0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a56c4: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1a56c8: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x1a56cc: 0x4600a406
    ctx->f[16] = FPU_MOV_S(ctx->f[20]);
    // 0x1a56d0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a56d4: 0xe6010640
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1600), *(uint32_t*)&val); }
    // 0x1a56d8: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a56e0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a56e0
// Address: 0x1a56e0 - 0x1a5720

void entry_1a56e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a56e0: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x1a56e4: 0x3c01463b
    SET_GPR_U32(ctx, 1, ((uint32_t)17979 << 16));
    // 0x1a56e8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a56ec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a56f0: 0x3c01459c
    SET_GPR_U32(ctx, 1, ((uint32_t)17820 << 16));
    // 0x1a56f4: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1a56f8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a56fc: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a5700: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1a5704: 0x2404014e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 334));
    // 0x1a5708: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a570c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5710: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a5714: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5718: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a5720);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a5720
// Address: 0x1a5720 - 0x1a5760

void entry_1a5720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5720) {
        switch (ctx->pc) {
            case 0x1a5728: ctx->pc = 0; goto label_1a5728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5720: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1a5724: 0xafc2b314
    WRITE32(ADD32(GPR_U32(ctx, 30), 4294947604), GPR_U32(ctx, 2));
label_1a5728:
    // 0x1a5728: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a572c: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a5730: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a5734: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a5738: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a573c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a5740: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a5744: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a5748: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a574c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5750: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x1a5754: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1a5758: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustRobDifficulty__FP3ROBf
// Address: 0x1a5760 - 0x1a5a3c

void entry_1a5a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5a3c) {
        switch (ctx->pc) {
            case 0x1a5a50: ctx->pc = 0; goto label_1a5a50;
            case 0x1a5a90: ctx->pc = 0; goto label_1a5a90;
            case 0x1a5aa4: ctx->pc = 0; goto label_1a5aa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5a3c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a5a40: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a5a44: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a5a48: 0xe6010634
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1588), *(uint32_t*)&val); }
    // 0x1a5a4c: 0xae110624
    WRITE32(ADD32(GPR_U32(ctx, 16), 1572), GPR_U32(ctx, 17));
label_1a5a50:
    // 0x1a5a50: 0x26020590
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1424));
    // 0x1a5a54: 0xc6020590
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1424)); ctx->f[2] = *(float*)&val; }
    // 0x1a5a58: 0x26435c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 23648));
    // 0x1a5a5c: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a5a60: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a5a64: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1a5a68: 0xc6445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1a5a6c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a5a70: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1a5a74: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1a5a78: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a5a7c: 0x0
    // NOP
    // 0x1a5a80: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a5a90;
    }
    // 0x1a5a88: 0x10000006
    ctx->f[12] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a5aa4;
    }
label_1a5a90:
    // 0x1a5a90: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a5a94: 0x0
    // NOP
    // 0x1a5a98: 0x45000002
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a5aa4;
    }
    // 0x1a5aa0: 0x46001b06
    ctx->f[12] = FPU_MOV_S(ctx->f[3]);
label_1a5aa4:
    // 0x1a5aa4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a5aa8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a5aac: 0xc6020580
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1408)); ctx->f[2] = *(float*)&val; }
    // 0x1a5ab0: 0x460c0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x1a5ab4: 0xc6010584
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1412)); ctx->f[1] = *(float*)&val; }
    // 0x1a5ab8: 0x8e030628
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1576)));
    // 0x1a5abc: 0x46016042
    ctx->f[1] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x1a5ac0: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1a5ac4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a5ac8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1a5acc: 0x44110800
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[1]);
    // 0x1a5ad0: 0x71102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 17)));
    // 0x1a5ad4: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1576), GPR_U32(ctx, 17));
        ctx->pc = 0x1A5B08; return;
    }
    // 0x1a5adc: 0x8e02039c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 924)));
    // 0x1a5ae0: 0x54430009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1576), GPR_U32(ctx, 17));
        ctx->pc = 0x1A5B08; return;
    }
    // 0x1a5ae8: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1a5aec: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a5af4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1596)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a5af4
// Address: 0x1a5af4 - 0x1a5b28

void entry_1a5af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5af4) {
        switch (ctx->pc) {
            case 0x1a5b08: ctx->pc = 0; goto label_1a5b08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5af4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a5af8: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a5afc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a5b00: 0xe6010640
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1600), *(uint32_t*)&val); }
    // 0x1a5b04: 0xae110628
    WRITE32(ADD32(GPR_U32(ctx, 16), 1576), GPR_U32(ctx, 17));
label_1a5b08:
    // 0x1a5b08: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a5b0c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a5b10: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5b14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5b18: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1a5b1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a5b24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a5b28; return;
}


// Function: DestroyedRobRoc__FP3ROBP3ROC
// Address: 0x1a5b28 - 0x1a5b64

void entry_1a5b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5b64: 0x8e22055c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a5b68: 0x10400006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 872));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5B84; return;
    }
    // 0x1a5b70: 0x2604035c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 860));
    // 0x1a5b74: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a5b7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5b7c
// Address: 0x1a5b7c - 0x1a5b8c

void entry_1a5b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5b7c) {
        switch (ctx->pc) {
            case 0x1a5b84: ctx->pc = 0; goto label_1a5b84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5b7c: 0x10000004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5B90; return;
    }
label_1a5b84:
    // 0x1a5b84: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a5b8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5b8c
// Address: 0x1a5b8c - 0x1a5b98

void entry_1a5b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5b8c) {
        switch (ctx->pc) {
            case 0x1a5b90: ctx->pc = 0; goto label_1a5b90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5b8c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1a5b90:
    // 0x1a5b90: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5b98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 884));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5b98
// Address: 0x1a5b98 - 0x1a5bac

void entry_1a5b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5b98: 0x8e25055c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a5b9c: 0x50a0000f
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1A5BDC; return;
    }
    // 0x1a5ba4: 0xc069824
    SET_GPR_U32(ctx, 31, 0x1a5bac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FChooseRobRoc__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a5bac
// Address: 0x1a5bac - 0x1a5bc0

void entry_1a5bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5bac: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
        ctx->pc = 0x1A5BC8; return;
    }
    // 0x1a5bb4: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a5bb8: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a5bc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a5bc0
// Address: 0x1a5bc0 - 0x1a5bd8

void entry_1a5bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5bc0) {
        switch (ctx->pc) {
            case 0x1a5bc8: ctx->pc = 0; goto label_1a5bc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5bc0: 0x10000006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A5BDC; return;
    }
label_1a5bc8:
    // 0x1a5bc8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a5bcc: 0xac40055c
    WRITE32(ADD32(GPR_U32(ctx, 2), 1372), GPR_U32(ctx, 0));
    // 0x1a5bd0: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a5bd8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a5bd8
// Address: 0x1a5bd8 - 0x1a5bec

void entry_1a5bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5bd8) {
        switch (ctx->pc) {
            case 0x1a5bdc: ctx->pc = 0; goto label_1a5bdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5bd8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1a5bdc:
    // 0x1a5bdc: 0xae20055c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1372), GPR_U32(ctx, 0));
    // 0x1a5be0: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1a5be4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a5bec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a5bec
// Address: 0x1a5bec - 0x1a5c08

void entry_1a5bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5bec: 0x8e040380
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 896)));
    // 0x1a5bf0: 0x8e020624
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1572)));
    // 0x1a5bf4: 0x54820009
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 896)));
        ctx->pc = 0x1A5C1C; return;
    }
    // 0x1a5bfc: 0xc60c062c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1580)); ctx->f[12] = *(float*)&val; }
    // 0x1a5c00: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a5c08);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1584)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a5c08
// Address: 0x1a5c08 - 0x1a5c38

void entry_1a5c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5c08) {
        switch (ctx->pc) {
            case 0x1a5c1c: ctx->pc = 0; goto label_1a5c1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5c08: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a5c0c: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a5c10: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a5c14: 0xe6010634
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1588), *(uint32_t*)&val); }
    // 0x1a5c18: 0x8e020380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 896)));
label_1a5c1c:
    // 0x1a5c1c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a5c20: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1a5c24: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5c28: 0xae020380
    WRITE32(ADD32(GPR_U32(ctx, 16), 896), GPR_U32(ctx, 2));
    // 0x1a5c2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5c30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SpawnedRobRoh__FP3ROBP3ROH
// Address: 0x1a5c38 - 0x1a5c5c

void entry_1a5c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5c5c: 0x8e050560
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a5c60: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5c68);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 928));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5c68
// Address: 0x1a5c68 - 0x1a5c74

void entry_1a5c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5c68: 0x8e040560
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a5c6c: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x1a5c74);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_1a5c74
// Address: 0x1a5c74 - 0x1a5c90

void entry_1a5c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5c74: 0xae000560
    WRITE32(ADD32(GPR_U32(ctx, 16), 1376), GPR_U32(ctx, 0));
    // 0x1a5c78: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a5c7c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5c80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5c84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a5c8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a5c90; return;
}


// Function: GrabbedRobRoh__FP3ROBP3ROH
// Address: 0x1a5c90 - 0x1a5cb8

void entry_1a5cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5cb8: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a5cbc: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1a5cc0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a5cc4: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1a5cc8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5cd0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5cd0
// Address: 0x1a5cd0 - 0x1a5ce4

void entry_1a5cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5cd0: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a5cd4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a5cd8: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1a5cdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5ce4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5ce4
// Address: 0x1a5ce4 - 0x1a5cfc

void entry_1a5ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5ce4: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a5ce8: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a5cec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5cf0: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a5cf4: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a5cfc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a5cfc
// Address: 0x1a5cfc - 0x1a5d3c

void entry_1a5cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5cfc: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a5d00: 0x24040151
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 337));
    // 0x1a5d04: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1a5d08: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a5d0c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a5d10: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5d14: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1a5d18: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a5d1c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5d20: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a5d24: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a5d28: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5d2c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a5d30: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5d34: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a5d3c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a5d3c
// Address: 0x1a5d3c - 0x1a5d50

void entry_1a5d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5d3c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a5d40: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5d44: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5d48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DroppedRobRoh__FP3ROBP3ROH
// Address: 0x1a5d50 - 0x1a5d78

void entry_1a5d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5d78: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a5d7c: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1a5d80: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1a5d84: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a5d88: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1a5d8c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5d94);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5d94
// Address: 0x1a5d94 - 0x1a5da8

void entry_1a5d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5d94: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a5d98: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a5d9c: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1a5da0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5da8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5da8
// Address: 0x1a5da8 - 0x1a5dc4

void entry_1a5da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5da8: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1a5dac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a5db0: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x1a5db4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a5db8: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a5dbc: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a5dc4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a5dc4
// Address: 0x1a5dc4 - 0x1a5dd8

void entry_1a5dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5dc4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a5dc8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5dcc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5dd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReturnedRobRoh__FP3ROBP3ROH
// Address: 0x1a5dd8 - 0x1a5dec

void entry_1a5dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5dec: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5df0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ExitedRobRoh__FP3ROBP3ROH
// Address: 0x1a5df8 - 0x1a5e28

void entry_1a5e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e28: 0x8e05055c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x1a5e2c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5e34);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 884));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5e34
// Address: 0x1a5e34 - 0x1a5e40

void entry_1a5e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e34: 0x26240384
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 900));
    // 0x1a5e38: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a5e40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5e40
// Address: 0x1a5e40 - 0x1a5e4c

void entry_1a5e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e40: 0x26240390
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 912));
    // 0x1a5e44: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5e4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5e4c
// Address: 0x1a5e4c - 0x1a5e58

void entry_1a5e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e4c: 0x8e050560
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a5e50: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a5e58);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 940));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5e58
// Address: 0x1a5e58 - 0x1a5e64

void entry_1a5e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e58: 0x8e050560
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a5e5c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5e64);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 928));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5e64
// Address: 0x1a5e64 - 0x1a5e78

void entry_1a5e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e64: 0x8e04055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x1a5e68: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a5e6c: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x1a5e70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5e78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5e78
// Address: 0x1a5e78 - 0x1a5e8c

void entry_1a5e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e78: 0x8e04055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x1a5e7c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a5e80: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a5e84: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5e8c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5e8c
// Address: 0x1a5e8c - 0x1a5e9c

void entry_1a5e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e8c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a5e90: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a5e94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a5e9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a5e9c
// Address: 0x1a5e9c - 0x1a5ea8

void entry_1a5e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5e9c: 0x8e040560
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a5ea0: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x1a5ea8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_1a5ea8
// Address: 0x1a5ea8 - 0x1a5ed4

void entry_1a5ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5ea8: 0x8e02055c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x1a5eac: 0xae000560
    WRITE32(ADD32(GPR_U32(ctx, 16), 1376), GPR_U32(ctx, 0));
    // 0x1a5eb0: 0xac40055c
    WRITE32(ADD32(GPR_U32(ctx, 2), 1372), GPR_U32(ctx, 0));
    // 0x1a5eb4: 0xae00055c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1372), GPR_U32(ctx, 0));
    // 0x1a5eb8: 0x8e230380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 896)));
    // 0x1a5ebc: 0x8e220624
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1572)));
    // 0x1a5ec0: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 896)));
        ctx->pc = 0x1A5EE8; return;
    }
    // 0x1a5ec8: 0xc62c062c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1580)); ctx->f[12] = *(float*)&val; }
    // 0x1a5ecc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a5ed4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a5ed4
// Address: 0x1a5ed4 - 0x1a5f08

void entry_1a5ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5ed4) {
        switch (ctx->pc) {
            case 0x1a5ee8: ctx->pc = 0; goto label_1a5ee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5ed4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a5ed8: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a5edc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a5ee0: 0xe6210634
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1588), *(uint32_t*)&val); }
    // 0x1a5ee4: 0x8e220380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 896)));
label_1a5ee8:
    // 0x1a5ee8: 0x8e24039c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 924)));
    // 0x1a5eec: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1a5ef0: 0x8e230628
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1576)));
    // 0x1a5ef4: 0x14830008
    WRITE32(ADD32(GPR_U32(ctx, 17), 896), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1A5F18; return;
    }
    // 0x1a5efc: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1a5f00: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a5f08);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1596)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a5f08
// Address: 0x1a5f08 - 0x1a5f64

void entry_1a5f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5f08) {
        switch (ctx->pc) {
            case 0x1a5f18: ctx->pc = 0; goto label_1a5f18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5f08: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a5f0c: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a5f10: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a5f14: 0xe6210640
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1600), *(uint32_t*)&val); }
label_1a5f18:
    // 0x1a5f18: 0x8e22039c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 924)));
    // 0x1a5f1c: 0x24040051
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 81));
    // 0x1a5f20: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a5f24: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5f28: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1a5f2c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1a5f30: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a5f34: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a5f38: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1a5f3c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a5f40: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5f44: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a5f48: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a5f4c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5f50: 0xae22039c
    WRITE32(ADD32(GPR_U32(ctx, 17), 924), GPR_U32(ctx, 2));
    // 0x1a5f54: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a5f58: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a5f5c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a5f64);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a5f64
// Address: 0x1a5f64 - 0x1a5f78

void entry_1a5f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5f64: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a5f68: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a5f6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a5f70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: KilledRobRoh__FP3ROBP3ROH
// Address: 0x1a5f78 - 0x1a5f9c

void entry_1a5f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5f9c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a5fa0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5fa8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 912));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5fa8
// Address: 0x1a5fa8 - 0x1a5fbc

void entry_1a5fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5fa8: 0x8e250560
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x1a5fac: 0x50a0000a
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
        ctx->pc = 0x1A5FD8; return;
    }
    // 0x1a5fb4: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a5fbc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 940));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5fbc
// Address: 0x1a5fbc - 0x1a5fc8

void entry_1a5fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5fbc: 0x8e250560
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x1a5fc0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a5fc8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 928));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a5fc8
// Address: 0x1a5fc8 - 0x1a5fd4

void entry_1a5fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a5fc8: 0x8e240560
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x1a5fcc: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x1a5fd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_1a5fd4
// Address: 0x1a5fd4 - 0x1a5ff8

void entry_1a5fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5fd4) {
        switch (ctx->pc) {
            case 0x1a5fd8: ctx->pc = 0; goto label_1a5fd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5fd4: 0x8e32055c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
label_1a5fd8:
    // 0x1a5fd8: 0x52400013
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1A6028; return;
    }
    // 0x1a5fe0: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1a5fe4: 0x14510005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 860));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x1A5FFC; return;
    }
    // 0x1a5fec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a5ff0: 0xc069754
    SET_GPR_U32(ctx, 31, 0x1a5ff8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DroppedRobRoh__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a5ff8
// Address: 0x1a5ff8 - 0x1a6004

void entry_1a5ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a5ff8) {
        switch (ctx->pc) {
            case 0x1a5ffc: ctx->pc = 0; goto label_1a5ffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a5ff8: 0x2604035c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 860));
label_1a5ffc:
    // 0x1a5ffc: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a6004);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a6004
// Address: 0x1a6004 - 0x1a6010

void entry_1a6004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6004: 0x26040368
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 872));
    // 0x1a6008: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a6010);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a6010
// Address: 0x1a6010 - 0x1a601c

void entry_1a6010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6010: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6014: 0xc06988e
    SET_GPR_U32(ctx, 31, 0x1a601c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FChooseRobRoh__FP3ROBP3ROC(rdram, ctx, runtime); return;
}


// Function: entry_1a601c
// Address: 0x1a601c - 0x1a603c

void entry_1a601c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a601c) {
        switch (ctx->pc) {
            case 0x1a6024: ctx->pc = 0; goto label_1a6024;
            case 0x1a6028: ctx->pc = 0; goto label_1a6028;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a601c: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 1372), GPR_U32(ctx, 0));
        goto label_1a6024;
    }
label_1a6024:
    // 0x1a6024: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1a6028:
    // 0x1a6028: 0xae200560
    WRITE32(ADD32(GPR_U32(ctx, 17), 1376), GPR_U32(ctx, 0));
    // 0x1a602c: 0xae20055c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1372), GPR_U32(ctx, 0));
    // 0x1a6030: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1a6034: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a603c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a603c
// Address: 0x1a603c - 0x1a6058

void entry_1a603c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a603c: 0x8e04039c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 924)));
    // 0x1a6040: 0x8e020628
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1576)));
    // 0x1a6044: 0x54820009
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 924)));
        ctx->pc = 0x1A606C; return;
    }
    // 0x1a604c: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1a6050: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a6058);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1596)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a6058
// Address: 0x1a6058 - 0x1a6090

void entry_1a6058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6058) {
        switch (ctx->pc) {
            case 0x1a606c: ctx->pc = 0; goto label_1a606c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6058: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a605c: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1a6060: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a6064: 0xe6010640
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1600), *(uint32_t*)&val); }
    // 0x1a6068: 0x8e02039c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 924)));
label_1a606c:
    // 0x1a606c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a6070: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1a6074: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6078: 0xae02039c
    WRITE32(ADD32(GPR_U32(ctx, 16), 924), GPR_U32(ctx, 2));
    // 0x1a607c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6080: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6084: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a608c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a6090; return;
}


// Function: FChooseRobRoc__FP3ROBP3ROH
// Address: 0x1a6090 - 0x1a60bc

void entry_1a60bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a60bc) {
        switch (ctx->pc) {
            case 0x1a60e8: ctx->pc = 0; goto label_1a60e8;
            case 0x1a6124: ctx->pc = 0; goto label_1a6124;
            case 0x1a612c: ctx->pc = 0; goto label_1a612c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a60bc: 0x14400023
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A614C; return;
    }
    // 0x1a60c4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a60c8: 0x8e030368
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 872)));
    // 0x1a60cc: 0xc441caf4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294953716)); ctx->f[1] = *(float*)&val; }
    // 0x1a60d0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a60d4: 0x10600015
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 860));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a612c;
    }
    // 0x1a60dc: 0xda620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1a60e0: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1a60e4: 0x0
    // NOP
label_1a60e8:
    // 0x1a60e8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a60ec: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a60f0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a60f4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a60f8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a60fc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6100: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a6104: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a6108: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a610c: 0x0
    // NOP
    // 0x1a6110: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 1440)));
        goto label_1a6124;
    }
    // 0x1a6118: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1a611c: 0x60882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1a6120: 0x8c6305a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 1440)));
label_1a6124:
    // 0x1a6124: 0x5460fff0
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
        goto label_1a60e8;
    }
label_1a612c:
    // 0x1a612c: 0xae71055c
    WRITE32(ADD32(GPR_U32(ctx, 19), 1372), GPR_U32(ctx, 17));
    // 0x1a6130: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a6134: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a613c);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1372), GPR_U32(ctx, 19));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a613c
// Address: 0x1a613c - 0x1a6148

void entry_1a613c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a613c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6140: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a6148);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a6148
// Address: 0x1a6148 - 0x1a6168

void entry_1a6148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6148) {
        switch (ctx->pc) {
            case 0x1a614c: ctx->pc = 0; goto label_1a614c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6148: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1a614c:
    // 0x1a614c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a6150: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a6154: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a6158: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a615c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6160: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TakeRobRoc__FP3ROBP3ROHP3ROC
// Address: 0x1a6168 - 0x1a61b4

void entry_1a61b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a61b4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a61b8: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a61c0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 860));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a61c0
// Address: 0x1a61c0 - 0x1a61d0

void entry_1a61c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a61c0: 0x1220000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 860));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_1a61ec(rdram, ctx, runtime); return;
    }
    // 0x1a61c8: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a61d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a61d0
// Address: 0x1a61d0 - 0x1a61dc

void entry_1a61d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a61d0: 0x26640368
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 872));
    // 0x1a61d4: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a61dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a61dc
// Address: 0x1a61dc - 0x1a61ec

void entry_1a61dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a61dc: 0xae20055c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1372), GPR_U32(ctx, 0));
    // 0x1a61e0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a61e4: 0xc06988e
    SET_GPR_U32(ctx, 31, 0x1a61ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FChooseRobRoh__FP3ROBP3ROC(rdram, ctx, runtime); return;
}


// Function: entry_1a61ec
// Address: 0x1a61ec - 0x1a6200

void entry_1a61ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a61ec: 0x1240000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1a621c(rdram, ctx, runtime); return;
    }
    // 0x1a61f4: 0xae40055c
    WRITE32(ADD32(GPR_U32(ctx, 18), 1372), GPR_U32(ctx, 0));
    // 0x1a61f8: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a6200);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a6200
// Address: 0x1a6200 - 0x1a620c

void entry_1a6200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6200: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a6204: 0xc069824
    SET_GPR_U32(ctx, 31, 0x1a620c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FChooseRobRoc__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a620c
// Address: 0x1a620c - 0x1a621c

void entry_1a620c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a620c: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a621c(rdram, ctx, runtime); return;
    }
    // 0x1a6214: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a621c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a621c
// Address: 0x1a621c - 0x1a6238

void entry_1a621c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a621c) {
        switch (ctx->pc) {
            case 0x1a6220: ctx->pc = 0; goto label_1a6220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a621c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1a6220:
    // 0x1a6220: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a6224: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6228: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a622c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FChooseRobRoh__FP3ROBP3ROC
// Address: 0x1a6238 - 0x1a62e8

void entry_1a62e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a62e8: 0x2624035c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 860));
    // 0x1a62ec: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a62f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a62f4
// Address: 0x1a62f4 - 0x1a6300

void entry_1a62f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a62f4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a62f8: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a6300);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a6300
// Address: 0x1a6300 - 0x1a6328

void entry_1a6300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6300) {
        switch (ctx->pc) {
            case 0x1a6308: ctx->pc = 0; goto label_1a6308;
            case 0x1a630c: ctx->pc = 0; goto label_1a630c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6300: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a630c;
    }
label_1a6308:
    // 0x1a6308: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1a630c:
    // 0x1a630c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a6310: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a6314: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6318: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a631c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a6324: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a6328; return;
}


// Function: FChooseRobReturnPoint__FP3ROBP3ROH
// Address: 0x1a6328 - 0x1a6350

void entry_1a6350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6350) {
        switch (ctx->pc) {
            case 0x1a6380: ctx->pc = 0; goto label_1a6380;
            case 0x1a63bc: ctx->pc = 0; goto label_1a63bc;
            case 0x1a63c4: ctx->pc = 0; goto label_1a63c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6350: 0x14400023
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A63E0; return;
    }
    // 0x1a6358: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a635c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a6360: 0x8e0303a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 928)));
    // 0x1a6364: 0x261103ac
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 940));
    // 0x1a6368: 0xc441cafc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294953724)); ctx->f[1] = *(float*)&val; }
    // 0x1a636c: 0x10600015
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a63c4;
    }
    // 0x1a6374: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1a6378: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1a637c: 0x0
    // NOP
label_1a6380:
    // 0x1a6380: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6384: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6388: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a638c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6390: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6394: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6398: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a639c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a63a0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a63a4: 0x0
    // NOP
    // 0x1a63a8: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 1384)));
        goto label_1a63bc;
    }
    // 0x1a63b0: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1a63b4: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1a63b8: 0x8c630568
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 1384)));
label_1a63bc:
    // 0x1a63bc: 0x5460fff0
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
        goto label_1a6380;
    }
label_1a63c4:
    // 0x1a63c4: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1a63cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a63cc
// Address: 0x1a63cc - 0x1a63d8

void entry_1a63cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a63cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a63d0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a63d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a63d8
// Address: 0x1a63d8 - 0x1a63f8

void entry_1a63d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a63d8) {
        switch (ctx->pc) {
            case 0x1a63e0: ctx->pc = 0; goto label_1a63e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a63d8: 0xae500560
    WRITE32(ADD32(GPR_U32(ctx, 18), 1376), GPR_U32(ctx, 16));
    // 0x1a63dc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1a63e0:
    // 0x1a63e0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a63e4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a63e8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a63ec: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a63f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChooseRobWanderLocation__FP3ROBP3ROH
// Address: 0x1a63f8 - 0x1a6430

void entry_1a6430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6430: 0xc62d0348
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 840)); ctx->f[13] = *(float*)&val; }
    // 0x1a6434: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1a6438: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a6440);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a6440
// Address: 0x1a6440 - 0x1a6454

void entry_1a6440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6440: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1a6444: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x1a6448: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1a644c: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1a6454);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1392));
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1a6454
// Address: 0x1a6454 - 0x1a6480

void entry_1a6454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6454: 0xc621034c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 844)); ctx->f[1] = *(float*)&val; }
    // 0x1a6458: 0xc6000574
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1396)); ctx->f[0] = *(float*)&val; }
    // 0x1a645c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6460: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1a6464: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6468: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1a646c: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1a6470: 0xe6000574
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1396), *(uint32_t*)&val); }
    // 0x1a6474: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6478: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProddCurRob__FP3ROB4ENSK
// Address: 0x1a6480 - 0x1a6498

void entry_1a64ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a64ac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a64b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a64b4: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1a64b8: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x1a64bc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a64c0: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x1a64c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a64c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a64cc: 0xae020550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    // 0x1a64d0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a64d4: 0xe6000584
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1412), *(uint32_t*)&val); }
    // 0x1a64d8: 0x24070002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a64dc: 0xe6010588
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1416), *(uint32_t*)&val); }
    // 0x1a64e0: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a64e8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a64e8
// Address: 0x1a64e8 - 0x1a64f8

void entry_1a64e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a64e8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a64ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a64f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadRohFromBrx__FP3ROHP18CBinaryInputStream
// Address: 0x1a64f8 - 0x1a650c

void entry_1a650c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a650c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a6510: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6514: 0x24c6b7e8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948840));
    // 0x1a6518: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1a6520);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1a6520
// Address: 0x1a6520 - 0x1a652c

void entry_1a6520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6520: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6524: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x1a652c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1452));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a652c
// Address: 0x1a652c - 0x1a6540

void entry_1a652c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a652c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6530: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6534: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a653c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a6540; return;
}


// Function: CloneRoh__FP3ROHT0
// Address: 0x1a6540 - 0x1a6568

void entry_1a6568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6568: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1a656c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1a6570: 0xb20205b7
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1463); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a6574: 0xb60205b0
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1456); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a6578: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a657c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6580: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostRohLoad__FP3ROH
// Address: 0x1a6588 - 0x1a659c

void entry_1a659c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a659c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a65a0: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a65a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a65a8
// Address: 0x1a65a8 - 0x1a65b8

void entry_1a65a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a65a8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a65ac: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a65b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a65b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a65b8
// Address: 0x1a65b8 - 0x1a65c8

void entry_1a65b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a65b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a65bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a65c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateRoh__FP3ROHf
// Address: 0x1a65c8 - 0x1a65e0

void entry_1a65e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a65e0) {
        switch (ctx->pc) {
            case 0x1a65e8: ctx->pc = 0; goto label_1a65e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a65e0: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a65f0(rdram, ctx, runtime); return;
    }
label_1a65e8:
    // 0x1a65e8: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a65f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a65f0
// Address: 0x1a65f0 - 0x1a65f8

void entry_1a65f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a65f0: 0xc069a7e
    SET_GPR_U32(ctx, 31, 0x1a65f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RohsNextRoh__FP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a65f8
// Address: 0x1a65f8 - 0x1a6638

void entry_1a65f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a65f8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a65fc: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x1a6600: 0x14a2fff9
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 11));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A65E8; return;
    }
    // 0x1a6608: 0x10400059
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a6770(rdram, ctx, runtime); return;
    }
    // 0x1a6610: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1a6614: 0x2442cb00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953728));
    // 0x1a6618: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1a661c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a6620: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1a6628: 0x8e220560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x1a662c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6630: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1a6638);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1380)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a6638
// Address: 0x1a6638 - 0x1a6648

void entry_1a6638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6638: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a663c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6640: 0xc0699e2
    SET_GPR_U32(ctx, 31, 0x1a6648);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MoveRohToTarget__FP3ROHP6VECTORi(rdram, ctx, runtime); return;
}


// Function: entry_1a6648
// Address: 0x1a6648 - 0x1a66bc

void entry_1a6648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6648) {
        switch (ctx->pc) {
            case 0x1a66b4: ctx->pc = 0; goto label_1a66b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6648: 0x1000004a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6774; return;
    }
    // 0x1a6650: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a6654: 0xc6210580
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1408)); ctx->f[1] = *(float*)&val; }
    // 0x1a6658: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1a665c: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a6660: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a6664: 0x0
    // NOP
    // 0x1a6668: 0x45030012
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
        goto label_1a66b4;
    }
    // 0x1a6670: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1a6674: 0xda220570
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1392)));
    // 0x1a6678: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a667c: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1a6680: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a6684: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6688: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a668c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6690: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6694: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6698: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a669c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a66a0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a66a4: 0x0
    // NOP
    // 0x1a66a8: 0x4500000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A66D8; return;
    }
    // 0x1a66b0: 0x8e240558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
label_1a66b4:
    // 0x1a66b4: 0xc0698fe
    SET_GPR_U32(ctx, 31, 0x1a66bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ChooseRobWanderLocation__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a66bc
// Address: 0x1a66bc - 0x1a66c8

void entry_1a66bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a66bc: 0xc62c0584
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1412)); ctx->f[12] = *(float*)&val; }
    // 0x1a66c0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a66c8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1416)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a66c8
// Address: 0x1a66c8 - 0x1a66e4

void entry_1a66c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a66c8) {
        switch (ctx->pc) {
            case 0x1a66d8: ctx->pc = 0; goto label_1a66d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a66c8: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a66cc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a66d0: 0xe6210580
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1408), *(uint32_t*)&val); }
    // 0x1a66d4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1a66d8:
    // 0x1a66d8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a66dc: 0xc0699e2
    SET_GPR_U32(ctx, 31, 0x1a66e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 1392));
    MoveRohToTarget__FP3ROHP6VECTORi(rdram, ctx, runtime); return;
}


// Function: entry_1a66e4
// Address: 0x1a66e4 - 0x1a670c

void entry_1a66e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a66e4: 0x10000023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6774; return;
    }
    // 0x1a66ec: 0x8e25055c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a66f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a66f4: 0x1000000e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6730; return;
    }
    // 0x1a66fc: 0x8e220560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x1a6700: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6704: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1a670c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1380)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a670c
// Address: 0x1a670c - 0x1a671c

void entry_1a670c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a670c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a6710: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6714: 0xc0699e2
    SET_GPR_U32(ctx, 31, 0x1a671c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    MoveRohToTarget__FP3ROHP6VECTORi(rdram, ctx, runtime); return;
}


// Function: entry_1a671c
// Address: 0x1a671c - 0x1a6738

void entry_1a671c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a671c) {
        switch (ctx->pc) {
            case 0x1a6730: ctx->pc = 0; goto label_1a6730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a671c: 0x10000015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6774; return;
    }
    // 0x1a6724: 0x8e250560
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x1a6728: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a672c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
label_1a6730:
    // 0x1a6730: 0xc0699e2
    SET_GPR_U32(ctx, 31, 0x1a6738);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    MoveRohToTarget__FP3ROHP6VECTORi(rdram, ctx, runtime); return;
}


// Function: entry_1a6738
// Address: 0x1a6738 - 0x1a675c

void entry_1a6738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6738: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6774; return;
    }
    // 0x1a6740: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a6744: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1a6748: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1a674c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a6750: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1a6754: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a675c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a675c
// Address: 0x1a675c - 0x1a6770

void entry_1a675c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a675c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a6760: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a6764: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1a6768: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a6770);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a6770
// Address: 0x1a6770 - 0x1a6788

void entry_1a6770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6770) {
        switch (ctx->pc) {
            case 0x1a6774: ctx->pc = 0; goto label_1a6774;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6770: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1a6774:
    // 0x1a6774: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6778: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a677c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a6784: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a6788; return;
}


// Function: MoveRohToTarget__FP3ROHP6VECTORi
// Address: 0x1a6788 - 0x1a67f8

void entry_1a67f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a67f8) {
        switch (ctx->pc) {
            case 0x1a6888: ctx->pc = 0; goto label_1a6888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a67f8: 0x10400023
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a6888;
    }
    // 0x1a6800: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a6804: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a6808: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a680c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a6810: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a6814: 0x4be209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a6818: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a681c: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a6820: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a6824: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1a6828: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a682c: 0x8e020558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1a6830: 0xd8430330
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 816)));
    // 0x1a6834: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6838: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a683c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a6840: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a6844: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a6848: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a684c: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a6850: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6854: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6858: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a685c: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a6860: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6864: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6868: 0xfba200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a686c: 0xc4400340
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 832)); ctx->f[0] = *(float*)&val; }
    // 0x1a6870: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1a6874: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1a6878: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a687c: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a6880: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a6884: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_1a6888:
    // 0x1a6888: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a688c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6890: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6894: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a6898: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
    // 0x1a689c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a68a4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a68a4
// Address: 0x1a68a4 - 0x1a68b4

void entry_1a68a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a68a4: 0xc60c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 276)); ctx->f[12] = *(float*)&val; }
    // 0x1a68a8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1a68ac: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a68b4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 272)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a68b4
// Address: 0x1a68b4 - 0x1a68d0

void entry_1a68b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a68b4: 0x12400006
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1a68d0(rdram, ctx, runtime); return;
    }
    // 0x1a68bc: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1a68c0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1a68c4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a68c8: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1a68d0);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1a68d0
// Address: 0x1a68d0 - 0x1a68d8

void entry_1a68d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a68d0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1a68d8);
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1a68d8
// Address: 0x1a68d8 - 0x1a6914

void entry_1a68d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a68d8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1a68dc: 0x3c013d56
    SET_GPR_U32(ctx, 1, ((uint32_t)15702 << 16));
    // 0x1a68e0: 0x34217750
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 30544));
    // 0x1a68e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a68e8: 0x4600a005
    ctx->f[0] = FPU_ABS_S(ctx->f[20]);
    // 0x1a68ec: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a68f0: 0x0
    // NOP
    // 0x1a68f4: 0x45000009
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A691C; return;
    }
    // 0x1a68fc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a6900: 0x24a58d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    // 0x1a6904: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6908: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x1a690c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a6914);
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a6914
// Address: 0x1a6914 - 0x1a6994

void entry_1a6914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6914) {
        switch (ctx->pc) {
            case 0x1a691c: ctx->pc = 0; goto label_1a691c;
            case 0x1a6968: ctx->pc = 0; goto label_1a6968;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6914: 0x10000020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6998; return;
    }
label_1a691c:
    // 0x1a691c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1a6920: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6924: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1a6928: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a692c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a6930: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6934: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a6938: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a693c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6940: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6944: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1a6948: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a694c: 0xc6010564
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1380)); ctx->f[1] = *(float*)&val; }
    // 0x1a6950: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a6954: 0x60882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1a6958: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1a695c: 0x12400002
    ctx->f[1] = std::min(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1a6968;
    }
    // 0x1a6964: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
label_1a6968:
    // 0x1a6968: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1a696c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6970: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1a6974: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a6978: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1a697c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a6980: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1a6984: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1a6988: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1a698c: 0xc049d8a
    SET_GPR_U32(ctx, 31, 0x1a6994);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    SetAloVelocityLocal__FP3ALOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a6994
// Address: 0x1a6994 - 0x1a69dc

void entry_1a6994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6994) {
        switch (ctx->pc) {
            case 0x1a6998: ctx->pc = 0; goto label_1a6998;
            case 0x1a69bc: ctx->pc = 0; goto label_1a69bc;
            case 0x1a69cc: ctx->pc = 0; goto label_1a69cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6994: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
label_1a6998:
    // 0x1a6998: 0xc6010568
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1384)); ctx->f[1] = *(float*)&val; }
    // 0x1a699c: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a69a0: 0x46000887
    ctx->f[2] = FPU_NEG_S(ctx->f[1]);
    // 0x1a69a4: 0x4600a383
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[14] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[14] = ctx->f[20] / ctx->f[0];
    // 0x1a69a8: 0x46027034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[14], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a69ac: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a69bc;
    }
    // 0x1a69b4: 0x10000005
    ctx->f[14] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a69cc;
    }
label_1a69bc:
    // 0x1a69bc: 0x460e0834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[14])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a69c0: 0x0
    // NOP
    // 0x1a69c4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[14] = FPU_MOV_S(ctx->f[1]);
        goto label_1a69cc;
    }
label_1a69cc:
    // 0x1a69cc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a69d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a69d4: 0xc049d7c
    SET_GPR_U32(ctx, 31, 0x1a69dc);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    SetAloAngularVelocityXYZ__FP3ALOfff(rdram, ctx, runtime); return;
}


// Function: entry_1a69dc
// Address: 0x1a69dc - 0x1a69f8

void entry_1a69dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a69dc: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1a69e0: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1a69e4: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1a69e8: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1a69ec: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x1a69f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RohsNextRoh__FP3ROH
// Address: 0x1a69f8 - 0x1a6a3c

void entry_1a6a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6a3c: 0x54400020
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        ctx->pc = 0x1A6AC0; return;
    }
    // 0x1a6a44: 0x8e020560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a6a48: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6a4c: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1a6a54);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1380)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a6a54
// Address: 0x1a6a54 - 0x1a6aa0

void entry_1a6a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6a54: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6a58: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1a6a5c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6a60: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1a6a64: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a6a68: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6a6c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6a70: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6a74: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6a78: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6a7c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a6a80: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a6a84: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a6a88: 0x0
    // NOP
    // 0x1a6a8c: 0x4500004e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A6BC8; return;
    }
    // 0x1a6a94: 0x8e040558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1a6a98: 0xc069824
    SET_GPR_U32(ctx, 31, 0x1a6aa0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    FChooseRobRoc__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6aa0
// Address: 0x1a6aa0 - 0x1a6ab4

void entry_1a6aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6aa0: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a6aa4: 0x10000048
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6BC8; return;
    }
    // 0x1a6aac: 0xc069bca
    SET_GPR_U32(ctx, 31, 0x1a6ab4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ProcContactRoh__FP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6ab4
// Address: 0x1a6ab4 - 0x1a6ad0

void entry_1a6ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6ab4) {
        switch (ctx->pc) {
            case 0x1a6ac0: ctx->pc = 0; goto label_1a6ac0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6ab4: 0x50400045
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1A6BCC; return;
    }
    // 0x1a6abc: 0x8e040558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
label_1a6ac0:
    // 0x1a6ac0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6ac4: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a6ac8: 0xc06985a
    SET_GPR_U32(ctx, 31, 0x1a6ad0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    TakeRobRoc__FP3ROBP3ROHP3ROC(rdram, ctx, runtime); return;
}


// Function: entry_1a6ad0
// Address: 0x1a6ad0 - 0x1a6b14

void entry_1a6ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6ad0) {
        switch (ctx->pc) {
            case 0x1a6b08: ctx->pc = 0; goto label_1a6b08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6ad0: 0x1000003e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6BCC; return;
    }
    // 0x1a6ad8: 0x8e03059c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1436)));
    // 0x1a6adc: 0x5060000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        goto label_1a6b08;
    }
    // 0x1a6ae4: 0x8e020594
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1428)));
    // 0x1a6ae8: 0xc4610014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1a6aec: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1a6af0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a6af4: 0x0
    // NOP
    // 0x1a6af8: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        goto label_1a6b08;
    }
    // 0x1a6b00: 0x10000031
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6BC8; return;
    }
label_1a6b08:
    // 0x1a6b08: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6b0c: 0xc0698ca
    SET_GPR_U32(ctx, 31, 0x1a6b14);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    FChooseRobReturnPoint__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6b14
// Address: 0x1a6b14 - 0x1a6b30

void entry_1a6b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6b14: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1a6b18: 0x1000002b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6BC8; return;
    }
    // 0x1a6b20: 0x8e020560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a6b24: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6b28: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1a6b30);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1380)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a6b30
// Address: 0x1a6b30 - 0x1a6be0

void entry_1a6b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6b30) {
        switch (ctx->pc) {
            case 0x1a6bc8: ctx->pc = 0; goto label_1a6bc8;
            case 0x1a6bcc: ctx->pc = 0; goto label_1a6bcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6b30: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1a6b34: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6b38: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b3c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1a6b40: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a6b44: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b48: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b4c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b50: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6b54: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6b58: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a6b5c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a6b60: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a6b64: 0x0
    // NOP
    // 0x1a6b68: 0x45030017
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 6));
        goto label_1a6bc8;
    }
    // 0x1a6b70: 0x10000016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a6bcc;
    }
    // 0x1a6b78: 0x8e020560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1a6b7c: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1a6b80: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1a6b84: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b88: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1a6b8c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a6b90: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b94: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b98: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a6b9c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a6ba0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a6ba4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a6ba8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a6bac: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a6bb0: 0x0
    // NOP
    // 0x1a6bb4: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1a6bc8;
    }
    // 0x1a6bbc: 0x10000003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a6bcc;
    }
    // 0x1a6bc4: 0x2411000a
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 10));
label_1a6bc8:
    // 0x1a6bc8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1a6bcc:
    // 0x1a6bcc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a6bd0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6bd4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6bd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetRohRohs__FP3ROH4ROHS
// Address: 0x1a6be0 - 0x1a6c20

void entry_1a6c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6c20) {
        switch (ctx->pc) {
            case 0x1a6c28: ctx->pc = 0; goto label_1a6c28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6c20: 0xae00059c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1436), GPR_U32(ctx, 0));
    // 0x1a6c24: 0x8e0405a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1448)));
label_1a6c28:
    // 0x1a6c28: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        ctx->pc = 0x1A6C40; return;
    }
    // 0x1a6c30: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x1a6c38);
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_1a6c38
// Address: 0x1a6c38 - 0x1a6c88

void entry_1a6c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6c38) {
        switch (ctx->pc) {
            case 0x1a6c40: ctx->pc = 0; goto label_1a6c40;
            case 0x1a6c64: ctx->pc = 0; goto label_1a6c64;
            case 0x1a6c80: ctx->pc = 0; goto label_1a6c80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6c38: 0xae0005a8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1448), GPR_U32(ctx, 0));
    // 0x1a6c3c: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
label_1a6c40:
    // 0x1a6c40: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1a6c44: 0x10620012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A6C90; return;
    }
    // 0x1a6c4c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a6c64;
    }
    // 0x1a6c54: 0x5062000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        goto label_1a6c80;
    }
    // 0x1a6c5c: 0x1000001e
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6CD8; return;
    }
label_1a6c64:
    // 0x1a6c64: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1a6c68: 0x10620011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A6CB0; return;
    }
    // 0x1a6c70: 0x50620016
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        ctx->pc = 0x1A6CCC; return;
    }
    // 0x1a6c78: 0x10000017
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6CD8; return;
    }
label_1a6c80:
    // 0x1a6c80: 0xc06970e
    SET_GPR_U32(ctx, 31, 0x1a6c88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SpawnedRobRoh__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6c88
// Address: 0x1a6c88 - 0x1a6ca8

void entry_1a6c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6c88) {
        switch (ctx->pc) {
            case 0x1a6c90: ctx->pc = 0; goto label_1a6c90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6c88: 0x10000013
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6CD8; return;
    }
label_1a6c90:
    // 0x1a6c90: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1a6c94: 0x56420010
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
        ctx->pc = 0x1A6CD8; return;
    }
    // 0x1a6c9c: 0x8e040558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1a6ca0: 0xc069776
    SET_GPR_U32(ctx, 31, 0x1a6ca8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReturnedRobRoh__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6ca8
// Address: 0x1a6ca8 - 0x1a6cc4

void entry_1a6ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6ca8) {
        switch (ctx->pc) {
            case 0x1a6cb0: ctx->pc = 0; goto label_1a6cb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6ca8: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6CD8; return;
    }
label_1a6cb0:
    // 0x1a6cb0: 0x56400009
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
        ctx->pc = 0x1A6CD8; return;
    }
    // 0x1a6cb8: 0x8e040558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1a6cbc: 0xc06977e
    SET_GPR_U32(ctx, 31, 0x1a6cc4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ExitedRobRoh__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6cc4
// Address: 0x1a6cc4 - 0x1a6cd4

void entry_1a6cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6cc4) {
        switch (ctx->pc) {
            case 0x1a6ccc: ctx->pc = 0; goto label_1a6ccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6cc4: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6CD8; return;
    }
label_1a6ccc:
    // 0x1a6ccc: 0xc0697de
    SET_GPR_U32(ctx, 31, 0x1a6cd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    KilledRobRoh__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6cd4
// Address: 0x1a6cd4 - 0x1a6d28

void entry_1a6cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6cd4) {
        switch (ctx->pc) {
            case 0x1a6cd8: ctx->pc = 0; goto label_1a6cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6cd4: 0xae120550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 18));
label_1a6cd8:
    // 0x1a6cd8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a6cdc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a6ce0: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a6ce4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1a6ce8: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6cec: 0x2e42000b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 11));
    // 0x1a6cf0: 0x10400020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1364), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6D74; return;
    }
    // 0x1a6cf8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a6cfc: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x1a6d00: 0x2442cb60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953824));
    // 0x1a6d04: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1a6d08: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a6d0c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1a6d14: 0x10000017
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1420)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6D74; return;
    }
    // 0x1a6d1c: 0x8e040558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1a6d20: 0xc069724
    SET_GPR_U32(ctx, 31, 0x1a6d28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GrabbedRobRoh__FP3ROBP3ROH(rdram, ctx, runtime); return;
}


// Function: entry_1a6d28
// Address: 0x1a6d28 - 0x1a6da4

void entry_1a6d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6d28) {
        switch (ctx->pc) {
            case 0x1a6d74: ctx->pc = 0; goto label_1a6d74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6d28: 0x8e03055c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x1a6d2c: 0x240202a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 672));
    // 0x1a6d30: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x1a6d34: 0xae230004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 3));
    // 0x1a6d38: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1a6d3c: 0x1000000d
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1428)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a6d74;
    }
    // 0x1a6d44: 0x8e03055c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x1a6d48: 0x240202a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 672));
    // 0x1a6d4c: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x1a6d50: 0xae230004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 3));
    // 0x1a6d54: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1a6d58: 0x10000006
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1424)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a6d74;
    }
    // 0x1a6d60: 0x10000004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 1440)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a6d74;
    }
    // 0x1a6d68: 0x10000002
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 1444)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a6d74;
    }
    // 0x1a6d70: 0x8e050598
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1432)));
label_1a6d74:
    // 0x1a6d74: 0x10a0000b
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 29)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1a6da4(rdram, ctx, runtime); return;
    }
    // 0x1a6d7c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a6d80: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a6d84: 0x630c3
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 6), 3));
    // 0x1a6d88: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a6d8c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a6d90: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6d94: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a6d98: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a6d9c: 0xc04b0a2
    SET_GPR_U32(ctx, 31, 0x1a6da4);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 1436));
    ApplyAsegOvr__FP4ASEGP3ALOiP3OVRffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1a6da4
// Address: 0x1a6da4 - 0x1a6dbc

void entry_1a6da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6da4: 0x12600006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6DC0; return;
    }
    // 0x1a6dac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6db0: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a6db4: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1a6dbc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1a6dbc
// Address: 0x1a6dbc - 0x1a6de0

void entry_1a6dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6dbc) {
        switch (ctx->pc) {
            case 0x1a6dc0: ctx->pc = 0; goto label_1a6dc0;
            case 0x1a6dc4: ctx->pc = 0; goto label_1a6dc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6dbc: 0xae0205a8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1448), GPR_U32(ctx, 2));
label_1a6dc0:
    // 0x1a6dc0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1a6dc4:
    // 0x1a6dc4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a6dc8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a6dcc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a6dd0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6dd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a6ddc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a6de0; return;
}


// Function: FAbsorbRohWkr__FP3ROHP3WKR
// Address: 0x1a6de0 - 0x1a6e40

void entry_1a6e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6e40: 0x1000000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A6E6C; return;
    }
    // 0x1a6e48: 0x8e30055c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a6e4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a6e50: 0xc069af8
    SET_GPR_U32(ctx, 31, 0x1a6e58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    SetRohRohs__FP3ROH4ROHS(rdram, ctx, runtime); return;
}


// Function: entry_1a6e58
// Address: 0x1a6e58 - 0x1a6e68

void entry_1a6e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6e58: 0x12000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1a6e68(rdram, ctx, runtime); return;
    }
    // 0x1a6e60: 0xc069d20
    SET_GPR_U32(ctx, 31, 0x1a6e68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    SetRocRocs__FP3ROC4ROCS(rdram, ctx, runtime); return;
}


// Function: entry_1a6e68
// Address: 0x1a6e68 - 0x1a6ec4

void entry_1a6e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6e68) {
        switch (ctx->pc) {
            case 0x1a6e6c: ctx->pc = 0; goto label_1a6e6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6e68: 0x8e230550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
label_1a6e6c:
    // 0x1a6e6c: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1a6e70: 0x54620025
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x1A6F08; return;
    }
    // 0x1a6e78: 0x8e2605ac
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1452)));
    // 0x1a6e7c: 0x10c00011
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1a6ec4(rdram, ctx, runtime); return;
    }
    // 0x1a6e84: 0x7a420030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 48)));
    // 0x1a6e88: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1a6e8c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a6e90: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a6e94: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a6e98: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1a6e9c: 0x7a420020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1a6ea0: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1a6ea4: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1a6ea8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a6eac: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1a6eb0: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1a6eb4: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1a6eb8: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1a6ebc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a6ec4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a6ec4
// Address: 0x1a6ec4 - 0x1a6f04

void entry_1a6ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6ec4: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a6ec8: 0x24040037
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 55));
    // 0x1a6ecc: 0x3c01463b
    SET_GPR_U32(ctx, 1, ((uint32_t)17979 << 16));
    // 0x1a6ed0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a6ed4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a6ed8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a6edc: 0x3c0145fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17914 << 16));
    // 0x1a6ee0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a6ee4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a6ee8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a6eec: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a6ef0: 0x26470020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 32));
    // 0x1a6ef4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a6ef8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a6efc: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a6f04);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a6f04
// Address: 0x1a6f04 - 0x1a6f28

void entry_1a6f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6f04) {
        switch (ctx->pc) {
            case 0x1a6f08: ctx->pc = 0; goto label_1a6f08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6f04: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_1a6f08:
    // 0x1a6f08: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a6f0c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a6f10: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1a6f14: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a6f18: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a6f1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a6f24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a6f28; return;
}


// Function: ProcContactRoh__FP3ROH
// Address: 0x1a6f28 - 0x1a6f5c

void entry_1a6f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a6f5c) {
        switch (ctx->pc) {
            case 0x1a6f6c: ctx->pc = 0; goto label_1a6f6c;
            case 0x1a6f78: ctx->pc = 0; goto label_1a6f78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a6f5c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_1a6f6c;
    }
    // 0x1a6f64: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a6f78;
    }
label_1a6f6c:
    // 0x1a6f6c: 0x5600fff6
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1A6F48; return;
    }
    // 0x1a6f74: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1a6f78:
    // 0x1a6f78: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6f7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6f80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitRoc__FP3ROC
// Address: 0x1a6f88 - 0x1a6f9c

void entry_1a6f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6f9c: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1a6fa0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a6fa4: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x1a6fa8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a6fac: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a6fb0: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a6fb8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a6fb8
// Address: 0x1a6fb8 - 0x1a7008

void entry_1a6fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a6fb8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a6fbc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a6fc0: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1a6fc4: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1a6fc8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1a6fcc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a6fd0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a6fd4: 0xe6010590
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1424), *(uint32_t*)&val); }
    // 0x1a6fd8: 0x26020590
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1424));
    // 0x1a6fdc: 0xe6000570
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1392), *(uint32_t*)&val); }
    // 0x1a6fe0: 0xae040568
    WRITE32(ADD32(GPR_U32(ctx, 16), 1384), GPR_U32(ctx, 4));
    // 0x1a6fe4: 0xae030550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 3));
    // 0x1a6fe8: 0xe601056c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1388), *(uint32_t*)&val); }
    // 0x1a6fec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a6ff0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a6ff4: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x1a6ff8: 0xac400004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 0));
    // 0x1a6ffc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7004: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7008; return;
}


// Function: LoadRocFromBrx__FP3ROCP18CBinaryInputStream
// Address: 0x1a7008 - 0x1a701c

void entry_1a701c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a701c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a7020: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7024: 0x24c6b830
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948912));
    // 0x1a7028: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1a7030);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1a7030
// Address: 0x1a7030 - 0x1a703c

void entry_1a7030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7030: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7034: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x1a703c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1396));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a703c
// Address: 0x1a703c - 0x1a7050

void entry_1a703c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a703c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7040: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7044: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a704c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7050; return;
}


// Function: CloneRoc__FP3ROCT0
// Address: 0x1a7050 - 0x1a7078

void entry_1a7078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7078: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1a707c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1a7080: 0xb20205a7
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1447); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a7084: 0xb60205a0
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1440); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a7088: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a708c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7090: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostRocLoad__FP3ROC
// Address: 0x1a7098 - 0x1a70ac

void entry_1a70ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a70ac: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a70b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a70b4: 0x24c6b840
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948928));
    // 0x1a70b8: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1a70c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1a70c0
// Address: 0x1a70c0 - 0x1a70f4

void entry_1a70c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a70c0) {
        switch (ctx->pc) {
            case 0x1a70e0: ctx->pc = 0; goto label_1a70e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a70c0: 0x8e020578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1400)));
    // 0x1a70c4: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
        goto label_1a70e0;
    }
    // 0x1a70cc: 0x684302e3
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 739); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1a70d0: 0x6c4302dc
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 732); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1a70d4: 0xb2030583
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1411); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a70d8: 0xb603057c
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1404); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a70dc: 0x8e040560
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
label_1a70e0:
    // 0x1a70e0: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A70F8; return;
    }
    // 0x1a70e8: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a70ec: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1a70f4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1a70f4
// Address: 0x1a70f4 - 0x1a7104

void entry_1a70f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a70f4) {
        switch (ctx->pc) {
            case 0x1a70f8: ctx->pc = 0; goto label_1a70f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a70f4: 0xae020564
    WRITE32(ADD32(GPR_U32(ctx, 16), 1380), GPR_U32(ctx, 2));
label_1a70f8:
    // 0x1a70f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a70fc: 0xc069d20
    SET_GPR_U32(ctx, 31, 0x1a7104);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRocRocs__FP3ROC4ROCS(rdram, ctx, runtime); return;
}


// Function: entry_1a7104
// Address: 0x1a7104 - 0x1a7114

void entry_1a7104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7104: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a7108: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a710c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a7114);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a7114
// Address: 0x1a7114 - 0x1a7128

void entry_1a7114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7114: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7118: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a711c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7124: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7128; return;
}


// Function: UpdateRoc__FP3ROCf
// Address: 0x1a7128 - 0x1a7140

void entry_1a7140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7140) {
        switch (ctx->pc) {
            case 0x1a7148: ctx->pc = 0; goto label_1a7148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7140: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a7150(rdram, ctx, runtime); return;
    }
label_1a7148:
    // 0x1a7148: 0xc069d20
    SET_GPR_U32(ctx, 31, 0x1a7150);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetRocRocs__FP3ROC4ROCS(rdram, ctx, runtime); return;
}


// Function: entry_1a7150
// Address: 0x1a7150 - 0x1a7158

void entry_1a7150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7150: 0xc069d08
    SET_GPR_U32(ctx, 31, 0x1a7158);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RocsNextRoc__FP3ROC(rdram, ctx, runtime); return;
}


// Function: entry_1a7158
// Address: 0x1a7158 - 0x1a719c

void entry_1a7158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7158: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a715c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x1a7160: 0x14a2fff9
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A7148; return;
    }
    // 0x1a7168: 0x8e040578
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1400)));
    // 0x1a716c: 0x1080002c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7220; return;
    }
    // 0x1a7174: 0xc6000158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 344)); ctx->f[0] = *(float*)&val; }
    // 0x1a7178: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a717c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a7180: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a7184: 0x46000507
    ctx->f[20] = FPU_NEG_S(ctx->f[0]);
    // 0x1a7188: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a718c: 0x45000021
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A7214; return;
    }
    // 0x1a7194: 0xc0557e8
    SET_GPR_U32(ctx, 31, 0x1a719c);
    UnpauseEmitter__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1a719c
// Address: 0x1a719c - 0x1a721c

void entry_1a719c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a719c) {
        switch (ctx->pc) {
            case 0x1a71e0: ctx->pc = 0; goto label_1a71e0;
            case 0x1a71f4: ctx->pc = 0; goto label_1a71f4;
            case 0x1a7214: ctx->pc = 0; goto label_1a7214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a719c: 0x26020590
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1424));
    // 0x1a71a0: 0xc6020590
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1424)); ctx->f[2] = *(float*)&val; }
    // 0x1a71a4: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1a71a8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a71ac: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a71b0: 0x24645c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 23648));
    // 0x1a71b4: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1a71b8: 0xc4635c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x1a71bc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a71c0: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1a71c4: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1a71c8: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a71cc: 0x0
    // NOP
    // 0x1a71d0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a71e0;
    }
    // 0x1a71d8: 0x10000006
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a71f4;
    }
label_1a71e0:
    // 0x1a71e0: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a71e4: 0x0
    // NOP
    // 0x1a71e8: 0x45000002
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a71f4;
    }
    // 0x1a71f0: 0x46002086
    ctx->f[2] = FPU_MOV_S(ctx->f[4]);
label_1a71f4:
    // 0x1a71f4: 0xc600057c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1404)); ctx->f[0] = *(float*)&val; }
    // 0x1a71f8: 0xc6010580
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1408)); ctx->f[1] = *(float*)&val; }
    // 0x1a71fc: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1a7200: 0x8e020578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1400)));
    // 0x1a7204: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1a7208: 0xe44002dc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 732), *(uint32_t*)&val); }
    // 0x1a720c: 0x10000003
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 736), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a721c(rdram, ctx, runtime); return;
    }
label_1a7214:
    // 0x1a7214: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x1a721c);
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1a721c
// Address: 0x1a721c - 0x1a7230

void entry_1a721c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a721c) {
        switch (ctx->pc) {
            case 0x1a7220: ctx->pc = 0; goto label_1a7220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a721c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a7220:
    // 0x1a7220: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7224: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1a7228: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetRocAccel__FP3ROCf
// Address: 0x1a7230 - 0x1a7244

void entry_1a7244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7244: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1a7248: 0x1440000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7280; return;
    }
    // 0x1a7250: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a7254: 0x26040110
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1a7258: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x1a7260);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1a7260
// Address: 0x1a7260 - 0x1a727c

void entry_1a7260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7260: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a7264: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a7268: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x1a726c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7270: 0x24c6b850
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948944));
    // 0x1a7274: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1a727c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1a727c
// Address: 0x1a727c - 0x1a7290

void entry_1a727c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a727c) {
        switch (ctx->pc) {
            case 0x1a7280: ctx->pc = 0; goto label_1a7280;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a727c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1a7280:
    // 0x1a7280: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a7284: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a728c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7290; return;
}


// Function: AdjustRocNewXp__FP3ROCP2XPi
// Address: 0x1a7290 - 0x1a72b0

void entry_1a732c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a732c: 0x8e060574
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1396)));
    // 0x1a7330: 0x10c00010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1a7374(rdram, ctx, runtime); return;
    }
    // 0x1a7338: 0x7a220030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x1a733c: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x1a7340: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a7344: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a7348: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1a734c: 0x7a220020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1a7350: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1a7354: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1a7358: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a735c: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1a7360: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1a7364: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1a7368: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1a736c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a7374);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a7374
// Address: 0x1a7374 - 0x1a73b4

void entry_1a7374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7374: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a7378: 0x24040023
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 35));
    // 0x1a737c: 0x3c01463b
    SET_GPR_U32(ctx, 1, ((uint32_t)17979 << 16));
    // 0x1a7380: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a7384: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a7388: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a738c: 0x3c0145fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17914 << 16));
    // 0x1a7390: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a7394: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a7398: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a739c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a73a0: 0x26270020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 32));
    // 0x1a73a4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a73a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a73ac: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a73b4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a73b4
// Address: 0x1a73b4 - 0x1a73c4

void entry_1a73b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a73b4) {
        switch (ctx->pc) {
            case 0x1a73bc: ctx->pc = 0; goto label_1a73bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a73b4: 0x10000014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7408; return;
    }
label_1a73bc:
    // 0x1a73bc: 0xc069d20
    SET_GPR_U32(ctx, 31, 0x1a73c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetRocRocs__FP3ROC4ROCS(rdram, ctx, runtime); return;
}


// Function: entry_1a73c4
// Address: 0x1a73c4 - 0x1a7404

void entry_1a73c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a73c4: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1a73c8: 0x2404014f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 335));
    // 0x1a73cc: 0x3c01463b
    SET_GPR_U32(ctx, 1, ((uint32_t)17979 << 16));
    // 0x1a73d0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a73d4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a73d8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a73dc: 0x3c0145fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17914 << 16));
    // 0x1a73e0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a73e4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a73e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a73ec: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a73f0: 0x26270020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 32));
    // 0x1a73f4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1a73f8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a73fc: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1a7404);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1a7404
// Address: 0x1a7404 - 0x1a7420

void entry_1a7404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7404) {
        switch (ctx->pc) {
            case 0x1a7408: ctx->pc = 0; goto label_1a7408;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7404: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_1a7408:
    // 0x1a7408: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a740c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a7410: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1a7414: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a7418: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RocsNextRoc__FP3ROC
// Address: 0x1a7420 - 0x1a7480

void entry_1a74bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a74bc) {
        switch (ctx->pc) {
            case 0x1a74c0: ctx->pc = 0; goto label_1a74c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a74bc: 0xae110550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 17));
label_1a74c0:
    // 0x1a74c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a74c4: 0x8e060564
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x1a74c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1a74cc: 0x10c0000e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1364), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1a7508(rdram, ctx, runtime); return;
    }
    // 0x1a74d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1a74d8: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1a74dc: 0x2442b860
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294948960));
    // 0x1a74e0: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a74e4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1a74e8: 0x16440005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1A7500; return;
    }
    // 0x1a74f0: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1a74f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1a74f8
// Address: 0x1a74f8 - 0x1a7508

void entry_1a74f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a74f8) {
        switch (ctx->pc) {
            case 0x1a7500: ctx->pc = 0; goto label_1a7500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a74f8: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A750C; return;
    }
label_1a7500:
    // 0x1a7500: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1a7508);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1a7508
// Address: 0x1a7508 - 0x1a7520

void entry_1a7508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7508) {
        switch (ctx->pc) {
            case 0x1a750c: ctx->pc = 0; goto label_1a750c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7508: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1a750c:
    // 0x1a750c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a7510: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7514: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitRost__FP4ROST
// Address: 0x1a7520 - 0x1a7534

void entry_1a7534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7534: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a7538: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a753c: 0xae020550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    // 0x1a7540: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7544: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a754c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7550; return;
}


// Function: LoadRostFromBrx__FP4ROSTP18CBinaryInputStream
// Address: 0x1a7550 - 0x1a7564

void entry_1a7564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7564: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a7568: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a756c: 0x24c6b888
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294949000));
    // 0x1a7570: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1a7578);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1a7578
// Address: 0x1a7578 - 0x1a7588

void entry_1a7578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7578: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a757c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7580: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneRost__FP4ROSTT0
// Address: 0x1a7588 - 0x1a75b0

void entry_1a75b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a75b0: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1a75b4: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1a75b8: 0xb202056f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1391); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a75bc: 0xb6020568
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1384); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1a75c0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a75c4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a75c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostRostLoad__FP4ROST
// Address: 0x1a75d0 - 0x1a75e8

void entry_1a75e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a75e8: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a75ec: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7604; return;
    }
    // 0x1a75f4: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a75f8: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1a7600);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1a7600
// Address: 0x1a7600 - 0x1a7618

void entry_1a7600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7600) {
        switch (ctx->pc) {
            case 0x1a7604: ctx->pc = 0; goto label_1a7604;
            case 0x1a7608: ctx->pc = 0; goto label_1a7608;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7600: 0xae220560
    WRITE32(ADD32(GPR_U32(ctx, 17), 1376), GPR_U32(ctx, 2));
label_1a7604:
    // 0x1a7604: 0x8e300034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 52)));
label_1a7608:
    // 0x1a7608: 0x12000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7624; return;
    }
    // 0x1a7610: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a7618);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a7618
// Address: 0x1a7618 - 0x1a7630

void entry_1a7618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7618) {
        switch (ctx->pc) {
            case 0x1a7624: ctx->pc = 0; goto label_1a7624;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7618: 0x5040fffb
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x1A7608; return;
    }
    // 0x1a7620: 0xae300564
    WRITE32(ADD32(GPR_U32(ctx, 17), 1380), GPR_U32(ctx, 16));
label_1a7624:
    // 0x1a7624: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a7628: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x1a7630);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_1a7630
// Address: 0x1a7630 - 0x1a7648

void entry_1a7630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7630: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a7634: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a7638: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a763c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7644: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7648; return;
}


// Function: UpdateRost__FP4ROSTf
// Address: 0x1a7648 - 0x1a765c

void entry_1a765c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a765c) {
        switch (ctx->pc) {
            case 0x1a7668: ctx->pc = 0; goto label_1a7668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a765c: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a7670(rdram, ctx, runtime); return;
    }
    // 0x1a7664: 0x0
    // NOP
label_1a7668:
    // 0x1a7668: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x1a7670);
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_1a7670
// Address: 0x1a7670 - 0x1a7678

void entry_1a7670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7670: 0xc069da6
    SET_GPR_U32(ctx, 31, 0x1a7678);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RostsNextRost__FP4ROST(rdram, ctx, runtime); return;
}


// Function: entry_1a7678
// Address: 0x1a7678 - 0x1a7698

void entry_1a7678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7678: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x1a767c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7680: 0x1443fff9
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1A7668; return;
    }
    // 0x1a7688: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a768c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7690: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RostsNextRost__FP4ROST
// Address: 0x1a7698 - 0x1a76a0

void entry_1a76ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a76ec) {
        switch (ctx->pc) {
            case 0x1a76f4: ctx->pc = 0; goto label_1a76f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a76ec: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7700; return;
    }
label_1a76f4:
    // 0x1a76f4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1a76fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1a76fc
// Address: 0x1a76fc - 0x1a7708

void entry_1a76fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a76fc) {
        switch (ctx->pc) {
            case 0x1a7700: ctx->pc = 0; goto label_1a7700;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a76fc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a7700:
    // 0x1a7700: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitRop__FP3ROP
// Address: 0x1a7708 - 0x1a771c

void entry_1a771c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a771c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a7720: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7724: 0xae020550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    // 0x1a7728: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a772c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a7730: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a7734: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a773c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a773c
// Address: 0x1a773c - 0x1a7750

void entry_1a773c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a773c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7740: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7744: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a774c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7750; return;
}


// Function: LoadRopFromBrx__FP3ROPP18CBinaryInputStream
// Address: 0x1a7750 - 0x1a7764

void entry_1a7764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7764: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1a7768: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a776c: 0x24c6b8a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294949024));
    // 0x1a7770: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1a7778);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1a7778
// Address: 0x1a7778 - 0x1a7784

void entry_1a7778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7778: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a777c: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x1a7784);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1384));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a7784
// Address: 0x1a7784 - 0x1a7798

void entry_1a7784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7784: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7788: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a778c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7794: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7798; return;
}


// Function: PostRopLoad__FP3ROP
// Address: 0x1a7798 - 0x1a77ac

void entry_1a77ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a77ac: 0x8e020558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x1a77b0: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x1A77D0; return;
    }
    // 0x1a77b8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a77bc: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a77c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a77c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a77c8
// Address: 0x1a77c8 - 0x1a77e0

void entry_1a77c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a77c8) {
        switch (ctx->pc) {
            case 0x1a77d0: ctx->pc = 0; goto label_1a77d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a77c8: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A77F4; return;
    }
label_1a77d0:
    // 0x1a77d0: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x1a77d4: 0x8e070034
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1a77d8: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x1a77e0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 89));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a77e0
// Address: 0x1a77e0 - 0x1a77f0

void entry_1a77e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a77e0: 0xae02055c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1372), GPR_U32(ctx, 2));
    // 0x1a77e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a77e8: 0xc069e66
    SET_GPR_U32(ctx, 31, 0x1a77f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRopRops__FP3ROP4ROPS(rdram, ctx, runtime); return;
}


// Function: entry_1a77f0
// Address: 0x1a77f0 - 0x1a7800

void entry_1a77f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a77f0) {
        switch (ctx->pc) {
            case 0x1a77f4: ctx->pc = 0; goto label_1a77f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a77f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a77f4:
    // 0x1a77f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a77f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateRop__FP3ROPf
// Address: 0x1a7800 - 0x1a7818

void entry_1a7818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7818) {
        switch (ctx->pc) {
            case 0x1a7820: ctx->pc = 0; goto label_1a7820;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7818: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a7828(rdram, ctx, runtime); return;
    }
label_1a7820:
    // 0x1a7820: 0xc069e66
    SET_GPR_U32(ctx, 31, 0x1a7828);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetRopRops__FP3ROP4ROPS(rdram, ctx, runtime); return;
}


// Function: entry_1a7828
// Address: 0x1a7828 - 0x1a7830

void entry_1a7828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7828: 0xc069ea8
    SET_GPR_U32(ctx, 31, 0x1a7830);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RopsNextRop__FP3ROP(rdram, ctx, runtime); return;
}


// Function: entry_1a7830
// Address: 0x1a7830 - 0x1a7930

void entry_1a7830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7830) {
        switch (ctx->pc) {
            case 0x1a78b4: ctx->pc = 0; goto label_1a78b4;
            case 0x1a78c4: ctx->pc = 0; goto label_1a78c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7830: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a7834: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x1a7838: 0x14a2fff9
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A7820; return;
    }
    // 0x1a7840: 0x14a20051
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A7988; return;
    }
    // 0x1a7848: 0x8e250558
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
    // 0x1a784c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a7850: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a7854: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1a7858: 0x8ca30354
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 852)));
    // 0x1a785c: 0xd8820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x1a7860: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1a7864: 0x4be208ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a7868: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a786c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a7870: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a7874: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a7878: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a787c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a7880: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a7884: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a7888: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a788c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a7890: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a7894: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a7898: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1a789c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a78a0: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a78b4;
    }
    // 0x1a78a8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a78ac: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a78c4;
    }
label_1a78b4:
    // 0x1a78b4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a78b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a78bc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1a78c0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1a78c4:
    // 0x1a78c4: 0x8e22055c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a78c8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1a78cc: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1a78d0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1a78d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a78d8: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a78dc: 0xd8410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 336)));
    // 0x1a78e0: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a78e4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a78e8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a78ec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a78f0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a78f4: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1a78f8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1a78fc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a7900: 0xc46e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x1a7904: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a7908: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a790c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a7910: 0xe7a10010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1a7914: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a7918: 0xafa00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    // 0x1a791c: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1a7920: 0xe4a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 8), *(uint32_t*)&val); }
    // 0x1a7924: 0x46000b46
    ctx->f[13] = FPU_MOV_S(ctx->f[1]);
    // 0x1a7928: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1a7930);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1a7930
// Address: 0x1a7930 - 0x1a7960

void entry_1a7930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7930: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1a7934: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1a7938: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1a793c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7940: 0x8e26055c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a7944: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a7948: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a794c: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a7950: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1a7954: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x1a7958: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a7960);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a7960
// Address: 0x1a7960 - 0x1a7970

void entry_1a7960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7960: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1a7964: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a7968: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x1a7970);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a7970
// Address: 0x1a7970 - 0x1a7984

void entry_1a7970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7970: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1a7974: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a7978: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1a797c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a7984);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a7984
// Address: 0x1a7984 - 0x1a7998

void entry_1a7984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7984) {
        switch (ctx->pc) {
            case 0x1a7988: ctx->pc = 0; goto label_1a7988;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7984: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1a7988:
    // 0x1a7988: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a798c: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a7990: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetRopRops__FP3ROP4ROPS
// Address: 0x1a7998 - 0x1a79d4

void entry_1a79d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a79d4) {
        switch (ctx->pc) {
            case 0x1a79dc: ctx->pc = 0; goto label_1a79dc;
            case 0x1a7a08: ctx->pc = 0; goto label_1a7a08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a79d4: 0xae000564
    WRITE32(ADD32(GPR_U32(ctx, 16), 1380), GPR_U32(ctx, 0));
    // 0x1a79d8: 0xae110550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 17));
label_1a79dc:
    // 0x1a79dc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a79e0: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a79e4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a79e8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1a79ec: 0x12230006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1364), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 3)) {
        goto label_1a7a08;
    }
    // 0x1a79f4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a79f8: 0x52220011
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
        ctx->pc = 0x1A7A40; return;
    }
    // 0x1a7a00: 0x10000018
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a7a64(rdram, ctx, runtime); return;
    }
label_1a7a08:
    // 0x1a7a08: 0x8e060568
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
    // 0x1a7a0c: 0x10c00015
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1a7a64(rdram, ctx, runtime); return;
    }
    // 0x1a7a14: 0x7a030140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1a7a18: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1a7a1c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1a7a20: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a7a24: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x1a7a28: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1a7a2c: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1a7a30: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a7a38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a7a38
// Address: 0x1a7a38 - 0x1a7a50

void entry_1a7a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7a38) {
        switch (ctx->pc) {
            case 0x1a7a40: ctx->pc = 0; goto label_1a7a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7a38: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a7a64(rdram, ctx, runtime); return;
    }
label_1a7a40:
    // 0x1a7a40: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a7a44: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x1a7a48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a7a50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a7a50
// Address: 0x1a7a50 - 0x1a7a64

void entry_1a7a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7a50: 0x8e04055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x1a7a54: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a7a58: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x1a7a5c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a7a64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a7a64
// Address: 0x1a7a64 - 0x1a7a88

void entry_1a7a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7a64: 0x12400008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1a7a88(rdram, ctx, runtime); return;
    }
    // 0x1a7a6c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a7a70: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a7a74: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a7a78: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a7a7c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a7a80: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1a7a88);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 1380));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1a7a88
// Address: 0x1a7a88 - 0x1a7aa0

void entry_1a7a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7a88) {
        switch (ctx->pc) {
            case 0x1a7a8c: ctx->pc = 0; goto label_1a7a8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7a88: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1a7a8c:
    // 0x1a7a8c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a7a90: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a7a94: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a7a98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RopsNextRop__FP3ROP
// Address: 0x1a7aa0 - 0x1a7b20

void entry_1a7b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7b50) {
        switch (ctx->pc) {
            case 0x1a7b58: ctx->pc = 0; goto label_1a7b58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7b50: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7B68; return;
    }
label_1a7b58:
    // 0x1a7b58: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7b5c: 0xc069f66
    SET_GPR_U32(ctx, 31, 0x1a7b64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetRumbleRums__FP6RUMBLE4RUMS(rdram, ctx, runtime); return;
}


// Function: entry_1a7b64
// Address: 0x1a7b64 - 0x1a7b88

void entry_1a7b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7b64) {
        switch (ctx->pc) {
            case 0x1a7b68: ctx->pc = 0; goto label_1a7b68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7b64: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
label_1a7b68:
    // 0x1a7b68: 0xae120004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 18));
    // 0x1a7b6c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a7b70: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a7b74: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7b78: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7b7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7b84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7b88; return;
}


// Function: UpdateRumble__FP6RUMBLE
// Address: 0x1a7b88 - 0x1a7c5c

void entry_1a7c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7c5c) {
        switch (ctx->pc) {
            case 0x1a7c74: ctx->pc = 0; goto label_1a7c74;
            case 0x1a7c84: ctx->pc = 0; goto label_1a7c84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7c5c: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1a7c60: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1a7c64: 0x318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 3));
    // 0x1a7c68: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1a7c6c: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a7c70: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
label_1a7c74:
    // 0x1a7c74: 0xc6000018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1a7c78: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1a7c7c: 0x10000014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a7cd0(rdram, ctx, runtime); return;
    }
label_1a7c84:
    // 0x1a7c84: 0xc069f66
    SET_GPR_U32(ctx, 31, 0x1a7c8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetRumbleRums__FP6RUMBLE4RUMS(rdram, ctx, runtime); return;
}


// Function: entry_1a7c8c
// Address: 0x1a7c8c - 0x1a7cb0

void entry_1a7c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7c8c) {
        switch (ctx->pc) {
            case 0x1a7c94: ctx->pc = 0; goto label_1a7c94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7c8c: 0x10000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7CD4; return;
    }
label_1a7c94:
    // 0x1a7c94: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1a7c98: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a7c9c: 0x0
    // NOP
    // 0x1a7ca0: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x1A7CC0; return;
    }
    // 0x1a7ca8: 0xc069f90
    SET_GPR_U32(ctx, 31, 0x1a7cb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StopRumbleActuators__FP6RUMBLE(rdram, ctx, runtime); return;
}


// Function: entry_1a7cb0
// Address: 0x1a7cb0 - 0x1a7cd0

void entry_1a7cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7cb0) {
        switch (ctx->pc) {
            case 0x1a7cc0: ctx->pc = 0; goto label_1a7cc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7cb0: 0xc600001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[0] = *(float*)&val; }
    // 0x1a7cb4: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1a7cb8: 0x10000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a7cd0(rdram, ctx, runtime); return;
    }
label_1a7cc0:
    // 0x1a7cc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7cc4: 0x38a50003
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 3));
    // 0x1a7cc8: 0xc069f66
    SET_GPR_U32(ctx, 31, 0x1a7cd0);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetRumbleRums__FP6RUMBLE4RUMS(rdram, ctx, runtime); return;
}


// Function: entry_1a7cd0
// Address: 0x1a7cd0 - 0x1a7ce8

void entry_1a7cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7cd0) {
        switch (ctx->pc) {
            case 0x1a7cd4: ctx->pc = 0; goto label_1a7cd4;
            case 0x1a7cd8: ctx->pc = 0; goto label_1a7cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7cd0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a7cd4:
    // 0x1a7cd4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a7cd8:
    // 0x1a7cd8: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1a7cdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7ce4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7ce8; return;
}


// Function: TriggerRumbleRumk__FP6RUMBLE4RUMKf
// Address: 0x1a7ce8 - 0x1a7d08

void entry_1a7d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7d08: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7d0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7d14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7d18; return;
}


// Function: TriggerRumbleRumpat__FP6RUMBLEP6RUMPATf
// Address: 0x1a7d18 - 0x1a7d54

void entry_1a7d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7d54: 0x1040000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a7d80(rdram, ctx, runtime); return;
    }
    // 0x1a7d5c: 0xe6140018
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
    // 0x1a7d60: 0xae110010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 17));
    // 0x1a7d64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a7d68: 0xae000014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 0));
    // 0x1a7d6c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a7d70: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a7d74: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x1a7d78: 0xc069f66
    SET_GPR_U32(ctx, 31, 0x1a7d80);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    SetRumbleRums__FP6RUMBLE4RUMS(rdram, ctx, runtime); return;
}


// Function: entry_1a7d80
// Address: 0x1a7d80 - 0x1a7d98

void entry_1a7d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7d80: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a7d84: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7d88: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a7d8c: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1a7d90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetRumbleRums__FP6RUMBLE4RUMS
// Address: 0x1a7d98 - 0x1a7e00

void entry_1a7e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7e00: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A7E2C; return;
    }
    // 0x1a7e08: 0xc069f90
    SET_GPR_U32(ctx, 31, 0x1a7e10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StopRumbleActuators__FP6RUMBLE(rdram, ctx, runtime); return;
}


// Function: entry_1a7e10
// Address: 0x1a7e10 - 0x1a7e40

void entry_1a7e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7e10) {
        switch (ctx->pc) {
            case 0x1a7e28: ctx->pc = 0; goto label_1a7e28;
            case 0x1a7e2c: ctx->pc = 0; goto label_1a7e2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7e10: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1a7e14: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1a7e18: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a7e1c: 0xc440186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[0] = *(float*)&val; }
    // 0x1a7e20: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1a7e24: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
label_1a7e28:
    // 0x1a7e28: 0xae11000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 17));
label_1a7e2c:
    // 0x1a7e2c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a7e30: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a7e34: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7e38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StopRumbleActuators__FP6RUMBLE
// Address: 0x1a7e40 - 0x1a7e60

void entry_1a7e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a7e60: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a7e64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7e6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7e70; return;
}


// Function: FUN_001A7E70__Fv
// Address: 0x1a7e70 - 0x1a7e90

void FUN_001A7E70__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7e70) {
        switch (ctx->pc) {
            case 0x1a7e84: ctx->pc = 0; goto label_1a7e84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7e70: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a7e74: 0x8c62c3dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294951900)));
    // 0x1a7e78: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a7e84;
    }
    // 0x1a7e80: 0xac62c3dc
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294951900), GPR_U32(ctx, 2));
label_1a7e84:
    // 0x1a7e84: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7e8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7e90; return;
}


// Function: FUN_001A7E90
// Address: 0x1a7e90 - 0x1a7ee8

void FUN_001A7E90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7e90) {
        switch (ctx->pc) {
            case 0x1a7eb4: ctx->pc = 0; goto label_1a7eb4;
            case 0x1a7ebc: ctx->pc = 0; goto label_1a7ebc;
            case 0x1a7ed4: ctx->pc = 0; goto label_1a7ed4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7e90: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a7e94: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a7e98: 0x8c63c3dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4294951900)));
    // 0x1a7e9c: 0x10620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a7ebc;
    }
    // 0x1a7ea4: 0x14400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a7eb4;
    }
    // 0x1a7eac: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
        goto label_1a7ed4;
    }
label_1a7eb4:
    // 0x1a7eb4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
label_1a7ebc:
    // 0x1a7ebc: 0x8c8319ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x1a7ec0: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1a7ec4: 0x3442ffdf
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65503));
    // 0x1a7ec8: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1a7ecc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 6636), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1a7ed4:
    // 0x1a7ed4: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x1a7ed8: 0xac8219ec
    WRITE32(ADD32(GPR_U32(ctx, 4), 6636), GPR_U32(ctx, 2));
    // 0x1a7edc: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7ee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7ee8; return;
}


// Function: FUN_001A7EE8
// Address: 0x1a7ee8 - 0x1a7f50

void FUN_001A7EE8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7ee8) {
        switch (ctx->pc) {
            case 0x1a7f18: ctx->pc = 0; goto label_1a7f18;
            case 0x1a7f30: ctx->pc = 0; goto label_1a7f30;
            case 0x1a7f38: ctx->pc = 0; goto label_1a7f38;
            case 0x1a7f40: ctx->pc = 0; goto label_1a7f40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7ee8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a7eec: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a7ef0: 0x8c63c3dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4294951900)));
    // 0x1a7ef4: 0x50620012
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
        goto label_1a7f40;
    }
    // 0x1a7efc: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1a7f00: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_1a7f18;
    }
    // 0x1a7f08: 0x1060000b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a7f38;
    }
    // 0x1a7f10: 0x1000000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a7f40;
    }
label_1a7f18:
    // 0x1a7f18: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a7f30;
    }
    // 0x1a7f20: 0x10620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a7f38;
    }
    // 0x1a7f28: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a7f40;
    }
label_1a7f30:
    // 0x1a7f30: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1a7f38:
    // 0x1a7f38: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1a7f40:
    // 0x1a7f40: 0x21143
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 5));
    // 0x1a7f44: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x1a7f48: 0x3e00008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001A7F50
// Address: 0x1a7f50 - 0x1a7fe8

void FUN_001A7F50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a7f50) {
        switch (ctx->pc) {
            case 0x1a7f80: ctx->pc = 0; goto label_1a7f80;
            case 0x1a7f94: ctx->pc = 0; goto label_1a7f94;
            case 0x1a7fa0: ctx->pc = 0; goto label_1a7fa0;
            case 0x1a7fb0: ctx->pc = 0; goto label_1a7fb0;
            case 0x1a7fc0: ctx->pc = 0; goto label_1a7fc0;
            case 0x1a7fc4: ctx->pc = 0; goto label_1a7fc4;
            case 0x1a7fc8: ctx->pc = 0; goto label_1a7fc8;
            case 0x1a7fdc: ctx->pc = 0; goto label_1a7fdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a7f50: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1a7f54: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a7f58: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1a7f5c: 0x8c63c3dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4294951900)));
    // 0x1a7f60: 0x1062000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a7fa0;
    }
    // 0x1a7f68: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a7f80;
    }
    // 0x1a7f70: 0x10620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a7f94;
    }
    // 0x1a7f78: 0x10000013
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a7fc8;
    }
label_1a7f80:
    // 0x1a7f80: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a7f84: 0x5062000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
        goto label_1a7fb0;
    }
    // 0x1a7f8c: 0x1000000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a7fc4;
    }
label_1a7f94:
    // 0x1a7f94: 0x38420020
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 32));
    // 0x1a7f98: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 4), 6636), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a7fc0;
    }
label_1a7fa0:
    // 0x1a7fa0: 0x8c8219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x1a7fa4: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x1a7fa8: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 4), 6636), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a7fc0;
    }
label_1a7fb0:
    // 0x1a7fb0: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1a7fb4: 0x3442ffdf
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65503));
    // 0x1a7fb8: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1a7fbc: 0xac8319ec
    WRITE32(ADD32(GPR_U32(ctx, 4), 6636), GPR_U32(ctx, 3));
label_1a7fc0:
    // 0x1a7fc0: 0x8c8219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
label_1a7fc4:
    // 0x1a7fc4: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
label_1a7fc8:
    // 0x1a7fc8: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a7fdc;
    }
    // 0x1a7fd0: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1a7fd4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 4294951900), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1a7fdc:
    // 0x1a7fdc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 4294951900), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a7fe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a7fe8; return;
}


// Function: InitRwm__FP3RWM
// Address: 0x1a7fe8 - 0x1a8000

void entry_1a8000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8000: 0x26110060
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 96));
    // 0x1a8004: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a8008: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a800c: 0xae020058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 2));
    // 0x1a8010: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8014: 0x24060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1a8018: 0xae02004c
    WRITE32(ADD32(GPR_U32(ctx, 16), 76), GPR_U32(ctx, 2));
    // 0x1a801c: 0xae020050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 2));
    // 0x1a8020: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1a8028);
    WRITE32(ADD32(GPR_U32(ctx, 16), 84), GPR_U32(ctx, 2));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1a8028
// Address: 0x1a8028 - 0x1a8058

void entry_1a8028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8028: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1a802c: 0x260400e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 224));
    // 0x1a8030: 0x24e783d0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294935504));
    // 0x1a8034: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8038: 0x78e30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1a803c: 0x24060070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 112));
    // 0x1a8040: 0x7e230020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 3));
    // 0x1a8044: 0x78e20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 16)));
    // 0x1a8048: 0x7e220030
    WRITE128(ADD32(GPR_U32(ctx, 17), 48), GPR_VEC(ctx, 2));
    // 0x1a804c: 0x78e30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 7), 32)));
    // 0x1a8050: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1a8058);
    WRITE128(ADD32(GPR_U32(ctx, 17), 64), GPR_VEC(ctx, 3));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1a8058
// Address: 0x1a8058 - 0x1a8094

void entry_1a8058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8058: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a805c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a8060: 0x26020110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1a8064: 0xae000110
    WRITE32(ADD32(GPR_U32(ctx, 16), 272), GPR_U32(ctx, 0));
    // 0x1a8068: 0x26040150
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 336));
    // 0x1a806c: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x1a8070: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8074: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x1a8078: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1a807c: 0x3c01469c
    SET_GPR_U32(ctx, 1, ((uint32_t)18076 << 16));
    // 0x1a8080: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1a8084: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a8088: 0xae000120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 0));
    // 0x1a808c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1a8094);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 292), *(uint32_t*)&val); }
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1a8094
// Address: 0x1a8094 - 0x1a80cc

void entry_1a8094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8094: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1a8098: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1a809c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a80a0: 0xc461cbc4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294953924)); ctx->f[1] = *(float*)&val; }
    // 0x1a80a4: 0x3c05001b
    SET_GPR_U32(ctx, 5, ((uint32_t)27 << 16));
    // 0x1a80a8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1a80ac: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a80b0: 0xae000168
    WRITE32(ADD32(GPR_U32(ctx, 16), 360), GPR_U32(ctx, 0));
    // 0x1a80b4: 0x24a58208
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935048));
    // 0x1a80b8: 0xe60000d8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 216), *(uint32_t*)&val); }
    // 0x1a80bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a80c0: 0xe6010144
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 324), *(uint32_t*)&val); }
    // 0x1a80c4: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1a80cc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1a80cc
// Address: 0x1a80cc - 0x1a80e0

void entry_1a80cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a80cc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a80d0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a80d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a80d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnRwmRemove
// Address: 0x1a80e0 - 0x1a80f4

void entry_1a80f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a80f4: 0xc06a4f2
    SET_GPR_U32(ctx, 31, 0x1a80fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001a93c8(rdram, ctx, runtime); return;
}


// Function: entry_1a80fc
// Address: 0x1a80fc - 0x1a8110

void entry_1a80fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a80fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a8100: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8104: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a810c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a8110; return;
}


// Function: FUN_001a8110
// Address: 0x1a8110 - 0x1a8134

void FUN_001a8110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8110: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1a8114: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1a8118: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1a811c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1a8120: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1a8124: 0x14400007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8144; return;
    }
    // 0x1a812c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1a8134);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1a8134
// Address: 0x1a8134 - 0x1a8150

void entry_1a8134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8134) {
        switch (ctx->pc) {
            case 0x1a8144: ctx->pc = 0; goto label_1a8144;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8134: 0xae02003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 2));
    // 0x1a8138: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1a813c: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1a8140: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a8144:
    // 0x1a8144: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8148: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001a8150
// Address: 0x1a8150 - 0x1a8190

void FUN_001a8150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8150: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x1a8154: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x1a8158: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1a815c: 0xc0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a8160: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1a8164: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a8168: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1a816c: 0x100902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1a8170: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1a8174: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x1a8178: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1a817c: 0x8e020038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x1a8180: 0x14400004
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8194; return;
    }
    // 0x1a8188: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1a8190);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1a8190
// Address: 0x1a8190 - 0x1a8208

void entry_1a8190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8190) {
        switch (ctx->pc) {
            case 0x1a8194: ctx->pc = 0; goto label_1a8194;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8190: 0xae020038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 2));
label_1a8194:
    // 0x1a8194: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1a8198: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1a819c: 0x8e030038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x1a81a0: 0x2407fffe
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x1a81a4: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a81a8: 0x32280001
    SET_GPR_U32(ctx, 8, AND32(GPR_U32(ctx, 17), 1));
    // 0x1a81ac: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1a81b0: 0x32450001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 18), 1));
    // 0x1a81b4: 0xae020034
    WRITE32(ADD32(GPR_U32(ctx, 16), 52), GPR_U32(ctx, 2));
    // 0x1a81b8: 0x2406fffd
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967293));
    // 0x1a81bc: 0x52840
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 1));
    // 0x1a81c0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a81c4: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1a81c8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a81cc: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1a81d0: 0xac730000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 19));
    // 0x1a81d4: 0x471024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1a81d8: 0xac740004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 20));
    // 0x1a81dc: 0x481025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x1a81e0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a81e4: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1a81e8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a81ec: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1a81f0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a81f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a81f8: 0xac620010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
    // 0x1a81fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a8204: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a8208; return;
}


// Function: InitRwmCallback__FP3RWM5MSGIDPv
// Address: 0x1a8208 - 0x1a825c

void entry_1a825c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a825c) {
        switch (ctx->pc) {
            case 0x1a8268: ctx->pc = 0; goto label_1a8268;
            case 0x1a8278: ctx->pc = 0; goto label_1a8278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a825c: 0x8e83003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 60)));
    // 0x1a8260: 0xac62000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 2));
    // 0x1a8264: 0x8e820034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 52)));
label_1a8268:
    // 0x1a8268: 0x1840008a
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1A8494; return;
    }
    // 0x1a8270: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1a8274: 0x0
    // NOP
label_1a8278:
    // 0x1a8278: 0x8e830038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 56)));
    // 0x1a827c: 0x2a21018
    { int64_t result = (int64_t)GPR_S32(ctx, 21) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a8280: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1a8284: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1a8288: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1a828c: 0x629021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1a8290: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1a8298);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a8298
// Address: 0x1a8298 - 0x1a830c

void entry_1a8298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8298) {
        switch (ctx->pc) {
            case 0x1a82b0: ctx->pc = 0; goto label_1a82b0;
            case 0x1a82e8: ctx->pc = 0; goto label_1a82e8;
            case 0x1a82fc: ctx->pc = 0; goto label_1a82fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8298: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a829c: 0x56200004
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 60)));
        goto label_1a82b0;
    }
    // 0x1a82a4: 0xae400004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 0));
    // 0x1a82a8: 0x10000075
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 21), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8480; return;
    }
label_1a82b0:
    // 0x1a82b0: 0x50800022
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x1A833C; return;
    }
    // 0x1a82b8: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1a82bc: 0x1040001e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8338; return;
    }
    // 0x1a82c4: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1a82c8: 0x10650010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 5)) {
        entry_1a830c(rdram, ctx, runtime); return;
    }
    // 0x1a82d0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_1a82e8;
    }
    // 0x1a82d8: 0x50600008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 5));
        goto label_1a82fc;
    }
    // 0x1a82e0: 0x10000017
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8340; return;
    }
label_1a82e8:
    // 0x1a82e8: 0x14620015
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A8340; return;
    }
    // 0x1a82f0: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a82f4: 0x10000012
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8340; return;
    }
label_1a82fc:
    // 0x1a82fc: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1a8300: 0x8e84003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 60)));
    // 0x1a8304: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a830c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a830c
// Address: 0x1a830c - 0x1a8318

void entry_1a830c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a830c: 0x8e84003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 60)));
    // 0x1a8310: 0xc0549f6
    SET_GPR_U32(ctx, 31, 0x1a8318);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20));
    CPvDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_1a8318
// Address: 0x1a8318 - 0x1a8350

void entry_1a8318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8318) {
        switch (ctx->pc) {
            case 0x1a8338: ctx->pc = 0; goto label_1a8338;
            case 0x1a833c: ctx->pc = 0; goto label_1a833c;
            case 0x1a8340: ctx->pc = 0; goto label_1a8340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8318: 0x8e450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1a831c: 0x24440001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1a8320: 0x85182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x1a8324: 0xa0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a8328: 0x83b00a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 22, GPR_U32(ctx, 4));
    // 0x1a832c: 0x2c21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 22), GPR_U32(ctx, 2)));
    // 0x1a8330: 0x10000003
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a8340;
    }
label_1a8338:
    // 0x1a8338: 0x8e560004
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1a833c:
    // 0x1a833c: 0x26deffff
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 22), 4294967295));
label_1a8340:
    // 0x1a8340: 0x52c00005
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x1A8358; return;
    }
    // 0x1a8348: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1a8350);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 22), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1a8350
// Address: 0x1a8350 - 0x1a838c

void entry_1a8350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8350) {
        switch (ctx->pc) {
            case 0x1a8358: ctx->pc = 0; goto label_1a8358;
            case 0x1a8380: ctx->pc = 0; goto label_1a8380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8350: 0xae420008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    // 0x1a8354: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_1a8358:
    // 0x1a8358: 0x26b70001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1a835c: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1a8360: 0x21880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1a8364: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1a8368: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1a836c: 0xac710000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 17));
    // 0x1a8370: 0x1bc00024
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 30) <= 0) {
        ctx->pc = 0x1A8404; return;
    }
    // 0x1a8378: 0x3c0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1a837c: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_1a8380:
    // 0x1a8380: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a8384: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x1a838c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1a838c
// Address: 0x1a838c - 0x1a83c4

void entry_1a838c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a838c: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1a8390: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a8394: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1a8398: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1a839c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1a83a0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1a83a4: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1a83a8: 0xae43000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 3));
    // 0x1a83ac: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a83b0: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1a83b4: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1A83C8; return;
    }
    // 0x1a83bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a83c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a83c4
// Address: 0x1a83c4 - 0x1a83d8

void entry_1a83c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a83c4) {
        switch (ctx->pc) {
            case 0x1a83c8: ctx->pc = 0; goto label_1a83c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a83c4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1a83c8:
    // 0x1a83c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a83cc: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1a83d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a83d8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a83d8
// Address: 0x1a83d8 - 0x1a83ec

void entry_1a83d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a83d8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a83dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a83e0: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x1a83e4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a83ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a83ec
// Address: 0x1a83ec - 0x1a83fc

void entry_1a83ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a83ec: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a83f0: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a83f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a83fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a83fc
// Address: 0x1a83fc - 0x1a841c

void entry_1a83fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a83fc) {
        switch (ctx->pc) {
            case 0x1a8404: ctx->pc = 0; goto label_1a8404;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a83fc: 0x5660ffe0
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x1A8380; return;
    }
label_1a8404:
    // 0x1a8404: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a8408: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1a840c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1A8420; return;
    }
    // 0x1a8414: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a841c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a841c
// Address: 0x1a841c - 0x1a842c

void entry_1a841c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a841c) {
        switch (ctx->pc) {
            case 0x1a8420: ctx->pc = 0; goto label_1a8420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a841c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1a8420:
    // 0x1a8420: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1a8424: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a842c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a842c
// Address: 0x1a842c - 0x1a8440

void entry_1a842c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a842c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a8430: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a8434: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x1a8438: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a8440);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a8440
// Address: 0x1a8440 - 0x1a8450

void entry_1a8440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8440: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1a8444: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1a8448: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a8450);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a8450
// Address: 0x1a8450 - 0x1a84c8

void entry_1a8450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8450) {
        switch (ctx->pc) {
            case 0x1a8480: ctx->pc = 0; goto label_1a8480;
            case 0x1a8484: ctx->pc = 0; goto label_1a8484;
            case 0x1a8494: ctx->pc = 0; goto label_1a8494;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8450: 0x8e83003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 60)));
    // 0x1a8454: 0x5060000b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 52)));
        goto label_1a8484;
    }
    // 0x1a845c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1a8460: 0x10400007
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a8480;
    }
    // 0x1a8468: 0x8c64000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1a846c: 0x7a230190
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 400)));
    // 0x1a8470: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1a8474: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x1a8478: 0x7a2201d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 464)));
    // 0x1a847c: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
label_1a8480:
    // 0x1a8480: 0x8e820034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 52)));
label_1a8484:
    // 0x1a8484: 0x2e0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1a8488: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x1a848c: 0x1440ff7a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8278; return;
    }
label_1a8494:
    // 0x1a8494: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a8498: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a849c: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a84a0: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a84a4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a84a8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a84ac: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a84b0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a84b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a84b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a84bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a84c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a84c8; return;
}


// Function: FUN_001a84c8
// Address: 0x1a84c8 - 0x1a84e4

void FUN_001a84c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a84c8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1a84cc: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1a84d0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1a84d4: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1a84d8: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1a84dc: 0xc060c36
    SET_GPR_U32(ctx, 31, 0x1a84e4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    CloneLo__FP2LOT0(rdram, ctx, runtime); return;
}


// Function: entry_1a84e4
// Address: 0x1a84e4 - 0x1a8524

void entry_1a84e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a84e4: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1a84e8: 0x5040001f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 52)));
        ctx->pc = 0x1A8568; return;
    }
    // 0x1a84f0: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1a84f4: 0x5040001c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 52)));
        ctx->pc = 0x1A8568; return;
    }
    // 0x1a84fc: 0x8e23003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x1a8500: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1a8504: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 0));
        ctx->pc = 0x1A8528; return;
    }
    // 0x1a850c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a8510: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1a8514: 0xac620008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 2));
    // 0x1a8518: 0x8e24003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x1a851c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1a8524);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1a8524
// Address: 0x1a8524 - 0x1a8530

void entry_1a8524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8524) {
        switch (ctx->pc) {
            case 0x1a8528: ctx->pc = 0; goto label_1a8528;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8524: 0xae00003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 0));
label_1a8528:
    // 0x1a8528: 0xc06a044
    SET_GPR_U32(ctx, 31, 0x1a8530);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001a8110(rdram, ctx, runtime); return;
}


// Function: entry_1a8530
// Address: 0x1a8530 - 0x1a8560

void entry_1a8530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8530: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1a8534: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a8538: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a853c: 0xac830004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 3));
    // 0x1a8540: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1a8544: 0xac450008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 5));
    // 0x1a8548: 0x8e03003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1a854c: 0xac710014
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 17));
    // 0x1a8550: 0x8e24003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x1a8554: 0x8e05003c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1a8558: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1a8560);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1a8560
// Address: 0x1a8560 - 0x1a8578

void entry_1a8560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8560) {
        switch (ctx->pc) {
            case 0x1a8568: ctx->pc = 0; goto label_1a8568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8560: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8580; return;
    }
label_1a8568:
    // 0x1a8568: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1a856c: 0x8e250038
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 56)));
    // 0x1a8570: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x1a8578);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_1a8578
// Address: 0x1a8578 - 0x1a8590

void entry_1a8578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8578) {
        switch (ctx->pc) {
            case 0x1a8580: ctx->pc = 0; goto label_1a8580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8578: 0xae020038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 2));
    // 0x1a857c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a8580:
    // 0x1a8580: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a8584: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8588: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostRwmLoad__FP3RWM
// Address: 0x1a8590 - 0x1a85a8

void entry_1a85a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a85a8: 0x8e220168
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 360)));
    // 0x1a85ac: 0x1440004d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A86E4; return;
    }
    // 0x1a85b4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a85b8: 0x8e25004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x1a85bc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a85c0: 0x10a20017
    WRITE32(ADD32(GPR_U32(ctx, 17), 360), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A8620; return;
    }
    // 0x1a85c8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1a85cc: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a85d4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a85d4
// Address: 0x1a85d4 - 0x1a85e8

void entry_1a85d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a85d4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a85d8: 0x12000011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8620; return;
    }
    // 0x1a85e0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a85e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a85e8
// Address: 0x1a85e8 - 0x1a8600

void entry_1a85e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a85e8) {
        switch (ctx->pc) {
            case 0x1a85f8: ctx->pc = 0; goto label_1a85f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a85e8: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a85f8;
    }
    // 0x1a85f0: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 17), 96), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8620; return;
    }
label_1a85f8:
    // 0x1a85f8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8600);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 115));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8600
// Address: 0x1a8600 - 0x1a8618

void entry_1a8600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8600) {
        switch (ctx->pc) {
            case 0x1a8610: ctx->pc = 0; goto label_1a8610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8600: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a8610;
    }
    // 0x1a8608: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 17), 100), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8620; return;
    }
label_1a8610:
    // 0x1a8610: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8618);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8618
// Address: 0x1a8618 - 0x1a863c

void entry_1a8618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8618) {
        switch (ctx->pc) {
            case 0x1a8620: ctx->pc = 0; goto label_1a8620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8618: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 104), GPR_U32(ctx, 16));
        goto label_1a8620;
    }
label_1a8620:
    // 0x1a8620: 0x8e250050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1a8624: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a8628: 0x50a20013
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 84)));
        ctx->pc = 0x1A8678; return;
    }
    // 0x1a8630: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1a8634: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a863c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a863c
// Address: 0x1a863c - 0x1a8650

void entry_1a863c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a863c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a8640: 0x1200000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8670; return;
    }
    // 0x1a8648: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8650);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8650
// Address: 0x1a8650 - 0x1a8668

void entry_1a8650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8650) {
        switch (ctx->pc) {
            case 0x1a8660: ctx->pc = 0; goto label_1a8660;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8650: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a8660;
    }
    // 0x1a8658: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 17), 224), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8670; return;
    }
label_1a8660:
    // 0x1a8660: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8668);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 117));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8668
// Address: 0x1a8668 - 0x1a868c

void entry_1a8668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8668) {
        switch (ctx->pc) {
            case 0x1a8670: ctx->pc = 0; goto label_1a8670;
            case 0x1a8678: ctx->pc = 0; goto label_1a8678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8668: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 228), GPR_U32(ctx, 16));
        goto label_1a8670;
    }
label_1a8670:
    // 0x1a8670: 0x8e250054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 84)));
    // 0x1a8674: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1a8678:
    // 0x1a8678: 0x50a20012
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 88)));
        ctx->pc = 0x1A86C4; return;
    }
    // 0x1a8680: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1a8684: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a868c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a868c
// Address: 0x1a868c - 0x1a86a0

void entry_1a868c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a868c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a8690: 0x1200000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A86C0; return;
    }
    // 0x1a8698: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a86a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 115));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a86a0
// Address: 0x1a86a0 - 0x1a86b8

void entry_1a86a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a86a0) {
        switch (ctx->pc) {
            case 0x1a86b0: ctx->pc = 0; goto label_1a86b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a86a0: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a86b0;
    }
    // 0x1a86a8: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 17), 352), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A86C0; return;
    }
label_1a86b0:
    // 0x1a86b0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a86b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a86b8
// Address: 0x1a86b8 - 0x1a86dc

void entry_1a86b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a86b8) {
        switch (ctx->pc) {
            case 0x1a86c0: ctx->pc = 0; goto label_1a86c0;
            case 0x1a86c4: ctx->pc = 0; goto label_1a86c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a86b8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 356), GPR_U32(ctx, 16));
        goto label_1a86c0;
    }
label_1a86c0:
    // 0x1a86c0: 0x8e250058
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 88)));
label_1a86c4:
    // 0x1a86c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1a86c8: 0x10a20006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A86E4; return;
    }
    // 0x1a86d0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1a86d4: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1a86dc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1a86dc
// Address: 0x1a86dc - 0x1a86f8

void entry_1a86dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a86dc) {
        switch (ctx->pc) {
            case 0x1a86e4: ctx->pc = 0; goto label_1a86e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a86dc: 0xae22005c
    WRITE32(ADD32(GPR_U32(ctx, 17), 92), GPR_U32(ctx, 2));
    // 0x1a86e0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1a86e4:
    // 0x1a86e4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a86e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a86ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a86f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a86f8; return;
}


// Function: FUN_001a86f8
// Address: 0x1a86f8 - 0x1a870c

void FUN_001a86f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a86f8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1a86fc: 0x10a00003
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1a870c(rdram, ctx, runtime); return;
    }
    // 0x1a8704: 0xc06a4f2
    SET_GPR_U32(ctx, 31, 0x1a870c);
    FUN_001a93c8(rdram, ctx, runtime); return;
}


// Function: entry_1a870c
// Address: 0x1a870c - 0x1a8718

void entry_1a870c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a870c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8710: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PrwcFindRwm__FP3RWM3OID
// Address: 0x1a8718 - 0x1a8778

void entry_1a8788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8788) {
        switch (ctx->pc) {
            case 0x1a87a0: ctx->pc = 0; goto label_1a87a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8788: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a878c: 0x10600004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a87a0;
    }
    // 0x1a8794: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1a8798: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x1a879c: 0xac620010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
label_1a87a0:
    // 0x1a87a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DisableRwmRwc__FP3RWM3OID
// Address: 0x1a87a8 - 0x1a87b8

void entry_1a87b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a87b8) {
        switch (ctx->pc) {
            case 0x1a87d0: ctx->pc = 0; goto label_1a87d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a87b8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a87bc: 0x10800004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967293));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1a87d0;
    }
    // 0x1a87c4: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1a87c8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1a87cc: 0xac820010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 2));
label_1a87d0:
    // 0x1a87d0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a87d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a87dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a87e0; return;
}


// Function: ResizeRwmRwc__FP3RWM3OIDi
// Address: 0x1a87e0 - 0x1a87f4

void entry_1a87f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a87f4) {
        switch (ctx->pc) {
            case 0x1a8810: ctx->pc = 0; goto label_1a8810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a87f4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a87f8: 0x10800005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1a8810;
    }
    // 0x1a8800: 0x8c83000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1a8804: 0x203102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x1a8808: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x1a880c: 0xac900004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 16));
label_1a8810:
    // 0x1a8810: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8814: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a881c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a8820; return;
}


// Function: FIsRwmAmmo__FP3RWMP2SO
// Address: 0x1a8820 - 0x1a88a0

void entry_1a8974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8974: 0x14400017
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A89D4; return;
    }
    // 0x1a897c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a8980: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8988);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 59));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8988
// Address: 0x1a8988 - 0x1a89bc

void entry_1a8988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8988) {
        switch (ctx->pc) {
            case 0x1a899c: ctx->pc = 0; goto label_1a899c;
            case 0x1a89a4: ctx->pc = 0; goto label_1a89a4;
            case 0x1a89b4: ctx->pc = 0; goto label_1a89b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8988: 0x1040000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a89b4;
    }
    // 0x1a8990: 0x8e020678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1656)));
    // 0x1a8994: 0x14400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a89b4;
    }
label_1a899c:
    // 0x1a899c: 0x1000000d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A89D4; return;
    }
label_1a89a4:
    // 0x1a89a4: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1a89a8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a89ac: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 8), 4294947604), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A89D4; return;
    }
label_1a89b4:
    // 0x1a89b4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a89bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a89bc
// Address: 0x1a89bc - 0x1a89e8

void entry_1a89bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a89bc) {
        switch (ctx->pc) {
            case 0x1a89d4: ctx->pc = 0; goto label_1a89d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a89bc: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a89d4;
    }
    // 0x1a89c4: 0x8e030680
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x1a89c8: 0x14600002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1a89d4;
    }
    // 0x1a89d0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1a89d4:
    // 0x1a89d4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a89d8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a89dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a89e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a89e8; return;
}


// Function: CycleRwmCache__FP3RWM
// Address: 0x1a89e8 - 0x1a8a84

void entry_1a8a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8a84) {
        switch (ctx->pc) {
            case 0x1a8a9c: ctx->pc = 0; goto label_1a8a9c;
            case 0x1a8aa0: ctx->pc = 0; goto label_1a8aa0;
            case 0x1a8ab4: ctx->pc = 0; goto label_1a8ab4;
            case 0x1a8ac4: ctx->pc = 0; goto label_1a8ac4;
            case 0x1a8ad4: ctx->pc = 0; goto label_1a8ad4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8a84: 0x1440000f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a8ac4;
    }
    // 0x1a8a8c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1a8a90: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1a8a94: 0x5440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x1A8A70; return;
    }
label_1a8a9c:
    // 0x1a8a9c: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
label_1a8aa0:
    // 0x1a8aa0: 0x26630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1a8aa4: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1a8aa8: 0x62001a
    { int32_t divisor = GPR_S32(ctx, 2); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 3) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 2) % divisor); } else { ctx->lo = (GPR_S32(ctx,3) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,2); } }
    // 0x1a8aac: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1a8ab4;
    }
label_1a8ab4:
    // 0x1a8ab4: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x1a8ab8: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x1a8abc: 0x1440ffe0
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8A40; return;
    }
label_1a8ac4:
    // 0x1a8ac4: 0x8e420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1a8ac8: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x1a8acc: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 68), GPR_U32(ctx, 19));
        goto label_1a8ad4;
    }
label_1a8ad4:
    // 0x1a8ad4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a8ad8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a8adc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a8ae0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a8ae4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a8ae8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a8aec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8af0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReloadRwm__FP3RWM
// Address: 0x1a8af8 - 0x1a8b40

void entry_1a8b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8b40) {
        switch (ctx->pc) {
            case 0x1a8b44: ctx->pc = 0; goto label_1a8b44;
            case 0x1a8b78: ctx->pc = 0; goto label_1a8b78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8b40: 0x8e230044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 68)));
label_1a8b44:
    // 0x1a8b44: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1a8b48: 0x8e240038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 56)));
    // 0x1a8b4c: 0x621818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1a8b50: 0x838021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1a8b54: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1a8b58: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1a8b5c: 0x5040002d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 60)));
        ctx->pc = 0x1A8C14; return;
    }
    // 0x1a8b64: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1a8b68: 0x18400029
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1A8C10; return;
    }
    // 0x1a8b70: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8b74: 0x0
    // NOP
label_1a8b78:
    // 0x1a8b78: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1a8b7c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a8b80: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1a8b84: 0xc06a228
    SET_GPR_U32(ctx, 31, 0x1a8b8c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1a8b8c
// Address: 0x1a8b8c - 0x1a8bf8

void entry_1a8b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8b8c) {
        switch (ctx->pc) {
            case 0x1a8bc4: ctx->pc = 0; goto label_1a8bc4;
            case 0x1a8bc8: ctx->pc = 0; goto label_1a8bc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8b8c: 0x5040001c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x1A8C00; return;
    }
    // 0x1a8b94: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1a8b98: 0x8e23003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x1a8b9c: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1a8ba0: 0x10600008
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a8bc4;
    }
    // 0x1a8ba8: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1a8bac: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
        goto label_1a8bc8;
    }
    // 0x1a8bb4: 0x8e220044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 68)));
    // 0x1a8bb8: 0x8c63000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1a8bbc: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1a8bc0: 0x62a821
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1a8bc4:
    // 0x1a8bc4: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
label_1a8bc8:
    // 0x1a8bc8: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1a8bcc: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 60)));
        ctx->pc = 0x1A8C14; return;
    }
    // 0x1a8bd4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1a8bd8: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1a8bdc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1a8be0: 0x2442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    // 0x1a8be4: 0x533023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1a8be8: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1a8bec: 0x63080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1a8bf0: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x1a8bf8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_1a8bf8
// Address: 0x1a8bf8 - 0x1a8c50

void entry_1a8bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8bf8) {
        switch (ctx->pc) {
            case 0x1a8c00: ctx->pc = 0; goto label_1a8c00;
            case 0x1a8c10: ctx->pc = 0; goto label_1a8c10;
            case 0x1a8c14: ctx->pc = 0; goto label_1a8c14;
            case 0x1a8c28: ctx->pc = 0; goto label_1a8c28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8bf8: 0x10000006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a8c14;
    }
label_1a8c00:
    // 0x1a8c00: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1a8c04: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1a8c08: 0x1440ffdb
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8B78; return;
    }
label_1a8c10:
    // 0x1a8c10: 0x8e23003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 60)));
label_1a8c14:
    // 0x1a8c14: 0x10600004
    WRITE32(ADD32(GPR_U32(ctx, 17), 72), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a8c28;
    }
    // 0x1a8c1c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1a8c20: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 21));
        goto label_1a8c28;
    }
label_1a8c28:
    // 0x1a8c28: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a8c2c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a8c30: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a8c34: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a8c38: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a8c3c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a8c40: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8c44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a8c4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a8c50; return;
}


// Function: FEnsureRwmLoaded__FP3RWM
// Address: 0x1a8c50 - 0x1a8c74

void entry_1a8c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8c74) {
        switch (ctx->pc) {
            case 0x1a8c7c: ctx->pc = 0; goto label_1a8c7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8c74: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x1a8c78: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1a8c7c:
    // 0x1a8c7c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a8c80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8c84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a8c8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a8c90; return;
}


// Function: FFireRwm__FP3RWMi
// Address: 0x1a8c90 - 0x1a8cd4

void entry_1a8cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8cd4) {
        switch (ctx->pc) {
            case 0x1a8ce8: ctx->pc = 0; goto label_1a8ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8cd4: 0x8e420048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    // 0x1a8cd8: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 192), GPR_U32(ctx, 2));
        goto label_1a8ce8;
    }
    // 0x1a8ce0: 0x100001ae
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A939C; return;
    }
label_1a8ce8:
    // 0x1a8ce8: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1a8cec: 0x8e47005c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x1a8cf0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a8cf4: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a8cf8: 0xc06a530
    SET_GPR_U32(ctx, 31, 0x1a8d00);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 96));
    GetRwfiPosMat__FP4RWFIP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a8d00
// Address: 0x1a8d00 - 0x1a8d18

void entry_1a8d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8d00: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a8d04: 0x8e47005c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x1a8d08: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a8d0c: 0x264400e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 224));
    // 0x1a8d10: 0xc06a574
    SET_GPR_U32(ctx, 31, 0x1a8d18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetRwtiPos__FP4RWTIP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1a8d18
// Address: 0x1a8d18 - 0x1a8e30

void entry_1a8d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8d18) {
        switch (ctx->pc) {
            case 0x1a8d7c: ctx->pc = 0; goto label_1a8d7c;
            case 0x1a8d8c: ctx->pc = 0; goto label_1a8d8c;
            case 0x1a8dd0: ctx->pc = 0; goto label_1a8dd0;
            case 0x1a8de0: ctx->pc = 0; goto label_1a8de0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8d18: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a8d1c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1a8d20: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8d24: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1a8d28: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a8d2c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a8d30: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a8d34: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a8d38: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a8d3c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a8d40: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a8d44: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a8d48: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1a8d4c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a8d50: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a8d54: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a8d58: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a8d5c: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a8d60: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1a8d64: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a8d68: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a8d7c;
    }
    // 0x1a8d70: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a8d74: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a8d8c;
    }
label_1a8d7c:
    // 0x1a8d7c: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1a8d80: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a8d84: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1a8d88: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_1a8d8c:
    // 0x1a8d8c: 0x26420110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 272));
    // 0x1a8d90: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a8d94: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a8d98: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1a8d9c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a8da0: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1a8da4: 0xc6430110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 272)); ctx->f[3] = *(float*)&val; }
    // 0x1a8da8: 0xc6440120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 288)); ctx->f[4] = *(float*)&val; }
    // 0x1a8dac: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1a8db0: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1a8db4: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1a8db8: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a8dbc: 0x0
    // NOP
    // 0x1a8dc0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 292)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a8dd0;
    }
    // 0x1a8dc8: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a8de0;
    }
label_1a8dd0:
    // 0x1a8dd0: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a8dd4: 0x0
    // NOP
    // 0x1a8dd8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1a8de0;
    }
label_1a8de0:
    // 0x1a8de0: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x1a8de4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a8de8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a8dec: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a8df0: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8df4: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1a8df8: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a8dfc: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1a8e00: 0x10600010
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8E44; return;
    }
    // 0x1a8e08: 0x8c630050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1a8e0c: 0x5060000e
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
        ctx->pc = 0x1A8E48; return;
    }
    // 0x1a8e14: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1a8e18: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1a8e1c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1a8e20: 0x10400008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8E44; return;
    }
    // 0x1a8e28: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8e30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 60));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8e30
// Address: 0x1a8e30 - 0x1a8e64

void entry_1a8e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8e30) {
        switch (ctx->pc) {
            case 0x1a8e44: ctx->pc = 0; goto label_1a8e44;
            case 0x1a8e48: ctx->pc = 0; goto label_1a8e48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8e30: 0x10400004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a8e44;
    }
    // 0x1a8e38: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1a8e3c: 0x8c430050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1a8e40: 0xac8306e4
    WRITE32(ADD32(GPR_U32(ctx, 4), 1764), GPR_U32(ctx, 3));
label_1a8e44:
    // 0x1a8e44: 0x8e42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
label_1a8e48:
    // 0x1a8e48: 0x10400010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8E8C; return;
    }
    // 0x1a8e50: 0x8c430224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 548)));
    // 0x1a8e54: 0x54600006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 192)));
        ctx->pc = 0x1A8E70; return;
    }
    // 0x1a8e5c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1a8e64);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1a8e64
// Address: 0x1a8e64 - 0x1a8ea0

void entry_1a8e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8e64) {
        switch (ctx->pc) {
            case 0x1a8e70: ctx->pc = 0; goto label_1a8e70;
            case 0x1a8e8c: ctx->pc = 0; goto label_1a8e8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8e64: 0x8fa300c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8e68: 0xac620224
    WRITE32(ADD32(GPR_U32(ctx, 3), 548), GPR_U32(ctx, 2));
    // 0x1a8e6c: 0x8fa500c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 192)));
label_1a8e70:
    // 0x1a8e70: 0x8ca30224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 548)));
    // 0x1a8e74: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x1a8e78: 0x3442000c
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 12));
    // 0x1a8e7c: 0xac6200b0
    WRITE32(ADD32(GPR_U32(ctx, 3), 176), GPR_U32(ctx, 2));
    // 0x1a8e80: 0x8ca40224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 548)));
    // 0x1a8e84: 0x8e42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x1a8e88: 0xac820060
    WRITE32(ADD32(GPR_U32(ctx, 4), 96), GPR_U32(ctx, 2));
label_1a8e8c:
    // 0x1a8e8c: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8e90: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a8e94: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1a8e98: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a8ea0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a8ea0
// Address: 0x1a8ea0 - 0x1a8eb8

void entry_1a8ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8ea0: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8ea4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8ea8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8eac: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8eb0: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1a8eb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1a8eb8
// Address: 0x1a8eb8 - 0x1a8ecc

void entry_1a8eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8eb8: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8ebc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a8ec0: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1a8ec4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a8ecc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a8ecc
// Address: 0x1a8ecc - 0x1a8ee0

void entry_1a8ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8ecc: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8ed0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a8ed4: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1a8ed8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a8ee0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a8ee0
// Address: 0x1a8ee0 - 0x1a8f38

void entry_1a8ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8ee0) {
        switch (ctx->pc) {
            case 0x1a8f0c: ctx->pc = 0; goto label_1a8f0c;
            case 0x1a8f10: ctx->pc = 0; goto label_1a8f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8ee0: 0x8e43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x1a8ee4: 0x5060000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 104)));
        goto label_1a8f10;
    }
    // 0x1a8eec: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1a8ef0: 0x10400006
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a8f0c;
    }
    // 0x1a8ef8: 0x8c640010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1a8efc: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a8f00: 0x7ca20190
    WRITE128(ADD32(GPR_U32(ctx, 5), 400), GPR_VEC(ctx, 2));
    // 0x1a8f04: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1a8f08: 0x7ca301d0
    WRITE128(ADD32(GPR_U32(ctx, 5), 464), GPR_VEC(ctx, 3));
label_1a8f0c:
    // 0x1a8f0c: 0x8e440068
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 104)));
label_1a8f10:
    // 0x1a8f10: 0x10800015
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 112));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8F68; return;
    }
    // 0x1a8f18: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1a8f1c: 0x24860140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 320));
    // 0x1a8f20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8f24: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a8f28: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a8f2c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a8f30: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1a8f38);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1a8f38
// Address: 0x1a8f38 - 0x1a8f4c

void entry_1a8f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8f38: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8f3c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a8f40: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1a8f44: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a8f4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a8f4c
// Address: 0x1a8f4c - 0x1a8f60

void entry_1a8f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8f4c: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8f50: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a8f54: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1a8f58: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a8f60);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a8f60
// Address: 0x1a8f60 - 0x1a8f80

void entry_1a8f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8f60) {
        switch (ctx->pc) {
            case 0x1a8f68: ctx->pc = 0; goto label_1a8f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8f60: 0x100000c5
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 216)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9278; return;
    }
label_1a8f68:
    // 0x1a8f68: 0x1200007c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 176));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1a915c(rdram, ctx, runtime); return;
    }
    // 0x1a8f70: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8f74: 0x26500150
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 336));
    // 0x1a8f78: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8f80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 62));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8f80
// Address: 0x1a8f80 - 0x1a8f94

void entry_1a8f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a8f80: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 336)));
        ctx->pc = 0x1A8F9C; return;
    }
    // 0x1a8f88: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a8f8c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a8f94);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a8f94
// Address: 0x1a8f94 - 0x1a8fc4

void entry_1a8f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8f94) {
        switch (ctx->pc) {
            case 0x1a8f9c: ctx->pc = 0; goto label_1a8f9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8f94: 0x10400039
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 336)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A907C; return;
    }
label_1a8f9c:
    // 0x1a8f9c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a8fa0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a8fa4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1a8fa8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a8fac: 0x10400007
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8FCC; return;
    }
    // 0x1a8fb4: 0x8e46005c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x1a8fb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a8fbc: 0xc06a5f2
    SET_GPR_U32(ctx, 31, 0x1a8fc4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    GetRwacPan__FP4RWACPf(rdram, ctx, runtime); return;
}


// Function: entry_1a8fc4
// Address: 0x1a8fc4 - 0x1a8fd8

void entry_1a8fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8fc4) {
        switch (ctx->pc) {
            case 0x1a8fcc: ctx->pc = 0; goto label_1a8fcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8fc4: 0x10000006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A8FE0; return;
    }
label_1a8fcc:
    // 0x1a8fcc: 0xc7ac0064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[12] = *(float*)&val; }
    // 0x1a8fd0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a8fd8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a8fd8
// Address: 0x1a8fd8 - 0x1a8ff8

void entry_1a8fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8fd8) {
        switch (ctx->pc) {
            case 0x1a8fe0: ctx->pc = 0; goto label_1a8fe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8fd8: 0xe7a000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x1a8fdc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1a8fe0:
    // 0x1a8fe0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1a8fe4: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9000; return;
    }
    // 0x1a8fec: 0x8e46005c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x1a8ff0: 0xc06a61a
    SET_GPR_U32(ctx, 31, 0x1a8ff8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 180));
    GetRwacTilt__FP4RWACPf(rdram, ctx, runtime); return;
}


// Function: entry_1a8ff8
// Address: 0x1a8ff8 - 0x1a902c

void entry_1a8ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a8ff8) {
        switch (ctx->pc) {
            case 0x1a9000: ctx->pc = 0; goto label_1a9000;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a8ff8: 0x1000000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9034; return;
    }
label_1a9000:
    // 0x1a9000: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a9004: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9008: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a900c: 0xc7ac0068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[12] = *(float*)&val; }
    // 0x1a9010: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9014: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a9018: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a901c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a9020: 0x44836800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 3);
    // 0x1a9024: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a902c);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a902c
// Address: 0x1a902c - 0x1a9060

void entry_1a902c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a902c) {
        switch (ctx->pc) {
            case 0x1a9034: ctx->pc = 0; goto label_1a9034;
            case 0x1a9048: ctx->pc = 0; goto label_1a9048;
            case 0x1a904c: ctx->pc = 0; goto label_1a904c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a902c: 0xe7a000b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
    // 0x1a9030: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1a9034:
    // 0x1a9034: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1a9038: 0x10400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a9048;
    }
    // 0x1a9040: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a904c;
    }
label_1a9048:
    // 0x1a9048: 0xc4540690
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1680)); ctx->f[20] = *(float*)&val; }
label_1a904c:
    // 0x1a904c: 0xc7ac00b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[12] = *(float*)&val; }
    // 0x1a9050: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1a9054: 0xc7ad00b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 180)); ctx->f[13] = *(float*)&val; }
    // 0x1a9058: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1a9060);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 176));
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a9060
// Address: 0x1a9060 - 0x1a90a0

void entry_1a9060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9060) {
        switch (ctx->pc) {
            case 0x1a907c: ctx->pc = 0; goto label_1a907c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9060: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1a9064: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a9068: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a906c: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9070: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a9074: 0x10000039
    WRITE128(ADD32(GPR_U32(ctx, 18), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1a915c(rdram, ctx, runtime); return;
    }
label_1a907c:
    // 0x1a907c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a9080: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9084: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1a9088: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a908c: 0x10400014
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a90e0(rdram, ctx, runtime); return;
    }
    // 0x1a9094: 0xc7ac0064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[12] = *(float*)&val; }
    // 0x1a9098: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a90a0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a90a0
// Address: 0x1a90a0 - 0x1a90b4

void entry_1a90a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a90a0: 0x8e46005c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x1a90a4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1a90a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a90ac: 0xc06a5f2
    SET_GPR_U32(ctx, 31, 0x1a90b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 184));
    GetRwacPan__FP4RWACPf(rdram, ctx, runtime); return;
}


// Function: entry_1a90b4
// Address: 0x1a90b4 - 0x1a90bc

void entry_1a90b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a90b4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1a90bc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1a90bc
// Address: 0x1a90bc - 0x1a90c8

void entry_1a90bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a90bc: 0xc7ac00b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[12] = *(float*)&val; }
    // 0x1a90c0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1a90c8);
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1a90c8
// Address: 0x1a90c8 - 0x1a90e0

void entry_1a90c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a90c8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a90cc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a90d0: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1a90d4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a90d8: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1a90e0);
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1a90e0
// Address: 0x1a90e0 - 0x1a90fc

void entry_1a90e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a90e0: 0x8e430150
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1a90e4: 0x30620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 1));
    // 0x1a90e8: 0x1040000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A911C; return;
    }
    // 0x1a90f0: 0x8e46005c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x1a90f4: 0xc06a61a
    SET_GPR_U32(ctx, 31, 0x1a90fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 188));
    GetRwacTilt__FP4RWACPf(rdram, ctx, runtime); return;
}


// Function: entry_1a90fc
// Address: 0x1a90fc - 0x1a9114

void entry_1a90fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a90fc: 0xc7ac00bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 188)); ctx->f[12] = *(float*)&val; }
    // 0x1a9100: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a9104: 0x8fa700c0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a9108: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a910c: 0xc07b8a4
    SET_GPR_U32(ctx, 31, 0x1a9114);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCalculateMuzzleVelocityAngle__FP6VECTORT0fT0P2SO(rdram, ctx, runtime); return;
}


// Function: entry_1a9114
// Address: 0x1a9114 - 0x1a913c

void entry_1a9114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9114) {
        switch (ctx->pc) {
            case 0x1a911c: ctx->pc = 0; goto label_1a911c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9114: 0x10000012
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9160; return;
    }
label_1a911c:
    // 0x1a911c: 0x30620004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4));
    // 0x1a9120: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9144; return;
    }
    // 0x1a9128: 0xc60c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[12] = *(float*)&val; }
    // 0x1a912c: 0x8fa700c0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a9130: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a9134: 0xc07b824
    SET_GPR_U32(ctx, 31, 0x1a913c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCalculateMuzzleVelocity1(rdram, ctx, runtime); return;
}


// Function: entry_1a913c
// Address: 0x1a913c - 0x1a915c

void entry_1a913c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a913c) {
        switch (ctx->pc) {
            case 0x1a9144: ctx->pc = 0; goto label_1a9144;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a913c: 0x10000008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9160; return;
    }
label_1a9144:
    // 0x1a9144: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1a9148: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1a914c: 0x8fa700c0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a9150: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a9154: 0xc07b7bc
    SET_GPR_U32(ctx, 31, 0x1a915c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCalculateMuzzleVelocity__FP6VECTORT0fT0P2SO(rdram, ctx, runtime); return;
}


// Function: entry_1a915c
// Address: 0x1a915c - 0x1a9170

void entry_1a915c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a915c) {
        switch (ctx->pc) {
            case 0x1a9160: ctx->pc = 0; goto label_1a9160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a915c: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
label_1a9160:
    // 0x1a9160: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a9164: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1a9168: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a9170);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a9170
// Address: 0x1a9170 - 0x1a91a4

void entry_1a9170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9170: 0xc64100d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 212)); ctx->f[1] = *(float*)&val; }
    // 0x1a9174: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1a9178: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a917c: 0x0
    // NOP
    // 0x1a9180: 0x45000038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A9264; return;
    }
    // 0x1a9188: 0xc64c00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 208)); ctx->f[12] = *(float*)&val; }
    // 0x1a918c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1a9190: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1a9194: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a9198: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1a919c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a91a4);
    ctx->f[13] = FPU_MOV_S(ctx->f[1]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a91a4
// Address: 0x1a91a4 - 0x1a91b4

void entry_1a91a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a91a4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a91a8: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x1a91ac: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a91b4);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a91b4
// Address: 0x1a91b4 - 0x1a91c4

void entry_1a91b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a91b4: 0xe7a00060
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x1a91b8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a91bc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a91c4);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a91c4
// Address: 0x1a91c4 - 0x1a91d4

void entry_1a91c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a91c4: 0xe7a00064
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 100), *(uint32_t*)&val); }
    // 0x1a91c8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a91cc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1a91d4);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1a91d4
// Address: 0x1a91d4 - 0x1a925c

void entry_1a91d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a91d4) {
        switch (ctx->pc) {
            case 0x1a9230: ctx->pc = 0; goto label_1a9230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a91d4: 0xe7a00068
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    // 0x1a91d8: 0x26828d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294937856));
    // 0x1a91dc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a91e0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a91e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a91e8: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a91ec: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a91f0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a91f4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a91f8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a91fc: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a9200: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9204: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a9208: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a920c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a9210: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1a9214: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a9218: 0x0
    // NOP
    // 0x1a921c: 0x45010004
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1a9230;
    }
    // 0x1a9224: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a9228: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a922c: 0x4be0189c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1a9230:
    // 0x1a9230: 0x4402b000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[22]);
    // 0x1a9234: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1a9238: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1a923c: 0x8fa600c0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a9240: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a9244: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a9248: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1a924c: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1a9250: 0x8c430094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 148)));
    // 0x1a9254: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1a925c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1a925c
// Address: 0x1a925c - 0x1a9274

void entry_1a925c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a925c) {
        switch (ctx->pc) {
            case 0x1a9264: ctx->pc = 0; goto label_1a9264;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a925c: 0x10000006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 216)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9278; return;
    }
label_1a9264:
    // 0x1a9264: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a9268: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1a926c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a9274);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 192));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a9274
// Address: 0x1a9274 - 0x1a9294

void entry_1a9274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9274) {
        switch (ctx->pc) {
            case 0x1a9278: ctx->pc = 0; goto label_1a9278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9274: 0xc64100d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 216)); ctx->f[1] = *(float*)&val; }
label_1a9278:
    // 0x1a9278: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1a927c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a9280: 0x0
    // NOP
    // 0x1a9284: 0x4500000a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1A92B0; return;
    }
    // 0x1a928c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a9294);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 59));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a9294
// Address: 0x1a9294 - 0x1a92bc

void entry_1a9294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9294) {
        switch (ctx->pc) {
            case 0x1a92b0: ctx->pc = 0; goto label_1a92b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9294: 0x10400006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a92b0;
    }
    // 0x1a929c: 0xc64100d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 216)); ctx->f[1] = *(float*)&val; }
    // 0x1a92a0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1a92a4: 0x8fa300c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a92a8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1a92ac: 0xe4600554
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 1364), *(uint32_t*)&val); }
label_1a92b0:
    // 0x1a92b0: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a92b4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a92bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 60));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a92bc
// Address: 0x1a92bc - 0x1a92fc

void entry_1a92bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a92bc) {
        switch (ctx->pc) {
            case 0x1a92e8: ctx->pc = 0; goto label_1a92e8;
            case 0x1a92ec: ctx->pc = 0; goto label_1a92ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a92bc: 0x1040001f
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A933C; return;
    }
    // 0x1a92c4: 0x8e430100
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 256)));
    // 0x1a92c8: 0x4600007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_1a92e8;
    }
    // 0x1a92d0: 0x14400006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a92ec;
    }
    // 0x1a92d8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1a92dc: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 224)));
        ctx->pc = 0x1A9304; return;
    }
    // 0x1a92e4: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
label_1a92e8:
    // 0x1a92e8: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1a92ec:
    // 0x1a92ec: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a92f0: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x1a92f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a92fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a92fc
// Address: 0x1a92fc - 0x1a9338

void entry_1a92fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a92fc) {
        switch (ctx->pc) {
            case 0x1a9304: ctx->pc = 0; goto label_1a9304;
            case 0x1a9320: ctx->pc = 0; goto label_1a9320;
            case 0x1a9324: ctx->pc = 0; goto label_1a9324;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a92fc: 0x1000000f
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A933C; return;
    }
label_1a9304:
    // 0x1a9304: 0x14a00007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 240));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1a9324;
    }
    // 0x1a930c: 0x8e4600e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 228)));
    // 0x1a9310: 0x54c00003
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 24)));
        goto label_1a9320;
    }
    // 0x1a9318: 0x10000002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 240));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a9324;
    }
label_1a9320:
    // 0x1a9320: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
label_1a9324:
    // 0x1a9324: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a9328: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a932c: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x1a9330: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a9338);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a9338
// Address: 0x1a9338 - 0x1a9344

void entry_1a9338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9338) {
        switch (ctx->pc) {
            case 0x1a933c: ctx->pc = 0; goto label_1a933c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9338: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
label_1a933c:
    // 0x1a933c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a9344);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a9344
// Address: 0x1a9344 - 0x1a9358

void entry_1a9344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9344: 0x1040000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9374; return;
    }
    // 0x1a934c: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a9350: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1a9358);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1a9358
// Address: 0x1a9358 - 0x1a9364

void entry_1a9358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9358: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a935c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1a9364);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1a9364
// Address: 0x1a9364 - 0x1a9390

void entry_1a9364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9364) {
        switch (ctx->pc) {
            case 0x1a9374: ctx->pc = 0; goto label_1a9374;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9364: 0x10400003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a9374;
    }
    // 0x1a936c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a9370: 0xac620c3c
    WRITE32(ADD32(GPR_U32(ctx, 3), 3132), GPR_U32(ctx, 2));
label_1a9374:
    // 0x1a9374: 0x27a200c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1a9378: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a937c: 0xafa200c4
    WRITE32(ADD32(GPR_U32(ctx, 29), 196), GPR_U32(ctx, 2));
    // 0x1a9380: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1a9384: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a9388: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1a9390);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 196));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1a9390
// Address: 0x1a9390 - 0x1a9398

void entry_1a9390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9390: 0xc06a4f2
    SET_GPR_U32(ctx, 31, 0x1a9398);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_001a93c8(rdram, ctx, runtime); return;
}


// Function: entry_1a9398
// Address: 0x1a9398 - 0x1a93c8

void entry_1a9398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9398) {
        switch (ctx->pc) {
            case 0x1a939c: ctx->pc = 0; goto label_1a939c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9398: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1a939c:
    // 0x1a939c: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1a93a0: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1a93a4: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1a93a8: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1a93ac: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1a93b0: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1a93b4: 0xc7b60140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[22] = *(float*)&val; }
    // 0x1a93b8: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1a93bc: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1a93c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001a93c8
// Address: 0x1a93c8 - 0x1a93e8

void FUN_001a93c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a93c8) {
        switch (ctx->pc) {
            case 0x1a93e0: ctx->pc = 0; goto label_1a93e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a93c8: 0x8c83003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 60)));
    // 0x1a93cc: 0x10600004
    WRITE32(ADD32(GPR_U32(ctx, 4), 72), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1a93e0;
    }
    // 0x1a93d4: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1a93d8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 0));
        goto label_1a93e0;
    }
label_1a93e0:
    // 0x1a93e0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearRwmFireInfo__FP3RWM
// Address: 0x1a93e8 - 0x1a9408

void entry_1a9408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9408: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1a940c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a9410: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x1a9414: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a9418: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
    // 0x1a941c: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1a9420: 0x7e030030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    // 0x1a9424: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1a9428: 0x7e020040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 2));
    // 0x1a942c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9430: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearRwmTargetInfo__FP3RWM
// Address: 0x1a9438 - 0x1a9458

void entry_1a9458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9458: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a945c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a9460: 0x26020110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1a9464: 0xae000110
    WRITE32(ADD32(GPR_U32(ctx, 16), 272), GPR_U32(ctx, 0));
    // 0x1a9468: 0x3c01469c
    SET_GPR_U32(ctx, 1, ((uint32_t)18076 << 16));
    // 0x1a946c: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1a9470: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1a9474: 0xe4410004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x1a9478: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x1a947c: 0xe6000124
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 292), *(uint32_t*)&val); }
    // 0x1a9480: 0xae000120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 0));
    // 0x1a9484: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a9488: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a948c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a9494: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a9498; return;
}


// Function: ClearRwmAimConstraints__FP3RWM
// Address: 0x1a9498 - 0x1a94b0

void entry_1a94b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a94b0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a94b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a94bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a94c0; return;
}


// Function: GetRwfiPosMat__FP4RWFIP6VECTORP7MATRIX3
// Address: 0x1a94c0 - 0x1a94f8

void entry_1a94f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a94f8) {
        switch (ctx->pc) {
            case 0x1a9514: ctx->pc = 0; goto label_1a9514;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a94f8: 0x7a020020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1a94fc: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x1a9500: 0x7a030030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1a9504: 0x7e230010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), GPR_VEC(ctx, 3));
    // 0x1a9508: 0x7a020040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1a950c: 0x1000001e
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9588; return;
    }
label_1a9514:
    // 0x1a9514: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1a9518: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x1A953C; return;
    }
    // 0x1a9520: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1a9528);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a9528
// Address: 0x1a9528 - 0x1a9534

void entry_1a9528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9528: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1a952c: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x1a9534);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1a9534
// Address: 0x1a9534 - 0x1a95a0

void entry_1a9534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9534) {
        switch (ctx->pc) {
            case 0x1a953c: ctx->pc = 0; goto label_1a953c;
            case 0x1a956c: ctx->pc = 0; goto label_1a956c;
            case 0x1a9588: ctx->pc = 0; goto label_1a9588;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9534: 0x10000014
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a9588;
    }
label_1a953c:
    // 0x1a953c: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
        goto label_1a956c;
    }
    // 0x1a9544: 0x78420140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1a9548: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x1a954c: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1a9550: 0x78820110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 272)));
    // 0x1a9554: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x1a9558: 0x78830120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 288)));
    // 0x1a955c: 0x7e230010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), GPR_VEC(ctx, 3));
    // 0x1a9560: 0x78820130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 304)));
    // 0x1a9564: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a9588;
    }
label_1a956c:
    // 0x1a956c: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x1a9570: 0x7a030020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1a9574: 0x7e230000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 3));
    // 0x1a9578: 0x7a020030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1a957c: 0x7e220010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), GPR_VEC(ctx, 2));
    // 0x1a9580: 0x7a030040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1a9584: 0x7e230020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 3));
label_1a9588:
    // 0x1a9588: 0x1260000a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        entry_1a95b4(rdram, ctx, runtime); return;
    }
    // 0x1a9590: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a9594: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1a9598: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1a95a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1a95a0
// Address: 0x1a95a0 - 0x1a95b4

void entry_1a95a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a95a0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a95a4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a95a8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a95ac: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1a95b4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1a95b4
// Address: 0x1a95b4 - 0x1a95d0

void entry_1a95b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a95b4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a95b8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a95bc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a95c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a95c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a95c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetRwtiPos__FP4RWTIP6VECTORT1
// Address: 0x1a95d0 - 0x1a9644

void entry_1a9644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9644) {
        switch (ctx->pc) {
            case 0x1a964c: ctx->pc = 0; goto label_1a964c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9644: 0x10000056
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A97A0; return;
    }
label_1a964c:
    // 0x1a964c: 0x4400053
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 3));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1A979C; return;
    }
    // 0x1a9654: 0x10400051
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A979C; return;
    }
    // 0x1a965c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a9660: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1a9664: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1a966c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1a966c
// Address: 0x1a966c - 0x1a970c

void entry_1a966c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a966c) {
        switch (ctx->pc) {
            case 0x1a96d8: ctx->pc = 0; goto label_1a96d8;
            case 0x1a96ec: ctx->pc = 0; goto label_1a96ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a966c: 0xdaa20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1a9670: 0x26020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1a9674: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9678: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a967c: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1a9680: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9684: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a9688: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a968c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a9690: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1a9694: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9698: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a969c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a96a0: 0xc6030050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[3] = *(float*)&val; }
    // 0x1a96a4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a96a8: 0xc6040060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 96)); ctx->f[4] = *(float*)&val; }
    // 0x1a96ac: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1a96b0: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1a96b4: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1a96b8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1a96bc: 0x46001b00
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1a96c0: 0x46046034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a96c4: 0x0
    // NOP
    // 0x1a96c8: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 100)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a96d8;
    }
    // 0x1a96d0: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a96ec;
    }
label_1a96d8:
    // 0x1a96d8: 0x460c2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a96dc: 0x0
    // NOP
    // 0x1a96e0: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a96ec;
    }
    // 0x1a96e8: 0x46002d06
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
label_1a96ec:
    // 0x1a96ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1a96f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a96f4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a96f8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a96fc: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1a9700: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a9704: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1a970c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1a970c
// Address: 0x1a970c - 0x1a9758

void entry_1a970c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a970c: 0xda430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1a9710: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a9714: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a9718: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a971c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9720: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1a9724: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a9728: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a972c: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a9730: 0x1260001a
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A979C; return;
    }
    // 0x1a9738: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1a973c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1a9740: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a9744: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1a9748: 0x27a70050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1a974c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a9750: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1a9758);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1a9758
// Address: 0x1a9758 - 0x1a97c8

void entry_1a9758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9758) {
        switch (ctx->pc) {
            case 0x1a979c: ctx->pc = 0; goto label_1a979c;
            case 0x1a97a0: ctx->pc = 0; goto label_1a97a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9758: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a975c: 0xda830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1a9760: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a9764: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a9768: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a976c: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a9770: 0x4be3222a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1a9774: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1a9778: 0x4be311ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1a977c: 0x4be309aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9780: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1a9784: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a9788: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1a978c: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a9790: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1a9794: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a9798: 0xfa850000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[5]));
label_1a979c:
    // 0x1a979c: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1a97a0:
    // 0x1a97a0: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1a97a4: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1a97a8: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1a97ac: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1a97b0: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a97b4: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a97b8: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1a97bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a97c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a97c8; return;
}


// Function: GetRwacPan__FP4RWACPf
// Address: 0x1a97c8 - 0x1a97f4

void entry_1a97f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a97f4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a97f8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a97fc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a9800: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1a9808);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1a9808
// Address: 0x1a9808 - 0x1a9814

void entry_1a9808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9808: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1a980c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a9814);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a9814
// Address: 0x1a9814 - 0x1a9838

void entry_1a9814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9814) {
        switch (ctx->pc) {
            case 0x1a981c: ctx->pc = 0; goto label_1a981c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9814: 0x1000000f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9854; return;
    }
label_1a981c:
    // 0x1a981c: 0x8c860014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x1a9820: 0x10c0000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A984C; return;
    }
    // 0x1a9828: 0x24c60110
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 272));
    // 0x1a982c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1a9830: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1a9838);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1a9838
// Address: 0x1a9838 - 0x1a9844

void entry_1a9838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9838: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1a983c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a9844);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a9844
// Address: 0x1a9844 - 0x1a9868

void entry_1a9844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9844) {
        switch (ctx->pc) {
            case 0x1a984c: ctx->pc = 0; goto label_1a984c;
            case 0x1a9854: ctx->pc = 0; goto label_1a9854;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9844: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a9854;
    }
label_1a984c:
    // 0x1a984c: 0xc4800008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1a9850: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_1a9854:
    // 0x1a9854: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a9858: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a985c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a9860: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetRwacTilt__FP4RWACPf
// Address: 0x1a9868 - 0x1a9894

void entry_1a9894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9894: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a9898: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1a989c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a98a0: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1a98a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1a98a8
// Address: 0x1a98a8 - 0x1a98d4

void entry_1a98a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a98a8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a98ac: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a98b0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a98b4: 0xc7ac0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1a98b8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a98bc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a98c0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a98c4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a98c8: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1a98cc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1a98d4);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1a98d4
// Address: 0x1a98d4 - 0x1a98f8

void entry_1a98d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a98d4) {
        switch (ctx->pc) {
            case 0x1a98dc: ctx->pc = 0; goto label_1a98dc;
            case 0x1a98e4: ctx->pc = 0; goto label_1a98e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a98d4: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a98e4;
    }
label_1a98dc:
    // 0x1a98dc: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1a98e0: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_1a98e4:
    // 0x1a98e4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a98e8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a98ec: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a98f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSbgLoad__FP3SBG
// Address: 0x1a98f8 - 0x1a990c

void entry_1a990c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a990c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1a9910: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x1a9918);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_1a9918
// Address: 0x1a9918 - 0x1a9928

void entry_1a9918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9918: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a991c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9920: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001a9928__FP3SBG
// Address: 0x1a9928 - 0x1a9940

void FUN_001a9928__FP3SBG(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9928: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1a992c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1a9930: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1a9934: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1a9938: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x1a9940);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1a9940
// Address: 0x1a9940 - 0x1a9960

void entry_1a9940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9940) {
        switch (ctx->pc) {
            case 0x1a994c: ctx->pc = 0; goto label_1a994c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9940: 0x14400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1a994c;
    }
    // 0x1a9948: 0x8e020c24
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3108)));
label_1a994c:
    // 0x1a994c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a9950: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9954: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a995c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a9960; return;
}


// Function: UpdateSbgGoal__FP3SBGi
// Address: 0x1a9960 - 0x1a9974

void entry_1a9974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9974: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1a9978: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1a997c: 0x1462000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A99A8; return;
    }
    // 0x1a9984: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1a9988: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1a998c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a9994);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a9994
// Address: 0x1a9994 - 0x1a99a4

void entry_1a9994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9994: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a99a4(rdram, ctx, runtime); return;
    }
    // 0x1a999c: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1a99a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1a99a4
// Address: 0x1a99a4 - 0x1a99b8

void entry_1a99a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a99a4) {
        switch (ctx->pc) {
            case 0x1a99a8: ctx->pc = 0; goto label_1a99a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a99a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a99a8:
    // 0x1a99a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a99ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a99b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a99b8; return;
}


// Function: UpdateSbgSgs__FP3SBG
// Address: 0x1a99b8 - 0x1a99cc

void entry_1a99cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a99cc: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1a99d0: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1a99d4: 0x14620004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A99E8; return;
    }
    // 0x1a99dc: 0xc0722f0
    SET_GPR_U32(ctx, 31, 0x1a99e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LookStepguardAtGoal__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1a99e4
// Address: 0x1a99e4 - 0x1a99f8

void entry_1a99e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a99e4) {
        switch (ctx->pc) {
            case 0x1a99e8: ctx->pc = 0; goto label_1a99e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a99e4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a99e8:
    // 0x1a99e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a99ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a99f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a99f8; return;
}


// Function: OnSbgEnteringSgs__FP3SBG3SGSP4ASEG
// Address: 0x1a99f8 - 0x1a9a0c

void entry_1a9a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9a0c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1a9a10: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1a9a14: 0x14620007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1A9A34; return;
    }
    // 0x1a9a1c: 0xc0580fa
    SET_GPR_U32(ctx, 31, 0x1a9a24);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    DefeatBossFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1a9a24
// Address: 0x1a9a24 - 0x1a9a30

void entry_1a9a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9a24: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1a9a28: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x1a9a30);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_1a9a30
// Address: 0x1a9a30 - 0x1a9a40

void entry_1a9a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9a30) {
        switch (ctx->pc) {
            case 0x1a9a34: ctx->pc = 0; goto label_1a9a34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9a30: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a9a34:
    // 0x1a9a34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9a38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSbg__FP3SBGf
// Address: 0x1a9a40 - 0x1a9a54

void entry_1a9a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9a54: 0x8e040c20
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
    // 0x1a9a58: 0x1080000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9A88; return;
    }
    // 0x1a9a60: 0xc4810018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1a9a64: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1a9a68: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a9a6c: 0x0
    // NOP
    // 0x1a9a70: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x1A9A8C; return;
    }
    // 0x1a9a78: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1a9a80);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1a9a80
// Address: 0x1a9a80 - 0x1a9a98

void entry_1a9a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9a80) {
        switch (ctx->pc) {
            case 0x1a9a88: ctx->pc = 0; goto label_1a9a88;
            case 0x1a9a8c: ctx->pc = 0; goto label_1a9a8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9a80: 0xae000c20
    WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 0));
    // 0x1a9a84: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1a9a88:
    // 0x1a9a88: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a9a8c:
    // 0x1a9a8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a9a94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a9a98; return;
}


// Function: FUN_001a9a98
// Address: 0x1a9a98 - 0x1a9aa8

void FUN_001a9a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9a98: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1a9a9c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1a9aa0: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1a9aa8);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1a9aa8
// Address: 0x1a9aa8 - 0x1a9ac0

void entry_1a9aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9aa8: 0x10400007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9AC8; return;
    }
    // 0x1a9ab0: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x1a9ab4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1a9ab8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a9ac0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a9ac0
// Address: 0x1a9ac0 - 0x1a9ad8

void entry_1a9ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9ac0) {
        switch (ctx->pc) {
            case 0x1a9ac8: ctx->pc = 0; goto label_1a9ac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9ac0: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1A9ADC; return;
    }
label_1a9ac8:
    // 0x1a9ac8: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x1a9acc: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1a9ad0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a9ad8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a9ad8
// Address: 0x1a9ad8 - 0x1a9ae8

void entry_1a9ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9ad8) {
        switch (ctx->pc) {
            case 0x1a9adc: ctx->pc = 0; goto label_1a9adc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9ad8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1a9adc:
    // 0x1a9adc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a9ae4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a9ae8; return;
}


// Function: FAbsorbSbgWkr__FP3SBGP3WKR
// Address: 0x1a9ae8 - 0x1a9b2c

void entry_1a9b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9b2c) {
        switch (ctx->pc) {
            case 0x1a9b94: ctx->pc = 0; goto label_1a9b94;
            case 0x1a9ba0: ctx->pc = 0; goto label_1a9ba0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9b2c: 0x8e020b00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2816)));
    // 0x1a9b30: 0x10400021
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1a9bb8(rdram, ctx, runtime); return;
    }
    // 0x1a9b38: 0xda230030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x1a9b3c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1a9b40: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1a9b44: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9b48: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1a9b4c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1a9b50: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1a9b54: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1a9b58: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1a9b5c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a9b60: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1a9b64: 0x7a240020
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1a9b68: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a9b6c: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1a9b70: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1a9b74: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1a9b78: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1a9b7c: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1a9b80: 0x7fa40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 4));
    // 0x1a9b84: 0x45000003
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1a9b94;
    }
    // 0x1a9b8c: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a9ba0;
    }
label_1a9b94:
    // 0x1a9b94: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1a9b98: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1a9b9c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1a9ba0:
    // 0x1a9ba0: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1a9ba4: 0x8e040b00
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2816)));
    // 0x1a9ba8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1a9bac: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1a9bb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1a9bb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1a9bb8
// Address: 0x1a9bb8 - 0x1a9c28

void entry_1a9bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9bb8) {
        switch (ctx->pc) {
            case 0x1a9bf4: ctx->pc = 0; goto label_1a9bf4;
            case 0x1a9c08: ctx->pc = 0; goto label_1a9c08;
            case 0x1a9c0c: ctx->pc = 0; goto label_1a9c0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9bb8: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1a9bbc: 0x30620002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 2));
    // 0x1a9bc0: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1a9bf4;
    }
    // 0x1a9bc8: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1a9bcc: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3092)));
        goto label_1a9c0c;
    }
    // 0x1a9bd4: 0x8c43223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8764)));
    // 0x1a9bd8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1a9bdc: 0x1062000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1a9c08;
    }
    // 0x1a9be4: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3092)));
        goto label_1a9c0c;
    }
    // 0x1a9bec: 0x10000007
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3096)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a9c0c;
    }
label_1a9bf4:
    // 0x1a9bf4: 0x30620004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4));
    // 0x1a9bf8: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3092)));
        goto label_1a9c0c;
    }
    // 0x1a9c00: 0x10000002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3100)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1a9c0c;
    }
label_1a9c08:
    // 0x1a9c08: 0x8e040c14
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3092)));
label_1a9c0c:
    // 0x1a9c0c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1a9c10: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a9c14: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1a9c18: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1a9c1c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1a9c20: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1a9c28);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 3104));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1a9c28
// Address: 0x1a9c28 - 0x1a9c44

void entry_1a9c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1a9c28) {
        switch (ctx->pc) {
            case 0x1a9c38: ctx->pc = 0; goto label_1a9c38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1a9c28: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1a9c2c: 0x2403ffdf
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967263));
    // 0x1a9c30: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1a9c34: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
label_1a9c38:
    // 0x1a9c38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1a9c3c: 0xc0725b6
    SET_GPR_U32(ctx, 31, 0x1a9c44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FAbsorbStepguardWkr__FP9STEPGUARDP3WKR(rdram, ctx, runtime); return;
}


// Function: entry_1a9c44
// Address: 0x1a9c44 - 0x1a9c58

void entry_1a9c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9c44: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a9c48: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a9c4c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a9c50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001a9c58
// Address: 0x1a9c58 - 0x1a9c68

void FUN_001a9c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9c58: 0xac870c1c
    WRITE32(ADD32(GPR_U32(ctx, 4), 3100), GPR_U32(ctx, 7));
    // 0x1a9c5c: 0xac850c14
    WRITE32(ADD32(GPR_U32(ctx, 4), 3092), GPR_U32(ctx, 5));
    // 0x1a9c60: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 3096), GPR_U32(ctx, 6));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartupScreen__Fv
// Address: 0x1a9c68 - 0x1a9f30

void entry_1a9f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9f30: 0x603fff9
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 30), 0)));
        ctx->pc = 0x1A9F18; return;
    }
    // 0x1a9f38: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1a9f3c: 0xc07bf3a
    SET_GPR_U32(ctx, 31, 0x1a9f44);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    InitWipe__FP4WIPE(rdram, ctx, runtime); return;
}


// Function: entry_1a9f44
// Address: 0x1a9f44 - 0x1a9f78

void entry_1a9f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9f44: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1a9f48: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1a9f4c: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1a9f50: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1a9f54: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1a9f58: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1a9f5c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1a9f60: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a9f64: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a9f68: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9f6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1a9f74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1a9f78; return;
}


// Function: PostBlotsLoad__Fv
// Address: 0x1a9f78 - 0x1a9fb4

void entry_1a9fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1a9fb4: 0x623fffa
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1A9FA0; return;
    }
    // 0x1a9fbc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1a9fc0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1a9fc4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1a9fc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateBlots__Fv
// Address: 0x1a9fd0 - 0x1aa00c

void entry_1aa00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa00c) {
        switch (ctx->pc) {
            case 0x1aa038: ctx->pc = 0; goto label_1aa038;
            case 0x1aa040: ctx->pc = 0; goto label_1aa040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa00c: 0x623fffa
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1A9FF8; return;
    }
    // 0x1aa014: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1aa018: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1aa01c: 0x8c432c68
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11368)));
    // 0x1aa020: 0x30630004
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4));
    // 0x1aa024: 0x10600004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1aa038;
    }
    // 0x1aa02c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1aa030: 0x10000003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aa040;
    }
label_1aa038:
    // 0x1aa038: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1aa03c: 0x24452d38
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11576));
label_1aa040:
    // 0x1aa040: 0xc07bf44
    SET_GPR_U32(ctx, 31, 0x1aa048);
    UpdateWipe__FP4WIPEP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1aa048
// Address: 0x1aa048 - 0x1aa060

void entry_1aa048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa048: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aa04c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aa050: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa054: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa05c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa060; return;
}


// Function: ForceHideBlots__Fv
// Address: 0x1aa060 - 0x1aa0a0

void entry_1aa0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa0a0: 0x623fff9
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1AA088; return;
    }
    // 0x1aa0a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aa0ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aa0b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa0b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa0bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa0c0; return;
}


// Function: ResetBlots__Fv
// Address: 0x1aa0c0 - 0x1aa0f4

void entry_1aa0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa0f4: 0x623fffa
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1AA0E0; return;
    }
    // 0x1aa0fc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aa100: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aa104: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa108: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderBlots__Fv
// Address: 0x1aa110 - 0x1aa158

void entry_1aa158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa158: 0x623fff5
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1AA130; return;
    }
    // 0x1aa160: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aa164: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aa168: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa16c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa174: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa178; return;
}


// Function: DrawBlots__Fv
// Address: 0x1aa178 - 0x1aa1b8

void entry_1aa1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa1b8: 0x601fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x1AA198; return;
    }
    // 0x1aa1c0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1aa1c4: 0xc07bfb8
    SET_GPR_U32(ctx, 31, 0x1aa1cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    DrawWipe__FP4WIPE(rdram, ctx, runtime); return;
}


// Function: entry_1aa1cc
// Address: 0x1aa1cc - 0x1aa1d8

void entry_1aa1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa1cc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1aa1d0: 0xc06ba08
    SET_GPR_U32(ctx, 31, 0x1aa1d8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16048));
    FUN_001ae820(rdram, ctx, runtime); return;
}


// Function: entry_1aa1d8
// Address: 0x1aa1d8 - 0x1aa1f0

void entry_1aa1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa1d8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aa1dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aa1e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa1e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa1ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa1f0; return;
}


// Function: InitBlot__FP4BLOT5BLOTK
// Address: 0x1aa1f0 - 0x1aa244

void entry_1aa244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa244: 0xc600022c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 556)); ctx->f[0] = *(float*)&val; }
    // 0x1aa248: 0xc6010230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 560)); ctx->f[1] = *(float*)&val; }
    // 0x1aa24c: 0xe600021c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 540), *(uint32_t*)&val); }
    // 0x1aa250: 0xe6010220
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 544), *(uint32_t*)&val); }
    // 0x1aa254: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aa258: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa25c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa264: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa268; return;
}


// Function: PostBlotLoad__FP4BLOT
// Address: 0x1aa268 - 0x1aa298

void entry_1aa304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa304) {
        switch (ctx->pc) {
            case 0x1aa33c: ctx->pc = 0; goto label_1aa33c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa304: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1aa308: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1aa30c: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa310: 0x0
    // NOP
    // 0x1aa314: 0x45030050
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 592)));
        ctx->pc = 0x1AA458; return;
    }
    // 0x1aa31c: 0xc6000254
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 596)); ctx->f[0] = *(float*)&val; }
    // 0x1aa320: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1aa324: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa328: 0x0
    // NOP
    // 0x1aa32c: 0x45030049
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x1AA454; return;
    }
    // 0x1aa334: 0x10000048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AA458; return;
    }
label_1aa33c:
    // 0x1aa33c: 0x8c62002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 44)));
    // 0x1aa340: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1aa348);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1aa348
// Address: 0x1aa348 - 0x1aa3d4

void entry_1aa348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa348) {
        switch (ctx->pc) {
            case 0x1aa390: ctx->pc = 0; goto label_1aa390;
            case 0x1aa3a0: ctx->pc = 0; goto label_1aa3a0;
            case 0x1aa3a8: ctx->pc = 0; goto label_1aa3a8;
            case 0x1aa3c8: ctx->pc = 0; goto label_1aa3c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa348: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1aa34c: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x1aa350: 0x46021832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa354: 0x0
    // NOP
    // 0x1aa358: 0x45030013
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 572)); ctx->f[1] = *(float*)&val; }
        goto label_1aa3a8;
    }
    // 0x1aa360: 0xc6000254
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 596)); ctx->f[0] = *(float*)&val; }
    // 0x1aa364: 0xc601024c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 588)); ctx->f[1] = *(float*)&val; }
    // 0x1aa368: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1aa36c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1aa370: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1aa374: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1aa378: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1aa37c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa380: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1aa390;
    }
    // 0x1aa388: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aa3a0;
    }
label_1aa390:
    // 0x1aa390: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa394: 0x0
    // NOP
    // 0x1aa398: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[4]);
        goto label_1aa3a0;
    }
label_1aa3a0:
    // 0x1aa3a0: 0xe600023c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 572), *(uint32_t*)&val); }
    // 0x1aa3a4: 0xc601023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 572)); ctx->f[1] = *(float*)&val; }
label_1aa3a8:
    // 0x1aa3a8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1aa3ac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1aa3b0: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa3b4: 0x0
    // NOP
    // 0x1aa3b8: 0x45030026
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
        ctx->pc = 0x1AA454; return;
    }
    // 0x1aa3c0: 0x10000025
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AA458; return;
    }
label_1aa3c8:
    // 0x1aa3c8: 0x8c620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1aa3cc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1aa3d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1aa3d4
// Address: 0x1aa3d4 - 0x1aa4c0

void entry_1aa3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa3d4) {
        switch (ctx->pc) {
            case 0x1aa42c: ctx->pc = 0; goto label_1aa42c;
            case 0x1aa440: ctx->pc = 0; goto label_1aa440;
            case 0x1aa454: ctx->pc = 0; goto label_1aa454;
            case 0x1aa458: ctx->pc = 0; goto label_1aa458;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa3d4: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1aa3d8: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x1aa3dc: 0x46021832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa3e0: 0x0
    // NOP
    // 0x1aa3e4: 0x45030016
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 572)); ctx->f[1] = *(float*)&val; }
        goto label_1aa440;
    }
    // 0x1aa3ec: 0xc6000254
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 596)); ctx->f[0] = *(float*)&val; }
    // 0x1aa3f0: 0xc601024c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 588)); ctx->f[1] = *(float*)&val; }
    // 0x1aa3f4: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1aa3f8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1aa3fc: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1aa400: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1aa404: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1aa408: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa40c: 0x0
    // NOP
    // 0x1aa410: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1aa42c;
    }
    // 0x1aa418: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa41c: 0x0
    // NOP
    // 0x1aa420: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1aa42c;
    }
    // 0x1aa428: 0x46002046
    ctx->f[1] = FPU_MOV_S(ctx->f[4]);
label_1aa42c:
    // 0x1aa42c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1aa430: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1aa434: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1aa438: 0xe600023c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 572), *(uint32_t*)&val); }
    // 0x1aa43c: 0xc601023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 572)); ctx->f[1] = *(float*)&val; }
label_1aa440:
    // 0x1aa440: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1aa444: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aa448: 0x0
    // NOP
    // 0x1aa44c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1aa454;
    }
label_1aa454:
    // 0x1aa454: 0x8e020250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 592)));
label_1aa458:
    // 0x1aa458: 0x5622001a
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1AA4C4; return;
    }
    // 0x1aa460: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1aa464: 0xc607023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 572)); ctx->f[7] = *(float*)&val; }
    // 0x1aa468: 0x244343a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 17312));
    // 0x1aa46c: 0xc44543a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 17312)); ctx->f[5] = *(float*)&val; }
    // 0x1aa470: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1aa474: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1aa478: 0xc4630004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1aa47c: 0x46013842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x1aa480: 0xc6040230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 560)); ctx->f[4] = *(float*)&val; }
    // 0x1aa484: 0xc6000228
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 552)); ctx->f[0] = *(float*)&val; }
    // 0x1aa488: 0xc606022c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 556)); ctx->f[6] = *(float*)&val; }
    // 0x1aa48c: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1aa490: 0xc6020224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 548)); ctx->f[2] = *(float*)&val; }
    // 0x1aa494: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1aa498: 0x46061081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[6]);
    // 0x1aa49c: 0x460339c2
    ctx->f[7] = FPU_MUL_S(ctx->f[7], ctx->f[3]);
    // 0x1aa4a0: 0x46072940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[7]);
    // 0x1aa4a4: 0x46002802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x1aa4a8: 0x46022942
    ctx->f[5] = FPU_MUL_S(ctx->f[5], ctx->f[2]);
    // 0x1aa4ac: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x1aa4b0: 0x46053180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[5]);
    // 0x1aa4b4: 0xe6040220
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 544), *(uint32_t*)&val); }
    // 0x1aa4b8: 0xc06abb0
    SET_GPR_U32(ctx, 31, 0x1aa4c0);
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 540), *(uint32_t*)&val); }
    RepositionBlotDependents__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1aa4c0
// Address: 0x1aa4c0 - 0x1aa4d4

void entry_1aa4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa4c0) {
        switch (ctx->pc) {
            case 0x1aa4c4: ctx->pc = 0; goto label_1aa4c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa4c0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1aa4c4:
    // 0x1aa4c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1aa4c8: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1aa4cc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1aa4d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1aa4d4
// Address: 0x1aa4d4 - 0x1aa4f0

void entry_1aa4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa4d4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aa4d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aa4dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa4e0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1aa4e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa4ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa4f0; return;
}


// Function: SetBlotAchzDraw__FP4BLOTPc
// Address: 0x1aa4f0 - 0x1aa514

void entry_1aa514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa514: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AA534; return;
    }
    // 0x1aa51c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1aa520: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1aa524: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1aa52c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1aa52c
// Address: 0x1aa52c - 0x1aa54c

void entry_1aa52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa52c) {
        switch (ctx->pc) {
            case 0x1aa534: ctx->pc = 0; goto label_1aa534;
            case 0x1aa540: ctx->pc = 0; goto label_1aa540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa52c: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aa540;
    }
label_1aa534:
    // 0x1aa534: 0xa2200008
    WRITE8(ADD32(GPR_U32(ctx, 17), 8), (uint8_t)GPR_U32(ctx, 0));
    // 0x1aa538: 0x26300008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1aa53c: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1aa540:
    // 0x1aa540: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1aa544: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1aa54c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1aa54c
// Address: 0x1aa54c - 0x1aa55c

void entry_1aa54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa54c: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1aa550: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1aa554: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1aa55c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1aa55c
// Address: 0x1aa55c - 0x1aa570

void entry_1aa55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa55c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1aa560: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1aa564: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1aa568: 0xc0578a4
    SET_GPR_U32(ctx, 31, 0x1aa570);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 180));
    GetExtents__9CRichTextPfT1f(rdram, ctx, runtime); return;
}


// Function: entry_1aa570
// Address: 0x1aa570 - 0x1aa580

void entry_1aa570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa570: 0xc7ac00b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[12] = *(float*)&val; }
    // 0x1aa574: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1aa578: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1aa580);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 180)); ctx->f[13] = *(float*)&val; }
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1aa580
// Address: 0x1aa580 - 0x1aa588

void entry_1aa580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa580: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1aa588);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1aa588
// Address: 0x1aa588 - 0x1aa5a0

void entry_1aa588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa588: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1aa58c: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1aa590: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1aa594: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa59c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa5a0; return;
}


// Function: SetBlotRgba__FP4BLOTUi
// Address: 0x1aa5a0 - 0x1aa610

void entry_1aa610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa610: 0x5440001e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1AA68C; return;
    }
    // 0x1aa618: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1aa620);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1aa620
// Address: 0x1aa620 - 0x1aa638

void entry_1aa620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa620: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1aa624: 0x82050000
    SET_GPR_S32(ctx, 5, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aa628: 0x84640010
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1aa62c: 0x8c660014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1aa630: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1aa638);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1aa638
// Address: 0x1aa638 - 0x1aa650

void entry_1aa638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa638) {
        switch (ctx->pc) {
            case 0x1aa648: ctx->pc = 0; goto label_1aa648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa638: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1aa648;
    }
    // 0x1aa640: 0x1000000c
    SET_GPR_S32(ctx, 6, (int8_t)READ8(ADD32(GPR_U32(ctx, 20), 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AA674; return;
    }
label_1aa648:
    // 0x1aa648: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1aa650);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1aa650
// Address: 0x1aa650 - 0x1aa668

void entry_1aa650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa650: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1aa654: 0x82050000
    SET_GPR_S32(ctx, 5, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aa658: 0x84640010
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1aa65c: 0x8c660014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1aa660: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1aa668);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1aa668
// Address: 0x1aa668 - 0x1aa684

void entry_1aa668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa668) {
        switch (ctx->pc) {
            case 0x1aa674: ctx->pc = 0; goto label_1aa674;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa668: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1AA68C; return;
    }
    // 0x1aa670: 0x82860004
    SET_GPR_S32(ctx, 6, (int8_t)READ8(ADD32(GPR_U32(ctx, 20), 4)));
label_1aa674:
    // 0x1aa674: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1aa678: 0x82070000
    SET_GPR_S32(ctx, 7, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aa67c: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1aa684);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 21), 4294953936));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1aa684
// Address: 0x1aa684 - 0x1aa6c0

void entry_1aa684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa684) {
        switch (ctx->pc) {
            case 0x1aa68c: ctx->pc = 0; goto label_1aa68c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa684: 0x1000002c
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AA738; return;
    }
label_1aa68c:
    // 0x1aa68c: 0x2402002f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 47));
    // 0x1aa690: 0x14620027
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AA730; return;
    }
    // 0x1aa698: 0x82030001
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 1)));
    // 0x1aa69c: 0x26f2e879
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 23), 4294961273));
    // 0x1aa6a0: 0x721821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x1aa6a4: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1aa6a8: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1aa6ac: 0x50400021
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 4));
        ctx->pc = 0x1AA734; return;
    }
    // 0x1aa6b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1aa6b8: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1aa6c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 4294953944));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1aa6c0
// Address: 0x1aa6c0 - 0x1aa724

void entry_1aa6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa6c0) {
        switch (ctx->pc) {
            case 0x1aa6f0: ctx->pc = 0; goto label_1aa6f0;
            case 0x1aa718: ctx->pc = 0; goto label_1aa718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa6c0: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1aa6c4: 0x82030000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aa6c8: 0x2228821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1aa6cc: 0x92040000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aa6d0: 0x10600011
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1aa718;
    }
    // 0x1aa6d8: 0x721821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x1aa6dc: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1aa6e0: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1aa6e4: 0x1040000c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1aa718;
    }
    // 0x1aa6ec: 0xa2240000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 4));
label_1aa6f0:
    // 0x1aa6f0: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1aa6f4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1aa6f8: 0x82030000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aa6fc: 0x10600006
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1aa718;
    }
    // 0x1aa704: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1aa708: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1aa70c: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1aa710: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 4));
        goto label_1aa6f0;
    }
label_1aa718:
    // 0x1aa718: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1aa71c: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1aa724);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294953960));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1aa724
// Address: 0x1aa724 - 0x1aa758

void entry_1aa724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa724) {
        switch (ctx->pc) {
            case 0x1aa730: ctx->pc = 0; goto label_1aa730;
            case 0x1aa734: ctx->pc = 0; goto label_1aa734;
            case 0x1aa738: ctx->pc = 0; goto label_1aa738;
            case 0x1aa748: ctx->pc = 0; goto label_1aa748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa724: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1aa728: 0x10000003
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aa738;
    }
label_1aa730:
    // 0x1aa730: 0xa2240000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 4));
label_1aa734:
    // 0x1aa734: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_1aa738:
    // 0x1aa738: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1aa73c: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aa740: 0x5440ffad
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1AA5F8; return;
    }
label_1aa748:
    // 0x1aa748: 0x26640008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1aa74c: 0xa2200000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x1aa750: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1aa758);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1aa758
// Address: 0x1aa758 - 0x1aa788

void entry_1aa758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa758: 0x7bbf0280
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 640)));
    // 0x1aa75c: 0x7bb70270
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x1aa760: 0x7bb60260
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x1aa764: 0x7bb50250
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x1aa768: 0x7bb40240
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x1aa76c: 0x7bb30230
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x1aa770: 0x7bb20220
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1aa774: 0x7bb10210
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1aa778: 0x7bb00200
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1aa77c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 656));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa784: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa788; return;
}


// Function: SetBlotFontScale__FfP4BLOT
// Address: 0x1aa788 - 0x1aa790

void entry_1aa7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa7d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1aa7dc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1aa7e0: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1aa7e8);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1aa7e8
// Address: 0x1aa7e8 - 0x1aa7f8

void entry_1aa7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa7e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1aa7ec: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1aa7f0: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1aa7f8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1aa7f8
// Address: 0x1aa7f8 - 0x1aa804

void entry_1aa7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa7f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1aa7fc: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1aa804);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1aa804
// Address: 0x1aa804 - 0x1aa810

void entry_1aa804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa804: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1aa808: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1aa810);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1aa810
// Address: 0x1aa810 - 0x1aa840

void entry_1aa810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa810: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1aa814: 0x50a0000b
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1AA844; return;
    }
    // 0x1aa81c: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1aa820: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1aa840(rdram, ctx, runtime); return;
    }
    // 0x1aa828: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1aa82c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1aa830: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1aa834: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1aa838: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1aa840);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1aa840
// Address: 0x1aa840 - 0x1aa850

void entry_1aa840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa840) {
        switch (ctx->pc) {
            case 0x1aa844: ctx->pc = 0; goto label_1aa844;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa840: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1aa844:
    // 0x1aa844: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1aa848: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1aa850);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1aa850
// Address: 0x1aa850 - 0x1aa868

void entry_1aa850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa850: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1aa854: 0x26482280
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1aa858: 0x26250008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1aa85c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1aa860: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1aa868);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1aa868
// Address: 0x1aa868 - 0x1aa870

void entry_1aa868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa868: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1aa870);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1aa870
// Address: 0x1aa870 - 0x1aa890

void entry_1aa870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa870: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1aa874: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1aa878: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1aa87c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1aa880: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x1aa884: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1aa888: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001AA890
// Address: 0x1aa890 - 0x1aa898

void entry_1aa8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aa8e0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aa8e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa8ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa8f0; return;
}


// Function: ShowBlot__FP4BLOT
// Address: 0x1aa8f0 - 0x1aa938

void entry_1aa938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa938) {
        switch (ctx->pc) {
            case 0x1aa940: ctx->pc = 0; goto label_1aa940;
            case 0x1aa950: ctx->pc = 0; goto label_1aa950;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa938: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aa950;
    }
label_1aa940:
    // 0x1aa940: 0x8c820258
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 600)));
    // 0x1aa944: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1aa948: 0xe4800254
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 596), *(uint32_t*)&val); }
    // 0x1aa94c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1aa950:
    // 0x1aa950: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HideBlot__FP4BLOT
// Address: 0x1aa958 - 0x1aa988

void entry_1aa988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aa988) {
        switch (ctx->pc) {
            case 0x1aa98c: ctx->pc = 0; goto label_1aa98c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aa988: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1aa98c:
    // 0x1aa98c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aa994: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aa998; return;
}


// Function: SetBlotBlots__FP4BLOT5BLOTS
// Address: 0x1aa998 - 0x1aaa0c

void entry_1aaa0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aaa0c) {
        switch (ctx->pc) {
            case 0x1aaa14: ctx->pc = 0; goto label_1aaa14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aaa0c: 0x10000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 572)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AAA30; return;
    }
label_1aaa14:
    // 0x1aaa14: 0x8c620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1aaa18: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1aaa20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1aaa20
// Address: 0x1aaa20 - 0x1aaaac

void entry_1aaa20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aaa20) {
        switch (ctx->pc) {
            case 0x1aaa30: ctx->pc = 0; goto label_1aaa30;
            case 0x1aaa4c: ctx->pc = 0; goto label_1aaa4c;
            case 0x1aaa54: ctx->pc = 0; goto label_1aaa54;
            case 0x1aaa78: ctx->pc = 0; goto label_1aaa78;
            case 0x1aaa8c: ctx->pc = 0; goto label_1aaa8c;
            case 0x1aaa90: ctx->pc = 0; goto label_1aaa90;
            case 0x1aaa94: ctx->pc = 0; goto label_1aaa94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aaa20: 0xc602023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 572)); ctx->f[2] = *(float*)&val; }
    // 0x1aaa24: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1aaa28: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1aaa2c: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
label_1aaa30:
    // 0x1aaa30: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1aaa34: 0xe601024c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 588), *(uint32_t*)&val); }
    // 0x1aaa38: 0x8e030250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    // 0x1aaa3c: 0x10600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1aaa4c;
    }
    // 0x1aaa44: 0x54620013
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 592), GPR_U32(ctx, 17));
        goto label_1aaa94;
    }
label_1aaa4c:
    // 0x1aaa4c: 0x10000010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aaa90;
    }
label_1aaa54:
    // 0x1aaa54: 0xc6000224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 548)); ctx->f[0] = *(float*)&val; }
    // 0x1aaa58: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1aaa5c: 0xc6010228
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 552)); ctx->f[1] = *(float*)&val; }
    // 0x1aaa60: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1aaa64: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1aaa68: 0xe600021c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 540), *(uint32_t*)&val); }
    // 0x1aaa6c: 0xe6010220
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 544), *(uint32_t*)&val); }
    // 0x1aaa70: 0x10000006
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 572), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aaa8c;
    }
label_1aaa78:
    // 0x1aaa78: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1aaa7c: 0xc6000230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 560)); ctx->f[0] = *(float*)&val; }
    // 0x1aaa80: 0xe601021c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 540), *(uint32_t*)&val); }
    // 0x1aaa84: 0xe6000220
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 544), *(uint32_t*)&val); }
    // 0x1aaa88: 0xae00023c
    WRITE32(ADD32(GPR_U32(ctx, 16), 572), GPR_U32(ctx, 0));
label_1aaa8c:
    // 0x1aaa8c: 0xae00024c
    WRITE32(ADD32(GPR_U32(ctx, 16), 588), GPR_U32(ctx, 0));
label_1aaa90:
    // 0x1aaa90: 0xae110250
    WRITE32(ADD32(GPR_U32(ctx, 16), 592), GPR_U32(ctx, 17));
label_1aaa94:
    // 0x1aaa94: 0x8e020258
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 600)));
    // 0x1aaa98: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1aaa9c: 0x12400003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 596), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1aaaac(rdram, ctx, runtime); return;
    }
    // 0x1aaaa4: 0xc06aad8
    SET_GPR_U32(ctx, 31, 0x1aaaac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RepositionBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1aaaac
// Address: 0x1aaaac - 0x1aaac8

void entry_1aaaac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aaaac: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1aaab0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aaab4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aaab8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aaabc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aaac4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aaac8; return;
}


// Function: FIncludeBlotForPeg__FP4BLOTT0
// Address: 0x1aaac8 - 0x1aab20

void entry_1aab54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aab54: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aab58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RepositionBlot__FP4BLOT
// Address: 0x1aab60 - 0x1aac18

void entry_1aac18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aac18) {
        switch (ctx->pc) {
            case 0x1aac44: ctx->pc = 0; goto label_1aac44;
            case 0x1aac5c: ctx->pc = 0; goto label_1aac5c;
            case 0x1aac78: ctx->pc = 0; goto label_1aac78;
            case 0x1aac94: ctx->pc = 0; goto label_1aac94;
            case 0x1aacb4: ctx->pc = 0; goto label_1aacb4;
            case 0x1aaccc: ctx->pc = 0; goto label_1aaccc;
            case 0x1aace0: ctx->pc = 0; goto label_1aace0;
            case 0x1aace4: ctx->pc = 0; goto label_1aace4;
            case 0x1aad14: ctx->pc = 0; goto label_1aad14;
            case 0x1aad2c: ctx->pc = 0; goto label_1aad2c;
            case 0x1aad34: ctx->pc = 0; goto label_1aad34;
            case 0x1aad6c: ctx->pc = 0; goto label_1aad6c;
            case 0x1aad84: ctx->pc = 0; goto label_1aad84;
            case 0x1aad8c: ctx->pc = 0; goto label_1aad8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aac18: 0x5040002c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        goto label_1aaccc;
    }
    // 0x1aac20: 0x8e430010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1aac24: 0x10770014
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 23)) {
        goto label_1aac78;
    }
    // 0x1aac2c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1aac44;
    }
    // 0x1aac34: 0x50600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 564)); ctx->f[1] = *(float*)&val; }
        goto label_1aac5c;
    }
    // 0x1aac3c: 0x10000029
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aace4;
    }
label_1aac44:
    // 0x1aac44: 0x107e0013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 30)) {
        goto label_1aac94;
    }
    // 0x1aac4c: 0x50620019
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 568)); ctx->f[0] = *(float*)&val; }
        goto label_1aacb4;
    }
    // 0x1aac54: 0x10000023
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aace4;
    }
label_1aac5c:
    // 0x1aac5c: 0x46140832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aac60: 0x0
    // NOP
    // 0x1aac64: 0x4503001f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
        goto label_1aace4;
    }
    // 0x1aac6c: 0xc600021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 540)); ctx->f[0] = *(float*)&val; }
    // 0x1aac70: 0x1000001b
    ctx->f[21] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aace0;
    }
label_1aac78:
    // 0x1aac78: 0xc6000234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 564)); ctx->f[0] = *(float*)&val; }
    // 0x1aac7c: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aac80: 0x0
    // NOP
    // 0x1aac84: 0x45020016
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 540)); ctx->f[22] = *(float*)&val; }
        goto label_1aace0;
    }
    // 0x1aac8c: 0x10000015
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aace4;
    }
label_1aac94:
    // 0x1aac94: 0xc6010238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 568)); ctx->f[1] = *(float*)&val; }
    // 0x1aac98: 0x46140832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aac9c: 0x0
    // NOP
    // 0x1aaca0: 0x45030010
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
        goto label_1aace4;
    }
    // 0x1aaca8: 0xc6000220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 544)); ctx->f[0] = *(float*)&val; }
    // 0x1aacac: 0x1000000c
    ctx->f[23] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aace0;
    }
label_1aacb4:
    // 0x1aacb4: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aacb8: 0x0
    // NOP
    // 0x1aacbc: 0x45020008
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 544)); ctx->f[24] = *(float*)&val; }
        goto label_1aace0;
    }
    // 0x1aacc4: 0x10000007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aace4;
    }
label_1aaccc:
    // 0x1aaccc: 0x541818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1aacd0: 0x759021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x1aacd4: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1aacd8: 0x5473ffc7
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x1AABF8; return;
    }
label_1aace0:
    // 0x1aace0: 0x8e220218
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
label_1aace4:
    // 0x1aace4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1aace8: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1aacec: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aacf0: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1aad14;
    }
    // 0x1aacf8: 0x4615b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    // 0x1aacfc: 0xc6210234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[1] = *(float*)&val; }
    // 0x1aad00: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1aad04: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1aad08: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1aad0c: 0x10000009
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aad34;
    }
label_1aad14:
    // 0x1aad14: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aad18: 0x0
    // NOP
    // 0x1aad1c: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[0]);
        goto label_1aad2c;
    }
    // 0x1aad24: 0x10000003
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aad34;
    }
label_1aad2c:
    // 0x1aad2c: 0xc6210234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[1] = *(float*)&val; }
    // 0x1aad30: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
label_1aad34:
    // 0x1aad34: 0xe6200224
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 548), *(uint32_t*)&val); }
    // 0x1aad38: 0x8e220218
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    // 0x1aad3c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1aad40: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1aad44: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aad48: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1aad6c;
    }
    // 0x1aad50: 0x4617c001
    ctx->f[0] = FPU_SUB_S(ctx->f[24], ctx->f[23]);
    // 0x1aad54: 0xc6210238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[1] = *(float*)&val; }
    // 0x1aad58: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1aad5c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1aad60: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1aad64: 0x10000009
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aad8c;
    }
label_1aad6c:
    // 0x1aad6c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1aad70: 0x0
    // NOP
    // 0x1aad74: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[24], ctx->f[0]);
        goto label_1aad84;
    }
    // 0x1aad7c: 0x10000003
    ctx->f[0] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aad8c;
    }
label_1aad84:
    // 0x1aad84: 0xc6210238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[1] = *(float*)&val; }
    // 0x1aad88: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
label_1aad8c:
    // 0x1aad8c: 0xe6200228
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 552), *(uint32_t*)&val); }
    // 0x1aad90: 0xc6200228
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 552)); ctx->f[0] = *(float*)&val; }
    // 0x1aad94: 0x3c013f68
    SET_GPR_U32(ctx, 1, ((uint32_t)16232 << 16));
    // 0x1aad98: 0x3421ba2e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47662));
    // 0x1aad9c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1aada0: 0xc07abca
    SET_GPR_U32(ctx, 31, 0x1aada8);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    GTrunc__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1aada8
// Address: 0x1aada8 - 0x1aae7c

void entry_1aada8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aada8) {
        switch (ctx->pc) {
            case 0x1aadf4: ctx->pc = 0; goto label_1aadf4;
            case 0x1aae0c: ctx->pc = 0; goto label_1aae0c;
            case 0x1aae18: ctx->pc = 0; goto label_1aae18;
            case 0x1aae28: ctx->pc = 0; goto label_1aae28;
            case 0x1aae34: ctx->pc = 0; goto label_1aae34;
            case 0x1aae40: ctx->pc = 0; goto label_1aae40;
            case 0x1aae44: ctx->pc = 0; goto label_1aae44;
            case 0x1aae48: ctx->pc = 0; goto label_1aae48;
            case 0x1aae64: ctx->pc = 0; goto label_1aae64;
            case 0x1aae6c: ctx->pc = 0; goto label_1aae6c;
            case 0x1aae74: ctx->pc = 0; goto label_1aae74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aada8: 0x3c013f8c
    SET_GPR_U32(ctx, 1, ((uint32_t)16268 << 16));
    // 0x1aadac: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1aadb0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1aadb4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1aadb8: 0xc6220224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 548)); ctx->f[2] = *(float*)&val; }
    // 0x1aadbc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1aadc0: 0x8e220218
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    // 0x1aadc4: 0xe622022c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 556), *(uint32_t*)&val); }
    // 0x1aadc8: 0xe6200230
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 560), *(uint32_t*)&val); }
    // 0x1aadcc: 0xe6200228
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 552), *(uint32_t*)&val); }
    // 0x1aadd0: 0x8c440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1aadd4: 0x10830010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1aae18;
    }
    // 0x1aaddc: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_1aadf4;
    }
    // 0x1aade4: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[0] = *(float*)&val; }
        goto label_1aae0c;
    }
    // 0x1aadec: 0x10000016
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aae48;
    }
label_1aadf4:
    // 0x1aadf4: 0x1082000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1aae28;
    }
    // 0x1aadfc: 0x1082000d
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1aae34;
    }
    // 0x1aae04: 0x10000010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aae48;
    }
label_1aae0c:
    // 0x1aae0c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1aae10: 0x1000000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 556), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aae44;
    }
label_1aae18:
    // 0x1aae18: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1aae1c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1aae20: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 556), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aae44;
    }
label_1aae28:
    // 0x1aae28: 0xc6200238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[0] = *(float*)&val; }
    // 0x1aae2c: 0x10000004
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aae40;
    }
label_1aae34:
    // 0x1aae34: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x1aae38: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1aae3c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_1aae40:
    // 0x1aae40: 0xe6200230
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 560), *(uint32_t*)&val); }
label_1aae44:
    // 0x1aae44: 0x8e230250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 592)));
label_1aae48:
    // 0x1aae48: 0x10600006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1aae64;
    }
    // 0x1aae50: 0x14620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1aae74;
    }
    // 0x1aae58: 0xc6200224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 548)); ctx->f[0] = *(float*)&val; }
    // 0x1aae5c: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 552)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1aae6c;
    }
label_1aae64:
    // 0x1aae64: 0xc620022c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 556)); ctx->f[0] = *(float*)&val; }
    // 0x1aae68: 0xc6210230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 560)); ctx->f[1] = *(float*)&val; }
label_1aae6c:
    // 0x1aae6c: 0xe620021c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 540), *(uint32_t*)&val); }
    // 0x1aae70: 0xe6210220
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 544), *(uint32_t*)&val); }
label_1aae74:
    // 0x1aae74: 0xc06abb0
    SET_GPR_U32(ctx, 31, 0x1aae7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RepositionBlotDependents__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1aae7c
// Address: 0x1aae7c - 0x1aaec0

void entry_1aae7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aae7c: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1aae80: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1aae84: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1aae88: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1aae8c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1aae90: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1aae94: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1aae98: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aae9c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aaea0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aaea4: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1aaea8: 0xc7b700b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[23] = *(float*)&val; }
    // 0x1aaeac: 0xc7b600b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[22] = *(float*)&val; }
    // 0x1aaeb0: 0xc7b500a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[21] = *(float*)&val; }
    // 0x1aaeb4: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1aaeb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RepositionBlotDependents__FP4BLOT
// Address: 0x1aaec0 - 0x1aaf28

void entry_1aaf28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aaf28) {
        switch (ctx->pc) {
            case 0x1aaf2c: ctx->pc = 0; goto label_1aaf2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aaf28: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
label_1aaf2c:
    // 0x1aaf2c: 0x2a020025
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 37));
    // 0x1aaf30: 0x5440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x1AAEF8; return;
    }
    // 0x1aaf38: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1aaf3c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1aaf40: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1aaf44: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aaf48: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aaf4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aaf50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBlotClock__FP4BLOTPf
// Address: 0x1aaf58 - 0x1aaf88

void entry_1aaf9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aaf9c: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1aafa4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1aafa4
// Address: 0x1aafa4 - 0x1ab058

void entry_1aafa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aafa4) {
        switch (ctx->pc) {
            case 0x1ab044: ctx->pc = 0; goto label_1ab044;
            case 0x1ab048: ctx->pc = 0; goto label_1ab048;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aafa4: 0x8e030214
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 532)));
    // 0x1aafa8: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1aafac: 0x3c0145bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17851 << 16));
    // 0x1aafb0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1aafb4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1aafb8: 0x2463fffd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967293));
    // 0x1aafbc: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1aafc0: 0xae040260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 4));
    // 0x1aafc4: 0x2c620022
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 34));
    // 0x1aafc8: 0x1040001f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 620), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ab048;
    }
    // 0x1aafd0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1aafd4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1aafd8: 0x2442cbf0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953968));
    // 0x1aafdc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1aafe0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1aafe4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1aafec: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1aaff0: 0x8c6223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x1aaff4: 0x10000013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6624));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ab044;
    }
    // 0x1aaffc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1ab000: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1ab004: 0x8c8223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 9160)));
    // 0x1ab008: 0x8ca35710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 22288)));
    // 0x1ab00c: 0x24420064
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 100));
    // 0x1ab010: 0x24632300
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8960));
    // 0x1ab014: 0xae020264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 2));
    // 0x1ab018: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 16), 616), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ab048;
    }
    // 0x1ab020: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1ab024: 0x8c6223c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9156)));
    // 0x1ab028: 0x10000006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1080));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ab044;
    }
    // 0x1ab030: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1ab034: 0x8c6223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x1ab038: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6632));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ab044;
    }
    // 0x1ab040: 0x26020260
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 608));
label_1ab044:
    // 0x1ab044: 0xae020264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 2));
label_1ab048:
    // 0x1ab048: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ab04c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ab050: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateCtr__FP3CTR
// Address: 0x1ab058 - 0x1ab06c

void entry_1ab06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab06c) {
        switch (ctx->pc) {
            case 0x1ab0d0: ctx->pc = 0; goto label_1ab0d0;
            case 0x1ab0d8: ctx->pc = 0; goto label_1ab0d8;
            case 0x1ab0e0: ctx->pc = 0; goto label_1ab0e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab06c: 0x8e030264
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x1ab070: 0x8e060260
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab074: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ab078: 0x10c20044
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AB18C; return;
    }
    // 0x1ab080: 0x4c20017
    if (GPR_S32(ctx, 6) < 0) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
        goto label_1ab0e0;
    }
    // 0x1ab088: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ab08c: 0xc602026c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 620)); ctx->f[2] = *(float*)&val; }
    // 0x1ab090: 0xc4401860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[0] = *(float*)&val; }
    // 0x1ab094: 0xc6010270
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 624)); ctx->f[1] = *(float*)&val; }
    // 0x1ab098: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1ab09c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ab0a0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ab0a4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1ab0a8: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x1ab0ac: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ab0b0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1ab0b4: 0xe6000270
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 624), *(uint32_t*)&val); }
    // 0x1ab0b8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ab0bc: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    // 0x1ab0c0: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ab0d0;
    }
    // 0x1ab0c8: 0x10000003
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ab0d8;
    }
label_1ab0d0:
    // 0x1ab0d0: 0xc51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x1ab0d4: 0x44182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
label_1ab0d8:
    // 0x1ab0d8: 0x83100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x1ab0dc: 0xae020260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
label_1ab0e0:
    // 0x1ab0e0: 0x8e020264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x1ab0e4: 0x8e040260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab0e8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ab0ec: 0x14830008
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1AB110; return;
    }
    // 0x1ab0f4: 0x8e020274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 628)));
    // 0x1ab0f8: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB110; return;
    }
    // 0x1ab100: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ab108);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 632)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ab108
// Address: 0x1ab108 - 0x1ab118

void entry_1ab108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab108) {
        switch (ctx->pc) {
            case 0x1ab110: ctx->pc = 0; goto label_1ab110;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab108: 0xae000274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 0));
    // 0x1ab10c: 0xae000278
    WRITE32(ADD32(GPR_U32(ctx, 16), 632), GPR_U32(ctx, 0));
label_1ab110:
    // 0x1ab110: 0xc06acae
    SET_GPR_U32(ctx, 31, 0x1ab118);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebuildCtrAchzDraw__FP3CTR(rdram, ctx, runtime); return;
}


// Function: entry_1ab118
// Address: 0x1ab118 - 0x1ab134

void entry_1ab118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab118: 0x82020008
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1ab11c: 0x10400017
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB17C; return;
    }
    // 0x1ab124: 0xc60c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 524)); ctx->f[12] = *(float*)&val; }
    // 0x1ab128: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ab12c: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ab134);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ab134
// Address: 0x1ab134 - 0x1ab144

void entry_1ab134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab134: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ab138: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab13c: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ab144);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ab144
// Address: 0x1ab144 - 0x1ab14c

void entry_1ab144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab144: 0xc0577fe
    SET_GPR_U32(ctx, 31, 0x1ab14c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Dx__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_1ab14c
// Address: 0x1ab14c - 0x1ab16c

void entry_1ab14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab14c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ab150: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1ab154: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ab158: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1ab15c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ab160: 0xc44d0048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[13] = *(float*)&val; }
    // 0x1ab164: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1ab16c);
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[13]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1ab16c
// Address: 0x1ab16c - 0x1ab174

void entry_1ab16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab16c: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ab174);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ab174
// Address: 0x1ab174 - 0x1ab188

void entry_1ab174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab174) {
        switch (ctx->pc) {
            case 0x1ab17c: ctx->pc = 0; goto label_1ab17c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab174: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB18C; return;
    }
label_1ab17c:
    // 0x1ab17c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ab180: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1ab188);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1ab188
// Address: 0x1ab188 - 0x1ab198

void entry_1ab188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab188) {
        switch (ctx->pc) {
            case 0x1ab18c: ctx->pc = 0; goto label_1ab18c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab188: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_1ab18c:
    // 0x1ab18c: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ab190: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawCtr__FP3CTR
// Address: 0x1ab198 - 0x1ab21c

void entry_1ab21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab21c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab220: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1ab224: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ab22c);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ab22c
// Address: 0x1ab22c - 0x1ab23c

void entry_1ab22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab22c: 0xafb00030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    // 0x1ab230: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab234: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ab23c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ab23c
// Address: 0x1ab23c - 0x1ab248

void entry_1ab23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab23c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab240: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ab248);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ab248
// Address: 0x1ab248 - 0x1ab254

void entry_1ab248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab248: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab24c: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ab254);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ab254
// Address: 0x1ab254 - 0x1ab264

void entry_1ab254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab254: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
    // 0x1ab258: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ab25c: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ab264);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ab264
// Address: 0x1ab264 - 0x1ab278

void entry_1ab264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab264: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ab268: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ab26c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ab270: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ab278);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ab278
// Address: 0x1ab278 - 0x1ab290

void entry_1ab278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab278: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x1ab27c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ab280: 0x24e72280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 8832));
    // 0x1ab284: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab288: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x1ab290);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ab290
// Address: 0x1ab290 - 0x1ab298

void entry_1ab290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab290: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ab298);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ab298
// Address: 0x1ab298 - 0x1ab2b8

void entry_1ab298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab298: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1ab29c: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ab2a0: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ab2a4: 0xc7b50128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[21] = *(float*)&val; }
    // 0x1ab2a8: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x1ab2ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ab2b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ab2b8; return;
}


// Function: RebuildCtrAchzDraw__FP3CTR
// Address: 0x1ab2b8 - 0x1ab310

void entry_1ab310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab310: 0x100000aa
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab318: 0x8e020268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 616)));
    // 0x1ab31c: 0x8c480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ab320: 0x11000028
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB3C4; return;
    }
    // 0x1ab328: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab32c: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    // 0x1ab330: 0x2409003f
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1ab334: 0xe8102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 8)));
    // 0x1ab338: 0x24c6cc80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954112));
    // 0x1ab33c: 0x62480a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 9, GPR_U32(ctx, 3));
    // 0x1ab340: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab344: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab34c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab34c
// Address: 0x1ab34c - 0x1ab388

void entry_1ab34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab34c: 0x1000009b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab354: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ab358: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1ab35c: 0x8c8319d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6616)));
    // 0x1ab360: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1ab364: 0x2c630004
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 4));
    // 0x1ab368: 0x10600016
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB3C4; return;
    }
    // 0x1ab370: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab374: 0x24c6cc88
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954120));
    // 0x1ab378: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab37c: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab380: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab388);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 75));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab388
// Address: 0x1ab388 - 0x1ab3bc

void entry_1ab388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab388: 0x1000008c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab390: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ab394: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1ab398: 0x8c642354
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9044)));
    // 0x1ab39c: 0x10800009
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB3C4; return;
    }
    // 0x1ab3a4: 0x8e080260
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab3a8: 0x24c6cc78
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954104));
    // 0x1ab3ac: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab3b0: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab3b4: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab3bc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 67));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab3bc
// Address: 0x1ab3bc - 0x1ab408

void entry_1ab3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab3bc) {
        switch (ctx->pc) {
            case 0x1ab3c4: ctx->pc = 0; goto label_1ab3c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab3bc: 0x1000007f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
label_1ab3c4:
    // 0x1ab3c4: 0x1000007d
    WRITE8(ADD32(GPR_U32(ctx, 16), 8), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab3cc: 0x8e020268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 616)));
    // 0x1ab3d0: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab3d4: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab3d8: 0x24c6cc80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954112));
    // 0x1ab3dc: 0x1000002b
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB48C; return;
    }
    // 0x1ab3e4: 0x8e020268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 616)));
    // 0x1ab3e8: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab3ec: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab3f0: 0x24c6cc80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954112));
    // 0x1ab3f4: 0x8c480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ab3f8: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab3fc: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab400: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab408);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 78));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab408
// Address: 0x1ab408 - 0x1ab434

void entry_1ab408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab408: 0x1000006c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab410: 0x8e020268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 616)));
    // 0x1ab414: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab418: 0x8e080260
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab41c: 0x24c6cc90
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954128));
    // 0x1ab420: 0x8c490000
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ab424: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab428: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab42c: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab434);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 70));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab434
// Address: 0x1ab434 - 0x1ab458

void entry_1ab434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab434: 0x10000061
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab43c: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab440: 0x8e080260
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab444: 0x24c6cc78
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954104));
    // 0x1ab448: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab44c: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab450: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab458);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 78));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab458
// Address: 0x1ab458 - 0x1ab49c

void entry_1ab458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab458) {
        switch (ctx->pc) {
            case 0x1ab48c: ctx->pc = 0; goto label_1ab48c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab458: 0x10000058
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab460: 0x8e020268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 616)));
    // 0x1ab464: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab468: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab46c: 0x24c6cc80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954112));
    // 0x1ab470: 0x10000006
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ab48c;
    }
    // 0x1ab478: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ab47c: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab480: 0x8c4851d4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 20948)));
    // 0x1ab484: 0x24c6cc80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954112));
    // 0x1ab488: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
label_1ab48c:
    // 0x1ab48c: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab490: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab494: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab49c);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 86));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab49c
// Address: 0x1ab49c - 0x1ab4c8

void entry_1ab49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab49c: 0x10000047
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab4a4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ab4a8: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab4ac: 0x8c4951d4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 2), 20948)));
    // 0x1ab4b0: 0x24c6cc90
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954128));
    // 0x1ab4b4: 0x8e080260
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab4b8: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab4bc: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab4c0: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab4c8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 78));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab4c8
// Address: 0x1ab4c8 - 0x1ab4f4

void entry_1ab4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab4c8: 0x1000003c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab4d0: 0x8e020268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 616)));
    // 0x1ab4d4: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab4d8: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab4dc: 0x24c6cc80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954112));
    // 0x1ab4e0: 0x8c480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ab4e4: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab4e8: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab4ec: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab4f4);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 100));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab4f4
// Address: 0x1ab4f4 - 0x1ab55c

void entry_1ab4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab4f4: 0x10000031
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab4fc: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab500: 0x24040062
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 98));
    // 0x1ab504: 0x240a006d
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 109));
    // 0x1ab508: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ab50c: 0x28430005
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), 5));
    // 0x1ab510: 0x28470002
    SET_GPR_U32(ctx, 7, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1ab514: 0x143280b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 10));
    // 0x1ab518: 0x284c0003
    SET_GPR_U32(ctx, 12, SLT32(GPR_S32(ctx, 2), 3));
    // 0x1ab51c: 0x28430001
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), 1));
    // 0x1ab520: 0x80582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ab524: 0x80482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ab528: 0x28420004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 4));
    // 0x1ab52c: 0x147480b
    if (GPR_U32(ctx, 7) != 0) SET_GPR_U32(ctx, 9, GPR_U32(ctx, 10));
    // 0x1ab530: 0x2408006d
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 109));
    // 0x1ab534: 0x142580b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 11, GPR_U32(ctx, 10));
    // 0x1ab538: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab53c: 0x83400a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 4));
    // 0x1ab540: 0xafa50000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 5));
    // 0x1ab544: 0x8c500a
    if (GPR_U32(ctx, 12) == 0) SET_GPR_U32(ctx, 10, GPR_U32(ctx, 4));
    // 0x1ab548: 0x24c6cc98
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954136));
    // 0x1ab54c: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab550: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab554: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab55c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 115));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab55c
// Address: 0x1ab55c - 0x1ab578

void entry_1ab55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab55c: 0x10000017
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab564: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab568: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab56c: 0x24c6cca8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954152));
    // 0x1ab570: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab578);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab578
// Address: 0x1ab578 - 0x1ab59c

void entry_1ab578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab578: 0x10000010
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab580: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab584: 0x8e080260
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab588: 0x24c6ccb0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954160));
    // 0x1ab58c: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab590: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1ab594: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab59c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 70));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab59c
// Address: 0x1ab59c - 0x1ab5bc

void entry_1ab59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab59c: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ab5bc(rdram, ctx, runtime); return;
    }
    // 0x1ab5a4: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1ab5a8: 0x8e070260
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab5ac: 0x24c6ccb8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294954168));
    // 0x1ab5b0: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ab5b4: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1ab5bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ab5bc
// Address: 0x1ab5bc - 0x1ab5c4

void entry_1ab5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab5bc: 0xc06a968
    SET_GPR_U32(ctx, 31, 0x1ab5c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotRgba__FP4BLOTUi(rdram, ctx, runtime); return;
}


// Function: entry_1ab5c4
// Address: 0x1ab5c4 - 0x1ab5d8

void entry_1ab5c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab5c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ab5c8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ab5cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ab5d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ab5d8; return;
}


// Function: DtVisibleCtr__FP3CTR
// Address: 0x1ab5d8 - 0x1ab600

void FUN_001ab600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab600: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ab604: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ab608: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ab60c: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1ab614);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ab614
// Address: 0x1ab614 - 0x1ab61c

void entry_1ab614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab614: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ab61c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ab61c
// Address: 0x1ab61c - 0x1ab64c

void entry_1ab61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab61c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1ab620: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ab624: 0xc460cd48
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294954312)); ctx->f[0] = *(float*)&val; }
    // 0x1ab628: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ab62c: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1ab630: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ab634: 0xae060274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 6));
    // 0x1ab638: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ab63c: 0xe6000278
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 632), *(uint32_t*)&val); }
    // 0x1ab640: 0xae070290
    WRITE32(ADD32(GPR_U32(ctx, 16), 656), GPR_U32(ctx, 7));
    // 0x1ab644: 0xc06af88
    SET_GPR_U32(ctx, 31, 0x1ab64c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 624), GPR_U32(ctx, 6));
    SetTimerTimers__FP5TIMER6TIMERS(rdram, ctx, runtime); return;
}


// Function: entry_1ab64c
// Address: 0x1ab64c - 0x1ab660

void entry_1ab64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab64c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ab650: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ab654: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ab65c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ab660; return;
}


// Function: UpdateTimer__FP5TIMER
// Address: 0x1ab660 - 0x1ab674

void entry_1ab674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab674) {
        switch (ctx->pc) {
            case 0x1ab6b8: ctx->pc = 0; goto label_1ab6b8;
            case 0x1ab6e0: ctx->pc = 0; goto label_1ab6e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab674: 0x8e030250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    // 0x1ab678: 0x10600022
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB704; return;
    }
    // 0x1ab680: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ab684: 0x1440001b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB6F4; return;
    }
    // 0x1ab68c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ab690: 0xc6020264
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 612)); ctx->f[2] = *(float*)&val; }
    // 0x1ab694: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1ab698: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ab69c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ab6a0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ab6a4: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ab6a8: 0x0
    // NOP
    // 0x1ab6ac: 0x45010002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ab6b8;
    }
    // 0x1ab6b4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ab6b8:
    // 0x1ab6b8: 0x2462ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1ab6bc: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1ab6c0: 0x10400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB704; return;
    }
    // 0x1ab6c8: 0x8e020290
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 656)));
    // 0x1ab6cc: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1ab6e0;
    }
    // 0x1ab6d4: 0x5080000c
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x1AB708; return;
    }
    // 0x1ab6dc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1ab6e0:
    // 0x1ab6e0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1ab6e4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ab6ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ab6ec
// Address: 0x1ab6ec - 0x1ab700

void entry_1ab6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab6ec) {
        switch (ctx->pc) {
            case 0x1ab6f4: ctx->pc = 0; goto label_1ab6f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab6ec: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AB704; return;
    }
label_1ab6f4:
    // 0x1ab6f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ab6f8: 0xc06ae60
    SET_GPR_U32(ctx, 31, 0x1ab700);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    RebuildTimerAchzDraw__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_1ab700
// Address: 0x1ab700 - 0x1ab710

void entry_1ab700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab700) {
        switch (ctx->pc) {
            case 0x1ab704: ctx->pc = 0; goto label_1ab704;
            case 0x1ab708: ctx->pc = 0; goto label_1ab708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab700: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1ab704:
    // 0x1ab704: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1ab708:
    // 0x1ab708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawTimer__FP5TIMER
// Address: 0x1ab710 - 0x1ab75c

void entry_1ab75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab75c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab760: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ab764: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ab76c);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ab76c
// Address: 0x1ab76c - 0x1ab780

void entry_1ab76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab76c: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ab770: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab774: 0xafb00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 16));
    // 0x1ab778: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ab780);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ab780
// Address: 0x1ab780 - 0x1ab78c

void entry_1ab780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab780: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab784: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ab78c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ab78c
// Address: 0x1ab78c - 0x1ab798

void entry_1ab78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab78c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ab790: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ab798);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ab798
// Address: 0x1ab798 - 0x1ab7c8

void entry_1ab798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab798: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1ab79c: 0x50a0000b
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1AB7CC; return;
    }
    // 0x1ab7a4: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1ab7a8: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1ab7c8(rdram, ctx, runtime); return;
    }
    // 0x1ab7b0: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1ab7b4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab7b8: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1ab7bc: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1ab7c0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ab7c8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ab7c8
// Address: 0x1ab7c8 - 0x1ab7dc

void entry_1ab7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab7c8) {
        switch (ctx->pc) {
            case 0x1ab7cc: ctx->pc = 0; goto label_1ab7cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab7c8: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1ab7cc:
    // 0x1ab7cc: 0x26502280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1ab7d0: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ab7d4: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ab7dc);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ab7dc
// Address: 0x1ab7dc - 0x1ab800

void entry_1ab7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab7dc: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ab7e0: 0x24020054
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 84));
    // 0x1ab7e4: 0xa3a20020
    WRITE8(ADD32(GPR_U32(ctx, 29), 32), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ab7e8: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ab7ec: 0xa3a00021
    WRITE8(ADD32(GPR_U32(ctx, 29), 33), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ab7f0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab7f4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ab7f8: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1ab800);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ab800
// Address: 0x1ab800 - 0x1ab80c

void entry_1ab800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab800: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ab804: 0xc057106
    SET_GPR_U32(ctx, 31, 0x1ab80c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_1ab80c
// Address: 0x1ab80c - 0x1ab860

void entry_1ab80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ab80c) {
        switch (ctx->pc) {
            case 0x1ab848: ctx->pc = 0; goto label_1ab848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ab80c: 0xc621021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 540)); ctx->f[1] = *(float*)&val; }
    // 0x1ab810: 0xc6220220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 544)); ctx->f[2] = *(float*)&val; }
    // 0x1ab814: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1ab818: 0x8e220284
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x1ab81c: 0xe7a20004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1ab820: 0x10400009
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ab848;
    }
    // 0x1ab828: 0x8a22027f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 639); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ab82c: 0x9a22027c
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 636); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ab830: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ab834: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ab838: 0x8ba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ab83c: 0x9ba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ab840: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ab844: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
label_1ab848:
    // 0x1ab848: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ab84c: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ab850: 0x26250009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 9));
    // 0x1ab854: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ab858: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1ab860);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ab860
// Address: 0x1ab860 - 0x1ab868

void entry_1ab860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab860: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ab868);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ab868
// Address: 0x1ab868 - 0x1ab890

void entry_1ab868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab868: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ab86c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ab870: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ab874: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ab878: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ab87c: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1ab880: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1ab884: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ab88c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ab890; return;
}


// Function: SetTimer__FP5TIMERf
// Address: 0x1ab890 - 0x1ab8f0

void entry_1ab8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab8f0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ab8f4: 0xc06ae60
    SET_GPR_U32(ctx, 31, 0x1ab8fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebuildTimerAchzDraw__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_1ab8fc
// Address: 0x1ab8fc - 0x1ab90c

void entry_1ab8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab8fc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ab900: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1ab904: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ab90c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ab90c
// Address: 0x1ab90c - 0x1ab920

void entry_1ab90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab90c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ab910: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ab914: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ab91c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ab920; return;
}


// Function: SetTimerSpeed__FP5TIMERf
// Address: 0x1ab920 - 0x1ab928

void entry_1ab948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab948: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ab94c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ab954: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ab958; return;
}


// Function: StopTimer__FP5TIMER
// Address: 0x1ab958 - 0x1ab970

void entry_1ab970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ab970: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ab974: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ab97c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ab980; return;
}


// Function: RebuildTimerAchzDraw__FP5TIMERf
// Address: 0x1ab980 - 0x1abab4

void entry_1abab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1abab4) {
        switch (ctx->pc) {
            case 0x1ababc: ctx->pc = 0; goto label_1ababc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1abab4: 0x10000016
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ABB10; return;
    }
label_1ababc:
    // 0x1ababc: 0x12420013
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        entry_1abb0c(rdram, ctx, runtime); return;
    }
    // 0x1abac4: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1abac8: 0x24020073
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 115));
    // 0x1abacc: 0x24040072
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 114));
    // 0x1abad0: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1abad4: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1abad8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1abadc: 0x43200a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 2));
    // 0x1abae0: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1abae4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1abae8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abaec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1abaf0: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1abaf4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abaf8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abafc: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1abb00: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abb04: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1abb0c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1abb0c
// Address: 0x1abb0c - 0x1abc28

void entry_1abb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1abb0c) {
        switch (ctx->pc) {
            case 0x1abb10: ctx->pc = 0; goto label_1abb10;
            case 0x1abb98: ctx->pc = 0; goto label_1abb98;
            case 0x1abb9c: ctx->pc = 0; goto label_1abb9c;
            case 0x1abbac: ctx->pc = 0; goto label_1abbac;
            case 0x1abbe4: ctx->pc = 0; goto label_1abbe4;
            case 0x1abbe8: ctx->pc = 0; goto label_1abbe8;
            case 0x1abbf4: ctx->pc = 0; goto label_1abbf4;
            case 0x1abbfc: ctx->pc = 0; goto label_1abbfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1abb0c: 0xae110274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 17));
label_1abb10:
    // 0x1abb10: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1abb14: 0xae120270
    WRITE32(ADD32(GPR_U32(ctx, 16), 624), GPR_U32(ctx, 18));
    // 0x1abb18: 0x8c621858
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6232)));
    // 0x1abb1c: 0x1040005f
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ABC9C; return;
    }
    // 0x1abb24: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1abb28: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1abb2c: 0x1462005b
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1ABC9C; return;
    }
    // 0x1abb34: 0x8c622c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11368)));
    // 0x1abb38: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1abb3c: 0x10400057
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ABC9C; return;
    }
    // 0x1abb44: 0xc602026c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 620)); ctx->f[2] = *(float*)&val; }
    // 0x1abb48: 0xc6010268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 616)); ctx->f[1] = *(float*)&val; }
    // 0x1abb4c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abb50: 0x4602a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[2]);
    // 0x1abb54: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1abb58: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1abb5c: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abb60: 0x0
    // NOP
    // 0x1abb64: 0x45000011
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 616), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1abbac;
    }
    // 0x1abb6c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1abb70: 0xc6020278
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 632)); ctx->f[2] = *(float*)&val; }
    // 0x1abb74: 0xc440cd6c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294954348)); ctx->f[0] = *(float*)&val; }
    // 0x1abb78: 0x46001032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abb7c: 0x0
    // NOP
    // 0x1abb80: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 616)); ctx->f[1] = *(float*)&val; }
        goto label_1abb9c;
    }
    // 0x1abb88: 0x46020836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abb8c: 0x0
    // NOP
    // 0x1abb90: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1abb98;
    }
label_1abb98:
    // 0x1abb98: 0xc6010268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 616)); ctx->f[1] = *(float*)&val; }
label_1abb9c:
    // 0x1abb9c: 0xc6000288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 648)); ctx->f[0] = *(float*)&val; }
    // 0x1abba0: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abba4: 0x10000013
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1abbf4;
    }
label_1abbac:
    // 0x1abbac: 0x46021834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abbb0: 0x0
    // NOP
    // 0x1abbb4: 0x45000011
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1abbfc;
    }
    // 0x1abbbc: 0xc6020278
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 632)); ctx->f[2] = *(float*)&val; }
    // 0x1abbc0: 0xc440cd6c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294954348)); ctx->f[0] = *(float*)&val; }
    // 0x1abbc4: 0x46001032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abbc8: 0x0
    // NOP
    // 0x1abbcc: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 616)); ctx->f[1] = *(float*)&val; }
        goto label_1abbe8;
    }
    // 0x1abbd4: 0x46011036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abbd8: 0x0
    // NOP
    // 0x1abbdc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1abbe4;
    }
label_1abbe4:
    // 0x1abbe4: 0xc6010268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 616)); ctx->f[1] = *(float*)&val; }
label_1abbe8:
    // 0x1abbe8: 0xc6000288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 648)); ctx->f[0] = *(float*)&val; }
    // 0x1abbec: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abbf0: 0x0
    // NOP
label_1abbf4:
    // 0x1abbf4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1abbfc;
    }
label_1abbfc:
    // 0x1abbfc: 0x1060000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1abc28(rdram, ctx, runtime); return;
    }
    // 0x1abc04: 0x8e020284
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 644)));
    // 0x1abc08: 0x14400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1abc28(rdram, ctx, runtime); return;
    }
    // 0x1abc10: 0x8e030280
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 640)));
    // 0x1abc14: 0x10600004
    WRITE32(ADD32(GPR_U32(ctx, 16), 644), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1abc28(rdram, ctx, runtime); return;
    }
    // 0x1abc1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1abc20: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1abc28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1abc28
// Address: 0x1abc28 - 0x1abc74

void entry_1abc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abc28: 0x1220001a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_1abc94(rdram, ctx, runtime); return;
    }
    // 0x1abc30: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1abc34: 0xc6000288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 648)); ctx->f[0] = *(float*)&val; }
    // 0x1abc38: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abc3c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1abc40: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1abc44: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1abc48: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abc4c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1abc50: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1abc54: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abc58: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1abc5c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1abc60: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1abc64: 0xe6000268
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 616), *(uint32_t*)&val); }
    // 0x1abc68: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abc6c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1abc74);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1abc74
// Address: 0x1abc74 - 0x1abc80

void entry_1abc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abc74: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1abc78: 0xc06af88
    SET_GPR_U32(ctx, 31, 0x1abc80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTimerTimers__FP5TIMER6TIMERS(rdram, ctx, runtime); return;
}


// Function: entry_1abc80
// Address: 0x1abc80 - 0x1abc94

void entry_1abc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abc80: 0x8e02028c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 652)));
    // 0x1abc84: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1abc94(rdram, ctx, runtime); return;
    }
    // 0x1abc8c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1abc94);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1abc94
// Address: 0x1abc94 - 0x1abda8

void entry_1abc94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1abc94) {
        switch (ctx->pc) {
            case 0x1abc9c: ctx->pc = 0; goto label_1abc9c;
            case 0x1abce0: ctx->pc = 0; goto label_1abce0;
            case 0x1abcec: ctx->pc = 0; goto label_1abcec;
            case 0x1abd30: ctx->pc = 0; goto label_1abd30;
            case 0x1abd40: ctx->pc = 0; goto label_1abd40;
            case 0x1abd44: ctx->pc = 0; goto label_1abd44;
            case 0x1abd58: ctx->pc = 0; goto label_1abd58;
            case 0x1abd88: ctx->pc = 0; goto label_1abd88;
            case 0x1abd8c: ctx->pc = 0; goto label_1abd8c;
            case 0x1abd90: ctx->pc = 0; goto label_1abd90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1abc94: 0xc6000268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 616)); ctx->f[0] = *(float*)&val; }
    // 0x1abc98: 0x46000505
    ctx->f[20] = FPU_ABS_S(ctx->f[0]);
label_1abc9c:
    // 0x1abc9c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1abca0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1abca4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1abca8: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abcac: 0x0
    // NOP
    // 0x1abcb0: 0x4500000e
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1abcec;
    }
    // 0x1abcb8: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1abcbc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1abcc0: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1abcc4: 0x0
    // NOP
    // 0x1abcc8: 0x10950008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 21)) {
        goto label_1abcec;
    }
    // 0x1abcd0: 0x2403000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1abcd4: 0x82001a
    { int32_t divisor = GPR_S32(ctx, 2); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 4) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 2) % divisor); } else { ctx->lo = (GPR_S32(ctx,4) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,2); } }
    // 0x1abcd8: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1abce0;
    }
label_1abce0:
    // 0x1abce0: 0x2417002e
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 46));
    // 0x1abce4: 0x10000017
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1abd44;
    }
label_1abcec:
    // 0x1abcec: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1abcf0: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1abcf4: 0x0
    // NOP
    // 0x1abcf8: 0x1492000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 60));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 18)) {
        goto label_1abd30;
    }
    // 0x1abd00: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1abd04: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1abd08: 0x14620013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 6232));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1abd58;
    }
    // 0x1abd10: 0xc6020264
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 612)); ctx->f[2] = *(float*)&val; }
    // 0x1abd14: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1abd18: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1abd1c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1abd20: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1abd24: 0x0
    // NOP
    // 0x1abd28: 0x4500000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 60));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1abd58;
    }
label_1abd30:
    // 0x1abd30: 0x2403003c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 60));
    // 0x1abd34: 0x82001a
    { int32_t divisor = GPR_S32(ctx, 2); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 4) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 2) % divisor); } else { ctx->lo = (GPR_S32(ctx,4) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,2); } }
    // 0x1abd38: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1abd40;
    }
label_1abd40:
    // 0x1abd40: 0x2417003a
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 58));
label_1abd44:
    // 0x1abd44: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1abd48: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x1abd4c: 0x2810
    SET_GPR_U32(ctx, 5, ctx->hi);
    // 0x1abd50: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1abd54: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_1abd58:
    // 0x1abd58: 0x10c00024
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1abdec(rdram, ctx, runtime); return;
    }
    // 0x1abd60: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1abd64: 0x2446cd50
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954320));
    // 0x1abd68: 0x2a62000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 10));
    // 0x1abd6c: 0x10400006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1abd88;
    }
    // 0x1abd74: 0x14e00005
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        goto label_1abd8c;
    }
    // 0x1abd7c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1abd80: 0x10000003
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 2), 4294954336));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1abd90;
    }
label_1abd88:
    // 0x1abd88: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1abd8c:
    // 0x1abd8c: 0x244acd68
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 2), 4294954344));
label_1abd90:
    // 0x1abd90: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1abd94: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1abd98: 0x260582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1abd9c: 0x24070054
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 84));
    // 0x1abda0: 0xc07882e
    SET_GPR_U32(ctx, 31, 0x1abda8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    _snprintf(rdram, ctx, runtime); return;
}


// Function: entry_1abda8
// Address: 0x1abda8 - 0x1abdb8

void entry_1abda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abda8: 0xc60c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 524)); ctx->f[12] = *(float*)&val; }
    // 0x1abdac: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1abdb0: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1abdb8);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1abdb8
// Address: 0x1abdb8 - 0x1abdc4

void entry_1abdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abdb8: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1abdbc: 0xc057106
    SET_GPR_U32(ctx, 31, 0x1abdc4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_1abdc4
// Address: 0x1abdc4 - 0x1abde4

void entry_1abdc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abdc4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1abdc8: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1abdcc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1abdd0: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1abdd4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1abdd8: 0xc44d0048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[13] = *(float*)&val; }
    // 0x1abddc: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1abde4);
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[13]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1abde4
// Address: 0x1abde4 - 0x1abdec

void entry_1abde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abde4: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1abdec);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1abdec
// Address: 0x1abdec - 0x1abe20

void entry_1abdec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abdec: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1abdf0: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1abdf4: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1abdf8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1abdfc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1abe00: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1abe04: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1abe08: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1abe0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1abe10: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1abe14: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1abe18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetTimerTimers__FP5TIMER6TIMERS
// Address: 0x1abe20 - 0x1abe40

void FUN_001ABE60__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abe60: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1abe64: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1abe6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1abe70; return;
}


// Function: FUN_001abe70
// Address: 0x1abe70 - 0x1abe94

void FUN_001abe70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abe70: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1abe74: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1abe78: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1abe7c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1abe80: 0xe7b70038
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    // 0x1abe84: 0xe7b60030
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x1abe88: 0xe7b50028
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    // 0x1abe8c: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1abe94);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1abe94
// Address: 0x1abe94 - 0x1abe9c

void entry_1abe94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abe94: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1abe9c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1abe9c
// Address: 0x1abe9c - 0x1abf9c

void entry_1abe9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1abe9c) {
        switch (ctx->pc) {
            case 0x1abf1c: ctx->pc = 0; goto label_1abf1c;
            case 0x1abf38: ctx->pc = 0; goto label_1abf38;
            case 0x1abf40: ctx->pc = 0; goto label_1abf40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1abe9c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1abea0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1abea4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1abea8: 0x8c6423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x1abeac: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1abeb0: 0xe6000278
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 632), *(uint32_t*)&val); }
    // 0x1abeb4: 0xe600020c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 524), *(uint32_t*)&val); }
    // 0x1abeb8: 0xae000274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 0));
    // 0x1abebc: 0x8c8219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6616)));
    // 0x1abec0: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1abec4: 0x2c830005
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 5));
    // 0x1abec8: 0x1060005c
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC03C; return;
    }
    // 0x1abed0: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1abed4: 0x2442cd70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294954352));
    // 0x1abed8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1abedc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1abee0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1abee8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1abeec: 0x10000012
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1abf38;
    }
    // 0x1abef4: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1abef8: 0x1000000f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1abf38;
    }
    // 0x1abf00: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1abf04: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1abf08: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1abf1c;
    }
    // 0x1abf10: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1abf14: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1abf18: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
label_1abf1c:
    // 0x1abf1c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1abf20: 0xae020260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
    // 0x1abf24: 0xae030264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 3));
    // 0x1abf28: 0x10000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 628), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1abf40;
    }
    // 0x1abf30: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1abf34: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
label_1abf38:
    // 0x1abf38: 0xae020260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
    // 0x1abf3c: 0xae030264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 3));
label_1abf40:
    // 0x1abf40: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1abf44: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1abf48: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1abf4c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1abf50: 0xc44143b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 17328)); ctx->f[1] = *(float*)&val; }
    // 0x1abf54: 0xc46243b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 17332)); ctx->f[2] = *(float*)&val; }
    // 0x1abf58: 0xc48343b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 17336)); ctx->f[3] = *(float*)&val; }
    // 0x1abf5c: 0xc4a443bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 17340)); ctx->f[4] = *(float*)&val; }
    // 0x1abf60: 0xc600020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 524)); ctx->f[0] = *(float*)&val; }
    // 0x1abf64: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1abf68: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1abf6c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1abf70: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1abf74: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1abf78: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1abf7c: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1abf80: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1abf84: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1abf88: 0xe6010280
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 640), *(uint32_t*)&val); }
    // 0x1abf8c: 0xe6020284
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 644), *(uint32_t*)&val); }
    // 0x1abf90: 0xe6030288
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 648), *(uint32_t*)&val); }
    // 0x1abf94: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1abf9c);
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 652), *(uint32_t*)&val); }
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1abf9c
// Address: 0x1abf9c - 0x1abfc8

void entry_1abf9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abf9c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1abfa0: 0x2405007a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 122));
    // 0x1abfa4: 0x8c82004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 76)));
    // 0x1abfa8: 0xc4960008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[22] = *(float*)&val; }
    // 0x1abfac: 0x4680b5a0
    ctx->f[22] = FPU_CVT_S_W(*(int32_t*)&ctx->f[22]);
    // 0x1abfb0: 0xc4800048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1abfb4: 0x84430018
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1abfb8: 0x8c46001c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1abfbc: 0x4600b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x1abfc0: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1abfc8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1abfc8
// Address: 0x1abfc8 - 0x1abff4

void entry_1abfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abfc8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1abfcc: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1abfd0: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1abfd4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1abfd8: 0xc4540008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[20] = *(float*)&val; }
    // 0x1abfdc: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x1abfe0: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1abfe4: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1abfe8: 0x4614ab40
    ctx->f[13] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x1abfec: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1abff4);
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[23]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1abff4
// Address: 0x1abff4 - 0x1abffc

void entry_1abff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1abff4: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1abffc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1abffc
// Address: 0x1abffc - 0x1ac060

void entry_1abffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1abffc) {
        switch (ctx->pc) {
            case 0x1ac03c: ctx->pc = 0; goto label_1ac03c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1abffc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ac000: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ac004: 0x4617ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[23]);
    // 0x1ac008: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ac00c: 0x8e030264
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x1ac010: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ac014: 0x4600b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x1ac018: 0xae00027c
    WRITE32(ADD32(GPR_U32(ctx, 16), 636), GPR_U32(ctx, 0));
    // 0x1ac01c: 0x430018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1ac020: 0xae02026c
    WRITE32(ADD32(GPR_U32(ctx, 16), 620), GPR_U32(ctx, 2));
    // 0x1ac024: 0x4614ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x1ac028: 0xae030270
    WRITE32(ADD32(GPR_U32(ctx, 16), 624), GPR_U32(ctx, 3));
    // 0x1ac02c: 0xe6160290
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 16), 656), *(uint32_t*)&val); }
    // 0x1ac030: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x1ac034: 0xe6150294
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 660), *(uint32_t*)&val); }
    // 0x1ac038: 0xae040268
    WRITE32(ADD32(GPR_U32(ctx, 16), 616), GPR_U32(ctx, 4));
label_1ac03c:
    // 0x1ac03c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ac040: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ac044: 0xc7b70038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[23] = *(float*)&val; }
    // 0x1ac048: 0xc7b60030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[22] = *(float*)&val; }
    // 0x1ac04c: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x1ac050: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1ac054: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ac05c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ac060; return;
}


// Function: FUN_001ac060
// Address: 0x1ac060 - 0x1ac0e8

void FUN_001ac060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac060) {
        switch (ctx->pc) {
            case 0x1ac090: ctx->pc = 0; goto label_1ac090;
            case 0x1ac098: ctx->pc = 0; goto label_1ac098;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac060: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ac064: 0x8ce20270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 624)));
    // 0x1ac068: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ac06c: 0x1c40000a
    WRITE32(ADD32(GPR_U32(ctx, 7), 624), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) > 0) {
        goto label_1ac098;
    }
    // 0x1ac074: 0x8ce2026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 620)));
    // 0x1ac078: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ac07c: 0x1c400004
    WRITE32(ADD32(GPR_U32(ctx, 7), 620), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) > 0) {
        goto label_1ac090;
    }
    // 0x1ac084: 0xace00270
    WRITE32(ADD32(GPR_U32(ctx, 7), 624), GPR_U32(ctx, 0));
    // 0x1ac088: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 7), 620), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ac098;
    }
label_1ac090:
    // 0x1ac090: 0x8ce20264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 612)));
    // 0x1ac094: 0xace20270
    WRITE32(ADD32(GPR_U32(ctx, 7), 624), GPR_U32(ctx, 2));
label_1ac098:
    // 0x1ac098: 0x8ce2026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 620)));
    // 0x1ac09c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ac0a0: 0x8ce50264
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 612)));
    // 0x1ac0a4: 0xc4e10268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 616)); ctx->f[1] = *(float*)&val; }
    // 0x1ac0a8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ac0ac: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ac0b0: 0x8ce40270
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 624)));
    // 0x1ac0b4: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1ac0b8: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1ac0bc: 0x3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x1ac0c0: 0x451018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1ac0c4: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1ac0c8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1ac0cc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ac0d0: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1ac0d4: 0xe4e00278
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 632), *(uint32_t*)&val); }
    // 0x1ac0d8: 0xc4c1185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1ac0dc: 0x3e00008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 636), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ac0e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ac0e8; return;
}


// Function: FUN_001ac0e8
// Address: 0x1ac0e8 - 0x1ac1ac

void FUN_001ac0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac0e8) {
        switch (ctx->pc) {
            case 0x1ac16c: ctx->pc = 0; goto label_1ac16c;
            case 0x1ac188: ctx->pc = 0; goto label_1ac188;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac0e8: 0x27bdff00
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967040));
    // 0x1ac0ec: 0x7fb500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 21));
    // 0x1ac0f0: 0x7fb400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 20));
    // 0x1ac0f4: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    // 0x1ac0f8: 0x7fb30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 19));
    // 0x1ac0fc: 0xe7b700f8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 248), *(uint32_t*)&val); }
    // 0x1ac100: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ac104: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x1ac108: 0x7fb600c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 22));
    // 0x1ac10c: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x1ac110: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x1ac114: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x1ac118: 0xe7b600f0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 240), *(uint32_t*)&val); }
    // 0x1ac11c: 0xe7b500e8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 232), *(uint32_t*)&val); }
    // 0x1ac120: 0xe7b400e0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 224), *(uint32_t*)&val); }
    // 0x1ac124: 0x4480b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 0);
    // 0x1ac128: 0xc662027c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 636)); ctx->f[2] = *(float*)&val; }
    // 0x1ac12c: 0x46171032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ac130: 0x0
    // NOP
    // 0x1ac134: 0x45010014
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ac188;
    }
    // 0x1ac13c: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1ac140: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ac144: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ac148: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ac14c: 0x460200c1
    ctx->f[3] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ac150: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ac154: 0x45000005
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ac16c;
    }
    // 0x1ac15c: 0x46031840
    ctx->f[1] = FPU_ADD_S(ctx->f[3], ctx->f[3]);
    // 0x1ac160: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ac164: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ac168: 0x460105c1
    ctx->f[23] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
label_1ac16c:
    // 0x1ac16c: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x1ac170: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ac174: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ac178: 0x0
    // NOP
    // 0x1ac17c: 0x45010002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ac188;
    }
    // 0x1ac184: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ac188:
    // 0x1ac188: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1ac18c: 0xc66c0274
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 628)); ctx->f[12] = *(float*)&val; }
    // 0x1ac190: 0xc44e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1ac194: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1ac198: 0xc66d0278
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 632)); ctx->f[13] = *(float*)&val; }
    // 0x1ac19c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ac1a0: 0x3c10ff80
    SET_GPR_U32(ctx, 16, ((uint32_t)65408 << 16));
    // 0x1ac1a4: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1ac1ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 17344));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1ac1ac
// Address: 0x1ac1ac - 0x1ac1ec

void entry_1ac1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac1ac: 0x36108080
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 32896));
    // 0x1ac1b0: 0xc675028c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 652)); ctx->f[21] = *(float*)&val; }
    // 0x1ac1b4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac1b8: 0xc662021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[2] = *(float*)&val; }
    // 0x1ac1bc: 0x241100c0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 192));
    // 0x1ac1c0: 0x46150582
    ctx->f[22] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1ac1c4: 0xc6610220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[1] = *(float*)&val; }
    // 0x1ac1c8: 0xc66c0280
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 640)); ctx->f[12] = *(float*)&val; }
    // 0x1ac1cc: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x1ac1d0: 0xc66d0284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 644)); ctx->f[13] = *(float*)&val; }
    // 0x1ac1d4: 0x460c1300
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[12]);
    // 0x1ac1d8: 0xe6600274
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 628), *(uint32_t*)&val); }
    // 0x1ac1dc: 0x460d0b40
    ctx->f[13] = FPU_ADD_S(ctx->f[1], ctx->f[13]);
    // 0x1ac1e0: 0xc6740288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 648)); ctx->f[20] = *(float*)&val; }
    // 0x1ac1e4: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1ac1ec);
    ctx->f[21] = FPU_SUB_S(ctx->f[21], ctx->f[22]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ac1ec
// Address: 0x1ac1ec - 0x1ac1fc

void entry_1ac1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac1ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac1f0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ac1f4: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ac1fc);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ac1fc
// Address: 0x1ac1fc - 0x1ac210

void entry_1ac1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac1fc: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ac200: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac204: 0xafb00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 16));
    // 0x1ac208: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ac210);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ac210
// Address: 0x1ac210 - 0x1ac21c

void entry_1ac210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac210: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac214: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ac21c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ac21c
// Address: 0x1ac21c - 0x1ac228

void entry_1ac21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac21c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac220: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ac228);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ac228
// Address: 0x1ac228 - 0x1ac26c

void entry_1ac228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac228: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1ac22c: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1ac230: 0xc7ad0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1ac234: 0x24040020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1ac238: 0xc7ae0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1ac23c: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1ac240: 0xc7af000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 12)); ctx->f[15] = *(float*)&val; }
    // 0x1ac244: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1ac248: 0x460e6380
    ctx->f[14] = FPU_ADD_S(ctx->f[12], ctx->f[14]);
    // 0x1ac24c: 0xa3a20022
    WRITE8(ADD32(GPR_U32(ctx, 29), 34), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ac250: 0x460f6bc0
    ctx->f[15] = FPU_ADD_S(ctx->f[13], ctx->f[15]);
    // 0x1ac254: 0xa3a20020
    WRITE8(ADD32(GPR_U32(ctx, 29), 32), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ac258: 0xa3a20021
    WRITE8(ADD32(GPR_U32(ctx, 29), 33), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ac25c: 0x240700c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 192));
    // 0x1ac260: 0xa3b10023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 17));
    // 0x1ac264: 0xc067768
    SET_GPR_U32(ctx, 31, 0x1ac26c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 8832));
    FillScreenRect__FiiiiffffP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ac26c
// Address: 0x1ac26c - 0x1ac47c

void entry_1ac26c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac26c) {
        switch (ctx->pc) {
            case 0x1ac314: ctx->pc = 0; goto label_1ac314;
            case 0x1ac358: ctx->pc = 0; goto label_1ac358;
            case 0x1ac398: ctx->pc = 0; goto label_1ac398;
            case 0x1ac3b0: ctx->pc = 0; goto label_1ac3b0;
            case 0x1ac3f4: ctx->pc = 0; goto label_1ac3f4;
            case 0x1ac434: ctx->pc = 0; goto label_1ac434;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac26c: 0x3c0142c1
    SET_GPR_U32(ctx, 1, ((uint32_t)17089 << 16));
    // 0x1ac270: 0x3421ff7c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 65404));
    // 0x1ac274: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ac278: 0x24050060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1ac27c: 0xc6610284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 644)); ctx->f[1] = *(float*)&val; }
    // 0x1ac280: 0x240400ff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1ac284: 0xc6640220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[4] = *(float*)&val; }
    // 0x1ac288: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1ac28c: 0x3c014340
    SET_GPR_U32(ctx, 1, ((uint32_t)17216 << 16));
    // 0x1ac290: 0x3421ffbe
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 65470));
    // 0x1ac294: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ac298: 0x46012100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[1]);
    // 0x1ac29c: 0xc663021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[3] = *(float*)&val; }
    // 0x1ac2a0: 0x4602b882
    ctx->f[2] = FPU_MUL_S(ctx->f[23], ctx->f[2]);
    // 0x1ac2a4: 0xc6610280
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 640)); ctx->f[1] = *(float*)&val; }
    // 0x1ac2a8: 0x46000164
    *(int32_t*)&ctx->f[5] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ac2ac: 0x44022800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[5]);
    // 0x1ac2b0: 0xa3b10042
    WRITE8(ADD32(GPR_U32(ctx, 29), 66), (uint8_t)GPR_U32(ctx, 17));
    // 0x1ac2b4: 0xa3a00032
    WRITE8(ADD32(GPR_U32(ctx, 29), 50), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ac2b8: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1ac2bc: 0x46001024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[2]);
    // 0x1ac2c0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1ac2c4: 0x322600ff
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 17), 255));
    // 0x1ac2c8: 0x46152100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[21]);
    // 0x1ac2cc: 0xc6600288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 648)); ctx->f[0] = *(float*)&val; }
    // 0x1ac2d0: 0x24420060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 96));
    // 0x1ac2d4: 0x93a90032
    SET_GPR_U32(ctx, 9, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 50)));
    // 0x1ac2d8: 0xe7a30000
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1ac2dc: 0xe7a40004
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1ac2e0: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1ac2e4: 0xe7b6000c
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 12), *(uint32_t*)&val); }
    // 0x1ac2e8: 0xa3a50030
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 5));
    // 0x1ac2ec: 0xa3a40043
    WRITE8(ADD32(GPR_U32(ctx, 29), 67), (uint8_t)GPR_U32(ctx, 4));
    // 0x1ac2f0: 0xa3a20050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ac2f4: 0xa3a30051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 3));
    // 0x1ac2f8: 0xa3a00031
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ac2fc: 0xa3b10033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 17));
    // 0x1ac300: 0xa3b10040
    WRITE8(ADD32(GPR_U32(ctx, 29), 64), (uint8_t)GPR_U32(ctx, 17));
    // 0x1ac304: 0x15260003
    WRITE8(ADD32(GPR_U32(ctx, 29), 65), (uint8_t)GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 9) != GPR_U32(ctx, 6)) {
        goto label_1ac314;
    }
    // 0x1ac30c: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ac398;
    }
label_1ac314:
    // 0x1ac314: 0x126102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 6)));
    // 0x1ac318: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ac358;
    }
    // 0x1ac320: 0x44860000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 6);
    // 0x1ac324: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ac328: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1ac32c: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1ac330: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ac334: 0x44891000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 9);
    // 0x1ac338: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1ac33c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ac340: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ac344: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1ac348: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ac34c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ac350: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ac398;
    }
label_1ac358:
    // 0x1ac358: 0x44890800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 9);
    // 0x1ac35c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ac360: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1ac364: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1ac368: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ac36c: 0x44861800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 6);
    // 0x1ac370: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1ac374: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ac378: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ac37c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1ac380: 0x46170001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[23]);
    // 0x1ac384: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1ac388: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ac38c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ac390: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ac394: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
label_1ac398:
    // 0x1ac398: 0x93a40033
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 51)));
    // 0x1ac39c: 0x93a30043
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x1ac3a0: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1ac3b0;
    }
    // 0x1ac3a8: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ac434;
    }
label_1ac3b0:
    // 0x1ac3b0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1ac3b4: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ac3f4;
    }
    // 0x1ac3bc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1ac3c0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ac3c4: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1ac3c8: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1ac3cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ac3d0: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1ac3d4: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1ac3d8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ac3dc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ac3e0: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1ac3e4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ac3e8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ac3ec: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ac434;
    }
label_1ac3f4:
    // 0x1ac3f4: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1ac3f8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ac3fc: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1ac400: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1ac404: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ac408: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1ac40c: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1ac410: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ac414: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ac418: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1ac41c: 0x46170001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[23]);
    // 0x1ac420: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1ac424: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ac428: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ac42c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ac430: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1ac434:
    // 0x1ac434: 0xa3a20053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ac438: 0x26522280
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1ac43c: 0x8ba20053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ac440: 0x9ba20050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ac444: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ac448: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ac44c: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ac450: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1ac454: 0xc7ad0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1ac458: 0xc7ae0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1ac45c: 0xc7af000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 12)); ctx->f[15] = *(float*)&val; }
    // 0x1ac460: 0x460e6380
    ctx->f[14] = FPU_ADD_S(ctx->f[12], ctx->f[14]);
    // 0x1ac464: 0x93a40020
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ac468: 0x460f6bc0
    ctx->f[15] = FPU_ADD_S(ctx->f[13], ctx->f[15]);
    // 0x1ac46c: 0x93a50021
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 33)));
    // 0x1ac470: 0x93a60022
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 34)));
    // 0x1ac474: 0xc067768
    SET_GPR_U32(ctx, 31, 0x1ac47c);
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 35)));
    FillScreenRect__FiiiiffffP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ac47c
// Address: 0x1ac47c - 0x1ac48c

void entry_1ac47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac47c: 0xc66c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 524)); ctx->f[12] = *(float*)&val; }
    // 0x1ac480: 0x8e640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1ac484: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ac48c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ac48c
// Address: 0x1ac48c - 0x1ac4b8

void entry_1ac48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac48c: 0x8e680004
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1ac490: 0x2405007a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 122));
    // 0x1ac494: 0xc66c021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[12] = *(float*)&val; }
    // 0x1ac498: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ac49c: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1ac4a0: 0xc66d0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[13] = *(float*)&val; }
    // 0x1ac4a4: 0x84440040
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1ac4a8: 0x8c430044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 68)));
    // 0x1ac4ac: 0x8fa60010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ac4b0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ac4b8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ac4b8
// Address: 0x1ac4b8 - 0x1ac4dc

void entry_1ac4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac4b8: 0x44802000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 0);
    // 0x1ac4bc: 0x12800012
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC508; return;
    }
    // 0x1ac4c4: 0x26b01858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1ac4c8: 0x3c014220
    SET_GPR_U32(ctx, 1, ((uint32_t)16928 << 16));
    // 0x1ac4cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ac4d0: 0xc60c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1ac4d4: 0xc081500
    SET_GPR_U32(ctx, 31, 0x1ac4dc);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_1ac4dc
// Address: 0x1ac4dc - 0x1ac4fc

void entry_1ac4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac4dc: 0xc6020010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[2] = *(float*)&val; }
    // 0x1ac4e0: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x1ac4e4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ac4e8: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x1ac4ec: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ac4f0: 0x460c1302
    ctx->f[12] = FPU_MUL_S(ctx->f[2], ctx->f[12]);
    // 0x1ac4f4: 0xc081484
    SET_GPR_U32(ctx, 31, 0x1ac4fc);
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_1ac4fc
// Address: 0x1ac4fc - 0x1ac57c

void entry_1ac4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac4fc) {
        switch (ctx->pc) {
            case 0x1ac508: ctx->pc = 0; goto label_1ac508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac4fc: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1ac500: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ac504: 0x46010102
    ctx->f[4] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
label_1ac508:
    // 0x1ac508: 0xc6630290
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 656)); ctx->f[3] = *(float*)&val; }
    // 0x1ac50c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ac510: 0xc661021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[1] = *(float*)&val; }
    // 0x1ac514: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1ac518: 0xc6620294
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 660)); ctx->f[2] = *(float*)&val; }
    // 0x1ac51c: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ac520: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1ac524: 0xc6600220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[0] = *(float*)&val; }
    // 0x1ac528: 0x9262026c
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 19), 620)));
    // 0x1ac52c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac530: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1ac534: 0xafa30018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 3));
    // 0x1ac538: 0x46140840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[20]);
    // 0x1ac53c: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1ac540: 0xafa0000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 0));
    // 0x1ac544: 0x24420072
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 114));
    // 0x1ac548: 0xafa30014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    // 0x1ac54c: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x1ac550: 0xe7a10000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1ac554: 0x8e640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1ac558: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1ac55c: 0xa3a20030
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ac560: 0xa3a00031
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ac564: 0x83a90030
    SET_GPR_S32(ctx, 9, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ac568: 0x83aa0031
    SET_GPR_S32(ctx, 10, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 49)));
    // 0x1ac56c: 0xa3a90020
    WRITE8(ADD32(GPR_U32(ctx, 29), 32), (uint8_t)GPR_U32(ctx, 9));
    // 0x1ac570: 0xa3aa0021
    WRITE8(ADD32(GPR_U32(ctx, 29), 33), (uint8_t)GPR_U32(ctx, 10));
    // 0x1ac574: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1ac57c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ac57c
// Address: 0x1ac57c - 0x1ac584

void entry_1ac57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac57c: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ac584);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ac584
// Address: 0x1ac584 - 0x1ac5c0

void entry_1ac584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac584: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ac588: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ac58c: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ac590: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ac594: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ac598: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ac59c: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ac5a0: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ac5a4: 0xc7b700f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[23] = *(float*)&val; }
    // 0x1ac5a8: 0xc7b600f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[22] = *(float*)&val; }
    // 0x1ac5ac: 0xc7b500e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[21] = *(float*)&val; }
    // 0x1ac5b0: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x1ac5b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ac5bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ac5c0; return;
}


// Function: PostNoteLoad__FP4NOTE
// Address: 0x1ac5c0 - 0x1ac5d4

void entry_1ac5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac5d4: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ac5d8: 0x3c013fa0
    SET_GPR_U32(ctx, 1, ((uint32_t)16288 << 16));
    // 0x1ac5dc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ac5e0: 0x8ca3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x1ac5e4: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1ac5e8: 0x84640008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ac5ec: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1ac5f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ac5f8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ac5f8
// Address: 0x1ac5f8 - 0x1ac604

void entry_1ac5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac5f8: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1ac5fc: 0xc057062
    SET_GPR_U32(ctx, 31, 0x1ac604);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_1ac604
// Address: 0x1ac604 - 0x1ac61c

void entry_1ac604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac604: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC624; return;
    }
    // 0x1ac60c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ac610: 0x244243d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17360));
    // 0x1ac614: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ac61c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ac61c
// Address: 0x1ac61c - 0x1ac638

void entry_1ac61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac61c) {
        switch (ctx->pc) {
            case 0x1ac624: ctx->pc = 0; goto label_1ac624;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac61c: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x1ac620: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1ac624:
    // 0x1ac624: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ac628: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ac62c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ac634: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ac638; return;
}


// Function: SetNoteAchzDraw__FP4NOTEPc
// Address: 0x1ac638 - 0x1ac660

void entry_1ac660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac660: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC680; return;
    }
    // 0x1ac668: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ac66c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ac670: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1ac678);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1ac678
// Address: 0x1ac678 - 0x1ac69c

void entry_1ac678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac678) {
        switch (ctx->pc) {
            case 0x1ac680: ctx->pc = 0; goto label_1ac680;
            case 0x1ac68c: ctx->pc = 0; goto label_1ac68c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac678: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ac68c;
    }
label_1ac680:
    // 0x1ac680: 0xa2200008
    WRITE8(ADD32(GPR_U32(ctx, 17), 8), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ac684: 0x26300008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1ac688: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1ac68c:
    // 0x1ac68c: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ac690: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1ac694: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ac69c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ac69c
// Address: 0x1ac69c - 0x1ac6ac

void entry_1ac69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac69c: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ac6a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac6a4: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ac6ac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ac6ac
// Address: 0x1ac6ac - 0x1ac6c0

void entry_1ac6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac6ac: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ac6b0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ac6b4: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1ac6b8: 0xc0578a4
    SET_GPR_U32(ctx, 31, 0x1ac6c0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 180));
    GetExtents__9CRichTextPfT1f(rdram, ctx, runtime); return;
}


// Function: entry_1ac6c0
// Address: 0x1ac6c0 - 0x1ac6dc

void entry_1ac6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac6c0) {
        switch (ctx->pc) {
            case 0x1ac6d4: ctx->pc = 0; goto label_1ac6d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac6c0: 0x82220008
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1ac6c4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1ac6c8: 0x10400002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ac6d4;
    }
    // 0x1ac6d0: 0xc7ad00b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 180)); ctx->f[13] = *(float*)&val; }
label_1ac6d4:
    // 0x1ac6d4: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1ac6dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1ac6dc
// Address: 0x1ac6dc - 0x1ac6e4

void entry_1ac6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac6dc: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ac6e4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ac6e4
// Address: 0x1ac6e4 - 0x1ac700

void entry_1ac6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac6e4: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1ac6e8: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ac6ec: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ac6f0: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1ac6f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ac6fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ac700; return;
}


// Function: DrawNote__FP4NOTE
// Address: 0x1ac700 - 0x1ac778

void entry_1ac778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac778: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ac77c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ac780: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ac788);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ac788
// Address: 0x1ac788 - 0x1ac798

void entry_1ac788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac788: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ac78c: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ac790: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ac798);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ac798
// Address: 0x1ac798 - 0x1ac7a4

void entry_1ac798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac798: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ac79c: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ac7a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ac7a4
// Address: 0x1ac7a4 - 0x1ac7b0

void entry_1ac7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac7a4: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ac7a8: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ac7b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ac7b0
// Address: 0x1ac7b0 - 0x1ac814

void entry_1ac7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac7b0: 0x8e230210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1ac7b4: 0x5060001d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1AC82C; return;
    }
    // 0x1ac7bc: 0x8862001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ac7c0: 0x98620018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ac7c4: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ac7c8: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ac7cc: 0x9062001b
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 27)));
    // 0x1ac7d0: 0xc621023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[1] = *(float*)&val; }
    // 0x1ac7d4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1ac7d8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ac7dc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ac7e0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ac7e4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ac7e8: 0xa062001b
    WRITE8(ADD32(GPR_U32(ctx, 3), 27), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ac7ec: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1ac7f0: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1ac7f4: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1ac814(rdram, ctx, runtime); return;
    }
    // 0x1ac7fc: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1ac800: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ac804: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1ac808: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1ac80c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ac814);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ac814
// Address: 0x1ac814 - 0x1ac838

void entry_1ac814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac814) {
        switch (ctx->pc) {
            case 0x1ac82c: ctx->pc = 0; goto label_1ac82c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac814: 0x8e220210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1ac818: 0x8ba30033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ac81c: 0x9ba30030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1ac820: 0xa843001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ac824: 0xb8430018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ac828: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1ac82c:
    // 0x1ac82c: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ac830: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ac838);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ac838
// Address: 0x1ac838 - 0x1ac84c

void entry_1ac838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac838: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ac83c: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ac840: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ac844: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ac84c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ac84c
// Address: 0x1ac84c - 0x1ac860

void entry_1ac84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac84c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ac850: 0x26472280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1ac854: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ac858: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x1ac860);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ac860
// Address: 0x1ac860 - 0x1ac868

void entry_1ac860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac860: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ac868);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ac868
// Address: 0x1ac868 - 0x1ac888

void entry_1ac868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac868: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1ac86c: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1ac870: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ac874: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ac878: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1ac87c: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1ac880: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ac888
// Address: 0x1ac888 - 0x1ac89c

void FUN_001ac888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac888: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ac88c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ac890: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ac894: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1ac89c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ac89c
// Address: 0x1ac89c - 0x1ac8c4

void entry_1ac89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac89c: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ac8a0: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x1ac8a4: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1ac8a8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ac8ac: 0x8ca3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x1ac8b0: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1ac8b4: 0x84640008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ac8b8: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1ac8bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ac8c4);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ac8c4
// Address: 0x1ac8c4 - 0x1ac8dc

void entry_1ac8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac8c4: 0x3c03df7f
    SET_GPR_U32(ctx, 3, ((uint32_t)57215 << 16));
    // 0x1ac8c8: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1ac8cc: 0x34637f7f
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 32639));
    // 0x1ac8d0: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ac8d4: 0xc057062
    SET_GPR_U32(ctx, 31, 0x1ac8dc);
    WRITE32(ADD32(GPR_U32(ctx, 16), 520), GPR_U32(ctx, 3));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_1ac8dc
// Address: 0x1ac8dc - 0x1ac8f4

void entry_1ac8dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac8dc: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC8FC; return;
    }
    // 0x1ac8e4: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ac8e8: 0x244243f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17392));
    // 0x1ac8ec: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ac8f4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ac8f4
// Address: 0x1ac8f4 - 0x1ac910

void entry_1ac8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac8f4) {
        switch (ctx->pc) {
            case 0x1ac8fc: ctx->pc = 0; goto label_1ac8fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac8f4: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x1ac8f8: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1ac8fc:
    // 0x1ac8fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ac900: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ac904: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ac90c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ac910; return;
}


// Function: FUN_001ac910
// Address: 0x1ac910 - 0x1ac938

void FUN_001ac910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac910: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ac914: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ac918: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ac91c: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ac920: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ac924: 0x8e020250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    // 0x1ac928: 0x14400005
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC940; return;
    }
    // 0x1ac930: 0xc06a93c
    SET_GPR_U32(ctx, 31, 0x1ac938);
    SetBlotAchzDraw__FP4BLOTPc(rdram, ctx, runtime); return;
}


// Function: entry_1ac938
// Address: 0x1ac938 - 0x1ac958

void entry_1ac938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac938) {
        switch (ctx->pc) {
            case 0x1ac940: ctx->pc = 0; goto label_1ac940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac938: 0x10000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC980; return;
    }
label_1ac940:
    // 0x1ac940: 0x440000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 4));
    if (GPR_S32(ctx, 2) < 0) {
        entry_1ac97c(rdram, ctx, runtime); return;
    }
    // 0x1ac948: 0x1040000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ac97c(rdram, ctx, runtime); return;
    }
    // 0x1ac950: 0xc07d9ce
    SET_GPR_U32(ctx, 31, 0x1ac958);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    strcmp(rdram, ctx, runtime); return;
}


// Function: entry_1ac958
// Address: 0x1ac958 - 0x1ac97c

void entry_1ac958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac958: 0x10400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ac97c(rdram, ctx, runtime); return;
    }
    // 0x1ac960: 0xae110264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 17));
    // 0x1ac964: 0xae020260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
    // 0x1ac968: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ac96c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ac970: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1ac974: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ac97c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ac97c
// Address: 0x1ac97c - 0x1ac990

void entry_1ac97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac97c) {
        switch (ctx->pc) {
            case 0x1ac980: ctx->pc = 0; goto label_1ac980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac97c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1ac980:
    // 0x1ac980: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ac984: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ac988: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ac990
// Address: 0x1ac990 - 0x1ac9c0

void FUN_001ac990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac990: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ac994: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ac998: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ac99c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ac9a0: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ac9a4: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC9C4; return;
    }
    // 0x1ac9ac: 0x14a00005
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AC9C4; return;
    }
    // 0x1ac9b4: 0x8e050264
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x1ac9b8: 0xc06a93c
    SET_GPR_U32(ctx, 31, 0x1ac9c0);
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 0));
    SetBlotAchzDraw__FP4BLOTPc(rdram, ctx, runtime); return;
}


// Function: entry_1ac9c0
// Address: 0x1ac9c0 - 0x1ac9cc

void entry_1ac9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac9c0) {
        switch (ctx->pc) {
            case 0x1ac9c4: ctx->pc = 0; goto label_1ac9c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac9c0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1ac9c4:
    // 0x1ac9c4: 0xc06aa66
    SET_GPR_U32(ctx, 31, 0x1ac9cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime); return;
}


// Function: entry_1ac9cc
// Address: 0x1ac9cc - 0x1ac9e0

void entry_1ac9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac9cc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ac9d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ac9d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ac9dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ac9e0; return;
}


// Function: FUN_001ac9e0
// Address: 0x1ac9e0 - 0x1ac9fc

void FUN_001ac9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ac9e0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ac9e4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ac9e8: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ac9ec: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ac9f0: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ac9f4: 0xc06aab2
    SET_GPR_U32(ctx, 31, 0x1ac9fc);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FIncludeBlotForPeg__FP4BLOTT0(rdram, ctx, runtime); return;
}


// Function: entry_1ac9fc
// Address: 0x1ac9fc - 0x1aca30

void entry_1ac9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ac9fc) {
        switch (ctx->pc) {
            case 0x1aca14: ctx->pc = 0; goto label_1aca14;
            case 0x1aca18: ctx->pc = 0; goto label_1aca18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ac9fc: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1aca14;
    }
    // 0x1aca04: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1aca08: 0x10400003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1aca18;
    }
    // 0x1aca10: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
label_1aca14:
    // 0x1aca14: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1aca18:
    // 0x1aca18: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aca1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aca20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aca24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aca2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aca30; return;
}


// Function: FUN_001aca30
// Address: 0x1aca30 - 0x1aca5c

void FUN_001aca30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aca30) {
        switch (ctx->pc) {
            case 0x1aca54: ctx->pc = 0; goto label_1aca54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aca30: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1aca34: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1aca38: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1aca3c: 0x8c820250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 592)));
    // 0x1aca40: 0x14430004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1aca54;
    }
    // 0x1aca48: 0x8c820260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    // 0x1aca4c: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACA60; return;
    }
label_1aca54:
    // 0x1aca54: 0xc06aa3c
    SET_GPR_U32(ctx, 31, 0x1aca5c);
    ShowBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1aca5c
// Address: 0x1aca5c - 0x1aca68

void entry_1aca5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aca5c) {
        switch (ctx->pc) {
            case 0x1aca60: ctx->pc = 0; goto label_1aca60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aca5c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1aca60:
    // 0x1aca60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001aca68
// Address: 0x1aca68 - 0x1aca9c

void FUN_001aca68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aca68) {
        switch (ctx->pc) {
            case 0x1aca94: ctx->pc = 0; goto label_1aca94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aca68: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1aca6c: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1aca70: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1aca74: 0x8c820250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 592)));
    // 0x1aca78: 0x14430006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1aca94;
    }
    // 0x1aca80: 0x8c820260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    // 0x1aca84: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1aca94;
    }
    // 0x1aca8c: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 4), 608), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1aca9c(rdram, ctx, runtime); return;
    }
label_1aca94:
    // 0x1aca94: 0xc06aa56
    SET_GPR_U32(ctx, 31, 0x1aca9c);
    HideBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1aca9c
// Address: 0x1aca9c - 0x1acaa8

void entry_1aca9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aca9c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1acaa0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawTitle__FP5TITLE
// Address: 0x1acaa8 - 0x1acb24

void entry_1acb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acb24) {
        switch (ctx->pc) {
            case 0x1acb2c: ctx->pc = 0; goto label_1acb2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acb24: 0x10000091
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACD6C; return;
    }
label_1acb2c:
    // 0x1acb2c: 0x26240008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1acb30: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1acb38);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1acb38
// Address: 0x1acb38 - 0x1acbf4

void entry_1acb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acb38) {
        switch (ctx->pc) {
            case 0x1acb88: ctx->pc = 0; goto label_1acb88;
            case 0x1acb9c: ctx->pc = 0; goto label_1acb9c;
            case 0x1acba4: ctx->pc = 0; goto label_1acba4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acb38: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1acb3c: 0x1260008b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACD6C; return;
    }
    // 0x1acb44: 0x44930000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 19);
    // 0x1acb48: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1acb4c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1acb50: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1acb54: 0xc621023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[1] = *(float*)&val; }
    // 0x1acb58: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1acb5c: 0x46000606
    ctx->f[24] = FPU_MOV_S(ctx->f[0]);
    // 0x1acb60: 0x46000906
    ctx->f[4] = FPU_MOV_S(ctx->f[1]);
    // 0x1acb64: 0x46001003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[0] = ctx->f[2] / ctx->f[0];
    // 0x1acb68: 0xc6370224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 548)); ctx->f[23] = *(float*)&val; }
    // 0x1acb6c: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1acb70: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1acb74: 0x0
    // NOP
    // 0x1acb78: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 556)); ctx->f[22] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1acb88;
    }
    // 0x1acb80: 0x10000008
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1acba4;
    }
label_1acb88:
    // 0x1acb88: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1acb8c: 0x0
    // NOP
    // 0x1acb90: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1acb9c;
    }
    // 0x1acb98: 0x46001006
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
label_1acb9c:
    // 0x1acb9c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1acba0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
label_1acba4:
    // 0x1acba4: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1acba8: 0x8e220210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1acbac: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x1acbb0: 0x10400028
    ctx->f[12] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1acc54(rdram, ctx, runtime); return;
    }
    // 0x1acbb8: 0x46041001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[4]);
    // 0x1acbbc: 0xc62d0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 544)); ctx->f[13] = *(float*)&val; }
    // 0x1acbc0: 0x4604bd02
    ctx->f[20] = FPU_MUL_S(ctx->f[23], ctx->f[4]);
    // 0x1acbc4: 0xc6220234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[2] = *(float*)&val; }
    // 0x1acbc8: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x1acbcc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1acbd0: 0x4600b002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x1acbd4: 0xc6350238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[21] = *(float*)&val; }
    // 0x1acbd8: 0x460cb302
    ctx->f[12] = FPU_MUL_S(ctx->f[22], ctx->f[12]);
    // 0x1acbdc: 0x3c10ff80
    SET_GPR_U32(ctx, 16, ((uint32_t)65408 << 16));
    // 0x1acbe0: 0x36108080
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 32896));
    // 0x1acbe4: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1acbe8: 0x460c0b00
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    // 0x1acbec: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1acbf4);
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[2]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1acbf4
// Address: 0x1acbf4 - 0x1acc04

void entry_1acbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acbf4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1acbf8: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1acbfc: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1acc04);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1acc04
// Address: 0x1acc04 - 0x1acc14

void entry_1acc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acc04: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1acc08: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1acc0c: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1acc14);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1acc14
// Address: 0x1acc14 - 0x1acc20

void entry_1acc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acc14: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1acc18: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1acc20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1acc20
// Address: 0x1acc20 - 0x1acc2c

void entry_1acc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acc20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1acc24: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1acc2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1acc2c
// Address: 0x1acc2c - 0x1acc54

void entry_1acc2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acc2c: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1acc30: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1acc34: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 20), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1acc54(rdram, ctx, runtime); return;
    }
    // 0x1acc3c: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1acc40: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1acc44: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1acc48: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1acc4c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1acc54);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1acc54
// Address: 0x1acc54 - 0x1acc74

void entry_1acc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acc54: 0x8e270004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1acc58: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1acc5c: 0x26862280
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 8832));
    // 0x1acc60: 0x8ce2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 76)));
    // 0x1acc64: 0x84440020
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1acc68: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x1acc6c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1acc74);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1acc74
// Address: 0x1acc74 - 0x1acd18

void entry_1acc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acc74) {
        switch (ctx->pc) {
            case 0x1acc88: ctx->pc = 0; goto label_1acc88;
            case 0x1accc4: ctx->pc = 0; goto label_1accc4;
            case 0x1accdc: ctx->pc = 0; goto label_1accdc;
            case 0x1acce0: ctx->pc = 0; goto label_1acce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acc74: 0x1a600034
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x1ACD48; return;
    }
    // 0x1acc7c: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1acc80: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1acc84: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
label_1acc88:
    // 0x1acc88: 0x24830001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1acc8c: 0xc621023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[1] = *(float*)&val; }
    // 0x1acc90: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1acc94: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1acc98: 0x2a41021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 4)));
    // 0x1acc9c: 0x60902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1acca0: 0x46180003
    if (ctx->f[24] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[24];
    // 0x1acca4: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1acca8: 0x46150834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1accac: 0x0
    // NOP
    // 0x1accb0: 0x45000004
    SET_GPR_S32(ctx, 16, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1accc4;
    }
    // 0x1accb8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1accbc: 0x10000008
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1acce0;
    }
label_1accc4:
    // 0x1accc4: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1accc8: 0x0
    // NOP
    // 0x1acccc: 0x45000003
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1accdc;
    }
    // 0x1accd4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1accd8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_1accdc:
    // 0x1accdc: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
label_1acce0:
    // 0x1acce0: 0x8e280004
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1acce4: 0x4601a301
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x1acce8: 0x8e260208
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 520)));
    // 0x1accec: 0x46170802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x1accf0: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1accf4: 0xc62d0228
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 552)); ctx->f[13] = *(float*)&val; }
    // 0x1accf8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1accfc: 0x46166302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[22]);
    // 0x1acd00: 0x84440030
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1acd04: 0x8c430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1acd08: 0x26872280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 20), 8832));
    // 0x1acd0c: 0x1042021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    // 0x1acd10: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1acd18);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1acd18
// Address: 0x1acd18 - 0x1acd34

void entry_1acd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acd18: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1acd1c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1acd20: 0x8cc2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x1acd24: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1acd28: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1acd2c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1acd34);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1acd34
// Address: 0x1acd34 - 0x1acd68

void entry_1acd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acd34) {
        switch (ctx->pc) {
            case 0x1acd48: ctx->pc = 0; goto label_1acd48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acd34: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1acd38: 0x4600b580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[0]);
    // 0x1acd3c: 0x93102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 19)));
    // 0x1acd40: 0x1440ffd1
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACC88; return;
    }
label_1acd48:
    // 0x1acd48: 0x8e270004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1acd4c: 0x26862280
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 8832));
    // 0x1acd50: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1acd54: 0x8ce2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 76)));
    // 0x1acd58: 0x84440038
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x1acd5c: 0x8c43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 60)));
    // 0x1acd60: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1acd68);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1acd68
// Address: 0x1acd68 - 0x1acda0

void entry_1acd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acd68) {
        switch (ctx->pc) {
            case 0x1acd6c: ctx->pc = 0; goto label_1acd6c;
            case 0x1acd70: ctx->pc = 0; goto label_1acd70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acd68: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1acd6c:
    // 0x1acd6c: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1acd70:
    // 0x1acd70: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1acd74: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1acd78: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1acd7c: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1acd80: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1acd84: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1acd88: 0xc7b700b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[23] = *(float*)&val; }
    // 0x1acd8c: 0xc7b600b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[22] = *(float*)&val; }
    // 0x1acd90: 0xc7b500a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[21] = *(float*)&val; }
    // 0x1acd94: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1acd98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostTotalsLoad__FP6TOTALS
// Address: 0x1acda0 - 0x1acdb4

void entry_1acdb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acdb4: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1acdbc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1acdbc
// Address: 0x1acdbc - 0x1acddc

void entry_1acdbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acdbc: 0x8c45004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1acdc0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1acdc4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1acdc8: 0x84a40008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1acdcc: 0x8ca3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x1acdd0: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1acdd4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1acddc);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1acddc
// Address: 0x1acddc - 0x1ace04

void entry_1acddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acddc: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1acde0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1acde4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1acde8: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1acdec: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1acdf0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1acdf4: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1acdf8: 0xe601020c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 524), *(uint32_t*)&val); }
    // 0x1acdfc: 0xc057062
    SET_GPR_U32(ctx, 31, 0x1ace04);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 584), *(uint32_t*)&val); }
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_1ace04
// Address: 0x1ace04 - 0x1ace1c

void entry_1ace04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ace04: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACE24; return;
    }
    // 0x1ace0c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ace10: 0x24424410
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17424));
    // 0x1ace14: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ace1c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ace1c
// Address: 0x1ace1c - 0x1ace38

void entry_1ace1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ace1c) {
        switch (ctx->pc) {
            case 0x1ace24: ctx->pc = 0; goto label_1ace24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ace1c: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x1ace20: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1ace24:
    // 0x1ace24: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ace28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ace2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ace34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ace38; return;
}


// Function: FUN_001ace38
// Address: 0x1ace38 - 0x1ace60

void FUN_001ace38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ace38: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ace3c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ace40: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ace44: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ace48: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ace4c: 0x8e020250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    // 0x1ace50: 0x14400005
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACE68; return;
    }
    // 0x1ace58: 0xc06a93c
    SET_GPR_U32(ctx, 31, 0x1ace60);
    SetBlotAchzDraw__FP4BLOTPc(rdram, ctx, runtime); return;
}


// Function: entry_1ace60
// Address: 0x1ace60 - 0x1ace90

void entry_1ace60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ace60) {
        switch (ctx->pc) {
            case 0x1ace68: ctx->pc = 0; goto label_1ace68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ace60: 0x1000001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACED0; return;
    }
label_1ace68:
    // 0x1ace68: 0x4400018
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 4));
    if (GPR_S32(ctx, 2) < 0) {
        entry_1acecc(rdram, ctx, runtime); return;
    }
    // 0x1ace70: 0x10400017
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACED0; return;
    }
    // 0x1ace78: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ace7c: 0x14400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACE98; return;
    }
    // 0x1ace84: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ace88: 0xc07d9ce
    SET_GPR_U32(ctx, 31, 0x1ace90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    strcmp(rdram, ctx, runtime); return;
}


// Function: entry_1ace90
// Address: 0x1ace90 - 0x1aceac

void entry_1ace90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ace90) {
        switch (ctx->pc) {
            case 0x1ace98: ctx->pc = 0; goto label_1ace98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ace90: 0x1040000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1acecc(rdram, ctx, runtime); return;
    }
label_1ace98:
    // 0x1ace98: 0x12200006
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACEB4; return;
    }
    // 0x1acea0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1acea4: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1aceac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 612));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1aceac
// Address: 0x1aceac - 0x1acecc

void entry_1aceac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aceac) {
        switch (ctx->pc) {
            case 0x1aceb4: ctx->pc = 0; goto label_1aceb4;
            case 0x1acebc: ctx->pc = 0; goto label_1acebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aceac: 0x10000003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1acebc;
    }
label_1aceb4:
    // 0x1aceb4: 0xa2000264
    WRITE8(ADD32(GPR_U32(ctx, 16), 612), (uint8_t)GPR_U32(ctx, 0));
    // 0x1aceb8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1acebc:
    // 0x1acebc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1acec0: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1acec4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1acecc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1acecc
// Address: 0x1acecc - 0x1acee0

void entry_1acecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acecc) {
        switch (ctx->pc) {
            case 0x1aced0: ctx->pc = 0; goto label_1aced0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acecc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1aced0:
    // 0x1aced0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aced4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aced8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001acee0
// Address: 0x1acee0 - 0x1acf40

void FUN_001acee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acee0) {
        switch (ctx->pc) {
            case 0x1acf30: ctx->pc = 0; goto label_1acf30;
            case 0x1acf38: ctx->pc = 0; goto label_1acf38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acee0: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1acee4: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1acee8: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1aceec: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1acef0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1acef4: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1acef8: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1acefc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1acf00: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1acf04: 0x32220002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 2));
    // 0x1acf08: 0x8e720000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1acf0c: 0x1040000d
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACF44; return;
    }
    // 0x1acf14: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acf18: 0x32430002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 18), 2));
    // 0x1acf1c: 0x10600004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294954376));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1acf30;
    }
    // 0x1acf24: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acf28: 0x10000003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954384));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1acf38;
    }
label_1acf30:
    // 0x1acf30: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acf34: 0x2446cd98
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954392));
label_1acf38:
    // 0x1acf38: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1acf40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1acf40
// Address: 0x1acf40 - 0x1acf8c

void entry_1acf40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acf40) {
        switch (ctx->pc) {
            case 0x1acf44: ctx->pc = 0; goto label_1acf44;
            case 0x1acf60: ctx->pc = 0; goto label_1acf60;
            case 0x1acf7c: ctx->pc = 0; goto label_1acf7c;
            case 0x1acf84: ctx->pc = 0; goto label_1acf84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acf40: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_1acf44:
    // 0x1acf44: 0x32220004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 4));
    // 0x1acf48: 0x10400011
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ACF90; return;
    }
    // 0x1acf50: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1acf60;
    }
    // 0x1acf58: 0xa2020000
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1acf5c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
label_1acf60:
    // 0x1acf60: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acf64: 0x32430004
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 18), 4));
    // 0x1acf68: 0x10600004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294954376));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1acf7c;
    }
    // 0x1acf70: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acf74: 0x10000003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954400));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1acf84;
    }
label_1acf7c:
    // 0x1acf7c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acf80: 0x2446cda8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954408));
label_1acf84:
    // 0x1acf84: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1acf8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1acf8c
// Address: 0x1acf8c - 0x1acfd8

void entry_1acf8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1acf8c) {
        switch (ctx->pc) {
            case 0x1acf90: ctx->pc = 0; goto label_1acf90;
            case 0x1acfac: ctx->pc = 0; goto label_1acfac;
            case 0x1acfc8: ctx->pc = 0; goto label_1acfc8;
            case 0x1acfd0: ctx->pc = 0; goto label_1acfd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1acf8c: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_1acf90:
    // 0x1acf90: 0x32220008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 8));
    // 0x1acf94: 0x10400034
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ad068(rdram, ctx, runtime); return;
    }
    // 0x1acf9c: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1acfac;
    }
    // 0x1acfa4: 0xa2020000
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1acfa8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
label_1acfac:
    // 0x1acfac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acfb0: 0x32510008
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 18), 8));
    // 0x1acfb4: 0x12200004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294954416));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1acfc8;
    }
    // 0x1acfbc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acfc0: 0x10000003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954424));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1acfd0;
    }
label_1acfc8:
    // 0x1acfc8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1acfcc: 0x2446cdc0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954432));
label_1acfd0:
    // 0x1acfd0: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1acfd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1acfd8
// Address: 0x1acfd8 - 0x1ad020

void entry_1acfd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1acfd8: 0x1220001f
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_1ad058(rdram, ctx, runtime); return;
    }
    // 0x1acfe0: 0xc6610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1acfe4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1acfe8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1acfec: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1acff0: 0x0
    // NOP
    // 0x1acff4: 0x4500000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 60));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1AD028; return;
    }
    // 0x1acffc: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1ad000: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ad004: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ad008: 0x24a5cdc8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954440));
    // 0x1ad00c: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1ad010: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ad014: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1ad018: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ad020);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ad020
// Address: 0x1ad020 - 0x1ad058

void entry_1ad020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad020) {
        switch (ctx->pc) {
            case 0x1ad028: ctx->pc = 0; goto label_1ad028;
            case 0x1ad040: ctx->pc = 0; goto label_1ad040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad020: 0x1000000e
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD05C; return;
    }
label_1ad028:
    // 0x1ad028: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1ad02c: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1ad030: 0x2402003c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 60));
    // 0x1ad034: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ad038: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1ad040;
    }
label_1ad040:
    // 0x1ad040: 0x24a5cde0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954464));
    // 0x1ad044: 0xc2001a
    { int32_t divisor = GPR_S32(ctx, 2); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 6) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 2) % divisor); } else { ctx->lo = (GPR_S32(ctx,6) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,2); } }
    // 0x1ad048: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x1ad04c: 0x3810
    SET_GPR_U32(ctx, 7, ctx->hi);
    // 0x1ad050: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ad058);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ad058
// Address: 0x1ad058 - 0x1ad068

void entry_1ad058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad058) {
        switch (ctx->pc) {
            case 0x1ad05c: ctx->pc = 0; goto label_1ad05c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad058: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
label_1ad05c:
    // 0x1ad05c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad060: 0xc078860
    SET_GPR_U32(ctx, 31, 0x1ad068);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954488));
    strcpy1(rdram, ctx, runtime); return;
}


// Function: entry_1ad068
// Address: 0x1ad068 - 0x1ad088

void entry_1ad068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad068: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ad06c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ad070: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ad074: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ad078: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ad07c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ad084: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ad088; return;
}


// Function: render_level_info_from_id
// Address: 0x1ad088 - 0x1ad0a4

void entry_1ad0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad0a4) {
        switch (ctx->pc) {
            case 0x1ad0ac: ctx->pc = 0; goto label_1ad0ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad0a4: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD0C4; return;
    }
label_1ad0ac:
    // 0x1ad0ac: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ad0b0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ad0b4: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1ad0b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ad0c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954496));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ad0c0
// Address: 0x1ad0c0 - 0x1ad0d0

void entry_1ad0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad0c0) {
        switch (ctx->pc) {
            case 0x1ad0c4: ctx->pc = 0; goto label_1ad0c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad0c0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1ad0c4:
    // 0x1ad0c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ad0cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ad0d0; return;
}


// Function: render_level_info
// Address: 0x1ad0d0 - 0x1ad124

void entry_1ad124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad124: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ad128: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad12c: 0xc06b3b8
    SET_GPR_U32(ctx, 31, 0x1ad134);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FUN_001acee0(rdram, ctx, runtime); return;
}


// Function: entry_1ad134
// Address: 0x1ad134 - 0x1ad13c

void entry_1ad134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad134: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1ad13c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1ad13c
// Address: 0x1ad13c - 0x1ad154

void entry_1ad13c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad13c: 0x10400016
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD198; return;
    }
    // 0x1ad144: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1ad148: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ad14c: 0xc058052
    SET_GPR_U32(ctx, 31, 0x1ad154);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 4294954512));
    PchzFriendlyFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1ad154
// Address: 0x1ad154 - 0x1ad164

void entry_1ad154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad154: 0x220a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ad158: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ad15c: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1ad164);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1ad164
// Address: 0x1ad164 - 0x1ad190

void entry_1ad164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad164) {
        switch (ctx->pc) {
            case 0x1ad174: ctx->pc = 0; goto label_1ad174;
            case 0x1ad17c: ctx->pc = 0; goto label_1ad17c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad164: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ad174;
    }
    // 0x1ad16c: 0x10000003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4294954520));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ad17c;
    }
label_1ad174:
    // 0x1ad174: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1ad178: 0x2447cd68
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4294954344));
label_1ad17c:
    // 0x1ad17c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ad180: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ad184: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad188: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ad190);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ad190
// Address: 0x1ad190 - 0x1ad1a4

void entry_1ad190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad190) {
        switch (ctx->pc) {
            case 0x1ad198: ctx->pc = 0; goto label_1ad198;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad190: 0x10000009
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD1B8; return;
    }
label_1ad198:
    // 0x1ad198: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ad19c: 0xc058052
    SET_GPR_U32(ctx, 31, 0x1ad1a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PchzFriendlyFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1ad1a4
// Address: 0x1ad1a4 - 0x1ad1b0

void entry_1ad1a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad1a4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ad1a8: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1ad1b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1ad1b0
// Address: 0x1ad1b0 - 0x1ad1c8

void entry_1ad1b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad1b0) {
        switch (ctx->pc) {
            case 0x1ad1b8: ctx->pc = 0; goto label_1ad1b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad1b0: 0x200a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad1b4: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_1ad1b8:
    // 0x1ad1b8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ad1bc: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1ad1c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ad1c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ad1c8
// Address: 0x1ad1c8 - 0x1ad1e8

void entry_1ad1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad1c8: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ad1cc: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ad1d0: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ad1d4: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ad1d8: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ad1dc: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ad1e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: render_hideout_world_info
// Address: 0x1ad1e8 - 0x1ad218

void entry_1ad218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad218: 0x2403044c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x1ad21c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ad220: 0x2031818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1ad224: 0x24424430
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17456));
    // 0x1ad228: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1ad22c: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1ad230: 0x8c8623c0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1ad234: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1ad238: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ad23c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ad240: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1ad244: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1ad24c);
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1ad24c
// Address: 0x1ad24c - 0x1ad254

void entry_1ad24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad24c: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1ad254);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1ad254
// Address: 0x1ad254 - 0x1ad274

void entry_1ad254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad254: 0x8fa70200
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1ad258: 0x10e00007
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD278; return;
    }
    // 0x1ad260: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ad264: 0x8e260438
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1080)));
    // 0x1ad268: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad26c: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ad274);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954624));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ad274
// Address: 0x1ad274 - 0x1ad2b0

void entry_1ad274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad274) {
        switch (ctx->pc) {
            case 0x1ad278: ctx->pc = 0; goto label_1ad278;
            case 0x1ad29c: ctx->pc = 0; goto label_1ad29c;
            case 0x1ad2a4: ctx->pc = 0; goto label_1ad2a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad274: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_1ad278:
    // 0x1ad278: 0x8fa80204
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 516)));
    // 0x1ad27c: 0x1100000d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD2B4; return;
    }
    // 0x1ad284: 0x8fa30200
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1ad288: 0x10600004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294954656));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1ad29c;
    }
    // 0x1ad290: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1ad294: 0x10000003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954520));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ad2a4;
    }
label_1ad29c:
    // 0x1ad29c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1ad2a0: 0x2446cd68
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954344));
label_1ad2a4:
    // 0x1ad2a4: 0x8e27043c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1084)));
    // 0x1ad2a8: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ad2b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ad2b0
// Address: 0x1ad2b0 - 0x1ad2f4

void entry_1ad2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad2b0) {
        switch (ctx->pc) {
            case 0x1ad2b4: ctx->pc = 0; goto label_1ad2b4;
            case 0x1ad2d8: ctx->pc = 0; goto label_1ad2d8;
            case 0x1ad2e4: ctx->pc = 0; goto label_1ad2e4;
            case 0x1ad2e8: ctx->pc = 0; goto label_1ad2e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad2b0: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_1ad2b4:
    // 0x1ad2b4: 0x8fa80208
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 520)));
    // 0x1ad2b8: 0x1100000e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1ad2f4(rdram, ctx, runtime); return;
    }
    // 0x1ad2c0: 0x8fa30200
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1ad2c4: 0x14600004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294954688));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1ad2d8;
    }
    // 0x1ad2cc: 0x8fa20204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 516)));
    // 0x1ad2d0: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ad2e4;
    }
label_1ad2d8:
    // 0x1ad2d8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1ad2dc: 0x10000002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954520));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ad2e8;
    }
label_1ad2e4:
    // 0x1ad2e4: 0x2446cd68
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294954344));
label_1ad2e8:
    // 0x1ad2e8: 0x8e270440
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1088)));
    // 0x1ad2ec: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ad2f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ad2f4
// Address: 0x1ad2f4 - 0x1ad308

void entry_1ad2f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad2f4: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1ad2f8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ad2fc: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1ad300: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ad308);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ad308
// Address: 0x1ad308 - 0x1ad320

void entry_1ad308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad308: 0x7bbf0240
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x1ad30c: 0x7bb20230
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x1ad310: 0x7bb10220
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1ad314: 0x7bb00210
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1ad318: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 592));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetTotalsBlots__FP6TOTALS5BLOTS
// Address: 0x1ad320 - 0x1ad350

void entry_1ad350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad350) {
        switch (ctx->pc) {
            case 0x1ad354: ctx->pc = 0; goto label_1ad354;
            case 0x1ad35c: ctx->pc = 0; goto label_1ad35c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad350: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1ad354:
    // 0x1ad354: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1124), GPR_U32(ctx, 0));
        goto label_1ad35c;
    }
label_1ad35c:
    // 0x1ad35c: 0xc06aa66
    SET_GPR_U32(ctx, 31, 0x1ad364);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime); return;
}


// Function: entry_1ad364
// Address: 0x1ad364 - 0x1ad378

void entry_1ad364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad364: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ad368: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ad36c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ad374: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ad378; return;
}


// Function: ShowTotalsQMARK
// Address: 0x1ad378 - 0x1ad3a4

void entry_1ad3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad3a4) {
        switch (ctx->pc) {
            case 0x1ad3a8: ctx->pc = 0; goto label_1ad3a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad3a4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1ad3a8:
    // 0x1ad3a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HideTotalsQMARK
// Address: 0x1ad3b0 - 0x1ad3e4

void entry_1ad3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad3e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ad3e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawTotals__FP6TOTALS
// Address: 0x1ad3f0 - 0x1ad4d0

void entry_1ad4d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad4d0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ad4d4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ad4d8: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ad4e0);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ad4e0
// Address: 0x1ad4e0 - 0x1ad4f0

void entry_1ad4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad4e0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ad4e4: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ad4e8: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ad4f0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ad4f0
// Address: 0x1ad4f0 - 0x1ad4fc

void entry_1ad4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad4f0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ad4f4: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ad4fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ad4fc
// Address: 0x1ad4fc - 0x1ad508

void entry_1ad4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad4fc: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ad500: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ad508);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ad508
// Address: 0x1ad508 - 0x1ad5ac

void entry_1ad508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad508) {
        switch (ctx->pc) {
            case 0x1ad550: ctx->pc = 0; goto label_1ad550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad508: 0x8e220464
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1124)));
    // 0x1ad50c: 0x5440004c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1AD640; return;
    }
    // 0x1ad514: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ad518: 0x26502280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1ad51c: 0x2443f808
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x1ad520: 0x8c62025c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 604)));
    // 0x1ad524: 0x1040000a
    ctx->f[1] = FPU_MOV_S(ctx->f[23]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ad550;
    }
    // 0x1ad52c: 0x8c620260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 608)));
    // 0x1ad530: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ad550;
    }
    // 0x1ad538: 0x8c4302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 720)));
    // 0x1ad53c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ad540: 0x14620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1ad550;
    }
    // 0x1ad548: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ad54c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
label_1ad550:
    // 0x1ad550: 0x3c014280
    SET_GPR_U32(ctx, 1, ((uint32_t)17024 << 16));
    // 0x1ad554: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ad558: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x1ad55c: 0x34e741ee
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 16878));
    // 0x1ad560: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x1ad564: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1ad568: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1ad56c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad570: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1ad574: 0xa3a00030
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ad578: 0x4614b500
    ctx->f[20] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x1ad57c: 0x3c014284
    SET_GPR_U32(ctx, 1, ((uint32_t)17028 << 16));
    // 0x1ad580: 0x3421ccce
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52430));
    // 0x1ad584: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ad588: 0xa3a00031
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ad58c: 0x24050046
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 70));
    // 0x1ad590: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ad594: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1ad598: 0xa3a00032
    WRITE8(ADD32(GPR_U32(ctx, 29), 50), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ad59c: 0x4601a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x1ad5a0: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ad5a4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1ad5ac);
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 2));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1ad5ac
// Address: 0x1ad5ac - 0x1ad5bc

void entry_1ad5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad5ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad5b0: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x1ad5b4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1ad5bc);
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1ad5bc
// Address: 0x1ad5bc - 0x1ad5cc

void entry_1ad5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad5bc: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1ad5c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad5c4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1ad5cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1ad5cc
// Address: 0x1ad5cc - 0x1ad5d8

void entry_1ad5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad5cc: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ad5d0: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1ad5d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1ad5d8
// Address: 0x1ad5d8 - 0x1ad620

void entry_1ad5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad5d8: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1ad5dc: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1ad5e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ad5e4: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1ad5e8: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1ad5ec: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ad5f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad5f4: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ad5f8: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1ad5fc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ad600: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x1ad604: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1ad608: 0x4602a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[2]);
    // 0x1ad60c: 0x4601a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1ad610: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1ad614: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1ad618: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1ad620);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1ad620
// Address: 0x1ad620 - 0x1ad63c

void entry_1ad620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad620: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1ad624: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad628: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x1ad62c: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x1ad630: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1ad634: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1ad63c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1ad63c
// Address: 0x1ad63c - 0x1ad64c

void entry_1ad63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad63c) {
        switch (ctx->pc) {
            case 0x1ad640: ctx->pc = 0; goto label_1ad640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad63c: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1ad640:
    // 0x1ad640: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ad644: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ad64c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ad64c
// Address: 0x1ad64c - 0x1ad660

void entry_1ad64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad64c: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ad650: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ad654: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad658: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ad660);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ad660
// Address: 0x1ad660 - 0x1ad674

void entry_1ad660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad660: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad664: 0x26472280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1ad668: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ad66c: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x1ad674);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ad674
// Address: 0x1ad674 - 0x1ad67c

void entry_1ad674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad674: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ad67c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ad67c
// Address: 0x1ad67c - 0x1ad6a8

void entry_1ad67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad67c) {
        switch (ctx->pc) {
            case 0x1ad680: ctx->pc = 0; goto label_1ad680;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad67c: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
label_1ad680:
    // 0x1ad680: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1ad684: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ad688: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ad68c: 0xc7b70148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[23] = *(float*)&val; }
    // 0x1ad690: 0xc7b60140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[22] = *(float*)&val; }
    // 0x1ad694: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1ad698: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1ad69c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ad6a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ad6a8; return;
}


// Function: FUN_001ad6a8
// Address: 0x1ad6a8 - 0x1ad6bc

void FUN_001ad6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad6a8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ad6ac: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ad6b0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ad6b4: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1ad6bc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ad6bc
// Address: 0x1ad6bc - 0x1ad6c4

void entry_1ad6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad6bc: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ad6c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ad6c4
// Address: 0x1ad6c4 - 0x1ad6e4

void entry_1ad6c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad6c4: 0x8c45004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1ad6c8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ad6cc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ad6d0: 0x84a40008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1ad6d4: 0x8ca3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x1ad6d8: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1ad6dc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ad6e4);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ad6e4
// Address: 0x1ad6e4 - 0x1ad700

void entry_1ad6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad6e4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ad6e8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ad6ec: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1ad6f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ad6f4: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1ad6f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ad700);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954720));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ad700
// Address: 0x1ad700 - 0x1ad718

void entry_1ad700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad700: 0xae000260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 0));
    // 0x1ad704: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ad708: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ad70c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ad714: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ad718; return;
}


// Function: FUN_001ad718
// Address: 0x1ad718 - 0x1ad72c

void FUN_001ad718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad718: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ad71c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ad720: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ad724: 0xc06a8a6
    SET_GPR_U32(ctx, 31, 0x1ad72c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    UpdateBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ad72c
// Address: 0x1ad72c - 0x1ad784

void entry_1ad72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad72c) {
        switch (ctx->pc) {
            case 0x1ad754: ctx->pc = 0; goto label_1ad754;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad72c: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1ad730: 0x10400016
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD78C; return;
    }
    // 0x1ad738: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1ad73c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
        goto label_1ad754;
    }
    // 0x1ad744: 0x8c432220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8736)));
    // 0x1ad748: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1ad74c: 0x1062000f
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AD78C; return;
    }
label_1ad754:
    // 0x1ad754: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1ad758: 0x24425bc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23488));
    // 0x1ad75c: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1ad760: 0x1464000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1AD790; return;
    }
    // 0x1ad768: 0x8c42002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 44)));
    // 0x1ad76c: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1ad770: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD790; return;
    }
    // 0x1ad778: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1ad77c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ad784);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ad784
// Address: 0x1ad784 - 0x1ad79c

void entry_1ad784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad784) {
        switch (ctx->pc) {
            case 0x1ad78c: ctx->pc = 0; goto label_1ad78c;
            case 0x1ad790: ctx->pc = 0; goto label_1ad790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad784: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AD7A0; return;
    }
label_1ad78c:
    // 0x1ad78c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1ad790:
    // 0x1ad790: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1ad794: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ad79c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ad79c
// Address: 0x1ad79c - 0x1ad7b0

void entry_1ad79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad79c) {
        switch (ctx->pc) {
            case 0x1ad7a0: ctx->pc = 0; goto label_1ad7a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad79c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1ad7a0:
    // 0x1ad7a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ad7a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ad7ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ad7b0; return;
}


// Function: FUN_001ad7b0
// Address: 0x1ad7b0 - 0x1ad7e4

void FUN_001ad7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad7b0: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x1ad7b4: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x1ad7b8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ad7bc: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x1ad7c0: 0x7fb30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 19));
    // 0x1ad7c4: 0x7fb20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 18));
    // 0x1ad7c8: 0x3c13ff80
    SET_GPR_U32(ctx, 19, ((uint32_t)65408 << 16));
    // 0x1ad7cc: 0x7fb10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 17));
    // 0x1ad7d0: 0x36738080
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 19), 32896));
    // 0x1ad7d4: 0xe7b60090
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x1ad7d8: 0xe7b50088
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    // 0x1ad7dc: 0xc06a9e4
    SET_GPR_U32(ctx, 31, 0x1ad7e4);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    DrawBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ad7e4
// Address: 0x1ad7e4 - 0x1ad804

void entry_1ad7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad7e4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ad7e8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1ad7ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ad7f0: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x1ad7f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ad7f8: 0xc44c1868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[12] = *(float*)&val; }
    // 0x1ad7fc: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1ad804);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1ad804
// Address: 0x1ad804 - 0x1ad80c

void entry_1ad804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad804: 0xc081484
    SET_GPR_U32(ctx, 31, 0x1ad80c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_1ad80c
// Address: 0x1ad80c - 0x1ad81c

void entry_1ad80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad80c: 0x46150502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1ad810: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ad814: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ad81c);
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[21]);
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ad81c
// Address: 0x1ad81c - 0x1ad844

void entry_1ad81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad81c: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1ad820: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1ad824: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ad828: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ad82c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ad830: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ad834: 0x4615a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[21]);
    // 0x1ad838: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ad83c: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ad844);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ad844
// Address: 0x1ad844 - 0x1ad858

void entry_1ad844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad844: 0x3c120025
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    // 0x1ad848: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ad84c: 0x2652cee8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294954728));
    // 0x1ad850: 0xc057106
    SET_GPR_U32(ctx, 31, 0x1ad858);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_1ad858
// Address: 0x1ad858 - 0x1ad8bc

void entry_1ad858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad858: 0xc6340008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[20] = *(float*)&val; }
    // 0x1ad85c: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x1ad860: 0xc6210048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1ad864: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x1ad868: 0x3c014160
    SET_GPR_U32(ctx, 1, ((uint32_t)16736 << 16));
    // 0x1ad86c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ad870: 0xc6030238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 568)); ctx->f[3] = *(float*)&val; }
    // 0x1ad874: 0x4615b102
    ctx->f[4] = FPU_MUL_S(ctx->f[22], ctx->f[21]);
    // 0x1ad878: 0x4601a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1ad87c: 0xc60c021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 540)); ctx->f[12] = *(float*)&val; }
    // 0x1ad880: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1ad884: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ad888: 0x461518c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[21]);
    // 0x1ad88c: 0xc6000234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 564)); ctx->f[0] = *(float*)&val; }
    // 0x1ad890: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ad894: 0xc60d0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 544)); ctx->f[13] = *(float*)&val; }
    // 0x1ad898: 0x46016300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x1ad89c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1ad8a0: 0x46026b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[2]);
    // 0x1ad8a4: 0x4615a542
    ctx->f[21] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x1ad8a8: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1ad8ac: 0x46036b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[3]);
    // 0x1ad8b0: 0x46046301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[4]);
    // 0x1ad8b4: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1ad8bc);
    ctx->f[13] = FPU_SUB_S(ctx->f[13], ctx->f[21]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ad8bc
// Address: 0x1ad8bc - 0x1ad8cc

void entry_1ad8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad8bc: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1ad8c0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1ad8c4: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ad8cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ad8cc
// Address: 0x1ad8cc - 0x1ad8dc

void entry_1ad8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad8cc: 0xafb30020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 19));
    // 0x1ad8d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ad8d4: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ad8dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ad8dc
// Address: 0x1ad8dc - 0x1ad8e8

void entry_1ad8dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad8dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ad8e0: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ad8e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ad8e8
// Address: 0x1ad8e8 - 0x1ad8f4

void entry_1ad8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad8e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ad8ec: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ad8f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ad8f4
// Address: 0x1ad8f4 - 0x1ad910

void entry_1ad8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad8f4: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x1ad8f8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ad8fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ad900: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ad904: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ad908: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1ad910);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 8832));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ad910
// Address: 0x1ad910 - 0x1ad918

void entry_1ad910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad910: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ad918);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ad918
// Address: 0x1ad918 - 0x1ad940

void entry_1ad918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad918: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ad91c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ad920: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ad924: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ad928: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ad92c: 0xc7b60090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[22] = *(float*)&val; }
    // 0x1ad930: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x1ad934: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1ad938: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ad940
// Address: 0x1ad940 - 0x1ad954

void FUN_001ad940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad940: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ad944: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ad948: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ad94c: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1ad954);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ad954
// Address: 0x1ad954 - 0x1ad970

void entry_1ad954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ad954: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ad958: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ad95c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ad960: 0xe6000248
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 584), *(uint32_t*)&val); }
    // 0x1ad964: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ad968: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ad970
// Address: 0x1ad970 - 0x1ada48

void FUN_001ad970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ad970) {
        switch (ctx->pc) {
            case 0x1ad9d0: ctx->pc = 0; goto label_1ad9d0;
            case 0x1ad9d4: ctx->pc = 0; goto label_1ad9d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ad970: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x1ad974: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1ad978: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1ad97c: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ad980: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x1ad984: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ad988: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x1ad98c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ad990: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ad994: 0x8e650250
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 592)));
    // 0x1ad998: 0x10b2004e
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 18)) {
        entry_1adad4(rdram, ctx, runtime); return;
    }
    // 0x1ad9a0: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ad9a4: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ad9a8: 0x24425f80
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 24448));
    // 0x1ad9ac: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1ad9b0: 0x14640008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 24448));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_1ad9d4;
    }
    // 0x1ad9b8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1ad9bc: 0x52420004
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
        goto label_1ad9d0;
    }
    // 0x1ad9c4: 0x16400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 24448));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1ad9d4;
    }
    // 0x1ad9cc: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_1ad9d0:
    // 0x1ad9d0: 0x24c25f80
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 24448));
label_1ad9d4:
    // 0x1ad9d4: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1ad9d8: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1ad9dc: 0x5464002a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 592)));
        ctx->pc = 0x1ADA88; return;
    }
    // 0x1ad9e4: 0x2642ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x1ad9e8: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1ad9ec: 0x10400025
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ada84(rdram, ctx, runtime); return;
    }
    // 0x1ad9f4: 0x8c625b00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 23296)));
    // 0x1ad9f8: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1ad9fc: 0x14400021
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1ada84(rdram, ctx, runtime); return;
    }
    // 0x1ada04: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x1ada08: 0x8e8223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 9152)));
    // 0x1ada0c: 0x8c4319d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6616)));
    // 0x1ada10: 0x1060001c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1ada84(rdram, ctx, runtime); return;
    }
    // 0x1ada18: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ada1c: 0x8c43051c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x1ada20: 0x54600019
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 592)));
        ctx->pc = 0x1ADA88; return;
    }
    // 0x1ada28: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x1ada2c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ada30: 0x2630f138
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294963512));
    // 0x1ada34: 0x8e23f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294963512)));
    // 0x1ada38: 0xae000260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 0));
    // 0x1ada3c: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1ada40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ada48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ada48
// Address: 0x1ada48 - 0x1ada5c

void entry_1ada48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ada48: 0x8e8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 9152)));
    // 0x1ada4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ada50: 0x8c6519d8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1ada54: 0xc06b434
    SET_GPR_U32(ctx, 31, 0x1ada5c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    render_level_info(rdram, ctx, runtime); return;
}


// Function: entry_1ada5c
// Address: 0x1ada5c - 0x1ada70

void entry_1ada5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ada5c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ada60: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ada64: 0xae020464
    WRITE32(ADD32(GPR_U32(ctx, 16), 1124), GPR_U32(ctx, 2));
    // 0x1ada68: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1ada70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1ada70
// Address: 0x1ada70 - 0x1ada84

void entry_1ada70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ada70: 0x8e23f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294963512)));
    // 0x1ada74: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ada78: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1ada7c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ada84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ada84
// Address: 0x1ada84 - 0x1adab4

void entry_1ada84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ada84) {
        switch (ctx->pc) {
            case 0x1ada88: ctx->pc = 0; goto label_1ada88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ada84: 0x8e620250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 592)));
label_1ada88:
    // 0x1ada88: 0x10520013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x1ADAD8; return;
    }
    // 0x1ada90: 0x16400011
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ADAD8; return;
    }
    // 0x1ada98: 0x2464f138
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 4294963512));
    // 0x1ada9c: 0x8c820464
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1124)));
    // 0x1adaa0: 0x10400004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4294963512)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1adab4(rdram, ctx, runtime); return;
    }
    // 0x1adaa8: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1adaac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1adab4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1adab4
// Address: 0x1adab4 - 0x1adad4

void entry_1adab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adab4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1adab8: 0x24643eb0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 16048));
    // 0x1adabc: 0x8c820260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    // 0x1adac0: 0x10400004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 16048)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1adad4(rdram, ctx, runtime); return;
    }
    // 0x1adac8: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1adacc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1adad4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1adad4
// Address: 0x1adad4 - 0x1adae0

void entry_1adad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1adad4) {
        switch (ctx->pc) {
            case 0x1adad8: ctx->pc = 0; goto label_1adad8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1adad4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1adad8:
    // 0x1adad8: 0xc06aa66
    SET_GPR_U32(ctx, 31, 0x1adae0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime); return;
}


// Function: entry_1adae0
// Address: 0x1adae0 - 0x1adb00

void entry_1adae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adae0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1adae4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1adae8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1adaec: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1adaf0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1adaf4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1adaf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawLetterbox__FP9LETTERBOX
// Address: 0x1adb00 - 0x1adb80

void entry_1adb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adb80: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adb84: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x1adb88: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1adb90);
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1adb90
// Address: 0x1adb90 - 0x1adba0

void entry_1adb90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adb90: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1adb94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adb98: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1adba0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1adba0
// Address: 0x1adba0 - 0x1adbac

void entry_1adba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adba0: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x1adba4: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1adbac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1adbac
// Address: 0x1adbac - 0x1adbc8

void entry_1adbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adbac: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1adbb0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adbb4: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x1adbb8: 0x24067900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    // 0x1adbbc: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1adbc0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1adbc8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1adbc8
// Address: 0x1adbc8 - 0x1adbf4

void entry_1adbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adbc8: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x1adbcc: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1adbd0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adbd4: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x1adbd8: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1adbdc: 0x4618a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
    // 0x1adbe0: 0x4617a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[23]);
    // 0x1adbe4: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1adbe8: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1adbec: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1adbf4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1adbf4
// Address: 0x1adbf4 - 0x1adc20

void entry_1adbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adbf4: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x1adbf8: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1adbfc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adc00: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x1adc04: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1adc08: 0x4618ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[24]);
    // 0x1adc0c: 0x4617ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[23]);
    // 0x1adc10: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1adc14: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1adc18: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1adc20);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1adc20
// Address: 0x1adc20 - 0x1adc3c

void entry_1adc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adc20: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1adc24: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adc28: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x1adc2c: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x1adc30: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1adc34: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1adc3c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1adc3c
// Address: 0x1adc3c - 0x1adc60

void entry_1adc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adc3c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1adc40: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1adc44: 0xc7b80040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[24] = *(float*)&val; }
    // 0x1adc48: 0xc7b70038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[23] = *(float*)&val; }
    // 0x1adc4c: 0xc7b60030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[22] = *(float*)&val; }
    // 0x1adc50: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x1adc54: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1adc58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001adc60
// Address: 0x1adc60 - 0x1adc74

void FUN_001adc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adc60: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1adc64: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1adc68: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1adc6c: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1adc74);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1adc74
// Address: 0x1adc74 - 0x1adc9c

void entry_1adc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adc74: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1adc78: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1adc7c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1adc80: 0xc48d444c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 17484)); ctx->f[13] = *(float*)&val; }
    // 0x1adc84: 0x8ca3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x1adc88: 0xc44c4448
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 17480)); ctx->f[12] = *(float*)&val; }
    // 0x1adc8c: 0x84640008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1adc90: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1adc94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1adc9c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1adc9c
// Address: 0x1adc9c - 0x1adca8

void entry_1adc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adc9c: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1adca0: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1adca8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1adca8
// Address: 0x1adca8 - 0x1adcc0

void entry_1adca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adca8: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ADCC8; return;
    }
    // 0x1adcb0: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1adcb4: 0x24424450
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17488));
    // 0x1adcb8: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1adcc0);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1adcc0
// Address: 0x1adcc0 - 0x1adcd0

void entry_1adcc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1adcc0) {
        switch (ctx->pc) {
            case 0x1adcc8: ctx->pc = 0; goto label_1adcc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1adcc0: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x1adcc4: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1adcc8:
    // 0x1adcc8: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1adcd0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1171));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1adcd0
// Address: 0x1adcd0 - 0x1adcf8

void entry_1adcd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adcd0: 0x1040000b
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ADD00; return;
    }
    // 0x1adcd8: 0x3c0143b7
    SET_GPR_U32(ctx, 1, ((uint32_t)17335 << 16));
    // 0x1adcdc: 0x34216000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 24576));
    // 0x1adce0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1adce4: 0x3c014325
    SET_GPR_U32(ctx, 1, ((uint32_t)17189 << 16));
    // 0x1adce8: 0x3421c000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49152));
    // 0x1adcec: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1adcf0: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1adcf8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1adcf8
// Address: 0x1adcf8 - 0x1add18

void entry_1adcf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1adcf8) {
        switch (ctx->pc) {
            case 0x1add00: ctx->pc = 0; goto label_1add00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1adcf8: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ADD1C; return;
    }
label_1add00:
    // 0x1add00: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1add04: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1add08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1add0c: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1add10: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1add18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954736));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1add18
// Address: 0x1add18 - 0x1add28

void entry_1add18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1add18) {
        switch (ctx->pc) {
            case 0x1add1c: ctx->pc = 0; goto label_1add1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1add18: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1add1c:
    // 0x1add1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1add20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawLogo__FP4LOGO
// Address: 0x1add28 - 0x1add88

void entry_1add88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1add88: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1add8c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1add90: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1add94: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1add98: 0x26102280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8832));
    // 0x1add9c: 0x24070043
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 67));
    // 0x1adda0: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x1adda4: 0x34e7431e
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17182));
    // 0x1adda8: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x1addac: 0x34e7eeee
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 61166));
    // 0x1addb0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1addb4: 0x24050156
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 342));
    // 0x1addb8: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1addbc: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1addc0: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1addc8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 10));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1addc8
// Address: 0x1addc8 - 0x1adddc

void entry_1addc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1addc8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1addcc: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1addd0: 0x34c63001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 12289));
    // 0x1addd4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1adddc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1adddc
// Address: 0x1adddc - 0x1addec

void entry_1adddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adddc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adde0: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1adde4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1addec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1addec
// Address: 0x1addec - 0x1addfc

void entry_1addec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1addec: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1addf0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1addf4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1addfc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1addfc
// Address: 0x1addfc - 0x1ade0c

void entry_1addfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1addfc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ade00: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1ade04: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1ade0c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 96));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1ade0c
// Address: 0x1ade0c - 0x1ade1c

void entry_1ade0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ade0c: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ade10: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ade14: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1ade1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1ade1c
// Address: 0x1ade1c - 0x1ade38

void entry_1ade1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ade1c: 0x3c028080
    SET_GPR_U32(ctx, 2, ((uint32_t)32896 << 16));
    // 0x1ade20: 0x3c058080
    SET_GPR_U32(ctx, 5, ((uint32_t)32896 << 16));
    // 0x1ade24: 0x34428080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32896));
    // 0x1ade28: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ade2c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1ade30: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1ade38);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 32896));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1ade38
// Address: 0x1ade38 - 0x1ade4c

void entry_1ade38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ade38: 0x96460002
    SET_GPR_U32(ctx, 6, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x1ade3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ade40: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ade44: 0xc058532
    SET_GPR_U32(ctx, 31, 0x1ade4c);
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1ade4c
// Address: 0x1ade4c - 0x1ade88

void entry_1ade4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ade4c: 0xc6600220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[0] = *(float*)&val; }
    // 0x1ade50: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ade54: 0xc661021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[1] = *(float*)&val; }
    // 0x1ade58: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ade5c: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1ade60: 0x46160840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[22]);
    // 0x1ade64: 0x46150000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x1ade68: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1ade6c: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ade70: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1ade74: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1ade78: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ade7c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1ade80: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1ade88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1ade88
// Address: 0x1ade88 - 0x1ade9c

void entry_1ade88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ade88: 0x96450000
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1ade8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ade90: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ade94: 0xc058532
    SET_GPR_U32(ctx, 31, 0x1ade9c);
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1ade9c
// Address: 0x1ade9c - 0x1adee8

void entry_1ade9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ade9c: 0xc6630238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 568)); ctx->f[3] = *(float*)&val; }
    // 0x1adea0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1adea4: 0xc6610220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[1] = *(float*)&val; }
    // 0x1adea8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1adeac: 0xc6620234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 564)); ctx->f[2] = *(float*)&val; }
    // 0x1adeb0: 0xc660021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[0] = *(float*)&val; }
    // 0x1adeb4: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1adeb8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1adebc: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x1adec0: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1adec4: 0x46150840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[21]);
    // 0x1adec8: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1adecc: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1aded0: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1aded4: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1aded8: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1adedc: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1adee0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1adee8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1adee8
// Address: 0x1adee8 - 0x1adef8

void entry_1adee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1adee8) {
        switch (ctx->pc) {
            case 0x1adef0: ctx->pc = 0; goto label_1adef0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1adee8: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ADEFC; return;
    }
label_1adef0:
    // 0x1adef0: 0xc06a9e4
    SET_GPR_U32(ctx, 31, 0x1adef8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    DrawBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1adef8
// Address: 0x1adef8 - 0x1adf28

void entry_1adef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1adef8) {
        switch (ctx->pc) {
            case 0x1adefc: ctx->pc = 0; goto label_1adefc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1adef8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1adefc:
    // 0x1adefc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1adf00: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1adf04: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1adf08: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1adf0c: 0xc7b70078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[23] = *(float*)&val; }
    // 0x1adf10: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x1adf14: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x1adf18: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1adf1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1adf24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1adf28; return;
}


// Function: FUN_001adf28
// Address: 0x1adf28 - 0x1adf3c

void FUN_001adf28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adf28: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1adf2c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1adf30: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1adf34: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1adf3c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1adf3c
// Address: 0x1adf3c - 0x1adf64

void entry_1adf3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adf3c: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1adf40: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1adf44: 0xc44c446c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 17516)); ctx->f[12] = *(float*)&val; }
    // 0x1adf48: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1adf4c: 0x8cc5004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x1adf50: 0xc46d4470
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 17520)); ctx->f[13] = *(float*)&val; }
    // 0x1adf54: 0x84a40008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1adf58: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x1adf5c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1adf64);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1adf64
// Address: 0x1adf64 - 0x1adf70

void entry_1adf64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adf64: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1adf68: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1adf70);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1adf70
// Address: 0x1adf70 - 0x1adf88

void entry_1adf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adf70: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ADF90; return;
    }
    // 0x1adf78: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1adf7c: 0x24424488
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17544));
    // 0x1adf80: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1adf88);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1adf88
// Address: 0x1adf88 - 0x1adfdc

void entry_1adf88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1adf88) {
        switch (ctx->pc) {
            case 0x1adf90: ctx->pc = 0; goto label_1adf90;
            case 0x1adfd0: ctx->pc = 0; goto label_1adfd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1adf88: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x1adf8c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1adf90:
    // 0x1adf90: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1adf94: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1adf98: 0x8c432c84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11396)));
    // 0x1adf9c: 0xae000264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 0));
    // 0x1adfa0: 0x38630003
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 3));
    // 0x1adfa4: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x1adfa8: 0xae030260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 3));
    // 0x1adfac: 0x8c829988
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294941064)));
    // 0x1adfb0: 0x10400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1adfd0;
    }
    // 0x1adfb8: 0xc441000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[1] = *(float*)&val; }
    // 0x1adfbc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1adfc0: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1adfc4: 0x0
    // NOP
    // 0x1adfc8: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1adfd0;
    }
label_1adfd0:
    // 0x1adfd0: 0xae050264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 5));
    // 0x1adfd4: 0xc06b7fc
    SET_GPR_U32(ctx, 31, 0x1adfdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001adff0(rdram, ctx, runtime); return;
}


// Function: entry_1adfdc
// Address: 0x1adfdc - 0x1adff0

void entry_1adfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adfdc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1adfe0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1adfe4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1adfec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1adff0; return;
}


// Function: FUN_001adff0
// Address: 0x1adff0 - 0x1ae074

void FUN_001adff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1adff0: 0x27bdfef0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967024));
    // 0x1adff4: 0x7fb100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 17));
    // 0x1adff8: 0x7fbf00f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 31));
    // 0x1adffc: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ae000: 0x7fb200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 18));
    // 0x1ae004: 0x7fb000c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 16));
    // 0x1ae008: 0xe7b40100
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1ae00c: 0x8e220260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x1ae010: 0x1040001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 111));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AE07C; return;
    }
    // 0x1ae018: 0x240400ff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1ae01c: 0xa3a40003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 4));
    // 0x1ae020: 0x26270008
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1ae024: 0xa3a20002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ae028: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ae02c: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ae030: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1ae034: 0xa3a20001
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ae038: 0x24c64478
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 17528));
    // 0x1ae03c: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1ae040: 0xe0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1ae044: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ae048: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ae04c: 0xaa22020b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 523); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ae050: 0xba220208
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 520); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ae054: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ae058: 0x24a5cf90
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954896));
    // 0x1ae05c: 0x8e220264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 612)));
    // 0x1ae060: 0x8cc70008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1ae064: 0x2180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
    // 0x1ae068: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1ae06c: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ae074);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ae074
// Address: 0x1ae074 - 0x1ae0bc

void entry_1ae074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae074) {
        switch (ctx->pc) {
            case 0x1ae07c: ctx->pc = 0; goto label_1ae07c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae074: 0x10000012
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AE0C0; return;
    }
label_1ae07c:
    // 0x1ae07c: 0x2404001f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 31));
    // 0x1ae080: 0x240300ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1ae084: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ae088: 0x26220008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1ae08c: 0xa3a40002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 4));
    // 0x1ae090: 0xa3a40001
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 4));
    // 0x1ae094: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ae098: 0xa3a30003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 3));
    // 0x1ae09c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ae0a0: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ae0a4: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ae0a8: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ae0ac: 0xaa22020b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 523); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ae0b0: 0xba220208
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 520); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ae0b4: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1ae0bc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 17540)));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1ae0bc
// Address: 0x1ae0bc - 0x1ae0cc

void entry_1ae0bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae0bc) {
        switch (ctx->pc) {
            case 0x1ae0c0: ctx->pc = 0; goto label_1ae0c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae0bc: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1ae0c0:
    // 0x1ae0c0: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ae0c4: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ae0cc);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ae0cc
// Address: 0x1ae0cc - 0x1ae0e0

void entry_1ae0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae0cc: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ae0d0: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ae0d4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ae0d8: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ae0e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae0e0
// Address: 0x1ae0e0 - 0x1ae0e8

void entry_1ae0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae0e0: 0xc05787c
    SET_GPR_U32(ctx, 31, 0x1ae0e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DxMaxLine__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_1ae0e8
// Address: 0x1ae0e8 - 0x1ae0f8

void entry_1ae0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae0e8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ae0ec: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1ae0f0: 0xc05786c
    SET_GPR_U32(ctx, 31, 0x1ae0f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0015e1b0(rdram, ctx, runtime); return;
}


// Function: entry_1ae0f8
// Address: 0x1ae0f8 - 0x1ae108

void entry_1ae0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae0f8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ae0fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ae100: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1ae108);
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1ae108
// Address: 0x1ae108 - 0x1ae110

void entry_1ae108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae108: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ae110);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae110
// Address: 0x1ae110 - 0x1ae130

void entry_1ae110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae110: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ae114: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1ae118: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ae11c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ae120: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x1ae124: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ae12c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ae130; return;
}


// Function: FUN_001ae130
// Address: 0x1ae130 - 0x1ae15c

void FUN_001ae130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae130: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ae134: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ae138: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ae13c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ae140: 0x8e020268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 616)));
    // 0x1ae144: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AE160; return;
    }
    // 0x1ae14c: 0x14a00004
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AE160; return;
    }
    // 0x1ae154: 0xc06b7fc
    SET_GPR_U32(ctx, 31, 0x1ae15c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 616), GPR_U32(ctx, 0));
    FUN_001adff0(rdram, ctx, runtime); return;
}


// Function: entry_1ae15c
// Address: 0x1ae15c - 0x1ae168

void entry_1ae15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae15c) {
        switch (ctx->pc) {
            case 0x1ae160: ctx->pc = 0; goto label_1ae160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae15c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1ae160:
    // 0x1ae160: 0xc06aa66
    SET_GPR_U32(ctx, 31, 0x1ae168);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime); return;
}


// Function: entry_1ae168
// Address: 0x1ae168 - 0x1ae178

void entry_1ae168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae168: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ae16c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ae170: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateAttract__FP7ATTRACT
// Address: 0x1ae178 - 0x1ae208

void entry_1ae208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae208: 0xc06a8a6
    SET_GPR_U32(ctx, 31, 0x1ae210);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ae210
// Address: 0x1ae210 - 0x1ae220

void entry_1ae210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae210: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ae214: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ae218: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawAttract__FP7ATTRACT
// Address: 0x1ae220 - 0x1ae25c

void entry_1ae25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae25c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ae260: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1ae264: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ae268: 0xc621023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[1] = *(float*)&val; }
    // 0x1ae26c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae270: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1ae274: 0xc44c2b6c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11116)); ctx->f[12] = *(float*)&val; }
    // 0x1ae278: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ae27c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ae280: 0x3c01437f
    SET_GPR_U32(ctx, 1, ((uint32_t)17279 << 16));
    // 0x1ae284: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1ae288: 0x46016329
    ctx->f[12] = std::min(ctx->f[12], ctx->f[1]);
    // 0x1ae28c: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x1ae290: 0xc62d0228
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 552)); ctx->f[13] = *(float*)&val; }
    // 0x1ae294: 0x460c1081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[12]);
    // 0x1ae298: 0xc6230224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 548)); ctx->f[3] = *(float*)&val; }
    // 0x1ae29c: 0xc6210230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 560)); ctx->f[1] = *(float*)&val; }
    // 0x1ae2a0: 0x460d6342
    ctx->f[13] = FPU_MUL_S(ctx->f[12], ctx->f[13]);
    // 0x1ae2a4: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1ae2a8: 0xc625022c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 556)); ctx->f[5] = *(float*)&val; }
    // 0x1ae2ac: 0x8a22020b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 523); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ae2b0: 0x9a220208
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 520); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ae2b4: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ae2b8: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ae2bc: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1ae2c0: 0x46036302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[3]);
    // 0x1ae2c4: 0x46051082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[5]);
    // 0x1ae2c8: 0xc6350234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[21] = *(float*)&val; }
    // 0x1ae2cc: 0x460000e4
    *(int32_t*)&ctx->f[3] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1ae2d0: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x1ae2d4: 0xc6340238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[20] = *(float*)&val; }
    // 0x1ae2d8: 0x460d0b40
    ctx->f[13] = FPU_ADD_S(ctx->f[1], ctx->f[13]);
    // 0x1ae2dc: 0x460c1300
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[12]);
    // 0x1ae2e0: 0xa3a20023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ae2e4: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1ae2ec);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ae2ec
// Address: 0x1ae2ec - 0x1ae2fc

void entry_1ae2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae2ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae2f0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1ae2f4: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ae2fc);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ae2fc
// Address: 0x1ae2fc - 0x1ae30c

void entry_1ae2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae2fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae300: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ae304: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ae30c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ae30c
// Address: 0x1ae30c - 0x1ae318

void entry_1ae30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae30c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae310: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ae318);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ae318
// Address: 0x1ae318 - 0x1ae324

void entry_1ae318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae318: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ae31c: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ae324);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ae324
// Address: 0x1ae324 - 0x1ae354

void entry_1ae324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae324: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1ae328: 0x50a0000b
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1AE358; return;
    }
    // 0x1ae330: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1ae334: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1ae354(rdram, ctx, runtime); return;
    }
    // 0x1ae33c: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1ae340: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae344: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1ae348: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1ae34c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ae354);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ae354
// Address: 0x1ae354 - 0x1ae364

void entry_1ae354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae354) {
        switch (ctx->pc) {
            case 0x1ae358: ctx->pc = 0; goto label_1ae358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae354: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
label_1ae358:
    // 0x1ae358: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ae35c: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ae364);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ae364
// Address: 0x1ae364 - 0x1ae378

void entry_1ae364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae364: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ae368: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ae36c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae370: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ae378);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae378
// Address: 0x1ae378 - 0x1ae38c

void entry_1ae378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae378: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae37c: 0x26472280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1ae380: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae384: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x1ae38c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ae38c
// Address: 0x1ae38c - 0x1ae394

void entry_1ae38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae38c: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ae394);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae394
// Address: 0x1ae394 - 0x1ae3b8

void entry_1ae394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae394: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1ae398: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1ae39c: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ae3a0: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ae3a4: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1ae3a8: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1ae3ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ae3b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ae3b8; return;
}


// Function: DrawLineScreen__FUiUiUiUiUiUiG4RGBAi
// Address: 0x1ae3b8 - 0x1ae434

void entry_1ae434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae434) {
        switch (ctx->pc) {
            case 0x1ae454: ctx->pc = 0; goto label_1ae454;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae434: 0x3c060001
    SET_GPR_U32(ctx, 6, ((uint32_t)1 << 16));
    // 0x1ae438: 0x34c61000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4096));
    // 0x1ae43c: 0x3c020001
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    // 0x1ae440: 0x34421001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4097));
    // 0x1ae444: 0x50300b
    if (GPR_U32(ctx, 16) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    // 0x1ae448: 0x12000002
    SET_GPR_U32(ctx, 2, ((uint32_t)2 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1ae454;
    }
    // 0x1ae450: 0x3c020006
    SET_GPR_U32(ctx, 2, ((uint32_t)6 << 16));
label_1ae454:
    // 0x1ae454: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1ae458: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ae45c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ae460: 0x24502280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 8832));
    // 0x1ae464: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1ae46c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1ae46c
// Address: 0x1ae46c - 0x1ae4a4

void entry_1ae46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae46c: 0x92250003
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 3)));
    // 0x1ae470: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae474: 0x92220002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 2)));
    // 0x1ae478: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1ae47c: 0x92230001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 1)));
    // 0x1ae480: 0x30a501fe
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 510));
    // 0x1ae484: 0x21400
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 16));
    // 0x1ae488: 0x52dc0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 23));
    // 0x1ae48c: 0x31a00
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 8));
    // 0x1ae490: 0xa22825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1ae494: 0x92260000
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ae498: 0xa32825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1ae49c: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1ae4a4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1ae4a4
// Address: 0x1ae4a4 - 0x1ae4bc

void entry_1ae4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae4a4: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1ae4a8: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1ae4ac: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1ae4b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae4b4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1ae4bc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1ae4bc
// Address: 0x1ae4bc - 0x1ae4d4

void entry_1ae4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae4bc: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1ae4c0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ae4c4: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ae4c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae4cc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1ae4d4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1ae4d4
// Address: 0x1ae4d4 - 0x1ae4e0

void entry_1ae4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae4d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae4d8: 0xc05849e
    SET_GPR_U32(ctx, 31, 0x1ae4e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EndPrim__4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_1ae4e0
// Address: 0x1ae4e0 - 0x1ae510

void entry_1ae4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae4e0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ae4e4: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ae4e8: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ae4ec: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ae4f0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ae4f4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ae4f8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ae4fc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ae500: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ae504: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ae508: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ae510
// Address: 0x1ae510 - 0x1ae528

void FUN_001ae510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae510: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ae514: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ae518: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ae51c: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ae520: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1ae528);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ae528
// Address: 0x1ae528 - 0x1ae530

void entry_1ae528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae528: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ae530);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ae530
// Address: 0x1ae530 - 0x1ae55c

void entry_1ae530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae530: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1ae534: 0x24633c50
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 15440));
    // 0x1ae538: 0x1603000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1AE564; return;
    }
    // 0x1ae540: 0x26020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1ae544: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ae548: 0x24a5cf98
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954904));
    // 0x1ae54c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ae550: 0x2406004c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 76));
    // 0x1ae554: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ae55c);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ae55c
// Address: 0x1ae55c - 0x1ae588

void entry_1ae55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae55c) {
        switch (ctx->pc) {
            case 0x1ae564: ctx->pc = 0; goto label_1ae564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae55c: 0x1000000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AE58C; return;
    }
label_1ae564:
    // 0x1ae564: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ae568: 0x244239f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14832));
    // 0x1ae56c: 0x16020006
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        entry_1ae588(rdram, ctx, runtime); return;
    }
    // 0x1ae574: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1ae578: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ae57c: 0x24a5cf98
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294954904));
    // 0x1ae580: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ae588);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 75));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ae588
// Address: 0x1ae588 - 0x1ae59c

void entry_1ae588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae588) {
        switch (ctx->pc) {
            case 0x1ae58c: ctx->pc = 0; goto label_1ae58c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae588: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1ae58c:
    // 0x1ae58c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ae590: 0xc44c44a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 17576)); ctx->f[12] = *(float*)&val; }
    // 0x1ae594: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ae59c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ae59c
// Address: 0x1ae59c - 0x1ae5a8

void entry_1ae59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae59c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ae5a0: 0xc057106
    SET_GPR_U32(ctx, 31, 0x1ae5a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_1ae5a8
// Address: 0x1ae5a8 - 0x1ae5c8

void entry_1ae5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae5a8: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ae5ac: 0xe6000234
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 564), *(uint32_t*)&val); }
    // 0x1ae5b0: 0xc4800008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1ae5b4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ae5b8: 0xc4810048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1ae5bc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ae5c0: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ae5c8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 568), *(uint32_t*)&val); }
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae5c8
// Address: 0x1ae5c8 - 0x1ae5e0

void entry_1ae5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae5c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ae5cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ae5d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ae5d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ae5dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ae5e0; return;
}


// Function: FUN_001ae5e0
// Address: 0x1ae5e0 - 0x1ae6a0

void FUN_001ae5e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae5e0) {
        switch (ctx->pc) {
            case 0x1ae678: ctx->pc = 0; goto label_1ae678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae5e0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ae5e4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1ae5e8: 0xc44444a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 17576)); ctx->f[4] = *(float*)&val; }
    // 0x1ae5ec: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x1ae5f0: 0xc46144a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 17572)); ctx->f[1] = *(float*)&val; }
    // 0x1ae5f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ae5f8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ae5fc: 0x46010882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x1ae600: 0x7fb20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 18));
    // 0x1ae604: 0x46046001
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[4]);
    // 0x1ae608: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ae60c: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x1ae610: 0x7fb10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 17));
    // 0x1ae614: 0x460200c3
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[3] = ctx->f[0] / ctx->f[2];
    // 0x1ae618: 0x7fb00040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 16));
    // 0x1ae61c: 0xe7b50088
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    // 0x1ae620: 0xe7b40080
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x1ae624: 0xe7a40000
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1ae628: 0xafa00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    // 0x1ae62c: 0xe7a30008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1ae630: 0x46032003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[4] * 0.0f); } else ctx->f[0] = ctx->f[4] / ctx->f[3];
    // 0x1ae634: 0x46000144
    ctx->f[5] = FPU_SQRT_S(ctx->f[0]);
    // 0x1ae638: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ae63c: 0xc6420254
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 596)); ctx->f[2] = *(float*)&val; }
    // 0x1ae640: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x1ae644: 0x46012840
    ctx->f[1] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    // 0x1ae648: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ae64c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ae650: 0x0
    // NOP
    // 0x1ae654: 0x45030008
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 524)); ctx->f[0] = *(float*)&val; }
        goto label_1ae678;
    }
    // 0x1ae65c: 0x46050001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[5]);
    // 0x1ae660: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1ae664: 0x46030042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1ae668: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ae66c: 0x46002000
    ctx->f[0] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x1ae670: 0x46001328
    ctx->f[12] = std::max(ctx->f[2], ctx->f[0]);
    // 0x1ae674: 0xc640020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 524)); ctx->f[0] = *(float*)&val; }
label_1ae678:
    // 0x1ae678: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1ae67c: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1ae680: 0x46016036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ae684: 0x0
    // NOP
    // 0x1ae688: 0x4501002b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1AE738; return;
    }
    // 0x1ae690: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1ae694: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1ae698: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ae6a0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 8));
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ae6a0
// Address: 0x1ae6a0 - 0x1ae6ac

void entry_1ae6a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae6a0: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1ae6a4: 0xc057106
    SET_GPR_U32(ctx, 31, 0x1ae6ac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DxFromPchz__5CFontPc(rdram, ctx, runtime); return;
}


// Function: entry_1ae6ac
// Address: 0x1ae6ac - 0x1ae6d8

void entry_1ae6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae6ac: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1ae6b0: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1ae6b4: 0xc64c021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 540)); ctx->f[12] = *(float*)&val; }
    // 0x1ae6b8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ae6bc: 0xc4540008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[20] = *(float*)&val; }
    // 0x1ae6c0: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x1ae6c4: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1ae6c8: 0xc64d0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 544)); ctx->f[13] = *(float*)&val; }
    // 0x1ae6cc: 0x8e500208
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 520)));
    // 0x1ae6d0: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1ae6d8);
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ae6d8
// Address: 0x1ae6d8 - 0x1ae6e8

void entry_1ae6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae6d8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ae6dc: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1ae6e0: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ae6e8);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ae6e8
// Address: 0x1ae6e8 - 0x1ae6f8

void entry_1ae6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae6e8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ae6ec: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ae6f0: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ae6f8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ae6f8
// Address: 0x1ae6f8 - 0x1ae704

void entry_1ae6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae6f8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ae6fc: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ae704);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ae704
// Address: 0x1ae704 - 0x1ae710

void entry_1ae704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae704: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ae708: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ae710);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ae710
// Address: 0x1ae710 - 0x1ae72c

void entry_1ae710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae710: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1ae714: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x1ae718: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ae71c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ae720: 0x25082280
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 8832));
    // 0x1ae724: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1ae72c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ae72c
// Address: 0x1ae72c - 0x1ae734

void entry_1ae72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae72c: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ae734);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae734
// Address: 0x1ae734 - 0x1ae758

void entry_1ae734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae734) {
        switch (ctx->pc) {
            case 0x1ae738: ctx->pc = 0; goto label_1ae738;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae734: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1ae738:
    // 0x1ae738: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ae73c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ae740: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ae744: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x1ae748: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1ae74c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ae754: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ae758; return;
}


// Function: FUN_001ae758
// Address: 0x1ae758 - 0x1ae778

void FUN_001ae758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae758: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1ae75c: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1ae760: 0xe7b40030
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x1ae764: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ae768: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1ae76c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1ae770: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x1ae778);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ae778
// Address: 0x1ae778 - 0x1ae784

void entry_1ae778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae778: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae77c: 0xc06aa2c
    SET_GPR_U32(ctx, 31, 0x1ae784);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetBlotDtAppear__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1ae784
// Address: 0x1ae784 - 0x1ae790

void entry_1ae784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae784: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ae788: 0xc06aa30
    SET_GPR_U32(ctx, 31, 0x1ae790);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtDisappear__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1ae790
// Address: 0x1ae790 - 0x1ae79c

void entry_1ae790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae790: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ae794: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1ae79c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1ae79c
// Address: 0x1ae79c - 0x1ae7a4

void entry_1ae79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae79c: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1ae7a4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1ae7a4
// Address: 0x1ae7a4 - 0x1ae7b8

void entry_1ae7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae7a4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1ae7a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae7ac: 0xc46c44ac
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 17580)); ctx->f[12] = *(float*)&val; }
    // 0x1ae7b0: 0xc06a9e2
    SET_GPR_U32(ctx, 31, 0x1ae7b8);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    SetBlotFontScale__FfP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1ae7b8
// Address: 0x1ae7b8 - 0x1ae7c0

void entry_1ae7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae7b8: 0xc06ba82
    SET_GPR_U32(ctx, 31, 0x1ae7c0);
    FUN_001aea08(rdram, ctx, runtime); return;
}


// Function: entry_1ae7c0
// Address: 0x1ae7c0 - 0x1ae7dc

void entry_1ae7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae7c0: 0xa3a00001
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ae7c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae7c8: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1ae7cc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ae7d0: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1ae7d4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ae7dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ae7dc
// Address: 0x1ae7dc - 0x1ae7f8

void entry_1ae7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae7dc: 0xa2000008
    WRITE8(ADD32(GPR_U32(ctx, 16), 8), (uint8_t)GPR_U32(ctx, 0));
    // 0x1ae7e0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ae7e4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ae7e8: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1ae7ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ae7f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ae7f8; return;
}


// Function: FUN_001ae7f8
// Address: 0x1ae7f8 - 0x1ae810

void FUN_001ae7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae7f8) {
        switch (ctx->pc) {
            case 0x1ae808: ctx->pc = 0; goto label_1ae808;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae7f8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ae7fc: 0x14a00002
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1ae808;
    }
    // 0x1ae804: 0xac800260
    WRITE32(ADD32(GPR_U32(ctx, 4), 608), GPR_U32(ctx, 0));
label_1ae808:
    // 0x1ae808: 0xc06aa66
    SET_GPR_U32(ctx, 31, 0x1ae810);
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime); return;
}


// Function: entry_1ae810
// Address: 0x1ae810 - 0x1ae820

void entry_1ae810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae810: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ae814: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ae81c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ae820; return;
}


// Function: FUN_001ae820
// Address: 0x1ae820 - 0x1ae8fc

void FUN_001ae820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae820) {
        switch (ctx->pc) {
            case 0x1ae890: ctx->pc = 0; goto label_1ae890;
            case 0x1ae894: ctx->pc = 0; goto label_1ae894;
            case 0x1ae898: ctx->pc = 0; goto label_1ae898;
            case 0x1ae8c4: ctx->pc = 0; goto label_1ae8c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae820: 0x27bdfea0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966944));
    // 0x1ae824: 0x7fb30130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 19));
    // 0x1ae828: 0x7fbf0140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 31));
    // 0x1ae82c: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ae830: 0x7fb20120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 18));
    // 0x1ae834: 0x7fb10110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 17));
    // 0x1ae838: 0x7fb00100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 16));
    // 0x1ae83c: 0xe7b50158
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 344), *(uint32_t*)&val); }
    // 0x1ae840: 0xe7b40150
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 336), *(uint32_t*)&val); }
    // 0x1ae844: 0x8e640250
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 592)));
    // 0x1ae848: 0x10800066
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1ae9e4(rdram, ctx, runtime); return;
    }
    // 0x1ae850: 0xc6610254
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 596)); ctx->f[1] = *(float*)&val; }
    // 0x1ae854: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x1ae858: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ae85c: 0x1483000d
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1ae894;
    }
    // 0x1ae864: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ae868: 0x8c432420
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9248)));
    // 0x1ae86c: 0x5464000a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 608)));
        goto label_1ae898;
    }
    // 0x1ae874: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1ae878: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ae87c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ae880: 0x0
    // NOP
    // 0x1ae884: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ae890;
    }
    // 0x1ae88c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ae890:
    // 0x1ae890: 0xae620260
    WRITE32(ADD32(GPR_U32(ctx, 19), 608), GPR_U32(ctx, 2));
label_1ae894:
    // 0x1ae894: 0x8e620260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 608)));
label_1ae898:
    // 0x1ae898: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ae8c4;
    }
    // 0x1ae8a0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ae8a4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ae8a8: 0xc441240c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 9228)); ctx->f[1] = *(float*)&val; }
    // 0x1ae8ac: 0x3c014284
    SET_GPR_U32(ctx, 1, ((uint32_t)17028 << 16));
    // 0x1ae8b0: 0x3421ccce
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52430));
    // 0x1ae8b4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ae8b8: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1ae8bc: 0x10000015
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ae914(rdram, ctx, runtime); return;
    }
label_1ae8c4:
    // 0x1ae8c4: 0x8e630250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 592)));
    // 0x1ae8c8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ae8cc: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1ae8d0: 0x54620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[13] = *(float*)&val; }
        ctx->pc = 0x1AE918; return;
    }
    // 0x1ae8d8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ae8dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ae8e0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ae8e4: 0x0
    // NOP
    // 0x1ae8e8: 0x4502000b
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[13] = *(float*)&val; }
        ctx->pc = 0x1AE918; return;
    }
    // 0x1ae8f0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1ae8f4: 0xc062ddc
    SET_GPR_U32(ctx, 31, 0x1ae8fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    FCheckMemcardThread__FP7MEMCARD(rdram, ctx, runtime); return;
}


// Function: entry_1ae8fc
// Address: 0x1ae8fc - 0x1ae914

void entry_1ae8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae8fc: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[13] = *(float*)&val; }
        ctx->pc = 0x1AE918; return;
    }
    // 0x1ae904: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1ae908: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1ae90c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ae914);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ae914
// Address: 0x1ae914 - 0x1ae934

void entry_1ae914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ae914) {
        switch (ctx->pc) {
            case 0x1ae918: ctx->pc = 0; goto label_1ae918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ae914: 0xc66d0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[13] = *(float*)&val; }
label_1ae918:
    // 0x1ae918: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae91c: 0xc66c021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[12] = *(float*)&val; }
    // 0x1ae920: 0x46146b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[20]);
    // 0x1ae924: 0x8e700208
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 520)));
    // 0x1ae928: 0xc6740234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 564)); ctx->f[20] = *(float*)&val; }
    // 0x1ae92c: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1ae934);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 568)); ctx->f[21] = *(float*)&val; }
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ae934
// Address: 0x1ae934 - 0x1ae944

void entry_1ae934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae934: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae938: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ae93c: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1ae944);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1ae944
// Address: 0x1ae944 - 0x1ae954

void entry_1ae944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae944: 0xafb00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 16));
    // 0x1ae948: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae94c: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1ae954);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1ae954
// Address: 0x1ae954 - 0x1ae960

void entry_1ae954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae954: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae958: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1ae960);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1ae960
// Address: 0x1ae960 - 0x1ae96c

void entry_1ae960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae960: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae964: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1ae96c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1ae96c
// Address: 0x1ae96c - 0x1ae97c

void entry_1ae96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae96c: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1ae970: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ae974: 0xc06ba82
    SET_GPR_U32(ctx, 31, 0x1ae97c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294954912));
    FUN_001aea08(rdram, ctx, runtime); return;
}


// Function: entry_1ae97c
// Address: 0x1ae97c - 0x1ae98c

void entry_1ae97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae97c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1ae980: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ae984: 0xc0582ca
    SET_GPR_U32(ctx, 31, 0x1ae98c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_1ae98c
// Address: 0x1ae98c - 0x1ae9a0

void entry_1ae98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae98c: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ae990: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae994: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ae998: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1ae9a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1ae9a0
// Address: 0x1ae9a0 - 0x1ae9b0

void entry_1ae9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae9a0: 0xc66c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 524)); ctx->f[12] = *(float*)&val; }
    // 0x1ae9a4: 0x8e640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1ae9a8: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1ae9b0);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1ae9b0
// Address: 0x1ae9b0 - 0x1ae9c4

void entry_1ae9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae9b0: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1ae9b4: 0x8e660004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1ae9b8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ae9bc: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1ae9c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae9c4
// Address: 0x1ae9c4 - 0x1ae9dc

void entry_1ae9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae9c4: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x1ae9c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ae9cc: 0x24e72280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 8832));
    // 0x1ae9d0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ae9d4: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x1ae9dc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1ae9dc
// Address: 0x1ae9dc - 0x1ae9e4

void entry_1ae9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae9dc: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1ae9e4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1ae9e4
// Address: 0x1ae9e4 - 0x1aea08

void entry_1ae9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ae9e4: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1ae9e8: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1ae9ec: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1ae9f0: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1ae9f4: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ae9f8: 0xc7b50158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[21] = *(float*)&val; }
    // 0x1ae9fc: 0xc7b40150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[20] = *(float*)&val; }
    // 0x1aea00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001aea08
// Address: 0x1aea08 - 0x1aea40

void FUN_001aea08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aea08: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1aea0c: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1aea10: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1aea14: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x1aea18: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1aea1c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1aea20: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1aea24: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1aea28: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x1aea2c: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1aea30: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1aea34: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1aea38: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1aea40);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 17584)));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1aea40
// Address: 0x1aea40 - 0x1aea70

void entry_1aea40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aea40) {
        switch (ctx->pc) {
            case 0x1aea48: ctx->pc = 0; goto label_1aea48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aea40: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1aea48;
    }
label_1aea48:
    // 0x1aea48: 0x202001b
    { uint32_t divisor = GPR_U32(ctx, 2); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 16) / divisor; ctx->hi = GPR_U32(ctx, 2) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,16); } }
    // 0x1aea4c: 0x8e2344b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 17584)));
    // 0x1aea50: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aea54: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aea58: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aea5c: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x1aea60: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1aea64: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1aea68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001aea70
// Address: 0x1aea70 - 0x1aeb48

void FUN_001aea70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aea70) {
        switch (ctx->pc) {
            case 0x1aeab8: ctx->pc = 0; goto label_1aeab8;
            case 0x1aeae0: ctx->pc = 0; goto label_1aeae0;
            case 0x1aeb08: ctx->pc = 0; goto label_1aeb08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aea70: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x1aea74: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x1aea78: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x1aea7c: 0x7fb60060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 22));
    // 0x1aea80: 0x7fb50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 21));
    // 0x1aea84: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x1aea88: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1aea8c: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1aea90: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1aea94: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1aea98: 0xe7b60090
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x1aea9c: 0xe7b50088
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    // 0x1aeaa0: 0x14a20069
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AEC48; return;
    }
    // 0x1aeaa8: 0x10800067
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 56));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEC48; return;
    }
    // 0x1aeab0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1aeab4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
label_1aeab8:
    // 0x1aeab8: 0x0
    // NOP
    // 0x1aeabc: 0x0
    // NOP
    // 0x1aeac0: 0x0
    // NOP
    // 0x1aeac4: 0x0
    // NOP
    // 0x1aeac8: 0x0
    // NOP
    // 0x1aeacc: 0x1443fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1aeab8;
    }
    // 0x1aead4: 0x24020038
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 56));
    // 0x1aead8: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1aeadc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
label_1aeae0:
    // 0x1aeae0: 0x0
    // NOP
    // 0x1aeae4: 0x0
    // NOP
    // 0x1aeae8: 0x0
    // NOP
    // 0x1aeaec: 0x0
    // NOP
    // 0x1aeaf0: 0x0
    // NOP
    // 0x1aeaf4: 0x1443fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1aeae0;
    }
    // 0x1aeafc: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1aeb00: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1aeb04: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
label_1aeb08:
    // 0x1aeb08: 0x0
    // NOP
    // 0x1aeb0c: 0x0
    // NOP
    // 0x1aeb10: 0x0
    // NOP
    // 0x1aeb14: 0x0
    // NOP
    // 0x1aeb18: 0x0
    // NOP
    // 0x1aeb1c: 0x1443fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1aeb08;
    }
    // 0x1aeb24: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1aeb28: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1aeb2c: 0x261043d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 17360));
    // 0x1aeb30: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1aeb34: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1aeb38: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1aeb3c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1aeb40: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1aeb48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1aeb48
// Address: 0x1aeb48 - 0x1aebac

void entry_1aeb48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aeb48: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1aeb4c: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1aeb50: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1aeb54: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1aeb58: 0x3c15ff7d
    SET_GPR_U32(ctx, 21, ((uint32_t)65405 << 16));
    // 0x1aeb5c: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x1aeb60: 0x36b54b00
    SET_GPR_U32(ctx, 21, OR32(GPR_U32(ctx, 21), 19200));
    // 0x1aeb64: 0x263143f0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 17392));
    // 0x1aeb68: 0x2416002d
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 45));
    // 0x1aeb6c: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1aeb70: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1aeb74: 0x3c01c080
    SET_GPR_U32(ctx, 1, ((uint32_t)49280 << 16));
    // 0x1aeb78: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1aeb7c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1aeb80: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1aeb84: 0xae150018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 21));
    // 0x1aeb88: 0xa2160004
    WRITE8(ADD32(GPR_U32(ctx, 16), 4), (uint8_t)GPR_U32(ctx, 22));
    // 0x1aeb8c: 0x3c120027
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    // 0x1aeb90: 0xe6160008
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1aeb94: 0x26524410
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 17424));
    // 0x1aeb98: 0xe6140010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x1aeb9c: 0x3c130027
    SET_GPR_U32(ctx, 19, ((uint32_t)39 << 16));
    // 0x1aeba0: 0xe6140014
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x1aeba4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1aebac);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 17488));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1aebac
// Address: 0x1aebac - 0x1aebdc

void entry_1aebac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aebac: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1aebb0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1aebb4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1aebb8: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1aebbc: 0xae350018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 21));
    // 0x1aebc0: 0xa2360004
    WRITE8(ADD32(GPR_U32(ctx, 17), 4), (uint8_t)GPR_U32(ctx, 22));
    // 0x1aebc4: 0x26944488
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 17544));
    // 0x1aebc8: 0xe6360008
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x1aebcc: 0xe635000c
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    // 0x1aebd0: 0xe6340010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x1aebd4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1aebdc);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 20), *(uint32_t*)&val); }
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1aebdc
// Address: 0x1aebdc - 0x1aec08

void entry_1aebdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aebdc: 0x2403003d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1aebe0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1aebe4: 0xa2430004
    WRITE8(ADD32(GPR_U32(ctx, 18), 4), (uint8_t)GPR_U32(ctx, 3));
    // 0x1aebe8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1aebec: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1aebf0: 0xae550018
    WRITE32(ADD32(GPR_U32(ctx, 18), 24), GPR_U32(ctx, 21));
    // 0x1aebf4: 0xe6560008
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 18), 8), *(uint32_t*)&val); }
    // 0x1aebf8: 0xe655000c
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
    // 0x1aebfc: 0xe6540010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
    // 0x1aec00: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1aec08);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 20), *(uint32_t*)&val); }
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1aec08
// Address: 0x1aec08 - 0x1aec30

void entry_1aec08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aec08: 0xae750018
    WRITE32(ADD32(GPR_U32(ctx, 19), 24), GPR_U32(ctx, 21));
    // 0x1aec0c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1aec10: 0xa2760004
    WRITE8(ADD32(GPR_U32(ctx, 19), 4), (uint8_t)GPR_U32(ctx, 22));
    // 0x1aec14: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1aec18: 0xe6760008
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 19), 8), *(uint32_t*)&val); }
    // 0x1aec1c: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1aec20: 0xe675000c
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 19), 12), *(uint32_t*)&val); }
    // 0x1aec24: 0xe6740010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 19), 16), *(uint32_t*)&val); }
    // 0x1aec28: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1aec30);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 19), 20), *(uint32_t*)&val); }
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1aec30
// Address: 0x1aec30 - 0x1aec80

void entry_1aec30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aec30) {
        switch (ctx->pc) {
            case 0x1aec48: ctx->pc = 0; goto label_1aec48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aec30: 0xae950018
    WRITE32(ADD32(GPR_U32(ctx, 20), 24), GPR_U32(ctx, 21));
    // 0x1aec34: 0xa2960004
    WRITE8(ADD32(GPR_U32(ctx, 20), 4), (uint8_t)GPR_U32(ctx, 22));
    // 0x1aec38: 0xe6960008
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 20), 8), *(uint32_t*)&val); }
    // 0x1aec3c: 0xe695000c
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 20), 12), *(uint32_t*)&val); }
    // 0x1aec40: 0xe6940014
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 20), 20), *(uint32_t*)&val); }
    // 0x1aec44: 0xe6940010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 20), 16), *(uint32_t*)&val); }
label_1aec48:
    // 0x1aec48: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1aec4c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1aec50: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1aec54: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1aec58: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1aec5c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aec60: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aec64: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aec68: 0xc7b60090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[22] = *(float*)&val; }
    // 0x1aec6c: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x1aec70: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1aec74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aec7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aec80; return;
}


// Function: junk_001aec80
// Address: 0x1aec80 - 0x1aec90

void FUN_001aec90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aec90: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1aec94: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1aec98: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1aec9c: 0xc06ba9c
    SET_GPR_U32(ctx, 31, 0x1aeca4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    FUN_001aea70(rdram, ctx, runtime); return;
}


// Function: entry_1aeca4
// Address: 0x1aeca4 - 0x1aecb0

void entry_1aeca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aeca4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aeca8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSensor__FP6SENSOR
// Address: 0x1aecb0 - 0x1aecc4

void entry_1aecc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aecc4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1aecc8: 0xae000554
    WRITE32(ADD32(GPR_U32(ctx, 16), 1364), GPR_U32(ctx, 0));
    // 0x1aeccc: 0xae020558
    WRITE32(ADD32(GPR_U32(ctx, 16), 1368), GPR_U32(ctx, 2));
    // 0x1aecd0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aecd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aecd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSensorAlarm__FP6SENSORP5ALARM
// Address: 0x1aece0 - 0x1aece8

void entry_1aed34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aed34) {
        switch (ctx->pc) {
            case 0x1aed44: ctx->pc = 0; goto label_1aed44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aed34: 0x8e230558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
    // 0x1aed38: 0x38620001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 1));
    // 0x1aed3c: 0x62800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x1aed40: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1aed44:
    // 0x1aed44: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1aed48: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1aed4c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1aed54);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1aed54
// Address: 0x1aed54 - 0x1aed78

void entry_1aed54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aed54) {
        switch (ctx->pc) {
            case 0x1aed58: ctx->pc = 0; goto label_1aed58;
            case 0x1aed64: ctx->pc = 0; goto label_1aed64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aed54: 0xae300558
    WRITE32(ADD32(GPR_U32(ctx, 17), 1368), GPR_U32(ctx, 16));
label_1aed58:
    // 0x1aed58: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1aed5c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1aed60: 0xe620055c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1372), *(uint32_t*)&val); }
label_1aed64:
    // 0x1aed64: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aed68: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aed6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aed70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCheckSensorObject__FP6SENSORP2SO
// Address: 0x1aed78 - 0x1aedb4

void entry_1aedb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aedb4) {
        switch (ctx->pc) {
            case 0x1aedd0: ctx->pc = 0; goto label_1aedd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aedb4: 0x1440001e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEE30; return;
    }
    // 0x1aedbc: 0x8e420564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1380)));
    // 0x1aedc0: 0x1840000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1AEDF4; return;
    }
    // 0x1aedc8: 0x26500568
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1384));
    // 0x1aedcc: 0x0
    // NOP
label_1aedd0:
    // 0x1aedd0: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aedd4: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x1aeddc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_1aeddc
// Address: 0x1aeddc - 0x1aee14

void entry_1aeddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aeddc) {
        switch (ctx->pc) {
            case 0x1aedf4: ctx->pc = 0; goto label_1aedf4;
            case 0x1aee08: ctx->pc = 0; goto label_1aee08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aeddc: 0x1440fff0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEDA0; return;
    }
    // 0x1aede4: 0x8e420564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1380)));
    // 0x1aede8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1aedec: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEDD0; return;
    }
label_1aedf4:
    // 0x1aedf4: 0x8e42058c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
    // 0x1aedf8: 0x1840000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1AEE2C; return;
    }
    // 0x1aee00: 0x26500590
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1424));
    // 0x1aee04: 0x0
    // NOP
label_1aee08:
    // 0x1aee08: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aee0c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1aee14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1aee14
// Address: 0x1aee14 - 0x1aee50

void entry_1aee14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aee14) {
        switch (ctx->pc) {
            case 0x1aee2c: ctx->pc = 0; goto label_1aee2c;
            case 0x1aee30: ctx->pc = 0; goto label_1aee30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aee14: 0x1440ffe2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEDA0; return;
    }
    // 0x1aee1c: 0x8e42058c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
    // 0x1aee20: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1aee24: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEE08; return;
    }
label_1aee2c:
    // 0x1aee2c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1aee30:
    // 0x1aee30: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1aee34: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1aee38: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aee3c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aee40: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aee44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aee4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aee50; return;
}


// Function: FIgnoreSensorObject__FP6SENSORP2SO
// Address: 0x1aee50 - 0x1aee8c

void entry_1aee8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aee8c) {
        switch (ctx->pc) {
            case 0x1aeea8: ctx->pc = 0; goto label_1aeea8;
            case 0x1aeeb8: ctx->pc = 0; goto label_1aeeb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aee8c: 0x14400015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEEE4; return;
    }
    // 0x1aee94: 0x8e420578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1400)));
    // 0x1aee98: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1aee9c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1aeea0: 0x1440fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEE80; return;
    }
label_1aeea8:
    // 0x1aeea8: 0x8e4205a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1440)));
    // 0x1aeeac: 0x1840000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1AEEE0; return;
    }
    // 0x1aeeb4: 0x265005a4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1444));
label_1aeeb8:
    // 0x1aeeb8: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1aeebc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1aeec4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1aeec4
// Address: 0x1aeec4 - 0x1aef00

void entry_1aeec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aeec4) {
        switch (ctx->pc) {
            case 0x1aeee0: ctx->pc = 0; goto label_1aeee0;
            case 0x1aeee4: ctx->pc = 0; goto label_1aeee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aeec4: 0x14400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1aeee4;
    }
    // 0x1aeecc: 0x8e4205a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1440)));
    // 0x1aeed0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1aeed4: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1aeed8: 0x1440fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AEEB8; return;
    }
label_1aeee0:
    // 0x1aeee0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1aeee4:
    // 0x1aeee4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1aeee8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1aeeec: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1aeef0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1aeef4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aeef8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FOnlySensorTriggerObject__FP6SENSORP2SO
// Address: 0x1aef00 - 0x1aef48

void entry_1aef48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aef48) {
        switch (ctx->pc) {
            case 0x1aef58: ctx->pc = 0; goto label_1aef58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aef48: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1aef4c: 0x14600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1aef58;
    }
    // 0x1aef54: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1aef58:
    // 0x1aef58: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aef5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aef64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1aef68; return;
}


// Function: PauseSensor__FP6SENSOR
// Address: 0x1aef68 - 0x1aef7c

void entry_1aef7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aef7c) {
        switch (ctx->pc) {
            case 0x1aef94: ctx->pc = 0; goto label_1aef94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aef7c: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1aef94;
    }
    // 0x1aef84: 0xc4400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1aef88: 0xe60005cc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1484), *(uint32_t*)&val); }
    // 0x1aef8c: 0xac400018
    WRITE32(ADD32(GPR_U32(ctx, 2), 24), GPR_U32(ctx, 0));
    // 0x1aef90: 0xae0205c8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1480), GPR_U32(ctx, 2));
label_1aef94:
    // 0x1aef94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1aef98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSensor__FP6SENSORf
// Address: 0x1aefa0 - 0x1aefb4

void entry_1aefb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aefb4) {
        switch (ctx->pc) {
            case 0x1aefec: ctx->pc = 0; goto label_1aefec;
            case 0x1aeff0: ctx->pc = 0; goto label_1aeff0;
            case 0x1aeff4: ctx->pc = 0; goto label_1aeff4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aefb4: 0x8e0405c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1480)));
    // 0x1aefb8: 0x1080000c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1aefec;
    }
    // 0x1aefc0: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1aefc4: 0x1040000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1aeff0;
    }
    // 0x1aefcc: 0x8c432220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8736)));
    // 0x1aefd0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1aefd4: 0x50620007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        goto label_1aeff4;
    }
    // 0x1aefdc: 0xc60005cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1484)); ctx->f[0] = *(float*)&val; }
    // 0x1aefe0: 0xe4800018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 24), *(uint32_t*)&val); }
    // 0x1aefe4: 0xae0005cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1484), GPR_U32(ctx, 0));
    // 0x1aefe8: 0xae0005c8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1480), GPR_U32(ctx, 0));
label_1aefec:
    // 0x1aefec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1aeff0:
    // 0x1aeff0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1aeff4:
    // 0x1aeff4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1aeffc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1af000; return;
}


// Function: AddSensorTriggerObject__FP6SENSOR3OID
// Address: 0x1af000 - 0x1af028

void entry_1af0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af0b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1af0b8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1af0bc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1af0c0: 0xe6000b04
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2820), *(uint32_t*)&val); }
    // 0x1af0c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1af0c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadLasenFromBrx__FP5LASENP18CBinaryInputStream
// Address: 0x1af0d0 - 0x1af0e4

void entry_1af0e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af0e4: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1af0e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1af0ec: 0x24c644b8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 17592));
    // 0x1af0f0: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1af0f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1af0f8
// Address: 0x1af0f8 - 0x1af108

void entry_1af0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af0f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1af0fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1af100: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BindLasen__FP5LASEN
// Address: 0x1af108 - 0x1af12c

void entry_1af12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af12c) {
        switch (ctx->pc) {
            case 0x1af168: ctx->pc = 0; goto label_1af168;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af12c: 0x26230034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 52));
    // 0x1af130: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1af134: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1af138: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1af13c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1af140: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1af144: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1af148: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1af14c: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1af150: 0x8e230034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1af154: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1af158: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1af15c: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1af160: 0x1200005b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF2D0; return;
    }
label_1af168:
    // 0x1af168: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1af16c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1af174);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 110));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1af174
// Address: 0x1af174 - 0x1af208

void entry_1af174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af174) {
        switch (ctx->pc) {
            case 0x1af1f0: ctx->pc = 0; goto label_1af1f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af174: 0x1040003c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF268; return;
    }
    // 0x1af17c: 0x8e2305d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1492)));
    // 0x1af180: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x1af184: 0x1040004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF2B8; return;
    }
    // 0x1af18c: 0x8e120034
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1af190: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1af194: 0x14400048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF2B8; return;
    }
    // 0x1af19c: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1af1a0: 0x24620001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1af1a4: 0x642818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1af1a8: 0xae2205d4
    WRITE32(ADD32(GPR_U32(ctx, 17), 1492), GPR_U32(ctx, 2));
    // 0x1af1ac: 0xb12021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 17)));
    // 0x1af1b0: 0xac9005e0
    WRITE32(ADD32(GPR_U32(ctx, 4), 1504), GPR_U32(ctx, 16));
    // 0x1af1b4: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1af1b8: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1af1bc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1af1c0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1af1c4: 0xc440fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x1af1c8: 0xe48005e4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 1508), *(uint32_t*)&val); }
    // 0x1af1cc: 0x8e230ae0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 2784)));
    // 0x1af1d0: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1af1d4: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1af1d8: 0x82180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x1af1dc: 0xae230ae0
    WRITE32(ADD32(GPR_U32(ctx, 17), 2784), GPR_U32(ctx, 3));
    // 0x1af1e0: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1af1e4: 0x18400033
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_1af2b4(rdram, ctx, runtime); return;
    }
    // 0x1af1ec: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
label_1af1f0:
    // 0x1af1f0: 0x133100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 19), 4));
    // 0x1af1f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1af1f8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1af1fc: 0x463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1af200: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1af208);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1af208
// Address: 0x1af208 - 0x1af270

void entry_1af208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af208) {
        switch (ctx->pc) {
            case 0x1af24c: ctx->pc = 0; goto label_1af24c;
            case 0x1af268: ctx->pc = 0; goto label_1af268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af208: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1af20c: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1af210: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af214: 0xc62002a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 680)); ctx->f[0] = *(float*)&val; }
    // 0x1af218: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af21c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1af220: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af224: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1af228: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af22c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1af230: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1af234: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1af238: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1af23c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af240: 0x0
    // NOP
    // 0x1af244: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 680), *(uint32_t*)&val); }
        goto label_1af24c;
    }
label_1af24c:
    // 0x1af24c: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1af250: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1af254: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1af258: 0x5440ffe5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
        ctx->pc = 0x1AF1F0; return;
    }
    // 0x1af260: 0x10000015
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF2B8; return;
    }
label_1af268:
    // 0x1af268: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1af270);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1af270
// Address: 0x1af270 - 0x1af2b4

void entry_1af270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af270: 0x10400011
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF2B8; return;
    }
    // 0x1af278: 0x8e230604
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1540)));
    // 0x1af27c: 0x2c620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 4));
    // 0x1af280: 0x1040000c
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1af2b4(rdram, ctx, runtime); return;
    }
    // 0x1af288: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1af28c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1af290: 0x24420608
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1544));
    // 0x1af294: 0xae230604
    WRITE32(ADD32(GPR_U32(ctx, 17), 1540), GPR_U32(ctx, 3));
    // 0x1af298: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1af29c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1af2a0: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1af2a4: 0x38630289
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 649));
    // 0x1af2a8: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x1af2ac: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x1af2b4);
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_1af2b4
// Address: 0x1af2b4 - 0x1af2fc

void entry_1af2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af2b4) {
        switch (ctx->pc) {
            case 0x1af2b8: ctx->pc = 0; goto label_1af2b8;
            case 0x1af2d0: ctx->pc = 0; goto label_1af2d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af2b4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1af2b8:
    // 0x1af2b8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1af2bc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1af2c0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1af2c4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1af2c8: 0x1600ffa7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF168; return;
    }
label_1af2d0:
    // 0x1af2d0: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x1af2d4: 0x3c030300
    SET_GPR_U32(ctx, 3, ((uint32_t)768 << 16));
    // 0x1af2d8: 0x3c040200
    SET_GPR_U32(ctx, 4, ((uint32_t)512 << 16));
    // 0x1af2dc: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1af2e0: 0x10440006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        entry_1af2fc(rdram, ctx, runtime); return;
    }
    // 0x1af2e8: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1af2ec: 0xc62c02a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 680)); ctx->f[12] = *(float*)&val; }
    // 0x1af2f0: 0x26260088
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 136));
    // 0x1af2f4: 0xc07bad8
    SET_GPR_U32(ctx, 31, 0x1af2fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7876)));
    ClipVismapSphereOneHop__FP6VISMAPP6VECTORfPi(rdram, ctx, runtime); return;
}


// Function: entry_1af2fc
// Address: 0x1af2fc - 0x1af380

void entry_1af2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af2fc) {
        switch (ctx->pc) {
            case 0x1af318: ctx->pc = 0; goto label_1af318;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af2fc: 0x220802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1af300: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1af304: 0x10400022
    SET_GPR_U32(ctx, 18, ((uint32_t)768 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF390; return;
    }
    // 0x1af30c: 0x3c110200
    SET_GPR_U32(ctx, 17, ((uint32_t)512 << 16));
    // 0x1af310: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1af314: 0x0
    // NOP
label_1af318:
    // 0x1af318: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af31c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1af320: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af324: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1af328: 0xc60202a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 680)); ctx->f[2] = *(float*)&val; }
    // 0x1af32c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af330: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1af334: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1af338: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1af33c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1af340: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1af344: 0xc4a102a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 680)); ctx->f[1] = *(float*)&val; }
    // 0x1af348: 0x46020300
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1af34c: 0x46016036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af350: 0x0
    // NOP
    // 0x1af354: 0x4501000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1AF394; return;
    }
    // 0x1af35c: 0xdca202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 712)));
    // 0x1af360: 0x521024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1af364: 0x10510006
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 5), 680), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        entry_1af380(rdram, ctx, runtime); return;
    }
    // 0x1af36c: 0x8ca20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 20)));
    // 0x1af370: 0x24a60088
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 5), 136));
    // 0x1af374: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x1af378: 0xc07bad8
    SET_GPR_U32(ctx, 31, 0x1af380);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7876)));
    ClipVismapSphereOneHop__FP6VISMAPP6VECTORfPi(rdram, ctx, runtime); return;
}


// Function: entry_1af380
// Address: 0x1af380 - 0x1af3b8

void entry_1af380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af380) {
        switch (ctx->pc) {
            case 0x1af390: ctx->pc = 0; goto label_1af390;
            case 0x1af394: ctx->pc = 0; goto label_1af394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af380: 0x8e100018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1af384: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1af388: 0x5440ffe3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
        ctx->pc = 0x1AF318; return;
    }
label_1af390:
    // 0x1af390: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_1af394:
    // 0x1af394: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1af398: 0xae82b314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    // 0x1af39c: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1af3a0: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1af3a4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1af3a8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1af3ac: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1af3b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostLasenLoad__FP5LASEN
// Address: 0x1af3b8 - 0x1af3f0

void entry_1af3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af3f0) {
        switch (ctx->pc) {
            case 0x1af400: ctx->pc = 0; goto label_1af400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af3f0: 0x8e4205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1492)));
    // 0x1af3f4: 0x1840002f
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1AF4B4; return;
    }
    // 0x1af3fc: 0x2171018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_1af400:
    // 0x1af400: 0x244205e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1504));
    // 0x1af404: 0x242a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1af408: 0x8e840000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1af40c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1af410: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1af414: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1af41c);
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1af41c
// Address: 0x1af41c - 0x1af448

void entry_1af41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af41c) {
        switch (ctx->pc) {
            case 0x1af438: ctx->pc = 0; goto label_1af438;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af41c: 0x52000021
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1492)));
        ctx->pc = 0x1AF4A4; return;
    }
    // 0x1af424: 0x8ea20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 36)));
    // 0x1af428: 0x1840001c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1AF49C; return;
    }
    // 0x1af430: 0x26900028
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 40));
    // 0x1af434: 0x26b10028
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 21), 40));
label_1af438:
    // 0x1af438: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1af43c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1af440: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x1af448);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1af448
// Address: 0x1af448 - 0x1af468

void entry_1af448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af448: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1af44c: 0xae040000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 4));
    // 0x1af450: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1af454: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1af458: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1AF46C; return;
    }
    // 0x1af460: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1af468);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1af468
// Address: 0x1af468 - 0x1af47c

void entry_1af468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af468) {
        switch (ctx->pc) {
            case 0x1af46c: ctx->pc = 0; goto label_1af46c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af468: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1af46c:
    // 0x1af46c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1af470: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1af474: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1af47c);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1af47c
// Address: 0x1af47c - 0x1af4c4

void entry_1af47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af47c) {
        switch (ctx->pc) {
            case 0x1af49c: ctx->pc = 0; goto label_1af49c;
            case 0x1af4a4: ctx->pc = 0; goto label_1af4a4;
            case 0x1af4b4: ctx->pc = 0; goto label_1af4b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af47c: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1af480: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1af484: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    // 0x1af488: 0x8ea20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 36)));
    // 0x1af48c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1af490: 0x1440ffe9
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF438; return;
    }
    // 0x1af498: 0x8ea20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 36)));
label_1af49c:
    // 0x1af49c: 0xae820024
    WRITE32(ADD32(GPR_U32(ctx, 20), 36), GPR_U32(ctx, 2));
    // 0x1af4a0: 0x8e4205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1492)));
label_1af4a4:
    // 0x1af4a4: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1af4a8: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1af4ac: 0x1440ffd4
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF400; return;
    }
label_1af4b4:
    // 0x1af4b4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1af4b8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1af4bc: 0xc06bbc0
    SET_GPR_U32(ctx, 31, 0x1af4c4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    FOnlySensorTriggerObject__FP6SENSORP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1af4c4
// Address: 0x1af4c4 - 0x1af4dc

void entry_1af4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af4c4: 0xae420b00
    WRITE32(ADD32(GPR_U32(ctx, 18), 2816), GPR_U32(ctx, 2));
    // 0x1af4c8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1af4cc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1af4d0: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1af4d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1af4dc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1376)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1af4dc
// Address: 0x1af4dc - 0x1af508

void entry_1af4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af4dc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1af4e0: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1af4e4: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1af4e8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1af4ec: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1af4f0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1af4f4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1af4f8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1af4fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1af500: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateBusyLasenSenseTimes__Fv
// Address: 0x1af508 - 0x1af5c8

void entry_1af5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af5e4) {
        switch (ctx->pc) {
            case 0x1af614: ctx->pc = 0; goto label_1af614;
            case 0x1af624: ctx->pc = 0; goto label_1af624;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af5e4: 0xc6000b08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2824)); ctx->f[0] = *(float*)&val; }
    // 0x1af5e8: 0xc6010b04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2820)); ctx->f[1] = *(float*)&val; }
    // 0x1af5ec: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1af5f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1af5f4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1af5f8: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1af5fc: 0x46140840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[20]);
    // 0x1af600: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af604: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1af614;
    }
    // 0x1af60c: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1af624;
    }
label_1af614:
    // 0x1af614: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af618: 0x0
    // NOP
    // 0x1af61c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[3]);
        goto label_1af624;
    }
label_1af624:
    // 0x1af624: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1af628: 0xe6010b04
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 2820), *(uint32_t*)&val); }
    // 0x1af62c: 0x8c6244d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 17616)));
    // 0x1af630: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        ctx->pc = 0x1AF644; return;
    }
    // 0x1af638: 0xc06bd42
    SET_GPR_U32(ctx, 31, 0x1af640);
    UpdateBusyLasenSenseTimes__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1af640
// Address: 0x1af640 - 0x1af734

void entry_1af640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af640) {
        switch (ctx->pc) {
            case 0x1af644: ctx->pc = 0; goto label_1af644;
            case 0x1af71c: ctx->pc = 0; goto label_1af71c;
            case 0x1af720: ctx->pc = 0; goto label_1af720;
            case 0x1af724: ctx->pc = 0; goto label_1af724;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af640: 0x8e030558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
label_1af644:
    // 0x1af644: 0x2c620009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 9));
    // 0x1af648: 0x1040004d
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1af780(rdram, ctx, runtime); return;
    }
    // 0x1af650: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1af654: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1af658: 0x2442cfc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294954944));
    // 0x1af65c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1af660: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1af664: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1af66c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1af670: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1af674: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1af678: 0xc60105b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1464)); ctx->f[1] = *(float*)&val; }
    // 0x1af67c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1af680: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af684: 0x0
    // NOP
    // 0x1af688: 0x45000024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1af71c;
    }
    // 0x1af690: 0x10000022
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1af71c;
    }
    // 0x1af698: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1af69c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1af6a0: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1af6a4: 0x1000001f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1af724;
    }
    // 0x1af6ac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1af6b0: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1af6b4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1af6b8: 0xc60105bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1468)); ctx->f[1] = *(float*)&val; }
    // 0x1af6bc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1af6c0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af6c4: 0x0
    // NOP
    // 0x1af6c8: 0x45020015
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1af720;
    }
    // 0x1af6d0: 0x8e030554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x1af6d4: 0x10600022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF760; return;
    }
    // 0x1af6dc: 0x14620029
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AF784; return;
    }
    // 0x1af6e4: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1af6e8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1af6ec: 0x1000000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1af724;
    }
    // 0x1af6f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1af6f8: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1af6fc: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1af700: 0xc60105b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1464)); ctx->f[1] = *(float*)&val; }
    // 0x1af704: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1af708: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af70c: 0x0
    // NOP
    // 0x1af710: 0x45000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1af71c;
    }
    // 0x1af718: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
label_1af71c:
    // 0x1af71c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1af720:
    // 0x1af720: 0x8c420130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 304)));
label_1af724:
    // 0x1af724: 0x10400016
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1af780(rdram, ctx, runtime); return;
    }
    // 0x1af72c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1af734);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1af734
// Address: 0x1af734 - 0x1af780

void entry_1af734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af734) {
        switch (ctx->pc) {
            case 0x1af760: ctx->pc = 0; goto label_1af760;
            case 0x1af76c: ctx->pc = 0; goto label_1af76c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af734: 0x10000013
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF784; return;
    }
    // 0x1af73c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1af740: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x1af744: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1af748: 0xc6010aec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2796)); ctx->f[1] = *(float*)&val; }
    // 0x1af74c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1af750: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af754: 0x0
    // NOP
    // 0x1af758: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1af76c;
    }
label_1af760:
    // 0x1af760: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1af764: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1af780(rdram, ctx, runtime); return;
    }
label_1af76c:
    // 0x1af76c: 0x8c420130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 304)));
    // 0x1af770: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1af780(rdram, ctx, runtime); return;
    }
    // 0x1af778: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1af780);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1af780
// Address: 0x1af780 - 0x1af794

void entry_1af780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af780) {
        switch (ctx->pc) {
            case 0x1af784: ctx->pc = 0; goto label_1af784;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af780: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1af784:
    // 0x1af784: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1af788: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1af78c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1af794);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1af794
// Address: 0x1af794 - 0x1af7a8

void entry_1af794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af794: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1af798: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1af79c: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1af7a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreezeLasen__FP5LASENi
// Address: 0x1af7a8 - 0x1af7c4

void entry_1af7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af7c4: 0x52000009
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x1AF7EC; return;
    }
    // 0x1af7cc: 0x8e220af8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2808)));
    // 0x1af7d0: 0x1040000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF800; return;
    }
    // 0x1af7d8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1af7dc: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1af7e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7336));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1af7e4
// Address: 0x1af7e4 - 0x1af7f8

void entry_1af7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af7e4) {
        switch (ctx->pc) {
            case 0x1af7ec: ctx->pc = 0; goto label_1af7ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af7e4: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 17), 2808), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF800; return;
    }
label_1af7ec:
    // 0x1af7ec: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1af7f0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1af7f8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7336));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1af7f8
// Address: 0x1af7f8 - 0x1af820

void entry_1af7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af7f8) {
        switch (ctx->pc) {
            case 0x1af800: ctx->pc = 0; goto label_1af800;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af7f8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1af7fc: 0xae220af8
    WRITE32(ADD32(GPR_U32(ctx, 17), 2808), GPR_U32(ctx, 2));
label_1af800:
    // 0x1af800: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1af804: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1af808: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1af80c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1af810: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1af814: 0xac6244d0
    WRITE32(ADD32(GPR_U32(ctx, 3), 17616), GPR_U32(ctx, 2));
    // 0x1af818: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderLasenSelf__FP5LASENP2CMP2RO
// Address: 0x1af820 - 0x1af86c

void entry_1af86c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af86c) {
        switch (ctx->pc) {
            case 0x1af894: ctx->pc = 0; goto label_1af894;
            case 0x1af8a0: ctx->pc = 0; goto label_1af8a0;
            case 0x1af8b8: ctx->pc = 0; goto label_1af8b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af86c: 0x8e830558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1368)));
    // 0x1af870: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1af874: 0x10620091
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AFABC; return;
    }
    // 0x1af87c: 0x460008f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x1AFABC; return;
    }
    // 0x1af884: 0x10400003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1af894;
    }
    // 0x1af88c: 0x10000004
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 20), 2788)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1af8a0;
    }
label_1af894:
    // 0x1af894: 0x10400089
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFABC; return;
    }
    // 0x1af89c: 0x8e9e0ae8
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 20), 2792)));
label_1af8a0:
    // 0x1af8a0: 0x17c00005
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_1af8b8;
    }
    // 0x1af8a8: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1af8ac: 0x8c5e1d14
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 2), 7444)));
    // 0x1af8b0: 0x13c00082
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFABC; return;
    }
label_1af8b8:
    // 0x1af8b8: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1af8c0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1af8c0
// Address: 0x1af8c0 - 0x1af8cc

void entry_1af8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1af8c0: 0x8e840ae0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 2784)));
    // 0x1af8c4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1af8cc);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1af8cc
// Address: 0x1af8cc - 0x1af908

void entry_1af8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af8cc) {
        switch (ctx->pc) {
            case 0x1af8e0: ctx->pc = 0; goto label_1af8e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af8cc: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1af8d0: 0x8e8205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1492)));
    // 0x1af8d4: 0x18400076
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1AFAB0; return;
    }
    // 0x1af8dc: 0x0
    // NOP
label_1af8e0:
    // 0x1af8e0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1af8e4: 0x2021018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1af8e8: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1af8ec: 0x244205e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1504));
    // 0x1af8f0: 0x2829821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1af8f4: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1af8f8: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1af8fc: 0x8c750034
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1af900: 0xc06c0d8
    SET_GPR_U32(ctx, 31, 0x1af908);
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 21), 12)));
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime); return;
}


// Function: entry_1af908
// Address: 0x1af908 - 0x1af95c

void entry_1af908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af908) {
        switch (ctx->pc) {
            case 0x1af924: ctx->pc = 0; goto label_1af924;
            case 0x1af940: ctx->pc = 0; goto label_1af940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af908: 0x8e62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x1af90c: 0x10400005
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1af924;
    }
    // 0x1af914: 0x8e620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1af918: 0x24420002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2));
    // 0x1af91c: 0x51182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 17)));
    // 0x1af920: 0x43880b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
label_1af924:
    // 0x1af924: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1af928: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1af92c: 0xafb00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 16));
    // 0x1af930: 0x1a20000e
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x1AF96C; return;
    }
    // 0x1af938: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1af93c: 0x0
    // NOP
label_1af940:
    // 0x1af940: 0x8ea20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 24)));
    // 0x1af944: 0x123100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 18), 4));
    // 0x1af948: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1af94c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1af950: 0x463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1af954: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1af95c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1af95c
// Address: 0x1af95c - 0x1afa4c

void entry_1af95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1af95c) {
        switch (ctx->pc) {
            case 0x1af96c: ctx->pc = 0; goto label_1af96c;
            case 0x1af98c: ctx->pc = 0; goto label_1af98c;
            case 0x1af9a8: ctx->pc = 0; goto label_1af9a8;
            case 0x1afa1c: ctx->pc = 0; goto label_1afa1c;
            case 0x1afa34: ctx->pc = 0; goto label_1afa34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1af95c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1af960: 0x251102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 17)));
    // 0x1af964: 0x1440fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF940; return;
    }
label_1af96c:
    // 0x1af96c: 0x8e62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x1af970: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1af98c;
    }
    // 0x1af978: 0x8e620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1af97c: 0x7a630010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1af980: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1af984: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1af988: 0x7c430010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 3));
label_1af98c:
    // 0x1af98c: 0x1ae00038
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 23) <= 0) {
        ctx->pc = 0x1AFA70; return;
    }
    // 0x1af994: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1af998: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1af99c: 0x26d10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 22), 16));
    // 0x1af9a0: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1af9a4: 0x0
    // NOP
label_1af9a8:
    // 0x1af9a8: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1af9ac: 0x4615b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    // 0x1af9b0: 0xda020010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1af9b4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af9b8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af9bc: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1af9c0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af9c4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1af9c8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1af9cc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1af9d0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1af9d4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1af9d8: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1af9dc: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1af9e0: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1afa1c;
    }
    // 0x1af9e8: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1af9ec: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1af9f0: 0x4600b801
    ctx->f[0] = FPU_SUB_S(ctx->f[23], ctx->f[0]);
    // 0x1af9f4: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1af9f8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1af9fc: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1afa00: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1afa04: 0xda030000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1afa08: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1afa0c: 0xda010010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1afa10: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1afa14: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1afa18: 0xfa020010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_1afa1c:
    // 0x1afa1c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1afa20: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1afa24: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1afa28: 0x10400002
    ctx->f[12] = FPU_MOV_S(ctx->f[13]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1afa34;
    }
    // 0x1afa30: 0xc44d0040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[13] = *(float*)&val; }
label_1afa34:
    // 0x1afa34: 0x4614ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x1afa38: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1afa3c: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1afa40: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1afa44: 0xc049a2e
    SET_GPR_U32(ctx, 31, 0x1afa4c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime); return;
}


// Function: entry_1afa4c
// Address: 0x1afa4c - 0x1afab8

void entry_1afa4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afa4c) {
        switch (ctx->pc) {
            case 0x1afa70: ctx->pc = 0; goto label_1afa70;
            case 0x1afa74: ctx->pc = 0; goto label_1afa74;
            case 0x1afa9c: ctx->pc = 0; goto label_1afa9c;
            case 0x1afaa0: ctx->pc = 0; goto label_1afaa0;
            case 0x1afab0: ctx->pc = 0; goto label_1afab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afa4c: 0x4615b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1afa50: 0x0
    // NOP
    // 0x1afa54: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1368)));
        goto label_1afa74;
    }
    // 0x1afa5c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1afa60: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1afa64: 0x257102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 23)));
    // 0x1afa68: 0x1440ffcf
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF9A8; return;
    }
label_1afa70:
    // 0x1afa70: 0x8e830558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1368)));
label_1afa74:
    // 0x1afa74: 0x4600009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_1afa9c;
    }
    // 0x1afa7c: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 19), 8), *(uint32_t*)&val); }
        goto label_1afa9c;
    }
    // 0x1afa84: 0x28620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 7));
    // 0x1afa88: 0x10400004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1afa9c;
    }
    // 0x1afa90: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1492)));
        goto label_1afaa0;
    }
    // 0x1afa98: 0xe6750008
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 19), 8), *(uint32_t*)&val); }
label_1afa9c:
    // 0x1afa9c: 0x8e8205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1492)));
label_1afaa0:
    // 0x1afaa0: 0x8fb00018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x1afaa4: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1afaa8: 0x1440ff8d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AF8E0; return;
    }
label_1afab0:
    // 0x1afab0: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1afab8);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1afab8
// Address: 0x1afab8 - 0x1afaf8

void entry_1afab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afab8) {
        switch (ctx->pc) {
            case 0x1afabc: ctx->pc = 0; goto label_1afabc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afab8: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_1afabc:
    // 0x1afabc: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1afac0: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1afac4: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1afac8: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1afacc: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1afad0: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1afad4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1afad8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1afadc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1afae0: 0xc7b700d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[23] = *(float*)&val; }
    // 0x1afae4: 0xc7b600d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[22] = *(float*)&val; }
    // 0x1afae8: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x1afaec: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1afaf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001afaf8__FP6SENSORP2SO
// Address: 0x1afaf8 - 0x1afb38

void FUN_001afaf8__FP6SENSORP2SO(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1afaf8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1afafc: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1afb00: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x1afb04: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1afb08: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1afb0c: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1afb10: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1afb14: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1afb18: 0x14400021
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFBA0; return;
    }
    // 0x1afb20: 0x8e030050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1afb24: 0x8c820050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 80)));
    // 0x1afb28: 0x1062001d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AFBA0; return;
    }
    // 0x1afb30: 0xc06bb94
    SET_GPR_U32(ctx, 31, 0x1afb38);
    FIgnoreSensorObject__FP6SENSORP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1afb38
// Address: 0x1afb38 - 0x1afb78

void entry_1afb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1afb38: 0x14400019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFBA0; return;
    }
    // 0x1afb40: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1afb44: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1afb48: 0x56030011
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 716)));
        ctx->pc = 0x1AFB90; return;
    }
    // 0x1afb50: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1afb54: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1afb58: 0x5462000d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 716)));
        ctx->pc = 0x1AFB90; return;
    }
    // 0x1afb60: 0x8e03239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x1afb64: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1afb68: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 716)));
        ctx->pc = 0x1AFB90; return;
    }
    // 0x1afb70: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1afb78);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1afb78
// Address: 0x1afb78 - 0x1afbb0

void entry_1afb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afb78) {
        switch (ctx->pc) {
            case 0x1afb90: ctx->pc = 0; goto label_1afb90;
            case 0x1afba0: ctx->pc = 0; goto label_1afba0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afb78: 0x3c030001
    SET_GPR_U32(ctx, 3, ((uint32_t)1 << 16));
    // 0x1afb7c: 0x34632000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8192));
    // 0x1afb80: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1afb84: 0x14400006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1afba0;
    }
    // 0x1afb8c: 0x9e0202cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 716)));
label_1afb90:
    // 0x1afb90: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1afb94: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1afb98: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x1afb9c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
label_1afba0:
    // 0x1afba0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1afba4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1afba8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SenseLasen__FP5LASENP7SENSORS
// Address: 0x1afbb0 - 0x1afc28

void entry_1afc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1afc28: 0x8e640ae0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 2784)));
    // 0x1afc2c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1afc34);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1afc34
// Address: 0x1afc34 - 0x1afc74

void entry_1afc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afc34) {
        switch (ctx->pc) {
            case 0x1afc48: ctx->pc = 0; goto label_1afc48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afc34: 0xafa200b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 2));
    // 0x1afc38: 0x8e6205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1492)));
    // 0x1afc3c: 0x18400117
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B009C; return;
    }
    // 0x1afc44: 0x0
    // NOP
label_1afc48:
    // 0x1afc48: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1afc4c: 0x2021018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1afc50: 0x4480b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 0);
    // 0x1afc54: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1afc58: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1afc5c: 0xafb000bc
    WRITE32(ADD32(GPR_U32(ctx, 29), 188), GPR_U32(ctx, 16));
    // 0x1afc60: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1afc64: 0x244205e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1504));
    // 0x1afc68: 0x262a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1afc6c: 0xc06c0d8
    SET_GPR_U32(ctx, 31, 0x1afc74);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SCalcLasenShapeExtent__FP5LASENP5LBEAM(rdram, ctx, runtime); return;
}


// Function: entry_1afc74
// Address: 0x1afc74 - 0x1afcac

void entry_1afc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afc74) {
        switch (ctx->pc) {
            case 0x1afc90: ctx->pc = 0; goto label_1afc90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afc74: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1afc78: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x1afc7c: 0x8c520034
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1afc80: 0x8e51000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1afc84: 0x1a20000d
    WRITE32(ADD32(GPR_U32(ctx, 20), 12), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x1AFCBC; return;
    }
    // 0x1afc8c: 0x8fb000b8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 184)));
label_1afc90:
    // 0x1afc90: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1afc94: 0x153100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 21), 4));
    // 0x1afc98: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1afc9c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1afca0: 0x463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1afca4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1afcac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1afcac
// Address: 0x1afcac - 0x1afde4

void entry_1afcac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afcac) {
        switch (ctx->pc) {
            case 0x1afcbc: ctx->pc = 0; goto label_1afcbc;
            case 0x1afcd0: ctx->pc = 0; goto label_1afcd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afcac: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1afcb0: 0x2b1102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 17)));
    // 0x1afcb4: 0x1440fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFC90; return;
    }
label_1afcbc:
    // 0x1afcbc: 0x2622ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1afcc0: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1afcc4: 0x184000c3
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1AFFD4; return;
    }
    // 0x1afccc: 0x8fa300b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 184)));
label_1afcd0:
    // 0x1afcd0: 0x151100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 4));
    // 0x1afcd4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1afcd8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1afcdc: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1afce0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1afce4: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1afce8: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1afcec: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1afcf0: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1afcf4: 0x8e630b00
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 2816)));
    // 0x1afcf8: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1afcfc: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1afd00: 0x4be409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1afd04: 0x4be411c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1afd08: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1afd0c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afd10: 0xfba70090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1afd14: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afd18: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1afd1c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afd20: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1afd24: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1afd28: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afd2c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1afd30: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1afd34: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1afd38: 0x4482a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 2);
    // 0x1afd3c: 0x10600036
    ctx->f[20] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFE18; return;
    }
    // 0x1afd44: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1afd48: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1afd4c: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1afd50: 0x4be00193
    // Unhandled VU0 Special1 function: 0x13
    // 0x1afd54: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1afd58: 0xd8620040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1afd5c: 0xfba500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1afd60: 0x4be238ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1afd64: 0xd8640070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1afd68: 0xd8630050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1afd6c: 0xd8610060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 96)));
    // 0x1afd70: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1afd74: 0x4be208bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1afd78: 0x4be220be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1afd7c: 0x4be530fc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1afd80: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1afd84: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1afd88: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1afd8c: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1afd90: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x1afd94: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x1afd98: 0x2c500001
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x1afd9c: 0x12000035
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1afe74(rdram, ctx, runtime); return;
    }
    // 0x1afda4: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1afda8: 0x1080001b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFE18; return;
    }
    // 0x1afdb0: 0x8e6305d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1488)));
    // 0x1afdb4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1afdb8: 0x14620017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AFE18; return;
    }
    // 0x1afdc0: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x1afdc4: 0x1462000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 11792));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AFDF8; return;
    }
    // 0x1afdcc: 0x8c83239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9116)));
    // 0x1afdd0: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1afdd4: 0x14620009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1AFDFC; return;
    }
    // 0x1afddc: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1afde4);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1afde4
// Address: 0x1afde4 - 0x1afe10

void entry_1afde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afde4) {
        switch (ctx->pc) {
            case 0x1afdf8: ctx->pc = 0; goto label_1afdf8;
            case 0x1afdfc: ctx->pc = 0; goto label_1afdfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afde4: 0x3c030001
    SET_GPR_U32(ctx, 3, ((uint32_t)1 << 16));
    // 0x1afde8: 0x34632000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8192));
    // 0x1afdec: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1afdf0: 0x14400009
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 11792));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFE18; return;
    }
label_1afdf8:
    // 0x1afdf8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1afdfc:
    // 0x1afdfc: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1afe00: 0x27a60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1afe04: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1afe08: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1afe10);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1afe10
// Address: 0x1afe10 - 0x1afe28

void entry_1afe10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afe10) {
        switch (ctx->pc) {
            case 0x1afe18: ctx->pc = 0; goto label_1afe18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afe10: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1afe14: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1afe18:
    // 0x1afe18: 0x12000016
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1afe74(rdram, ctx, runtime); return;
    }
    // 0x1afe20: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1afe28);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1afe28
// Address: 0x1afe28 - 0x1afe50

void entry_1afe28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1afe28: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x1afe2c: 0x3c07001b
    SET_GPR_U32(ctx, 7, ((uint32_t)27 << 16));
    // 0x1afe30: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1afe34: 0x27a900b0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1afe38: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1afe3c: 0x27aa00b4
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 180));
    // 0x1afe40: 0x24e7faf8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294966008));
    // 0x1afe44: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1afe48: 0xc077134
    SET_GPR_U32(ctx, 31, 0x1afe50);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1afe50
// Address: 0x1afe50 - 0x1afe6c

void entry_1afe50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1afe50: 0x8fa700b0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1afe54: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1afe58: 0x8fa800b4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x1afe5c: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1afe60: 0x27a60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1afe64: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1afe6c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1afe6c
// Address: 0x1afe6c - 0x1afe74

void entry_1afe6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1afe6c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1afe74);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1afe74
// Address: 0x1afe74 - 0x1afef4

void entry_1afe74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1afe74) {
        switch (ctx->pc) {
            case 0x1afec0: ctx->pc = 0; goto label_1afec0;
            case 0x1afee8: ctx->pc = 0; goto label_1afee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1afe74: 0x1240004e
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFFB0; return;
    }
    // 0x1afe7c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1afe80: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1afe84: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afe88: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afe8c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1afe90: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afe94: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1afe98: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1afe9c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1afea0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1afea4: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1afea8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1afeac: 0x4600b800
    ctx->f[0] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
    // 0x1afeb0: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1afeb4: 0x0
    // NOP
    // 0x1afeb8: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1afec0;
    }
label_1afec0:
    // 0x1afec0: 0x5040003c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[21]);
        ctx->pc = 0x1AFFB4; return;
    }
    // 0x1afec8: 0xfa830010
    WRITE128(ADD32(GPR_U32(ctx, 20), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1afecc: 0xae950020
    WRITE32(ADD32(GPR_U32(ctx, 20), 32), GPR_U32(ctx, 21));
    // 0x1afed0: 0xae92000c
    WRITE32(ADD32(GPR_U32(ctx, 20), 12), GPR_U32(ctx, 18));
    // 0x1afed4: 0x8ec30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1afed8: 0x28620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 8));
    // 0x1afedc: 0x10400002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1afee8;
    }
    // 0x1afee4: 0x38570001
    SET_GPR_U32(ctx, 23, XOR32(GPR_U32(ctx, 2), 1));
label_1afee8:
    // 0x1afee8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1afeec: 0xc06bb5e
    SET_GPR_U32(ctx, 31, 0x1afef4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FCheckSensorObject__FP6SENSORP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1afef4
// Address: 0x1afef4 - 0x1aff70

void entry_1afef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1afef4: 0x50400038
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
        ctx->pc = 0x1AFFD8; return;
    }
    // 0x1afefc: 0x8ec20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1aff00: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1aff04: 0x2c830007
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 7));
    // 0x1aff08: 0x10600022
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1aff94(rdram, ctx, runtime); return;
    }
    // 0x1aff10: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1aff14: 0x2442cff0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294954992));
    // 0x1aff18: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1aff1c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1aff20: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1aff28: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1aff2c: 0x10000019
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1aff94(rdram, ctx, runtime); return;
    }
    // 0x1aff34: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1aff38: 0xaec20000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 2));
    // 0x1aff3c: 0x8ec30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1aff40: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1aff44: 0x54620014
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1AFF98; return;
    }
    // 0x1aff4c: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x1aff50: 0x8e222e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x1aff54: 0x56420010
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1AFF98; return;
    }
    // 0x1aff5c: 0x27b000a0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1aff60: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1aff64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1aff68: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1aff70);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1aff70
// Address: 0x1aff70 - 0x1aff84

void entry_1aff70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aff70: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x1aff74: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1aff78: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1aff7c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1aff84);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1aff84
// Address: 0x1aff84 - 0x1aff94

void entry_1aff84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1aff84: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1AFF98; return;
    }
    // 0x1aff8c: 0xc06bbda
    SET_GPR_U32(ctx, 31, 0x1aff94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PauseSensor__FP6SENSOR(rdram, ctx, runtime); return;
}


// Function: entry_1aff94
// Address: 0x1aff94 - 0x1affa8

void entry_1aff94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1aff94) {
        switch (ctx->pc) {
            case 0x1aff98: ctx->pc = 0; goto label_1aff98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1aff94: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_1aff98:
    // 0x1aff98: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1aff9c: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1affa0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1affa8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1affa8
// Address: 0x1affa8 - 0x1b002c

void entry_1affa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1affa8) {
        switch (ctx->pc) {
            case 0x1affb0: ctx->pc = 0; goto label_1affb0;
            case 0x1affb4: ctx->pc = 0; goto label_1affb4;
            case 0x1affd4: ctx->pc = 0; goto label_1affd4;
            case 0x1affd8: ctx->pc = 0; goto label_1affd8;
            case 0x1afff0: ctx->pc = 0; goto label_1afff0;
            case 0x1b0024: ctx->pc = 0; goto label_1b0024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1affa8: 0x1000000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1affd8;
    }
label_1affb0:
    // 0x1affb0: 0x4615bdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[21]);
label_1affb4:
    // 0x1affb4: 0x4617b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1affb8: 0x0
    // NOP
    // 0x1affbc: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
        goto label_1affd8;
    }
    // 0x1affc4: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1affc8: 0x2be102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 30)));
    // 0x1affcc: 0x1440ff40
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1AFCD0; return;
    }
label_1affd4:
    // 0x1affd4: 0x8e820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
label_1affd8:
    // 0x1affd8: 0x1840002b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1B0088; return;
    }
    // 0x1affe0: 0x34158000
    SET_GPR_U32(ctx, 21, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1affe4: 0x15aa7c
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 21) << (32 + 9));
    // 0x1affe8: 0x27b20070
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1affec: 0x26900028
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 40));
label_1afff0:
    // 0x1afff0: 0x12e0001e
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B006C; return;
    }
    // 0x1afff8: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x1afffc: 0x1040001b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B006C; return;
    }
    // 0x1b0004: 0xdc420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 2), 1336)));
    // 0x1b0008: 0x551024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1b000c: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1b0024;
    }
    // 0x1b0014: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1b0018: 0x14400014
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1B006C; return;
    }
    // 0x1b0020: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1b0024:
    // 0x1b0024: 0xc0555de
    SET_GPR_U32(ctx, 31, 0x1b002c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PemitbEnsureEmitter__FP7EMITTER4ENSK(rdram, ctx, runtime); return;
}


// Function: entry_1b002c
// Address: 0x1b002c - 0x1b0048

void entry_1a00d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a00d0 inside RenderSpark__FP5SPARKP2CM (0x1a00a0 - 0x1a0194)
    ctx->pc = 0x1a00d0;
    RenderSpark__FP5SPARKP2CM(rdram, ctx, runtime);
}

void entry_1a0140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0140 inside RenderSpark__FP5SPARKP2CM (0x1a00a0 - 0x1a0194)
    ctx->pc = 0x1a0140;
    RenderSpark__FP5SPARKP2CM(rdram, ctx, runtime);
}

void entry_1a0150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0150 inside RenderSpark__FP5SPARKP2CM (0x1a00a0 - 0x1a0194)
    ctx->pc = 0x1a0150;
    RenderSpark__FP5SPARKP2CM(rdram, ctx, runtime);
}

void entry_1a018c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a018c inside RenderSpark__FP5SPARKP2CM (0x1a00a0 - 0x1a0194)
    ctx->pc = 0x1a018c;
    RenderSpark__FP5SPARKP2CM(rdram, ctx, runtime);
}

void entry_1a019c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a019c inside entry_1a0194 (0x1a0194 - 0x1a01a8)
    ctx->pc = 0x1a019c;
    entry_1a0194(rdram, ctx, runtime);
}

void entry_1a01ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a01ac inside entry_1a01a8 (0x1a01a8 - 0x1a01b8)
    ctx->pc = 0x1a01ac;
    entry_1a01a8(rdram, ctx, runtime);
}

void entry_1a037c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a037c inside SetTrailTrls__FP5TRAIL4TRLSPv (0x1a0338 - 0x1a0390)
    ctx->pc = 0x1a037c;
    SetTrailTrls__FP5TRAIL4TRLSPv(rdram, ctx, runtime);
}

void entry_1a03a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a03a4 inside entry_1a0390 (0x1a0390 - 0x1a03bc)
    ctx->pc = 0x1a03a4;
    entry_1a0390(rdram, ctx, runtime);
}

void entry_1a03d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a03d4 inside entry_1a03bc (0x1a03bc - 0x1a043c)
    ctx->pc = 0x1a03d4;
    entry_1a03bc(rdram, ctx, runtime);
}

void entry_1a03d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a03d8 inside entry_1a03bc (0x1a03bc - 0x1a043c)
    ctx->pc = 0x1a03d8;
    entry_1a03bc(rdram, ctx, runtime);
}

void entry_1a03e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a03e0 inside entry_1a03bc (0x1a03bc - 0x1a043c)
    ctx->pc = 0x1a03e0;
    entry_1a03bc(rdram, ctx, runtime);
}

void entry_1a0404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0404 inside entry_1a03bc (0x1a03bc - 0x1a043c)
    ctx->pc = 0x1a0404;
    entry_1a03bc(rdram, ctx, runtime);
}

void entry_1a0414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0414 inside entry_1a03bc (0x1a03bc - 0x1a043c)
    ctx->pc = 0x1a0414;
    entry_1a03bc(rdram, ctx, runtime);
}

void entry_1a0444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0444 inside entry_1a043c (0x1a043c - 0x1a0474)
    ctx->pc = 0x1a0444;
    entry_1a043c(rdram, ctx, runtime);
}

void entry_1a047c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a047c inside entry_1a0474 (0x1a0474 - 0x1a04a0)
    ctx->pc = 0x1a047c;
    entry_1a0474(rdram, ctx, runtime);
}

void entry_1a0484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0484 inside entry_1a0474 (0x1a0474 - 0x1a04a0)
    ctx->pc = 0x1a0484;
    entry_1a0474(rdram, ctx, runtime);
}

void entry_1a0488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0488 inside entry_1a0474 (0x1a0474 - 0x1a04a0)
    ctx->pc = 0x1a0488;
    entry_1a0474(rdram, ctx, runtime);
}

void entry_1a048c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a048c inside entry_1a0474 (0x1a0474 - 0x1a04a0)
    ctx->pc = 0x1a048c;
    entry_1a0474(rdram, ctx, runtime);
}

void entry_1a0588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0588 inside entry_1a04e4 (0x1a04e4 - 0x1a059c)
    ctx->pc = 0x1a0588;
    entry_1a04e4(rdram, ctx, runtime);
}

void entry_1a0590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0590 inside entry_1a04e4 (0x1a04e4 - 0x1a059c)
    ctx->pc = 0x1a0590;
    entry_1a04e4(rdram, ctx, runtime);
}

void entry_1a05b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a05b4 inside entry_1a05ac (0x1a05ac - 0x1a05c4)
    ctx->pc = 0x1a05b4;
    entry_1a05ac(rdram, ctx, runtime);
}

void entry_1a05c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a05c8 inside entry_1a05c4 (0x1a05c4 - 0x1a05d8)
    ctx->pc = 0x1a05c8;
    entry_1a05c4(rdram, ctx, runtime);
}

void entry_1a065c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a065c inside ProjectTrailTransform__FP5TRAILf (0x1a05d8 - 0x1a06f8)
    ctx->pc = 0x1a065c;
    ProjectTrailTransform__FP5TRAILf(rdram, ctx, runtime);
}

void entry_1a066c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a066c inside ProjectTrailTransform__FP5TRAILf (0x1a05d8 - 0x1a06f8)
    ctx->pc = 0x1a066c;
    ProjectTrailTransform__FP5TRAILf(rdram, ctx, runtime);
}

void entry_1a0684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0684 inside ProjectTrailTransform__FP5TRAILf (0x1a05d8 - 0x1a06f8)
    ctx->pc = 0x1a0684;
    ProjectTrailTransform__FP5TRAILf(rdram, ctx, runtime);
}

void entry_1a0694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0694 inside ProjectTrailTransform__FP5TRAILf (0x1a05d8 - 0x1a06f8)
    ctx->pc = 0x1a0694;
    ProjectTrailTransform__FP5TRAILf(rdram, ctx, runtime);
}

void entry_1a06b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a06b8 inside ProjectTrailTransform__FP5TRAILf (0x1a05d8 - 0x1a06f8)
    ctx->pc = 0x1a06b8;
    ProjectTrailTransform__FP5TRAILf(rdram, ctx, runtime);
}

void entry_1a06f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a06f0 inside ProjectTrailTransform__FP5TRAILf (0x1a05d8 - 0x1a06f8)
    ctx->pc = 0x1a06f0;
    ProjectTrailTransform__FP5TRAILf(rdram, ctx, runtime);
}

void entry_1a0700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0700 inside entry_1a06f8 (0x1a06f8 - 0x1a0748)
    ctx->pc = 0x1a0700;
    entry_1a06f8(rdram, ctx, runtime);
}

void entry_1a074c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a074c inside entry_1a0748 (0x1a0748 - 0x1a0758)
    ctx->pc = 0x1a074c;
    entry_1a0748(rdram, ctx, runtime);
}

void entry_1a078c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a078c inside entry_1a0784 (0x1a0784 - 0x1a07fc)
    ctx->pc = 0x1a078c;
    entry_1a0784(rdram, ctx, runtime);
}

void entry_1a0800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0800 inside entry_1a07fc (0x1a07fc - 0x1a0924)
    ctx->pc = 0x1a0800;
    entry_1a07fc(rdram, ctx, runtime);
}

void entry_1a0860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0860 inside entry_1a07fc (0x1a07fc - 0x1a0924)
    ctx->pc = 0x1a0860;
    entry_1a07fc(rdram, ctx, runtime);
}

void entry_1a0870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0870 inside entry_1a07fc (0x1a07fc - 0x1a0924)
    ctx->pc = 0x1a0870;
    entry_1a07fc(rdram, ctx, runtime);
}

void entry_1a08d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a08d8 inside entry_1a07fc (0x1a07fc - 0x1a0924)
    ctx->pc = 0x1a08d8;
    entry_1a07fc(rdram, ctx, runtime);
}

void entry_1a08e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a08e8 inside entry_1a07fc (0x1a07fc - 0x1a0924)
    ctx->pc = 0x1a08e8;
    entry_1a07fc(rdram, ctx, runtime);
}

void entry_1a08f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a08f4 inside entry_1a07fc (0x1a07fc - 0x1a0924)
    ctx->pc = 0x1a08f4;
    entry_1a07fc(rdram, ctx, runtime);
}

void entry_1a08fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a08fc inside entry_1a07fc (0x1a07fc - 0x1a0924)
    ctx->pc = 0x1a08fc;
    entry_1a07fc(rdram, ctx, runtime);
}

void entry_1a092c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a092c inside entry_1a0924 (0x1a0924 - 0x1a0934)
    ctx->pc = 0x1a092c;
    entry_1a0924(rdram, ctx, runtime);
}

void entry_1a0938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0938 inside entry_1a0934 (0x1a0934 - 0x1a0950)
    ctx->pc = 0x1a0938;
    entry_1a0934(rdram, ctx, runtime);
}

void entry_1a097c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a097c inside HandleTrailMessage__FP5TRAIL5MSGIDPv (0x1a0950 - 0x1a099c)
    ctx->pc = 0x1a097c;
    HandleTrailMessage__FP5TRAIL5MSGIDPv(rdram, ctx, runtime);
}

void entry_1a0990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0990 inside HandleTrailMessage__FP5TRAIL5MSGIDPv (0x1a0950 - 0x1a099c)
    ctx->pc = 0x1a0990;
    HandleTrailMessage__FP5TRAIL5MSGIDPv(rdram, ctx, runtime);
}

void entry_1a09a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a09a4 inside entry_1a099c (0x1a099c - 0x1a09b0)
    ctx->pc = 0x1a09a4;
    entry_1a099c(rdram, ctx, runtime);
}

void entry_1a09b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a09b4 inside entry_1a09b0 (0x1a09b0 - 0x1a09c0)
    ctx->pc = 0x1a09b4;
    entry_1a09b0(rdram, ctx, runtime);
}

void entry_1a0b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0b0c inside entry_1a0b08 (0x1a0b08 - 0x1a0b20)
    ctx->pc = 0x1a0b0c;
    entry_1a0b08(rdram, ctx, runtime);
}

void entry_1a0fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a0fd8 inside entry_1a0fd4 (0x1a0fd4 - 0x1a0fe8)
    ctx->pc = 0x1a0fd8;
    entry_1a0fd4(rdram, ctx, runtime);
}

void entry_1a10a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a10a4 inside ProjectOrbitTransform__FP5ORBITf (0x1a1030 - 0x1a11c0)
    ctx->pc = 0x1a10a4;
    ProjectOrbitTransform__FP5ORBITf(rdram, ctx, runtime);
}

void entry_1a10b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a10b8 inside ProjectOrbitTransform__FP5ORBITf (0x1a1030 - 0x1a11c0)
    ctx->pc = 0x1a10b8;
    ProjectOrbitTransform__FP5ORBITf(rdram, ctx, runtime);
}

void entry_1a12d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a12d4 inside entry_1a11ec (0x1a11ec - 0x1a1314)
    ctx->pc = 0x1a12d4;
    entry_1a11ec(rdram, ctx, runtime);
}

void entry_1a1348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1348 inside entry_1a133c (0x1a133c - 0x1a1360)
    ctx->pc = 0x1a1348;
    entry_1a133c(rdram, ctx, runtime);
}

void entry_1a1368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1368 inside entry_1a1360 (0x1a1360 - 0x1a1398)
    ctx->pc = 0x1a1368;
    entry_1a1360(rdram, ctx, runtime);
}

void entry_1a1384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1384 inside entry_1a1360 (0x1a1360 - 0x1a1398)
    ctx->pc = 0x1a1384;
    entry_1a1360(rdram, ctx, runtime);
}

void entry_1a14e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a14e8 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a14e8;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a14f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a14f8 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a14f8;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a1504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1504 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a1504;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a1510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1510 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a1510;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a1518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1518 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a1518;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a1530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1530 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a1530;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a1534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1534 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a1534;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a155c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a155c inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a155c;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a1590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1590 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a1590;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a15a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a15a0 inside UpdateRose__FP4ROSEf (0x1a14a0 - 0x1a15a8)
    ctx->pc = 0x1a15a0;
    UpdateRose__FP4ROSEf(rdram, ctx, runtime);
}

void entry_1a15b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a15b0 inside entry_1a15a8 (0x1a15a8 - 0x1a15b8)
    ctx->pc = 0x1a15b0;
    entry_1a15a8(rdram, ctx, runtime);
}

void entry_1a15c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a15c0 inside entry_1a15b8 (0x1a15b8 - 0x1a15c8)
    ctx->pc = 0x1a15c0;
    entry_1a15b8(rdram, ctx, runtime);
}

void entry_1a15cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a15cc inside entry_1a15c8 (0x1a15c8 - 0x1a15d8)
    ctx->pc = 0x1a15cc;
    entry_1a15c8(rdram, ctx, runtime);
}

void entry_1a166c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a166c inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a166c;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a1680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1680 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a1680;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a16a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a16a8 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a16a8;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a16b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a16b8 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a16b8;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a16c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a16c4 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a16c4;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a16d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a16d0 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a16d0;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a16d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a16d8 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a16d8;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a16f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a16f0 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a16f0;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a16f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a16f4 inside RenderRose__FP4ROSEP2CM (0x1a15d8 - 0x1a170c)
    ctx->pc = 0x1a16f4;
    RenderRose__FP4ROSEP2CM(rdram, ctx, runtime);
}

void entry_1a1768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1768 inside entry_1a170c (0x1a170c - 0x1a1790)
    ctx->pc = 0x1a1768;
    entry_1a170c(rdram, ctx, runtime);
}

void entry_1a17f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a17f4 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a17f4;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1808 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1808;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1850 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1850;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1864 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1864;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a18d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a18d8 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a18d8;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a18ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a18ec inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a18ec;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1928 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1928;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1970 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1970;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1990 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1990;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a19b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a19b0 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a19b0;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a24 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a24;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a34 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a34;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a44 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a44;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a68 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a68;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a80 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a80;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a84 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a84;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a8c inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a8c;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1a9c inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1a9c;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1ab8 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1ab8;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1b08 inside entry_1a1790 (0x1a1790 - 0x1a1b1c)
    ctx->pc = 0x1a1b08;
    entry_1a1790(rdram, ctx, runtime);
}

void entry_1a1c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1c20 inside entry_1a1bfc (0x1a1bfc - 0x1a1c94)
    ctx->pc = 0x1a1c20;
    entry_1a1bfc(rdram, ctx, runtime);
}

void entry_1a1c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1c60 inside entry_1a1bfc (0x1a1bfc - 0x1a1c94)
    ctx->pc = 0x1a1c60;
    entry_1a1bfc(rdram, ctx, runtime);
}

void entry_1a1c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1c80 inside entry_1a1bfc (0x1a1bfc - 0x1a1c94)
    ctx->pc = 0x1a1c80;
    entry_1a1bfc(rdram, ctx, runtime);
}

void entry_1a1d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1d74 inside entry_1a1d50 (0x1a1d50 - 0x1a1df0)
    ctx->pc = 0x1a1d74;
    entry_1a1d50(rdram, ctx, runtime);
}

void entry_1a1d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1d88 inside entry_1a1d50 (0x1a1d50 - 0x1a1df0)
    ctx->pc = 0x1a1d88;
    entry_1a1d50(rdram, ctx, runtime);
}

void entry_1a1d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1d98 inside entry_1a1d50 (0x1a1d50 - 0x1a1df0)
    ctx->pc = 0x1a1d98;
    entry_1a1d50(rdram, ctx, runtime);
}

void entry_1a1e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1e50 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1e50;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1e70 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1e70;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1e80 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1e80;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1e90 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1e90;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1ea4 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1ea4;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1eb0 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1eb0;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1ebc inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1ebc;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1ecc inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1ecc;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1ee0 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1ee0;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1ef0 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1ef0;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1ef4 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1ef4;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1f10 inside SetRoseRoses__FP4ROSE5ROSES (0x1a1df0 - 0x1a1f18)
    ctx->pc = 0x1a1f10;
    SetRoseRoses__FP4ROSE5ROSES(rdram, ctx, runtime);
}

void entry_1a1f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a1f34 inside SgnCmpHp__FPCvT0 (0x1a1f18 - 0x1a1f40)
    ctx->pc = 0x1a1f34;
    SgnCmpHp__FPCvT0(rdram, ctx, runtime);
}

void entry_1a20c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a20c0 inside ChpBuildConvexHullXY__FP7MATRIX4iP2HP (0x1a2070 - 0x1a20d8)
    ctx->pc = 0x1a20c0;
    ChpBuildConvexHullXY__FP7MATRIX4iP2HP(rdram, ctx, runtime);
}

void entry_1a2104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2104 inside entry_1a20d8 (0x1a20d8 - 0x1a21a4)
    ctx->pc = 0x1a2104;
    entry_1a20d8(rdram, ctx, runtime);
}

void entry_1a2118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2118 inside entry_1a20d8 (0x1a20d8 - 0x1a21a4)
    ctx->pc = 0x1a2118;
    entry_1a20d8(rdram, ctx, runtime);
}

void entry_1a2180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2180 inside entry_1a20d8 (0x1a20d8 - 0x1a21a4)
    ctx->pc = 0x1a2180;
    entry_1a20d8(rdram, ctx, runtime);
}

void entry_1a21b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a21b0 inside entry_1a21a4 (0x1a21a4 - 0x1a21cc)
    ctx->pc = 0x1a21b0;
    entry_1a21a4(rdram, ctx, runtime);
}

void entry_1a21e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a21e8 inside entry_1a21cc (0x1a21cc - 0x1a22c8)
    ctx->pc = 0x1a21e8;
    entry_1a21cc(rdram, ctx, runtime);
}

void entry_1a2210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2210 inside entry_1a21cc (0x1a21cc - 0x1a22c8)
    ctx->pc = 0x1a2210;
    entry_1a21cc(rdram, ctx, runtime);
}

void entry_1a2260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2260 inside entry_1a21cc (0x1a21cc - 0x1a22c8)
    ctx->pc = 0x1a2260;
    entry_1a21cc(rdram, ctx, runtime);
}

void entry_1a2264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2264 inside entry_1a21cc (0x1a21cc - 0x1a22c8)
    ctx->pc = 0x1a2264;
    entry_1a21cc(rdram, ctx, runtime);
}

void entry_1a2288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2288 inside entry_1a21cc (0x1a21cc - 0x1a22c8)
    ctx->pc = 0x1a2288;
    entry_1a21cc(rdram, ctx, runtime);
}

void entry_1a2330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2330 inside RenderFlying__FP6FLYINGP2CM (0x1a22e0 - 0x1a2354)
    ctx->pc = 0x1a2330;
    RenderFlying__FP6FLYINGP2CM(rdram, ctx, runtime);
}

void entry_1a233c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a233c inside RenderFlying__FP6FLYINGP2CM (0x1a22e0 - 0x1a2354)
    ctx->pc = 0x1a233c;
    RenderFlying__FP6FLYINGP2CM(rdram, ctx, runtime);
}

void entry_1a25b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a25b8 inside entry_1a2580 (0x1a2580 - 0x1a25f0)
    ctx->pc = 0x1a25b8;
    entry_1a2580(rdram, ctx, runtime);
}

void entry_1a25c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a25c0 inside entry_1a2580 (0x1a2580 - 0x1a25f0)
    ctx->pc = 0x1a25c0;
    entry_1a2580(rdram, ctx, runtime);
}

void entry_1a2630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2630 inside FBounceFlying__FP6FLYINGP2SOP6VECTORT2 (0x1a25f0 - 0x1a263c)
    ctx->pc = 0x1a2630;
    FBounceFlying__FP6FLYINGP2SOP6VECTORT2(rdram, ctx, runtime);
}

void entry_1a268c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a268c inside entry_1a2688 (0x1a2688 - 0x1a26b0)
    ctx->pc = 0x1a268c;
    entry_1a2688(rdram, ctx, runtime);
}

void entry_1a26ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a26ec inside entry_1a26e8 (0x1a26e8 - 0x1a26f8)
    ctx->pc = 0x1a26ec;
    entry_1a26e8(rdram, ctx, runtime);
}

void entry_1a28b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a28b8 inside ProjectLeafTransform__FP4LEAFf (0x1a2830 - 0x1a28dc)
    ctx->pc = 0x1a28b8;
    ProjectLeafTransform__FP4LEAFf(rdram, ctx, runtime);
}

void entry_1a28c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a28c8 inside ProjectLeafTransform__FP4LEAFf (0x1a2830 - 0x1a28dc)
    ctx->pc = 0x1a28c8;
    ProjectLeafTransform__FP4LEAFf(rdram, ctx, runtime);
}

void entry_1a29c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a29c4 inside entry_1a296c (0x1a296c - 0x1a2a48)
    ctx->pc = 0x1a29c4;
    entry_1a296c(rdram, ctx, runtime);
}

void entry_1a29d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a29d4 inside entry_1a296c (0x1a296c - 0x1a2a48)
    ctx->pc = 0x1a29d4;
    entry_1a296c(rdram, ctx, runtime);
}

void entry_1a2afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2afc inside entry_1a2af8 (0x1a2af8 - 0x1a2b18)
    ctx->pc = 0x1a2afc;
    entry_1a2af8(rdram, ctx, runtime);
}

void entry_1a2b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2b40 inside FFilterFlameObjects__FPvP2SO (0x1a2b18 - 0x1a2b48)
    ctx->pc = 0x1a2b40;
    FFilterFlameObjects__FPvP2SO(rdram, ctx, runtime);
}

void entry_1a2bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2bd0 inside PostFlameEmit__FP5FLAMEP5EMITB (0x1a2b48 - 0x1a2c64)
    ctx->pc = 0x1a2bd0;
    PostFlameEmit__FP5FLAMEP5EMITB(rdram, ctx, runtime);
}

void entry_1a2c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2c24 inside PostFlameEmit__FP5FLAMEP5EMITB (0x1a2b48 - 0x1a2c64)
    ctx->pc = 0x1a2c24;
    PostFlameEmit__FP5FLAMEP5EMITB(rdram, ctx, runtime);
}

void entry_1a2c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2c30 inside PostFlameEmit__FP5FLAMEP5EMITB (0x1a2b48 - 0x1a2c64)
    ctx->pc = 0x1a2c30;
    PostFlameEmit__FP5FLAMEP5EMITB(rdram, ctx, runtime);
}

void entry_1a2cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2cb8 inside entry_1a2cac (0x1a2cac - 0x1a2cc0)
    ctx->pc = 0x1a2cb8;
    entry_1a2cac(rdram, ctx, runtime);
}

void entry_1a2e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2e30 inside entry_1a2e28 (0x1a2e28 - 0x1a2e40)
    ctx->pc = 0x1a2e30;
    entry_1a2e28(rdram, ctx, runtime);
}

void entry_1a2e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2e58 inside entry_1a2e54 (0x1a2e54 - 0x1a2e68)
    ctx->pc = 0x1a2e58;
    entry_1a2e54(rdram, ctx, runtime);
}

void entry_1a2eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2eec inside entry_1a2ee4 (0x1a2ee4 - 0x1a2f10)
    ctx->pc = 0x1a2eec;
    entry_1a2ee4(rdram, ctx, runtime);
}

void entry_1a2fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2fd4 inside entry_1a2fa0 (0x1a2fa0 - 0x1a2fdc)
    ctx->pc = 0x1a2fd4;
    entry_1a2fa0(rdram, ctx, runtime);
}

void entry_1a2fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a2fe0 inside entry_1a2fdc (0x1a2fdc - 0x1a3008)
    ctx->pc = 0x1a2fe0;
    entry_1a2fdc(rdram, ctx, runtime);
}

void entry_1a30cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a30cc inside entry_1a3038 (0x1a3038 - 0x1a3100)
    ctx->pc = 0x1a30cc;
    entry_1a3038(rdram, ctx, runtime);
}

void entry_1a30dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a30dc inside entry_1a3038 (0x1a3038 - 0x1a3100)
    ctx->pc = 0x1a30dc;
    entry_1a3038(rdram, ctx, runtime);
}

void entry_1a30f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a30f0 inside entry_1a3038 (0x1a3038 - 0x1a3100)
    ctx->pc = 0x1a30f0;
    entry_1a3038(rdram, ctx, runtime);
}

void entry_1a3180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3180 inside entry_1a3178 (0x1a3178 - 0x1a31a0)
    ctx->pc = 0x1a3180;
    entry_1a3178(rdram, ctx, runtime);
}

void entry_1a3184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3184 inside entry_1a3178 (0x1a3178 - 0x1a31a0)
    ctx->pc = 0x1a3184;
    entry_1a3178(rdram, ctx, runtime);
}

void entry_1a32ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a32ec inside entry_1a32e4 (0x1a32e4 - 0x1a3314)
    ctx->pc = 0x1a32ec;
    entry_1a32e4(rdram, ctx, runtime);
}

void entry_1a33cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a33cc inside entry_1a3314 (0x1a3314 - 0x1a34ec)
    ctx->pc = 0x1a33cc;
    entry_1a3314(rdram, ctx, runtime);
}

void entry_1a33e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a33e0 inside entry_1a3314 (0x1a3314 - 0x1a34ec)
    ctx->pc = 0x1a33e0;
    entry_1a3314(rdram, ctx, runtime);
}

void entry_1a3438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3438 inside entry_1a3314 (0x1a3314 - 0x1a34ec)
    ctx->pc = 0x1a3438;
    entry_1a3314(rdram, ctx, runtime);
}

void entry_1a344c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a344c inside entry_1a3314 (0x1a3314 - 0x1a34ec)
    ctx->pc = 0x1a344c;
    entry_1a3314(rdram, ctx, runtime);
}

void entry_1a3494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3494 inside entry_1a3314 (0x1a3314 - 0x1a34ec)
    ctx->pc = 0x1a3494;
    entry_1a3314(rdram, ctx, runtime);
}

void entry_1a34a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a34a4 inside entry_1a3314 (0x1a3314 - 0x1a34ec)
    ctx->pc = 0x1a34a4;
    entry_1a3314(rdram, ctx, runtime);
}

void entry_1a3580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3580 inside entry_1a357c (0x1a357c - 0x1a3598)
    ctx->pc = 0x1a3580;
    entry_1a357c(rdram, ctx, runtime);
}

void entry_1a36ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a36ec inside entry_1a36c4 (0x1a36c4 - 0x1a3714)
    ctx->pc = 0x1a36ec;
    entry_1a36c4(rdram, ctx, runtime);
}

void entry_1a36fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a36fc inside entry_1a36c4 (0x1a36c4 - 0x1a3714)
    ctx->pc = 0x1a36fc;
    entry_1a36c4(rdram, ctx, runtime);
}

void entry_1a38d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a38d4 inside entry_1a3864 (0x1a3864 - 0x1a38f0)
    ctx->pc = 0x1a38d4;
    entry_1a3864(rdram, ctx, runtime);
}

void entry_1a3940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3940 inside entry_1a393c (0x1a393c - 0x1a3974)
    ctx->pc = 0x1a3940;
    entry_1a393c(rdram, ctx, runtime);
}

void entry_1a3980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3980 inside entry_1a397c (0x1a397c - 0x1a3990)
    ctx->pc = 0x1a3980;
    entry_1a397c(rdram, ctx, runtime);
}

void entry_1a39c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a39c0 inside entry_1a39bc (0x1a39bc - 0x1a39c8)
    ctx->pc = 0x1a39c0;
    entry_1a39bc(rdram, ctx, runtime);
}

void entry_1a3a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3a78 inside entry_1a3a38 (0x1a3a38 - 0x1a3a98)
    ctx->pc = 0x1a3a78;
    entry_1a3a38(rdram, ctx, runtime);
}

void entry_1a3ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3ab4 inside entry_1a3a98 (0x1a3a98 - 0x1a3ac8)
    ctx->pc = 0x1a3ab4;
    entry_1a3a98(rdram, ctx, runtime);
}

void entry_1a3bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3bbc inside entry_1a3bb8 (0x1a3bb8 - 0x1a3bd4)
    ctx->pc = 0x1a3bbc;
    entry_1a3bb8(rdram, ctx, runtime);
}

void entry_1a3bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3bd8 inside entry_1a3bd4 (0x1a3bd4 - 0x1a3bf8)
    ctx->pc = 0x1a3bd8;
    entry_1a3bd4(rdram, ctx, runtime);
}

void entry_1a3c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3c1c inside entry_1a3c14 (0x1a3c14 - 0x1a3c2c)
    ctx->pc = 0x1a3c1c;
    entry_1a3c14(rdram, ctx, runtime);
}

void entry_1a3c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3c30 inside entry_1a3c2c (0x1a3c2c - 0x1a3c40)
    ctx->pc = 0x1a3c30;
    entry_1a3c2c(rdram, ctx, runtime);
}

void entry_1a3c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3c74 inside entry_1a3c6c (0x1a3c6c - 0x1a3c80)
    ctx->pc = 0x1a3c74;
    entry_1a3c6c(rdram, ctx, runtime);
}

void entry_1a3dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3dfc inside entry_1a3d88 (0x1a3d88 - 0x1a3e20)
    ctx->pc = 0x1a3dfc;
    entry_1a3d88(rdram, ctx, runtime);
}

void entry_1a3e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3e08 inside entry_1a3d88 (0x1a3d88 - 0x1a3e20)
    ctx->pc = 0x1a3e08;
    entry_1a3d88(rdram, ctx, runtime);
}

void entry_1a3ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3ea0 inside entry_1a3e60 (0x1a3e60 - 0x1a3eb0)
    ctx->pc = 0x1a3ea0;
    entry_1a3e60(rdram, ctx, runtime);
}

void entry_1a3ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3ed8 inside entry_1a3ed0 (0x1a3ed0 - 0x1a3ee0)
    ctx->pc = 0x1a3ed8;
    entry_1a3ed0(rdram, ctx, runtime);
}

void entry_1a3f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3f00 inside entry_1a3ee8 (0x1a3ee8 - 0x1a3f08)
    ctx->pc = 0x1a3f00;
    entry_1a3ee8(rdram, ctx, runtime);
}

void entry_1a3f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a3f8c inside entry_1a3f88 (0x1a3f88 - 0x1a3fc4)
    ctx->pc = 0x1a3f8c;
    entry_1a3f88(rdram, ctx, runtime);
}

void entry_1a4008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4008 inside RovsNextRov__FP3ROV (0x1a3fe0 - 0x1a4070)
    ctx->pc = 0x1a4008;
    RovsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a4018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4018 inside RovsNextRov__FP3ROV (0x1a3fe0 - 0x1a4070)
    ctx->pc = 0x1a4018;
    RovsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a4038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4038 inside RovsNextRov__FP3ROV (0x1a3fe0 - 0x1a4070)
    ctx->pc = 0x1a4038;
    RovsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a4058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4058 inside RovsNextRov__FP3ROV (0x1a3fe0 - 0x1a4070)
    ctx->pc = 0x1a4058;
    RovsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a4060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4060 inside RovsNextRov__FP3ROV (0x1a3fe0 - 0x1a4070)
    ctx->pc = 0x1a4060;
    RovsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a4064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4064 inside RovsNextRov__FP3ROV (0x1a3fe0 - 0x1a4070)
    ctx->pc = 0x1a4064;
    RovsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a40dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a40dc inside SetRovRovs__FP3ROV4ROVS (0x1a4070 - 0x1a4124)
    ctx->pc = 0x1a40dc;
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime);
}

void entry_1a40f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a40f4 inside SetRovRovs__FP3ROV4ROVS (0x1a4070 - 0x1a4124)
    ctx->pc = 0x1a40f4;
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime);
}

void entry_1a4100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4100 inside SetRovRovs__FP3ROV4ROVS (0x1a4070 - 0x1a4124)
    ctx->pc = 0x1a4100;
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime);
}

void entry_1a4108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4108 inside SetRovRovs__FP3ROV4ROVS (0x1a4070 - 0x1a4124)
    ctx->pc = 0x1a4108;
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime);
}

void entry_1a4114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4114 inside SetRovRovs__FP3ROV4ROVS (0x1a4070 - 0x1a4124)
    ctx->pc = 0x1a4114;
    SetRovRovs__FP3ROV4ROVS(rdram, ctx, runtime);
}

void entry_1a4128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4128 inside entry_1a4124 (0x1a4124 - 0x1a4148)
    ctx->pc = 0x1a4128;
    entry_1a4124(rdram, ctx, runtime);
}

void entry_1a4138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4138 inside entry_1a4124 (0x1a4124 - 0x1a4148)
    ctx->pc = 0x1a4138;
    entry_1a4124(rdram, ctx, runtime);
}

void entry_1a4150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4150 inside entry_1a4148 (0x1a4148 - 0x1a4158)
    ctx->pc = 0x1a4150;
    entry_1a4148(rdram, ctx, runtime);
}

void entry_1a415c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a415c inside entry_1a4158 (0x1a4158 - 0x1a4188)
    ctx->pc = 0x1a415c;
    entry_1a4158(rdram, ctx, runtime);
}

void entry_1a416c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a416c inside entry_1a4158 (0x1a4158 - 0x1a4188)
    ctx->pc = 0x1a416c;
    entry_1a4158(rdram, ctx, runtime);
}

void entry_1a4190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4190 inside entry_1a4188 (0x1a4188 - 0x1a4198)
    ctx->pc = 0x1a4190;
    entry_1a4188(rdram, ctx, runtime);
}

void entry_1a41e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a41e4 inside entry_1a41dc (0x1a41dc - 0x1a422c)
    ctx->pc = 0x1a41e4;
    entry_1a41dc(rdram, ctx, runtime);
}

void entry_1a4230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4230 inside entry_1a422c (0x1a422c - 0x1a4258)
    ctx->pc = 0x1a4230;
    entry_1a422c(rdram, ctx, runtime);
}

void entry_1a4274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4274 inside RovtsNextRov__FP3ROV (0x1a4258 - 0x1a42c8)
    ctx->pc = 0x1a4274;
    RovtsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a429c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a429c inside RovtsNextRov__FP3ROV (0x1a4258 - 0x1a42c8)
    ctx->pc = 0x1a429c;
    RovtsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a42bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a42bc inside RovtsNextRov__FP3ROV (0x1a4258 - 0x1a42c8)
    ctx->pc = 0x1a42bc;
    RovtsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a42c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a42c0 inside RovtsNextRov__FP3ROV (0x1a4258 - 0x1a42c8)
    ctx->pc = 0x1a42c0;
    RovtsNextRov__FP3ROV(rdram, ctx, runtime);
}

void entry_1a4304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4304 inside SetRovRovts__FP3ROV5ROVTS (0x1a42c8 - 0x1a4330)
    ctx->pc = 0x1a4304;
    SetRovRovts__FP3ROV5ROVTS(rdram, ctx, runtime);
}

void entry_1a4310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4310 inside SetRovRovts__FP3ROV5ROVTS (0x1a42c8 - 0x1a4330)
    ctx->pc = 0x1a4310;
    SetRovRovts__FP3ROV5ROVTS(rdram, ctx, runtime);
}

void entry_1a4314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4314 inside SetRovRovts__FP3ROV5ROVTS (0x1a42c8 - 0x1a4330)
    ctx->pc = 0x1a4314;
    SetRovRovts__FP3ROV5ROVTS(rdram, ctx, runtime);
}

void entry_1a4318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4318 inside SetRovRovts__FP3ROV5ROVTS (0x1a42c8 - 0x1a4330)
    ctx->pc = 0x1a4318;
    SetRovRovts__FP3ROV5ROVTS(rdram, ctx, runtime);
}

void entry_1a4338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4338 inside entry_1a4330 (0x1a4330 - 0x1a4340)
    ctx->pc = 0x1a4338;
    entry_1a4330(rdram, ctx, runtime);
}

void entry_1a4344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4344 inside entry_1a4340 (0x1a4340 - 0x1a4360)
    ctx->pc = 0x1a4344;
    entry_1a4340(rdram, ctx, runtime);
}

void entry_1a4368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4368 inside entry_1a4360 (0x1a4360 - 0x1a43b0)
    ctx->pc = 0x1a4368;
    entry_1a4360(rdram, ctx, runtime);
}

void entry_1a43b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a43b4 inside entry_1a43b0 (0x1a43b0 - 0x1a43c8)
    ctx->pc = 0x1a43b4;
    entry_1a43b0(rdram, ctx, runtime);
}

void entry_1a4420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4420 inside entry_1a43ec (0x1a43ec - 0x1a4460)
    ctx->pc = 0x1a4420;
    entry_1a43ec(rdram, ctx, runtime);
}

void entry_1a4470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4470 inside entry_1a4468 (0x1a4468 - 0x1a44ac)
    ctx->pc = 0x1a4470;
    entry_1a4468(rdram, ctx, runtime);
}

void entry_1a44bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a44bc inside entry_1a44b4 (0x1a44b4 - 0x1a44e8)
    ctx->pc = 0x1a44bc;
    entry_1a44b4(rdram, ctx, runtime);
}

void entry_1a44d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a44d0 inside entry_1a44b4 (0x1a44b4 - 0x1a44e8)
    ctx->pc = 0x1a44d0;
    entry_1a44b4(rdram, ctx, runtime);
}

void entry_1a44d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a44d4 inside entry_1a44b4 (0x1a44b4 - 0x1a44e8)
    ctx->pc = 0x1a44d4;
    entry_1a44b4(rdram, ctx, runtime);
}

void entry_1a45a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a45a0 inside entry_1a455c (0x1a455c - 0x1a45b8)
    ctx->pc = 0x1a45a0;
    entry_1a455c(rdram, ctx, runtime);
}

void entry_1a4604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4604 inside entry_1a45cc (0x1a45cc - 0x1a4610)
    ctx->pc = 0x1a4604;
    entry_1a45cc(rdram, ctx, runtime);
}

void entry_1a4608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4608 inside entry_1a45cc (0x1a45cc - 0x1a4610)
    ctx->pc = 0x1a4608;
    entry_1a45cc(rdram, ctx, runtime);
}

void entry_1a46a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a46a4 inside entry_1a4698 (0x1a4698 - 0x1a46d0)
    ctx->pc = 0x1a46a4;
    entry_1a4698(rdram, ctx, runtime);
}

void entry_1a46b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a46b4 inside entry_1a4698 (0x1a4698 - 0x1a46d0)
    ctx->pc = 0x1a46b4;
    entry_1a4698(rdram, ctx, runtime);
}

void entry_1a46b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a46b8 inside entry_1a4698 (0x1a4698 - 0x1a46d0)
    ctx->pc = 0x1a46b8;
    entry_1a4698(rdram, ctx, runtime);
}

void entry_1a47b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a47b4 inside entry_1a4780 (0x1a4780 - 0x1a47e0)
    ctx->pc = 0x1a47b4;
    entry_1a4780(rdram, ctx, runtime);
}

void entry_1a48b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a48b8 inside RobkCur__Fv (0x1a4898 - 0x1a48c0)
    ctx->pc = 0x1a48b8;
    RobkCur__Fv(rdram, ctx, runtime);
}

void entry_1a4978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4978 inside entry_1a4970 (0x1a4970 - 0x1a49bc)
    ctx->pc = 0x1a4978;
    entry_1a4970(rdram, ctx, runtime);
}

void entry_1a49a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a49a0 inside entry_1a4970 (0x1a4970 - 0x1a49bc)
    ctx->pc = 0x1a49a0;
    entry_1a4970(rdram, ctx, runtime);
}

void entry_1a49b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a49b0 inside entry_1a4970 (0x1a4970 - 0x1a49bc)
    ctx->pc = 0x1a49b0;
    entry_1a4970(rdram, ctx, runtime);
}

void entry_1a49fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a49fc inside entry_1a49c8 (0x1a49c8 - 0x1a4a34)
    ctx->pc = 0x1a49fc;
    entry_1a49c8(rdram, ctx, runtime);
}

void entry_1a4a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4a18 inside entry_1a49c8 (0x1a49c8 - 0x1a4a34)
    ctx->pc = 0x1a4a18;
    entry_1a49c8(rdram, ctx, runtime);
}

void entry_1a4a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4a28 inside entry_1a49c8 (0x1a49c8 - 0x1a4a34)
    ctx->pc = 0x1a4a28;
    entry_1a49c8(rdram, ctx, runtime);
}

void entry_1a4a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4a68 inside entry_1a4a40 (0x1a4a40 - 0x1a4aa0)
    ctx->pc = 0x1a4a68;
    entry_1a4a40(rdram, ctx, runtime);
}

void entry_1a4a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4a80 inside entry_1a4a40 (0x1a4a40 - 0x1a4aa0)
    ctx->pc = 0x1a4a80;
    entry_1a4a40(rdram, ctx, runtime);
}

void entry_1a4ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4ab0 inside entry_1a4aa0 (0x1a4aa0 - 0x1a4acc)
    ctx->pc = 0x1a4ab0;
    entry_1a4aa0(rdram, ctx, runtime);
}

void entry_1a4ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4ad8 inside entry_1a4acc (0x1a4acc - 0x1a4aec)
    ctx->pc = 0x1a4ad8;
    entry_1a4acc(rdram, ctx, runtime);
}

void entry_1a4afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4afc inside entry_1a4aec (0x1a4aec - 0x1a4b30)
    ctx->pc = 0x1a4afc;
    entry_1a4aec(rdram, ctx, runtime);
}

void entry_1a4b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4b00 inside entry_1a4aec (0x1a4aec - 0x1a4b30)
    ctx->pc = 0x1a4b00;
    entry_1a4aec(rdram, ctx, runtime);
}

void entry_1a4b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4b70 inside entry_1a4b68 (0x1a4b68 - 0x1a4c2c)
    ctx->pc = 0x1a4b70;
    entry_1a4b68(rdram, ctx, runtime);
}

void entry_1a4bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4bbc inside entry_1a4b68 (0x1a4b68 - 0x1a4c2c)
    ctx->pc = 0x1a4bbc;
    entry_1a4b68(rdram, ctx, runtime);
}

void entry_1a4bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4bd0 inside entry_1a4b68 (0x1a4b68 - 0x1a4c2c)
    ctx->pc = 0x1a4bd0;
    entry_1a4b68(rdram, ctx, runtime);
}

void entry_1a4bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4bf0 inside entry_1a4b68 (0x1a4b68 - 0x1a4c2c)
    ctx->pc = 0x1a4bf0;
    entry_1a4b68(rdram, ctx, runtime);
}

void entry_1a4c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4c3c inside entry_1a4c38 (0x1a4c38 - 0x1a4c48)
    ctx->pc = 0x1a4c3c;
    entry_1a4c38(rdram, ctx, runtime);
}

void entry_1a4c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4c68 inside entry_1a4c60 (0x1a4c60 - 0x1a4c70)
    ctx->pc = 0x1a4c68;
    entry_1a4c60(rdram, ctx, runtime);
}

void entry_1a4cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4cec inside entry_1a4ce0 (0x1a4ce0 - 0x1a4d04)
    ctx->pc = 0x1a4cec;
    entry_1a4ce0(rdram, ctx, runtime);
}

void entry_1a4d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4d3c inside entry_1a4d04 (0x1a4d04 - 0x1a4d48)
    ctx->pc = 0x1a4d3c;
    entry_1a4d04(rdram, ctx, runtime);
}

void entry_1a4d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4d4c inside entry_1a4d48 (0x1a4d48 - 0x1a4d60)
    ctx->pc = 0x1a4d4c;
    entry_1a4d48(rdram, ctx, runtime);
}

void entry_1a4d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4d50 inside entry_1a4d48 (0x1a4d48 - 0x1a4d60)
    ctx->pc = 0x1a4d50;
    entry_1a4d48(rdram, ctx, runtime);
}

void entry_1a4d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4d54 inside entry_1a4d48 (0x1a4d48 - 0x1a4d60)
    ctx->pc = 0x1a4d54;
    entry_1a4d48(rdram, ctx, runtime);
}

void entry_1a4d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4d84 inside entry_1a4d80 (0x1a4d80 - 0x1a4d9c)
    ctx->pc = 0x1a4d84;
    entry_1a4d80(rdram, ctx, runtime);
}

void entry_1a4da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4da4 inside entry_1a4d9c (0x1a4d9c - 0x1a4db4)
    ctx->pc = 0x1a4da4;
    entry_1a4d9c(rdram, ctx, runtime);
}

void entry_1a4db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4db8 inside entry_1a4db4 (0x1a4db4 - 0x1a4dc0)
    ctx->pc = 0x1a4db8;
    entry_1a4db4(rdram, ctx, runtime);
}

void entry_1a4e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4e1c inside RobsNextRob__FP3ROB (0x1a4dc0 - 0x1a4ef0)
    ctx->pc = 0x1a4e1c;
    RobsNextRob__FP3ROB(rdram, ctx, runtime);
}

void entry_1a4e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4e38 inside RobsNextRob__FP3ROB (0x1a4dc0 - 0x1a4ef0)
    ctx->pc = 0x1a4e38;
    RobsNextRob__FP3ROB(rdram, ctx, runtime);
}

void entry_1a4ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4ea4 inside RobsNextRob__FP3ROB (0x1a4dc0 - 0x1a4ef0)
    ctx->pc = 0x1a4ea4;
    RobsNextRob__FP3ROB(rdram, ctx, runtime);
}

void entry_1a4ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4ee0 inside RobsNextRob__FP3ROB (0x1a4dc0 - 0x1a4ef0)
    ctx->pc = 0x1a4ee0;
    RobsNextRob__FP3ROB(rdram, ctx, runtime);
}

void entry_1a4ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4ee4 inside RobsNextRob__FP3ROB (0x1a4dc0 - 0x1a4ef0)
    ctx->pc = 0x1a4ee4;
    RobsNextRob__FP3ROB(rdram, ctx, runtime);
}

void entry_1a4f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4f74 inside SetRobRobs__FP3ROB4ROBS (0x1a4ef0 - 0x1a4f84)
    ctx->pc = 0x1a4f74;
    SetRobRobs__FP3ROB4ROBS(rdram, ctx, runtime);
}

void entry_1a4f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4f88 inside entry_1a4f84 (0x1a4f84 - 0x1a4fac)
    ctx->pc = 0x1a4f88;
    entry_1a4f84(rdram, ctx, runtime);
}

void entry_1a4f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a4f8c inside entry_1a4f84 (0x1a4f84 - 0x1a4fac)
    ctx->pc = 0x1a4f8c;
    entry_1a4f84(rdram, ctx, runtime);
}

void entry_1a5028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5028 inside entry_1a5014 (0x1a5014 - 0x1a5030)
    ctx->pc = 0x1a5028;
    entry_1a5014(rdram, ctx, runtime);
}

void entry_1a503c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a503c inside entry_1a5030 (0x1a5030 - 0x1a5044)
    ctx->pc = 0x1a503c;
    entry_1a5030(rdram, ctx, runtime);
}

void entry_1a5090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5090 inside entry_1a5080 (0x1a5080 - 0x1a50ac)
    ctx->pc = 0x1a5090;
    entry_1a5080(rdram, ctx, runtime);
}

void entry_1a50a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a50a4 inside entry_1a5080 (0x1a5080 - 0x1a50ac)
    ctx->pc = 0x1a50a4;
    entry_1a5080(rdram, ctx, runtime);
}

void entry_1a50b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a50b0 inside entry_1a50ac (0x1a50ac - 0x1a50c8)
    ctx->pc = 0x1a50b0;
    entry_1a50ac(rdram, ctx, runtime);
}

void entry_1a50b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a50b8 inside entry_1a50ac (0x1a50ac - 0x1a50c8)
    ctx->pc = 0x1a50b8;
    entry_1a50ac(rdram, ctx, runtime);
}

void entry_1a5110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5110 inside entry_1a510c (0x1a510c - 0x1a5120)
    ctx->pc = 0x1a5110;
    entry_1a510c(rdram, ctx, runtime);
}

void entry_1a516c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a516c inside AddRobRoc__FP3ROB (0x1a5120 - 0x1a518c)
    ctx->pc = 0x1a516c;
    AddRobRoc__FP3ROB(rdram, ctx, runtime);
}

void entry_1a5178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5178 inside AddRobRoc__FP3ROB (0x1a5120 - 0x1a518c)
    ctx->pc = 0x1a5178;
    AddRobRoc__FP3ROB(rdram, ctx, runtime);
}

void entry_1a522c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a522c inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a522c;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5234 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5234;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5250 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5250;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a528c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a528c inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a528c;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a52a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a52a0 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a52a0;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a52ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a52ac inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a52ac;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a52c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a52c0 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a52c0;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a530c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a530c inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a530c;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5318 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5318;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5320 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5320;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a532c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a532c inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a532c;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5338 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5338;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5380 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5380;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5388 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5388;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a5394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5394 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a5394;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a53a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a53a0 inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a53a0;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a53ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a53ac inside entry_1a51c4 (0x1a51c4 - 0x1a53dc)
    ctx->pc = 0x1a53ac;
    entry_1a51c4(rdram, ctx, runtime);
}

void entry_1a54d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a54d0 inside entry_1a54c0 (0x1a54c0 - 0x1a54f8)
    ctx->pc = 0x1a54d0;
    entry_1a54c0(rdram, ctx, runtime);
}

void entry_1a54d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a54d4 inside entry_1a54c0 (0x1a54c0 - 0x1a54f8)
    ctx->pc = 0x1a54d4;
    entry_1a54c0(rdram, ctx, runtime);
}

void entry_1a5554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5554 inside AddRobRoh__FP3ROB (0x1a54f8 - 0x1a5560)
    ctx->pc = 0x1a5554;
    AddRobRoh__FP3ROB(rdram, ctx, runtime);
}

void entry_1a55b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a55b8 inside entry_1a55a4 (0x1a55a4 - 0x1a55e4)
    ctx->pc = 0x1a55b8;
    entry_1a55a4(rdram, ctx, runtime);
}

void entry_1a55d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a55d8 inside entry_1a55a4 (0x1a55a4 - 0x1a55e4)
    ctx->pc = 0x1a55d8;
    entry_1a55a4(rdram, ctx, runtime);
}

void entry_1a5728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5728 inside entry_1a5720 (0x1a5720 - 0x1a5760)
    ctx->pc = 0x1a5728;
    entry_1a5720(rdram, ctx, runtime);
}

void entry_1a57c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a57c8 inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a57c8;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a57dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a57dc inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a57dc;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a5858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5858 inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a5858;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a586c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a586c inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a586c;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a58e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a58e8 inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a58e8;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a58fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a58fc inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a58fc;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a5960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5960 inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a5960;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a5974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5974 inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a5974;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a59d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a59d8 inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a59d8;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a59ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a59ec inside AdjustRobDifficulty__FP3ROBf (0x1a5760 - 0x1a5a3c)
    ctx->pc = 0x1a59ec;
    AdjustRobDifficulty__FP3ROBf(rdram, ctx, runtime);
}

void entry_1a5a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5a50 inside entry_1a5a3c (0x1a5a3c - 0x1a5af4)
    ctx->pc = 0x1a5a50;
    entry_1a5a3c(rdram, ctx, runtime);
}

void entry_1a5a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5a90 inside entry_1a5a3c (0x1a5a3c - 0x1a5af4)
    ctx->pc = 0x1a5a90;
    entry_1a5a3c(rdram, ctx, runtime);
}

void entry_1a5aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5aa4 inside entry_1a5a3c (0x1a5a3c - 0x1a5af4)
    ctx->pc = 0x1a5aa4;
    entry_1a5a3c(rdram, ctx, runtime);
}

void entry_1a5b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5b08 inside entry_1a5af4 (0x1a5af4 - 0x1a5b28)
    ctx->pc = 0x1a5b08;
    entry_1a5af4(rdram, ctx, runtime);
}

void entry_1a5b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5b84 inside entry_1a5b7c (0x1a5b7c - 0x1a5b8c)
    ctx->pc = 0x1a5b84;
    entry_1a5b7c(rdram, ctx, runtime);
}

void entry_1a5b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5b90 inside entry_1a5b8c (0x1a5b8c - 0x1a5b98)
    ctx->pc = 0x1a5b90;
    entry_1a5b8c(rdram, ctx, runtime);
}

void entry_1a5bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5bc8 inside entry_1a5bc0 (0x1a5bc0 - 0x1a5bd8)
    ctx->pc = 0x1a5bc8;
    entry_1a5bc0(rdram, ctx, runtime);
}

void entry_1a5bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5bdc inside entry_1a5bd8 (0x1a5bd8 - 0x1a5bec)
    ctx->pc = 0x1a5bdc;
    entry_1a5bd8(rdram, ctx, runtime);
}

void entry_1a5c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5c1c inside entry_1a5c08 (0x1a5c08 - 0x1a5c38)
    ctx->pc = 0x1a5c1c;
    entry_1a5c08(rdram, ctx, runtime);
}

void entry_1a5ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5ee8 inside entry_1a5ed4 (0x1a5ed4 - 0x1a5f08)
    ctx->pc = 0x1a5ee8;
    entry_1a5ed4(rdram, ctx, runtime);
}

void entry_1a5f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5f18 inside entry_1a5f08 (0x1a5f08 - 0x1a5f64)
    ctx->pc = 0x1a5f18;
    entry_1a5f08(rdram, ctx, runtime);
}

void entry_1a5fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5fd8 inside entry_1a5fd4 (0x1a5fd4 - 0x1a5ff8)
    ctx->pc = 0x1a5fd8;
    entry_1a5fd4(rdram, ctx, runtime);
}

void entry_1a5ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a5ffc inside entry_1a5ff8 (0x1a5ff8 - 0x1a6004)
    ctx->pc = 0x1a5ffc;
    entry_1a5ff8(rdram, ctx, runtime);
}

void entry_1a6024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6024 inside entry_1a601c (0x1a601c - 0x1a603c)
    ctx->pc = 0x1a6024;
    entry_1a601c(rdram, ctx, runtime);
}

void entry_1a6028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6028 inside entry_1a601c (0x1a601c - 0x1a603c)
    ctx->pc = 0x1a6028;
    entry_1a601c(rdram, ctx, runtime);
}

void entry_1a606c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a606c inside entry_1a6058 (0x1a6058 - 0x1a6090)
    ctx->pc = 0x1a606c;
    entry_1a6058(rdram, ctx, runtime);
}

void entry_1a60e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a60e8 inside entry_1a60bc (0x1a60bc - 0x1a613c)
    ctx->pc = 0x1a60e8;
    entry_1a60bc(rdram, ctx, runtime);
}

void entry_1a6124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6124 inside entry_1a60bc (0x1a60bc - 0x1a613c)
    ctx->pc = 0x1a6124;
    entry_1a60bc(rdram, ctx, runtime);
}

void entry_1a612c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a612c inside entry_1a60bc (0x1a60bc - 0x1a613c)
    ctx->pc = 0x1a612c;
    entry_1a60bc(rdram, ctx, runtime);
}

void entry_1a614c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a614c inside entry_1a6148 (0x1a6148 - 0x1a6168)
    ctx->pc = 0x1a614c;
    entry_1a6148(rdram, ctx, runtime);
}

void entry_1a6198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6198 inside TakeRobRoc__FP3ROBP3ROHP3ROC (0x1a6168 - 0x1a61b4)
    ctx->pc = 0x1a6198;
    TakeRobRoc__FP3ROBP3ROHP3ROC(rdram, ctx, runtime);
}

void entry_1a6220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6220 inside entry_1a621c (0x1a621c - 0x1a6238)
    ctx->pc = 0x1a6220;
    entry_1a621c(rdram, ctx, runtime);
}

void entry_1a6270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6270 inside FChooseRobRoh__FP3ROBP3ROC (0x1a6238 - 0x1a62e8)
    ctx->pc = 0x1a6270;
    FChooseRobRoh__FP3ROBP3ROC(rdram, ctx, runtime);
}

void entry_1a62c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a62c8 inside FChooseRobRoh__FP3ROBP3ROC (0x1a6238 - 0x1a62e8)
    ctx->pc = 0x1a62c8;
    FChooseRobRoh__FP3ROBP3ROC(rdram, ctx, runtime);
}

void entry_1a62d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a62d0 inside FChooseRobRoh__FP3ROBP3ROC (0x1a6238 - 0x1a62e8)
    ctx->pc = 0x1a62d0;
    FChooseRobRoh__FP3ROBP3ROC(rdram, ctx, runtime);
}

void entry_1a6308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6308 inside entry_1a6300 (0x1a6300 - 0x1a6328)
    ctx->pc = 0x1a6308;
    entry_1a6300(rdram, ctx, runtime);
}

void entry_1a630c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a630c inside entry_1a6300 (0x1a6300 - 0x1a6328)
    ctx->pc = 0x1a630c;
    entry_1a6300(rdram, ctx, runtime);
}

void entry_1a6380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6380 inside entry_1a6350 (0x1a6350 - 0x1a63cc)
    ctx->pc = 0x1a6380;
    entry_1a6350(rdram, ctx, runtime);
}

void entry_1a63bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a63bc inside entry_1a6350 (0x1a6350 - 0x1a63cc)
    ctx->pc = 0x1a63bc;
    entry_1a6350(rdram, ctx, runtime);
}

void entry_1a63c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a63c4 inside entry_1a6350 (0x1a6350 - 0x1a63cc)
    ctx->pc = 0x1a63c4;
    entry_1a6350(rdram, ctx, runtime);
}

void entry_1a63e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a63e0 inside entry_1a63d8 (0x1a63d8 - 0x1a63f8)
    ctx->pc = 0x1a63e0;
    entry_1a63d8(rdram, ctx, runtime);
}

void entry_1a65e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a65e8 inside entry_1a65e0 (0x1a65e0 - 0x1a65f0)
    ctx->pc = 0x1a65e8;
    entry_1a65e0(rdram, ctx, runtime);
}

void entry_1a66b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a66b4 inside entry_1a6648 (0x1a6648 - 0x1a66bc)
    ctx->pc = 0x1a66b4;
    entry_1a6648(rdram, ctx, runtime);
}

void entry_1a66d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a66d8 inside entry_1a66c8 (0x1a66c8 - 0x1a66e4)
    ctx->pc = 0x1a66d8;
    entry_1a66c8(rdram, ctx, runtime);
}

void entry_1a6730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6730 inside entry_1a671c (0x1a671c - 0x1a6738)
    ctx->pc = 0x1a6730;
    entry_1a671c(rdram, ctx, runtime);
}

void entry_1a6774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6774 inside entry_1a6770 (0x1a6770 - 0x1a6788)
    ctx->pc = 0x1a6774;
    entry_1a6770(rdram, ctx, runtime);
}

void entry_1a6888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6888 inside entry_1a67f8 (0x1a67f8 - 0x1a68a4)
    ctx->pc = 0x1a6888;
    entry_1a67f8(rdram, ctx, runtime);
}

void entry_1a691c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a691c inside entry_1a6914 (0x1a6914 - 0x1a6994)
    ctx->pc = 0x1a691c;
    entry_1a6914(rdram, ctx, runtime);
}

void entry_1a6968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6968 inside entry_1a6914 (0x1a6914 - 0x1a6994)
    ctx->pc = 0x1a6968;
    entry_1a6914(rdram, ctx, runtime);
}

void entry_1a6998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6998 inside entry_1a6994 (0x1a6994 - 0x1a69dc)
    ctx->pc = 0x1a6998;
    entry_1a6994(rdram, ctx, runtime);
}

void entry_1a69bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a69bc inside entry_1a6994 (0x1a6994 - 0x1a69dc)
    ctx->pc = 0x1a69bc;
    entry_1a6994(rdram, ctx, runtime);
}

void entry_1a69cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a69cc inside entry_1a6994 (0x1a6994 - 0x1a69dc)
    ctx->pc = 0x1a69cc;
    entry_1a6994(rdram, ctx, runtime);
}

void entry_1a6ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6ac0 inside entry_1a6ab4 (0x1a6ab4 - 0x1a6ad0)
    ctx->pc = 0x1a6ac0;
    entry_1a6ab4(rdram, ctx, runtime);
}

void entry_1a6b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6b08 inside entry_1a6ad0 (0x1a6ad0 - 0x1a6b14)
    ctx->pc = 0x1a6b08;
    entry_1a6ad0(rdram, ctx, runtime);
}

void entry_1a6bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6bc8 inside entry_1a6b30 (0x1a6b30 - 0x1a6be0)
    ctx->pc = 0x1a6bc8;
    entry_1a6b30(rdram, ctx, runtime);
}

void entry_1a6bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6bcc inside entry_1a6b30 (0x1a6b30 - 0x1a6be0)
    ctx->pc = 0x1a6bcc;
    entry_1a6b30(rdram, ctx, runtime);
}

void entry_1a6c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6c28 inside entry_1a6c20 (0x1a6c20 - 0x1a6c38)
    ctx->pc = 0x1a6c28;
    entry_1a6c20(rdram, ctx, runtime);
}

void entry_1a6c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6c40 inside entry_1a6c38 (0x1a6c38 - 0x1a6c88)
    ctx->pc = 0x1a6c40;
    entry_1a6c38(rdram, ctx, runtime);
}

void entry_1a6c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6c64 inside entry_1a6c38 (0x1a6c38 - 0x1a6c88)
    ctx->pc = 0x1a6c64;
    entry_1a6c38(rdram, ctx, runtime);
}

void entry_1a6c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6c80 inside entry_1a6c38 (0x1a6c38 - 0x1a6c88)
    ctx->pc = 0x1a6c80;
    entry_1a6c38(rdram, ctx, runtime);
}

void entry_1a6c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6c90 inside entry_1a6c88 (0x1a6c88 - 0x1a6ca8)
    ctx->pc = 0x1a6c90;
    entry_1a6c88(rdram, ctx, runtime);
}

void entry_1a6cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6cb0 inside entry_1a6ca8 (0x1a6ca8 - 0x1a6cc4)
    ctx->pc = 0x1a6cb0;
    entry_1a6ca8(rdram, ctx, runtime);
}

void entry_1a6ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6ccc inside entry_1a6cc4 (0x1a6cc4 - 0x1a6cd4)
    ctx->pc = 0x1a6ccc;
    entry_1a6cc4(rdram, ctx, runtime);
}

void entry_1a6cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6cd8 inside entry_1a6cd4 (0x1a6cd4 - 0x1a6d28)
    ctx->pc = 0x1a6cd8;
    entry_1a6cd4(rdram, ctx, runtime);
}

void entry_1a6d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6d74 inside entry_1a6d28 (0x1a6d28 - 0x1a6da4)
    ctx->pc = 0x1a6d74;
    entry_1a6d28(rdram, ctx, runtime);
}

void entry_1a6dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6dc0 inside entry_1a6dbc (0x1a6dbc - 0x1a6de0)
    ctx->pc = 0x1a6dc0;
    entry_1a6dbc(rdram, ctx, runtime);
}

void entry_1a6dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6dc4 inside entry_1a6dbc (0x1a6dbc - 0x1a6de0)
    ctx->pc = 0x1a6dc4;
    entry_1a6dbc(rdram, ctx, runtime);
}

void entry_1a6e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6e6c inside entry_1a6e68 (0x1a6e68 - 0x1a6ec4)
    ctx->pc = 0x1a6e6c;
    entry_1a6e68(rdram, ctx, runtime);
}

void entry_1a6f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6f08 inside entry_1a6f04 (0x1a6f04 - 0x1a6f28)
    ctx->pc = 0x1a6f08;
    entry_1a6f04(rdram, ctx, runtime);
}

void entry_1a6f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6f48 inside ProcContactRoh__FP3ROH (0x1a6f28 - 0x1a6f5c)
    ctx->pc = 0x1a6f48;
    ProcContactRoh__FP3ROH(rdram, ctx, runtime);
}

void entry_1a6f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6f6c inside entry_1a6f5c (0x1a6f5c - 0x1a6f88)
    ctx->pc = 0x1a6f6c;
    entry_1a6f5c(rdram, ctx, runtime);
}

void entry_1a6f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a6f78 inside entry_1a6f5c (0x1a6f5c - 0x1a6f88)
    ctx->pc = 0x1a6f78;
    entry_1a6f5c(rdram, ctx, runtime);
}

void entry_1a70e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a70e0 inside entry_1a70c0 (0x1a70c0 - 0x1a70f4)
    ctx->pc = 0x1a70e0;
    entry_1a70c0(rdram, ctx, runtime);
}

void entry_1a70f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a70f8 inside entry_1a70f4 (0x1a70f4 - 0x1a7104)
    ctx->pc = 0x1a70f8;
    entry_1a70f4(rdram, ctx, runtime);
}

void entry_1a7148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7148 inside entry_1a7140 (0x1a7140 - 0x1a7150)
    ctx->pc = 0x1a7148;
    entry_1a7140(rdram, ctx, runtime);
}

void entry_1a71e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a71e0 inside entry_1a719c (0x1a719c - 0x1a721c)
    ctx->pc = 0x1a71e0;
    entry_1a719c(rdram, ctx, runtime);
}

void entry_1a71f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a71f4 inside entry_1a719c (0x1a719c - 0x1a721c)
    ctx->pc = 0x1a71f4;
    entry_1a719c(rdram, ctx, runtime);
}

void entry_1a7214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7214 inside entry_1a719c (0x1a719c - 0x1a721c)
    ctx->pc = 0x1a7214;
    entry_1a719c(rdram, ctx, runtime);
}

void entry_1a7220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7220 inside entry_1a721c (0x1a721c - 0x1a7230)
    ctx->pc = 0x1a7220;
    entry_1a721c(rdram, ctx, runtime);
}

void entry_1a7280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7280 inside entry_1a727c (0x1a727c - 0x1a7290)
    ctx->pc = 0x1a7280;
    entry_1a727c(rdram, ctx, runtime);
}

void entry_1a73bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a73bc inside entry_1a73b4 (0x1a73b4 - 0x1a73c4)
    ctx->pc = 0x1a73bc;
    entry_1a73b4(rdram, ctx, runtime);
}

void entry_1a7408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7408 inside entry_1a7404 (0x1a7404 - 0x1a7420)
    ctx->pc = 0x1a7408;
    entry_1a7404(rdram, ctx, runtime);
}

void entry_1a7448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7448 inside RocsNextRoc__FP3ROC (0x1a7420 - 0x1a7480)
    ctx->pc = 0x1a7448;
    RocsNextRoc__FP3ROC(rdram, ctx, runtime);
}

void entry_1a7470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7470 inside RocsNextRoc__FP3ROC (0x1a7420 - 0x1a7480)
    ctx->pc = 0x1a7470;
    RocsNextRoc__FP3ROC(rdram, ctx, runtime);
}

void entry_1a7474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7474 inside RocsNextRoc__FP3ROC (0x1a7420 - 0x1a7480)
    ctx->pc = 0x1a7474;
    RocsNextRoc__FP3ROC(rdram, ctx, runtime);
}

void entry_1a7478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7478 inside RocsNextRoc__FP3ROC (0x1a7420 - 0x1a7480)
    ctx->pc = 0x1a7478;
    RocsNextRoc__FP3ROC(rdram, ctx, runtime);
}

void entry_1a74c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a74c0 inside entry_1a74bc (0x1a74bc - 0x1a74f8)
    ctx->pc = 0x1a74c0;
    entry_1a74bc(rdram, ctx, runtime);
}

void entry_1a7500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7500 inside entry_1a74f8 (0x1a74f8 - 0x1a7508)
    ctx->pc = 0x1a7500;
    entry_1a74f8(rdram, ctx, runtime);
}

void entry_1a750c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a750c inside entry_1a7508 (0x1a7508 - 0x1a7520)
    ctx->pc = 0x1a750c;
    entry_1a7508(rdram, ctx, runtime);
}

void entry_1a7604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7604 inside entry_1a7600 (0x1a7600 - 0x1a7618)
    ctx->pc = 0x1a7604;
    entry_1a7600(rdram, ctx, runtime);
}

void entry_1a7608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7608 inside entry_1a7600 (0x1a7600 - 0x1a7618)
    ctx->pc = 0x1a7608;
    entry_1a7600(rdram, ctx, runtime);
}

void entry_1a7624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7624 inside entry_1a7618 (0x1a7618 - 0x1a7630)
    ctx->pc = 0x1a7624;
    entry_1a7618(rdram, ctx, runtime);
}

void entry_1a7668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7668 inside entry_1a765c (0x1a765c - 0x1a7670)
    ctx->pc = 0x1a7668;
    entry_1a765c(rdram, ctx, runtime);
}

void entry_1a76f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a76f4 inside entry_1a76ec (0x1a76ec - 0x1a76fc)
    ctx->pc = 0x1a76f4;
    entry_1a76ec(rdram, ctx, runtime);
}

void entry_1a7700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7700 inside entry_1a76fc (0x1a76fc - 0x1a7708)
    ctx->pc = 0x1a7700;
    entry_1a76fc(rdram, ctx, runtime);
}

void entry_1a77d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a77d0 inside entry_1a77c8 (0x1a77c8 - 0x1a77e0)
    ctx->pc = 0x1a77d0;
    entry_1a77c8(rdram, ctx, runtime);
}

void entry_1a77f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a77f4 inside entry_1a77f0 (0x1a77f0 - 0x1a7800)
    ctx->pc = 0x1a77f4;
    entry_1a77f0(rdram, ctx, runtime);
}

void entry_1a7820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7820 inside entry_1a7818 (0x1a7818 - 0x1a7828)
    ctx->pc = 0x1a7820;
    entry_1a7818(rdram, ctx, runtime);
}

void entry_1a78b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a78b4 inside entry_1a7830 (0x1a7830 - 0x1a7930)
    ctx->pc = 0x1a78b4;
    entry_1a7830(rdram, ctx, runtime);
}

void entry_1a78c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a78c4 inside entry_1a7830 (0x1a7830 - 0x1a7930)
    ctx->pc = 0x1a78c4;
    entry_1a7830(rdram, ctx, runtime);
}

void entry_1a7988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7988 inside entry_1a7984 (0x1a7984 - 0x1a7998)
    ctx->pc = 0x1a7988;
    entry_1a7984(rdram, ctx, runtime);
}

void entry_1a79dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a79dc inside entry_1a79d4 (0x1a79d4 - 0x1a7a38)
    ctx->pc = 0x1a79dc;
    entry_1a79d4(rdram, ctx, runtime);
}

void entry_1a7a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7a08 inside entry_1a79d4 (0x1a79d4 - 0x1a7a38)
    ctx->pc = 0x1a7a08;
    entry_1a79d4(rdram, ctx, runtime);
}

void entry_1a7a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7a40 inside entry_1a7a38 (0x1a7a38 - 0x1a7a50)
    ctx->pc = 0x1a7a40;
    entry_1a7a38(rdram, ctx, runtime);
}

void entry_1a7a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7a8c inside entry_1a7a88 (0x1a7a88 - 0x1a7aa0)
    ctx->pc = 0x1a7a8c;
    entry_1a7a88(rdram, ctx, runtime);
}

void entry_1a7acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7acc inside RopsNextRop__FP3ROP (0x1a7aa0 - 0x1a7b20)
    ctx->pc = 0x1a7acc;
    RopsNextRop__FP3ROP(rdram, ctx, runtime);
}

void entry_1a7af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7af8 inside RopsNextRop__FP3ROP (0x1a7aa0 - 0x1a7b20)
    ctx->pc = 0x1a7af8;
    RopsNextRop__FP3ROP(rdram, ctx, runtime);
}

void entry_1a7afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7afc inside RopsNextRop__FP3ROP (0x1a7aa0 - 0x1a7b20)
    ctx->pc = 0x1a7afc;
    RopsNextRop__FP3ROP(rdram, ctx, runtime);
}

void entry_1a7b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7b14 inside RopsNextRop__FP3ROP (0x1a7aa0 - 0x1a7b20)
    ctx->pc = 0x1a7b14;
    RopsNextRop__FP3ROP(rdram, ctx, runtime);
}

void entry_1a7b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7b58 inside entry_1a7b50 (0x1a7b50 - 0x1a7b64)
    ctx->pc = 0x1a7b58;
    entry_1a7b50(rdram, ctx, runtime);
}

void entry_1a7b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7b68 inside entry_1a7b64 (0x1a7b64 - 0x1a7b88)
    ctx->pc = 0x1a7b68;
    entry_1a7b64(rdram, ctx, runtime);
}

void entry_1a7bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7bd4 inside UpdateRumble__FP6RUMBLE (0x1a7b88 - 0x1a7c5c)
    ctx->pc = 0x1a7bd4;
    UpdateRumble__FP6RUMBLE(rdram, ctx, runtime);
}

void entry_1a7c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7c2c inside UpdateRumble__FP6RUMBLE (0x1a7b88 - 0x1a7c5c)
    ctx->pc = 0x1a7c2c;
    UpdateRumble__FP6RUMBLE(rdram, ctx, runtime);
}

void entry_1a7c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7c74 inside entry_1a7c5c (0x1a7c5c - 0x1a7c8c)
    ctx->pc = 0x1a7c74;
    entry_1a7c5c(rdram, ctx, runtime);
}

void entry_1a7c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7c84 inside entry_1a7c5c (0x1a7c5c - 0x1a7c8c)
    ctx->pc = 0x1a7c84;
    entry_1a7c5c(rdram, ctx, runtime);
}

void entry_1a7c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7c94 inside entry_1a7c8c (0x1a7c8c - 0x1a7cb0)
    ctx->pc = 0x1a7c94;
    entry_1a7c8c(rdram, ctx, runtime);
}

void entry_1a7cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7cc0 inside entry_1a7cb0 (0x1a7cb0 - 0x1a7cd0)
    ctx->pc = 0x1a7cc0;
    entry_1a7cb0(rdram, ctx, runtime);
}

void entry_1a7cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7cd4 inside entry_1a7cd0 (0x1a7cd0 - 0x1a7ce8)
    ctx->pc = 0x1a7cd4;
    entry_1a7cd0(rdram, ctx, runtime);
}

void entry_1a7cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7cd8 inside entry_1a7cd0 (0x1a7cd0 - 0x1a7ce8)
    ctx->pc = 0x1a7cd8;
    entry_1a7cd0(rdram, ctx, runtime);
}

void entry_1a7e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7e28 inside entry_1a7e10 (0x1a7e10 - 0x1a7e40)
    ctx->pc = 0x1a7e28;
    entry_1a7e10(rdram, ctx, runtime);
}

void entry_1a7e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7e2c inside entry_1a7e10 (0x1a7e10 - 0x1a7e40)
    ctx->pc = 0x1a7e2c;
    entry_1a7e10(rdram, ctx, runtime);
}

void entry_1a7e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7e84 inside FUN_001A7E70__Fv (0x1a7e70 - 0x1a7e90)
    ctx->pc = 0x1a7e84;
    FUN_001A7E70__Fv(rdram, ctx, runtime);
}

void entry_1a7eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7eb4 inside FUN_001A7E90 (0x1a7e90 - 0x1a7ee8)
    ctx->pc = 0x1a7eb4;
    FUN_001A7E90(rdram, ctx, runtime);
}

void entry_1a7ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7ebc inside FUN_001A7E90 (0x1a7e90 - 0x1a7ee8)
    ctx->pc = 0x1a7ebc;
    FUN_001A7E90(rdram, ctx, runtime);
}

void entry_1a7ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7ed4 inside FUN_001A7E90 (0x1a7e90 - 0x1a7ee8)
    ctx->pc = 0x1a7ed4;
    FUN_001A7E90(rdram, ctx, runtime);
}

void entry_1a7f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7f18 inside FUN_001A7EE8 (0x1a7ee8 - 0x1a7f50)
    ctx->pc = 0x1a7f18;
    FUN_001A7EE8(rdram, ctx, runtime);
}

void entry_1a7f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7f30 inside FUN_001A7EE8 (0x1a7ee8 - 0x1a7f50)
    ctx->pc = 0x1a7f30;
    FUN_001A7EE8(rdram, ctx, runtime);
}

void entry_1a7f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7f38 inside FUN_001A7EE8 (0x1a7ee8 - 0x1a7f50)
    ctx->pc = 0x1a7f38;
    FUN_001A7EE8(rdram, ctx, runtime);
}

void entry_1a7f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7f40 inside FUN_001A7EE8 (0x1a7ee8 - 0x1a7f50)
    ctx->pc = 0x1a7f40;
    FUN_001A7EE8(rdram, ctx, runtime);
}

void entry_1a7f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7f80 inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7f80;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a7f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7f94 inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7f94;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a7fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7fa0 inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7fa0;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a7fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7fb0 inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7fb0;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a7fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7fc0 inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7fc0;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a7fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7fc4 inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7fc4;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a7fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7fc8 inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7fc8;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a7fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a7fdc inside FUN_001A7F50 (0x1a7f50 - 0x1a7fe8)
    ctx->pc = 0x1a7fdc;
    FUN_001A7F50(rdram, ctx, runtime);
}

void entry_1a8144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8144 inside entry_1a8134 (0x1a8134 - 0x1a8150)
    ctx->pc = 0x1a8144;
    entry_1a8134(rdram, ctx, runtime);
}

void entry_1a8194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8194 inside entry_1a8190 (0x1a8190 - 0x1a8208)
    ctx->pc = 0x1a8194;
    entry_1a8190(rdram, ctx, runtime);
}

void entry_1a8268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8268 inside entry_1a825c (0x1a825c - 0x1a8298)
    ctx->pc = 0x1a8268;
    entry_1a825c(rdram, ctx, runtime);
}

void entry_1a8278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8278 inside entry_1a825c (0x1a825c - 0x1a8298)
    ctx->pc = 0x1a8278;
    entry_1a825c(rdram, ctx, runtime);
}

void entry_1a82b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a82b0 inside entry_1a8298 (0x1a8298 - 0x1a830c)
    ctx->pc = 0x1a82b0;
    entry_1a8298(rdram, ctx, runtime);
}

void entry_1a82e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a82e8 inside entry_1a8298 (0x1a8298 - 0x1a830c)
    ctx->pc = 0x1a82e8;
    entry_1a8298(rdram, ctx, runtime);
}

void entry_1a82fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a82fc inside entry_1a8298 (0x1a8298 - 0x1a830c)
    ctx->pc = 0x1a82fc;
    entry_1a8298(rdram, ctx, runtime);
}

void entry_1a8338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8338 inside entry_1a8318 (0x1a8318 - 0x1a8350)
    ctx->pc = 0x1a8338;
    entry_1a8318(rdram, ctx, runtime);
}

void entry_1a833c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a833c inside entry_1a8318 (0x1a8318 - 0x1a8350)
    ctx->pc = 0x1a833c;
    entry_1a8318(rdram, ctx, runtime);
}

void entry_1a8340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8340 inside entry_1a8318 (0x1a8318 - 0x1a8350)
    ctx->pc = 0x1a8340;
    entry_1a8318(rdram, ctx, runtime);
}

void entry_1a8358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8358 inside entry_1a8350 (0x1a8350 - 0x1a838c)
    ctx->pc = 0x1a8358;
    entry_1a8350(rdram, ctx, runtime);
}

void entry_1a8380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8380 inside entry_1a8350 (0x1a8350 - 0x1a838c)
    ctx->pc = 0x1a8380;
    entry_1a8350(rdram, ctx, runtime);
}

void entry_1a83c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a83c8 inside entry_1a83c4 (0x1a83c4 - 0x1a83d8)
    ctx->pc = 0x1a83c8;
    entry_1a83c4(rdram, ctx, runtime);
}

void entry_1a8404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8404 inside entry_1a83fc (0x1a83fc - 0x1a841c)
    ctx->pc = 0x1a8404;
    entry_1a83fc(rdram, ctx, runtime);
}

void entry_1a8420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8420 inside entry_1a841c (0x1a841c - 0x1a842c)
    ctx->pc = 0x1a8420;
    entry_1a841c(rdram, ctx, runtime);
}

void entry_1a8480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8480 inside entry_1a8450 (0x1a8450 - 0x1a84c8)
    ctx->pc = 0x1a8480;
    entry_1a8450(rdram, ctx, runtime);
}

void entry_1a8484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8484 inside entry_1a8450 (0x1a8450 - 0x1a84c8)
    ctx->pc = 0x1a8484;
    entry_1a8450(rdram, ctx, runtime);
}

void entry_1a8494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8494 inside entry_1a8450 (0x1a8450 - 0x1a84c8)
    ctx->pc = 0x1a8494;
    entry_1a8450(rdram, ctx, runtime);
}

void entry_1a8528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8528 inside entry_1a8524 (0x1a8524 - 0x1a8530)
    ctx->pc = 0x1a8528;
    entry_1a8524(rdram, ctx, runtime);
}

void entry_1a8568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8568 inside entry_1a8560 (0x1a8560 - 0x1a8578)
    ctx->pc = 0x1a8568;
    entry_1a8560(rdram, ctx, runtime);
}

void entry_1a8580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8580 inside entry_1a8578 (0x1a8578 - 0x1a8590)
    ctx->pc = 0x1a8580;
    entry_1a8578(rdram, ctx, runtime);
}

void entry_1a85f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a85f8 inside entry_1a85e8 (0x1a85e8 - 0x1a8600)
    ctx->pc = 0x1a85f8;
    entry_1a85e8(rdram, ctx, runtime);
}

void entry_1a8610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8610 inside entry_1a8600 (0x1a8600 - 0x1a8618)
    ctx->pc = 0x1a8610;
    entry_1a8600(rdram, ctx, runtime);
}

void entry_1a8620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8620 inside entry_1a8618 (0x1a8618 - 0x1a863c)
    ctx->pc = 0x1a8620;
    entry_1a8618(rdram, ctx, runtime);
}

void entry_1a8660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8660 inside entry_1a8650 (0x1a8650 - 0x1a8668)
    ctx->pc = 0x1a8660;
    entry_1a8650(rdram, ctx, runtime);
}

void entry_1a8670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8670 inside entry_1a8668 (0x1a8668 - 0x1a868c)
    ctx->pc = 0x1a8670;
    entry_1a8668(rdram, ctx, runtime);
}

void entry_1a8678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8678 inside entry_1a8668 (0x1a8668 - 0x1a868c)
    ctx->pc = 0x1a8678;
    entry_1a8668(rdram, ctx, runtime);
}

void entry_1a86b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a86b0 inside entry_1a86a0 (0x1a86a0 - 0x1a86b8)
    ctx->pc = 0x1a86b0;
    entry_1a86a0(rdram, ctx, runtime);
}

void entry_1a86c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a86c0 inside entry_1a86b8 (0x1a86b8 - 0x1a86dc)
    ctx->pc = 0x1a86c0;
    entry_1a86b8(rdram, ctx, runtime);
}

void entry_1a86c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a86c4 inside entry_1a86b8 (0x1a86b8 - 0x1a86dc)
    ctx->pc = 0x1a86c4;
    entry_1a86b8(rdram, ctx, runtime);
}

void entry_1a86e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a86e4 inside entry_1a86dc (0x1a86dc - 0x1a86f8)
    ctx->pc = 0x1a86e4;
    entry_1a86dc(rdram, ctx, runtime);
}

void entry_1a8740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8740 inside PrwcFindRwm__FP3RWM3OID (0x1a8718 - 0x1a8778)
    ctx->pc = 0x1a8740;
    PrwcFindRwm__FP3RWM3OID(rdram, ctx, runtime);
}

void entry_1a8758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8758 inside PrwcFindRwm__FP3RWM3OID (0x1a8718 - 0x1a8778)
    ctx->pc = 0x1a8758;
    PrwcFindRwm__FP3RWM3OID(rdram, ctx, runtime);
}

void entry_1a8764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8764 inside PrwcFindRwm__FP3RWM3OID (0x1a8718 - 0x1a8778)
    ctx->pc = 0x1a8764;
    PrwcFindRwm__FP3RWM3OID(rdram, ctx, runtime);
}

void entry_1a876c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a876c inside PrwcFindRwm__FP3RWM3OID (0x1a8718 - 0x1a8778)
    ctx->pc = 0x1a876c;
    PrwcFindRwm__FP3RWM3OID(rdram, ctx, runtime);
}

void entry_1a87a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a87a0 inside entry_1a8788 (0x1a8788 - 0x1a87a8)
    ctx->pc = 0x1a87a0;
    entry_1a8788(rdram, ctx, runtime);
}

void entry_1a87d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a87d0 inside entry_1a87b8 (0x1a87b8 - 0x1a87e0)
    ctx->pc = 0x1a87d0;
    entry_1a87b8(rdram, ctx, runtime);
}

void entry_1a8810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8810 inside entry_1a87f4 (0x1a87f4 - 0x1a8820)
    ctx->pc = 0x1a8810;
    entry_1a87f4(rdram, ctx, runtime);
}

void entry_1a8838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8838 inside FIsRwmAmmo__FP3RWMP2SO (0x1a8820 - 0x1a88a0)
    ctx->pc = 0x1a8838;
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8868 inside FIsRwmAmmo__FP3RWMP2SO (0x1a8820 - 0x1a88a0)
    ctx->pc = 0x1a8868;
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a887c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a887c inside FIsRwmAmmo__FP3RWMP2SO (0x1a8820 - 0x1a88a0)
    ctx->pc = 0x1a887c;
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8888 inside FIsRwmAmmo__FP3RWMP2SO (0x1a8820 - 0x1a88a0)
    ctx->pc = 0x1a8888;
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a888c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a888c inside FIsRwmAmmo__FP3RWMP2SO (0x1a8820 - 0x1a88a0)
    ctx->pc = 0x1a888c;
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8898 inside FIsRwmAmmo__FP3RWMP2SO (0x1a8820 - 0x1a88a0)
    ctx->pc = 0x1a8898;
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a88e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a88e0 inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a88e0;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a88ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a88ec inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a88ec;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8900 inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a8900;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8904 inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a8904;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8938 inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a8938;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8950 inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a8950;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a8964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8964 inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a8964;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a896c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a896c inside FAvailableRwmAmmo__FP3RWMP2SO (0x1a88a0 - 0x1a8974)
    ctx->pc = 0x1a896c;
    FAvailableRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime);
}

void entry_1a899c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a899c inside entry_1a8988 (0x1a8988 - 0x1a89bc)
    ctx->pc = 0x1a899c;
    entry_1a8988(rdram, ctx, runtime);
}

void entry_1a89a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a89a4 inside entry_1a8988 (0x1a8988 - 0x1a89bc)
    ctx->pc = 0x1a89a4;
    entry_1a8988(rdram, ctx, runtime);
}

void entry_1a89b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a89b4 inside entry_1a8988 (0x1a8988 - 0x1a89bc)
    ctx->pc = 0x1a89b4;
    entry_1a8988(rdram, ctx, runtime);
}

void entry_1a89d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a89d4 inside entry_1a89bc (0x1a89bc - 0x1a89e8)
    ctx->pc = 0x1a89d4;
    entry_1a89bc(rdram, ctx, runtime);
}

void entry_1a8a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8a24 inside CycleRwmCache__FP3RWM (0x1a89e8 - 0x1a8a84)
    ctx->pc = 0x1a8a24;
    CycleRwmCache__FP3RWM(rdram, ctx, runtime);
}

void entry_1a8a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8a40 inside CycleRwmCache__FP3RWM (0x1a89e8 - 0x1a8a84)
    ctx->pc = 0x1a8a40;
    CycleRwmCache__FP3RWM(rdram, ctx, runtime);
}

void entry_1a8a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8a70 inside CycleRwmCache__FP3RWM (0x1a89e8 - 0x1a8a84)
    ctx->pc = 0x1a8a70;
    CycleRwmCache__FP3RWM(rdram, ctx, runtime);
}

void entry_1a8a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8a9c inside entry_1a8a84 (0x1a8a84 - 0x1a8af8)
    ctx->pc = 0x1a8a9c;
    entry_1a8a84(rdram, ctx, runtime);
}

void entry_1a8aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8aa0 inside entry_1a8a84 (0x1a8a84 - 0x1a8af8)
    ctx->pc = 0x1a8aa0;
    entry_1a8a84(rdram, ctx, runtime);
}

void entry_1a8ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8ab4 inside entry_1a8a84 (0x1a8a84 - 0x1a8af8)
    ctx->pc = 0x1a8ab4;
    entry_1a8a84(rdram, ctx, runtime);
}

void entry_1a8ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8ac4 inside entry_1a8a84 (0x1a8a84 - 0x1a8af8)
    ctx->pc = 0x1a8ac4;
    entry_1a8a84(rdram, ctx, runtime);
}

void entry_1a8ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8ad4 inside entry_1a8a84 (0x1a8a84 - 0x1a8af8)
    ctx->pc = 0x1a8ad4;
    entry_1a8a84(rdram, ctx, runtime);
}

void entry_1a8b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8b44 inside entry_1a8b40 (0x1a8b40 - 0x1a8b8c)
    ctx->pc = 0x1a8b44;
    entry_1a8b40(rdram, ctx, runtime);
}

void entry_1a8b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8b78 inside entry_1a8b40 (0x1a8b40 - 0x1a8b8c)
    ctx->pc = 0x1a8b78;
    entry_1a8b40(rdram, ctx, runtime);
}

void entry_1a8bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8bc4 inside entry_1a8b8c (0x1a8b8c - 0x1a8bf8)
    ctx->pc = 0x1a8bc4;
    entry_1a8b8c(rdram, ctx, runtime);
}

void entry_1a8bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8bc8 inside entry_1a8b8c (0x1a8b8c - 0x1a8bf8)
    ctx->pc = 0x1a8bc8;
    entry_1a8b8c(rdram, ctx, runtime);
}

void entry_1a8c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8c00 inside entry_1a8bf8 (0x1a8bf8 - 0x1a8c50)
    ctx->pc = 0x1a8c00;
    entry_1a8bf8(rdram, ctx, runtime);
}

void entry_1a8c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8c10 inside entry_1a8bf8 (0x1a8bf8 - 0x1a8c50)
    ctx->pc = 0x1a8c10;
    entry_1a8bf8(rdram, ctx, runtime);
}

void entry_1a8c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8c14 inside entry_1a8bf8 (0x1a8bf8 - 0x1a8c50)
    ctx->pc = 0x1a8c14;
    entry_1a8bf8(rdram, ctx, runtime);
}

void entry_1a8c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8c28 inside entry_1a8bf8 (0x1a8bf8 - 0x1a8c50)
    ctx->pc = 0x1a8c28;
    entry_1a8bf8(rdram, ctx, runtime);
}

void entry_1a8c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8c7c inside entry_1a8c74 (0x1a8c74 - 0x1a8c90)
    ctx->pc = 0x1a8c7c;
    entry_1a8c74(rdram, ctx, runtime);
}

void entry_1a8ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8ce8 inside entry_1a8cd4 (0x1a8cd4 - 0x1a8d00)
    ctx->pc = 0x1a8ce8;
    entry_1a8cd4(rdram, ctx, runtime);
}

void entry_1a8d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8d7c inside entry_1a8d18 (0x1a8d18 - 0x1a8e30)
    ctx->pc = 0x1a8d7c;
    entry_1a8d18(rdram, ctx, runtime);
}

void entry_1a8d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8d8c inside entry_1a8d18 (0x1a8d18 - 0x1a8e30)
    ctx->pc = 0x1a8d8c;
    entry_1a8d18(rdram, ctx, runtime);
}

void entry_1a8dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8dd0 inside entry_1a8d18 (0x1a8d18 - 0x1a8e30)
    ctx->pc = 0x1a8dd0;
    entry_1a8d18(rdram, ctx, runtime);
}

void entry_1a8de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8de0 inside entry_1a8d18 (0x1a8d18 - 0x1a8e30)
    ctx->pc = 0x1a8de0;
    entry_1a8d18(rdram, ctx, runtime);
}

void entry_1a8e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8e44 inside entry_1a8e30 (0x1a8e30 - 0x1a8e64)
    ctx->pc = 0x1a8e44;
    entry_1a8e30(rdram, ctx, runtime);
}

void entry_1a8e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8e48 inside entry_1a8e30 (0x1a8e30 - 0x1a8e64)
    ctx->pc = 0x1a8e48;
    entry_1a8e30(rdram, ctx, runtime);
}

void entry_1a8e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8e70 inside entry_1a8e64 (0x1a8e64 - 0x1a8ea0)
    ctx->pc = 0x1a8e70;
    entry_1a8e64(rdram, ctx, runtime);
}

void entry_1a8e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8e8c inside entry_1a8e64 (0x1a8e64 - 0x1a8ea0)
    ctx->pc = 0x1a8e8c;
    entry_1a8e64(rdram, ctx, runtime);
}

void entry_1a8f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8f0c inside entry_1a8ee0 (0x1a8ee0 - 0x1a8f38)
    ctx->pc = 0x1a8f0c;
    entry_1a8ee0(rdram, ctx, runtime);
}

void entry_1a8f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8f10 inside entry_1a8ee0 (0x1a8ee0 - 0x1a8f38)
    ctx->pc = 0x1a8f10;
    entry_1a8ee0(rdram, ctx, runtime);
}

void entry_1a8f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8f68 inside entry_1a8f60 (0x1a8f60 - 0x1a8f80)
    ctx->pc = 0x1a8f68;
    entry_1a8f60(rdram, ctx, runtime);
}

void entry_1a8f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8f9c inside entry_1a8f94 (0x1a8f94 - 0x1a8fc4)
    ctx->pc = 0x1a8f9c;
    entry_1a8f94(rdram, ctx, runtime);
}

void entry_1a8fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8fcc inside entry_1a8fc4 (0x1a8fc4 - 0x1a8fd8)
    ctx->pc = 0x1a8fcc;
    entry_1a8fc4(rdram, ctx, runtime);
}

void entry_1a8fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a8fe0 inside entry_1a8fd8 (0x1a8fd8 - 0x1a8ff8)
    ctx->pc = 0x1a8fe0;
    entry_1a8fd8(rdram, ctx, runtime);
}

void entry_1a9000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9000 inside entry_1a8ff8 (0x1a8ff8 - 0x1a902c)
    ctx->pc = 0x1a9000;
    entry_1a8ff8(rdram, ctx, runtime);
}

void entry_1a9034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9034 inside entry_1a902c (0x1a902c - 0x1a9060)
    ctx->pc = 0x1a9034;
    entry_1a902c(rdram, ctx, runtime);
}

void entry_1a9048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9048 inside entry_1a902c (0x1a902c - 0x1a9060)
    ctx->pc = 0x1a9048;
    entry_1a902c(rdram, ctx, runtime);
}

void entry_1a904c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a904c inside entry_1a902c (0x1a902c - 0x1a9060)
    ctx->pc = 0x1a904c;
    entry_1a902c(rdram, ctx, runtime);
}

void entry_1a907c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a907c inside entry_1a9060 (0x1a9060 - 0x1a90a0)
    ctx->pc = 0x1a907c;
    entry_1a9060(rdram, ctx, runtime);
}

void entry_1a911c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a911c inside entry_1a9114 (0x1a9114 - 0x1a913c)
    ctx->pc = 0x1a911c;
    entry_1a9114(rdram, ctx, runtime);
}

void entry_1a9144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9144 inside entry_1a913c (0x1a913c - 0x1a915c)
    ctx->pc = 0x1a9144;
    entry_1a913c(rdram, ctx, runtime);
}

void entry_1a9160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9160 inside entry_1a915c (0x1a915c - 0x1a9170)
    ctx->pc = 0x1a9160;
    entry_1a915c(rdram, ctx, runtime);
}

void entry_1a9230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9230 inside entry_1a91d4 (0x1a91d4 - 0x1a925c)
    ctx->pc = 0x1a9230;
    entry_1a91d4(rdram, ctx, runtime);
}

void entry_1a9264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9264 inside entry_1a925c (0x1a925c - 0x1a9274)
    ctx->pc = 0x1a9264;
    entry_1a925c(rdram, ctx, runtime);
}

void entry_1a9278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9278 inside entry_1a9274 (0x1a9274 - 0x1a9294)
    ctx->pc = 0x1a9278;
    entry_1a9274(rdram, ctx, runtime);
}

void entry_1a92b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a92b0 inside entry_1a9294 (0x1a9294 - 0x1a92bc)
    ctx->pc = 0x1a92b0;
    entry_1a9294(rdram, ctx, runtime);
}

void entry_1a92e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a92e8 inside entry_1a92bc (0x1a92bc - 0x1a92fc)
    ctx->pc = 0x1a92e8;
    entry_1a92bc(rdram, ctx, runtime);
}

void entry_1a92ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a92ec inside entry_1a92bc (0x1a92bc - 0x1a92fc)
    ctx->pc = 0x1a92ec;
    entry_1a92bc(rdram, ctx, runtime);
}

void entry_1a9304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9304 inside entry_1a92fc (0x1a92fc - 0x1a9338)
    ctx->pc = 0x1a9304;
    entry_1a92fc(rdram, ctx, runtime);
}

void entry_1a9320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9320 inside entry_1a92fc (0x1a92fc - 0x1a9338)
    ctx->pc = 0x1a9320;
    entry_1a92fc(rdram, ctx, runtime);
}

void entry_1a9324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9324 inside entry_1a92fc (0x1a92fc - 0x1a9338)
    ctx->pc = 0x1a9324;
    entry_1a92fc(rdram, ctx, runtime);
}

void entry_1a933c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a933c inside entry_1a9338 (0x1a9338 - 0x1a9344)
    ctx->pc = 0x1a933c;
    entry_1a9338(rdram, ctx, runtime);
}

void entry_1a9374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9374 inside entry_1a9364 (0x1a9364 - 0x1a9390)
    ctx->pc = 0x1a9374;
    entry_1a9364(rdram, ctx, runtime);
}

void entry_1a939c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a939c inside entry_1a9398 (0x1a9398 - 0x1a93c8)
    ctx->pc = 0x1a939c;
    entry_1a9398(rdram, ctx, runtime);
}

void entry_1a93e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a93e0 inside FUN_001a93c8 (0x1a93c8 - 0x1a93e8)
    ctx->pc = 0x1a93e0;
    FUN_001a93c8(rdram, ctx, runtime);
}

void entry_1a9514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9514 inside entry_1a94f8 (0x1a94f8 - 0x1a9528)
    ctx->pc = 0x1a9514;
    entry_1a94f8(rdram, ctx, runtime);
}

void entry_1a953c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a953c inside entry_1a9534 (0x1a9534 - 0x1a95a0)
    ctx->pc = 0x1a953c;
    entry_1a9534(rdram, ctx, runtime);
}

void entry_1a956c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a956c inside entry_1a9534 (0x1a9534 - 0x1a95a0)
    ctx->pc = 0x1a956c;
    entry_1a9534(rdram, ctx, runtime);
}

void entry_1a9588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9588 inside entry_1a9534 (0x1a9534 - 0x1a95a0)
    ctx->pc = 0x1a9588;
    entry_1a9534(rdram, ctx, runtime);
}

void entry_1a9618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9618 inside GetRwtiPos__FP4RWTIP6VECTORT1 (0x1a95d0 - 0x1a9644)
    ctx->pc = 0x1a9618;
    GetRwtiPos__FP4RWTIP6VECTORT1(rdram, ctx, runtime);
}

void entry_1a9624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9624 inside GetRwtiPos__FP4RWTIP6VECTORT1 (0x1a95d0 - 0x1a9644)
    ctx->pc = 0x1a9624;
    GetRwtiPos__FP4RWTIP6VECTORT1(rdram, ctx, runtime);
}

void entry_1a9628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9628 inside GetRwtiPos__FP4RWTIP6VECTORT1 (0x1a95d0 - 0x1a9644)
    ctx->pc = 0x1a9628;
    GetRwtiPos__FP4RWTIP6VECTORT1(rdram, ctx, runtime);
}

void entry_1a964c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a964c inside entry_1a9644 (0x1a9644 - 0x1a966c)
    ctx->pc = 0x1a964c;
    entry_1a9644(rdram, ctx, runtime);
}

void entry_1a96d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a96d8 inside entry_1a966c (0x1a966c - 0x1a970c)
    ctx->pc = 0x1a96d8;
    entry_1a966c(rdram, ctx, runtime);
}

void entry_1a96ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a96ec inside entry_1a966c (0x1a966c - 0x1a970c)
    ctx->pc = 0x1a96ec;
    entry_1a966c(rdram, ctx, runtime);
}

void entry_1a979c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a979c inside entry_1a9758 (0x1a9758 - 0x1a97c8)
    ctx->pc = 0x1a979c;
    entry_1a9758(rdram, ctx, runtime);
}

void entry_1a97a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a97a0 inside entry_1a9758 (0x1a9758 - 0x1a97c8)
    ctx->pc = 0x1a97a0;
    entry_1a9758(rdram, ctx, runtime);
}

void entry_1a981c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a981c inside entry_1a9814 (0x1a9814 - 0x1a9838)
    ctx->pc = 0x1a981c;
    entry_1a9814(rdram, ctx, runtime);
}

void entry_1a984c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a984c inside entry_1a9844 (0x1a9844 - 0x1a9868)
    ctx->pc = 0x1a984c;
    entry_1a9844(rdram, ctx, runtime);
}

void entry_1a9854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9854 inside entry_1a9844 (0x1a9844 - 0x1a9868)
    ctx->pc = 0x1a9854;
    entry_1a9844(rdram, ctx, runtime);
}

void entry_1a98dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a98dc inside entry_1a98d4 (0x1a98d4 - 0x1a98f8)
    ctx->pc = 0x1a98dc;
    entry_1a98d4(rdram, ctx, runtime);
}

void entry_1a98e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a98e4 inside entry_1a98d4 (0x1a98d4 - 0x1a98f8)
    ctx->pc = 0x1a98e4;
    entry_1a98d4(rdram, ctx, runtime);
}

void entry_1a994c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a994c inside entry_1a9940 (0x1a9940 - 0x1a9960)
    ctx->pc = 0x1a994c;
    entry_1a9940(rdram, ctx, runtime);
}

void entry_1a99a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a99a8 inside entry_1a99a4 (0x1a99a4 - 0x1a99b8)
    ctx->pc = 0x1a99a8;
    entry_1a99a4(rdram, ctx, runtime);
}

void entry_1a99e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a99e8 inside entry_1a99e4 (0x1a99e4 - 0x1a99f8)
    ctx->pc = 0x1a99e8;
    entry_1a99e4(rdram, ctx, runtime);
}

void entry_1a9a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9a34 inside entry_1a9a30 (0x1a9a30 - 0x1a9a40)
    ctx->pc = 0x1a9a34;
    entry_1a9a30(rdram, ctx, runtime);
}

void entry_1a9a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9a88 inside entry_1a9a80 (0x1a9a80 - 0x1a9a98)
    ctx->pc = 0x1a9a88;
    entry_1a9a80(rdram, ctx, runtime);
}

void entry_1a9a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9a8c inside entry_1a9a80 (0x1a9a80 - 0x1a9a98)
    ctx->pc = 0x1a9a8c;
    entry_1a9a80(rdram, ctx, runtime);
}

void entry_1a9ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9ac8 inside entry_1a9ac0 (0x1a9ac0 - 0x1a9ad8)
    ctx->pc = 0x1a9ac8;
    entry_1a9ac0(rdram, ctx, runtime);
}

void entry_1a9adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9adc inside entry_1a9ad8 (0x1a9ad8 - 0x1a9ae8)
    ctx->pc = 0x1a9adc;
    entry_1a9ad8(rdram, ctx, runtime);
}

void entry_1a9b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9b94 inside entry_1a9b2c (0x1a9b2c - 0x1a9bb8)
    ctx->pc = 0x1a9b94;
    entry_1a9b2c(rdram, ctx, runtime);
}

void entry_1a9ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9ba0 inside entry_1a9b2c (0x1a9b2c - 0x1a9bb8)
    ctx->pc = 0x1a9ba0;
    entry_1a9b2c(rdram, ctx, runtime);
}

void entry_1a9bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9bf4 inside entry_1a9bb8 (0x1a9bb8 - 0x1a9c28)
    ctx->pc = 0x1a9bf4;
    entry_1a9bb8(rdram, ctx, runtime);
}

void entry_1a9c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9c08 inside entry_1a9bb8 (0x1a9bb8 - 0x1a9c28)
    ctx->pc = 0x1a9c08;
    entry_1a9bb8(rdram, ctx, runtime);
}

void entry_1a9c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9c0c inside entry_1a9bb8 (0x1a9bb8 - 0x1a9c28)
    ctx->pc = 0x1a9c0c;
    entry_1a9bb8(rdram, ctx, runtime);
}

void entry_1a9c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9c38 inside entry_1a9c28 (0x1a9c28 - 0x1a9c44)
    ctx->pc = 0x1a9c38;
    entry_1a9c28(rdram, ctx, runtime);
}

void entry_1a9f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9f18 inside StartupScreen__Fv (0x1a9c68 - 0x1a9f30)
    ctx->pc = 0x1a9f18;
    StartupScreen__Fv(rdram, ctx, runtime);
}

void entry_1a9fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9fa0 inside PostBlotsLoad__Fv (0x1a9f78 - 0x1a9fb4)
    ctx->pc = 0x1a9fa0;
    PostBlotsLoad__Fv(rdram, ctx, runtime);
}

void entry_1a9ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1a9ff8 inside UpdateBlots__Fv (0x1a9fd0 - 0x1aa00c)
    ctx->pc = 0x1a9ff8;
    UpdateBlots__Fv(rdram, ctx, runtime);
}

void entry_1aa038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa038 inside entry_1aa00c (0x1aa00c - 0x1aa048)
    ctx->pc = 0x1aa038;
    entry_1aa00c(rdram, ctx, runtime);
}

void entry_1aa040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa040 inside entry_1aa00c (0x1aa00c - 0x1aa048)
    ctx->pc = 0x1aa040;
    entry_1aa00c(rdram, ctx, runtime);
}

void entry_1aa088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa088 inside ForceHideBlots__Fv (0x1aa060 - 0x1aa0a0)
    ctx->pc = 0x1aa088;
    ForceHideBlots__Fv(rdram, ctx, runtime);
}

void entry_1aa0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa0e0 inside ResetBlots__Fv (0x1aa0c0 - 0x1aa0f4)
    ctx->pc = 0x1aa0e0;
    ResetBlots__Fv(rdram, ctx, runtime);
}

void entry_1aa130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa130 inside RenderBlots__Fv (0x1aa110 - 0x1aa158)
    ctx->pc = 0x1aa130;
    RenderBlots__Fv(rdram, ctx, runtime);
}

void entry_1aa198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa198 inside DrawBlots__Fv (0x1aa178 - 0x1aa1b8)
    ctx->pc = 0x1aa198;
    DrawBlots__Fv(rdram, ctx, runtime);
}

void entry_1aa2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa2e0 inside UpdateBlot__FP4BLOT (0x1aa298 - 0x1aa304)
    ctx->pc = 0x1aa2e0;
    UpdateBlot__FP4BLOT(rdram, ctx, runtime);
}

void entry_1aa2f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa2f4 inside UpdateBlot__FP4BLOT (0x1aa298 - 0x1aa304)
    ctx->pc = 0x1aa2f4;
    UpdateBlot__FP4BLOT(rdram, ctx, runtime);
}

void entry_1aa33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa33c inside entry_1aa304 (0x1aa304 - 0x1aa348)
    ctx->pc = 0x1aa33c;
    entry_1aa304(rdram, ctx, runtime);
}

void entry_1aa390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa390 inside entry_1aa348 (0x1aa348 - 0x1aa3d4)
    ctx->pc = 0x1aa390;
    entry_1aa348(rdram, ctx, runtime);
}

void entry_1aa3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa3a0 inside entry_1aa348 (0x1aa348 - 0x1aa3d4)
    ctx->pc = 0x1aa3a0;
    entry_1aa348(rdram, ctx, runtime);
}

void entry_1aa3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa3a8 inside entry_1aa348 (0x1aa348 - 0x1aa3d4)
    ctx->pc = 0x1aa3a8;
    entry_1aa348(rdram, ctx, runtime);
}

void entry_1aa3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa3c8 inside entry_1aa348 (0x1aa348 - 0x1aa3d4)
    ctx->pc = 0x1aa3c8;
    entry_1aa348(rdram, ctx, runtime);
}

void entry_1aa42c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa42c inside entry_1aa3d4 (0x1aa3d4 - 0x1aa4c0)
    ctx->pc = 0x1aa42c;
    entry_1aa3d4(rdram, ctx, runtime);
}

void entry_1aa440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa440 inside entry_1aa3d4 (0x1aa3d4 - 0x1aa4c0)
    ctx->pc = 0x1aa440;
    entry_1aa3d4(rdram, ctx, runtime);
}

void entry_1aa454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa454 inside entry_1aa3d4 (0x1aa3d4 - 0x1aa4c0)
    ctx->pc = 0x1aa454;
    entry_1aa3d4(rdram, ctx, runtime);
}

void entry_1aa458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa458 inside entry_1aa3d4 (0x1aa3d4 - 0x1aa4c0)
    ctx->pc = 0x1aa458;
    entry_1aa3d4(rdram, ctx, runtime);
}

void entry_1aa4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa4c4 inside entry_1aa4c0 (0x1aa4c0 - 0x1aa4d4)
    ctx->pc = 0x1aa4c4;
    entry_1aa4c0(rdram, ctx, runtime);
}

void entry_1aa534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa534 inside entry_1aa52c (0x1aa52c - 0x1aa54c)
    ctx->pc = 0x1aa534;
    entry_1aa52c(rdram, ctx, runtime);
}

void entry_1aa540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa540 inside entry_1aa52c (0x1aa52c - 0x1aa54c)
    ctx->pc = 0x1aa540;
    entry_1aa52c(rdram, ctx, runtime);
}

void entry_1aa5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa5f8 inside SetBlotRgba__FP4BLOTUi (0x1aa5a0 - 0x1aa610)
    ctx->pc = 0x1aa5f8;
    SetBlotRgba__FP4BLOTUi(rdram, ctx, runtime);
}

void entry_1aa648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa648 inside entry_1aa638 (0x1aa638 - 0x1aa650)
    ctx->pc = 0x1aa648;
    entry_1aa638(rdram, ctx, runtime);
}

void entry_1aa674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa674 inside entry_1aa668 (0x1aa668 - 0x1aa684)
    ctx->pc = 0x1aa674;
    entry_1aa668(rdram, ctx, runtime);
}

void entry_1aa68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa68c inside entry_1aa684 (0x1aa684 - 0x1aa6c0)
    ctx->pc = 0x1aa68c;
    entry_1aa684(rdram, ctx, runtime);
}

void entry_1aa6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa6f0 inside entry_1aa6c0 (0x1aa6c0 - 0x1aa724)
    ctx->pc = 0x1aa6f0;
    entry_1aa6c0(rdram, ctx, runtime);
}

void entry_1aa718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa718 inside entry_1aa6c0 (0x1aa6c0 - 0x1aa724)
    ctx->pc = 0x1aa718;
    entry_1aa6c0(rdram, ctx, runtime);
}

void entry_1aa730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa730 inside entry_1aa724 (0x1aa724 - 0x1aa758)
    ctx->pc = 0x1aa730;
    entry_1aa724(rdram, ctx, runtime);
}

void entry_1aa734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa734 inside entry_1aa724 (0x1aa724 - 0x1aa758)
    ctx->pc = 0x1aa734;
    entry_1aa724(rdram, ctx, runtime);
}

void entry_1aa738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa738 inside entry_1aa724 (0x1aa724 - 0x1aa758)
    ctx->pc = 0x1aa738;
    entry_1aa724(rdram, ctx, runtime);
}

void entry_1aa748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa748 inside entry_1aa724 (0x1aa724 - 0x1aa758)
    ctx->pc = 0x1aa748;
    entry_1aa724(rdram, ctx, runtime);
}

void entry_1aa844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa844 inside entry_1aa840 (0x1aa840 - 0x1aa850)
    ctx->pc = 0x1aa844;
    entry_1aa840(rdram, ctx, runtime);
}

void entry_1aa920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa920 inside ShowBlot__FP4BLOT (0x1aa8f0 - 0x1aa938)
    ctx->pc = 0x1aa920;
    ShowBlot__FP4BLOT(rdram, ctx, runtime);
}

void entry_1aa928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa928 inside ShowBlot__FP4BLOT (0x1aa8f0 - 0x1aa938)
    ctx->pc = 0x1aa928;
    ShowBlot__FP4BLOT(rdram, ctx, runtime);
}

void entry_1aa940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa940 inside entry_1aa938 (0x1aa938 - 0x1aa958)
    ctx->pc = 0x1aa940;
    entry_1aa938(rdram, ctx, runtime);
}

void entry_1aa950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa950 inside entry_1aa938 (0x1aa938 - 0x1aa958)
    ctx->pc = 0x1aa950;
    entry_1aa938(rdram, ctx, runtime);
}

void entry_1aa98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa98c inside entry_1aa988 (0x1aa988 - 0x1aa998)
    ctx->pc = 0x1aa98c;
    entry_1aa988(rdram, ctx, runtime);
}

void entry_1aa9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa9e4 inside SetBlotBlots__FP4BLOT5BLOTS (0x1aa998 - 0x1aaa0c)
    ctx->pc = 0x1aa9e4;
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime);
}

void entry_1aa9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aa9fc inside SetBlotBlots__FP4BLOT5BLOTS (0x1aa998 - 0x1aaa0c)
    ctx->pc = 0x1aa9fc;
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime);
}

void entry_1aaa14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa14 inside entry_1aaa0c (0x1aaa0c - 0x1aaa20)
    ctx->pc = 0x1aaa14;
    entry_1aaa0c(rdram, ctx, runtime);
}

void entry_1aaa30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa30 inside entry_1aaa20 (0x1aaa20 - 0x1aaaac)
    ctx->pc = 0x1aaa30;
    entry_1aaa20(rdram, ctx, runtime);
}

void entry_1aaa4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa4c inside entry_1aaa20 (0x1aaa20 - 0x1aaaac)
    ctx->pc = 0x1aaa4c;
    entry_1aaa20(rdram, ctx, runtime);
}

void entry_1aaa54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa54 inside entry_1aaa20 (0x1aaa20 - 0x1aaaac)
    ctx->pc = 0x1aaa54;
    entry_1aaa20(rdram, ctx, runtime);
}

void entry_1aaa78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa78 inside entry_1aaa20 (0x1aaa20 - 0x1aaaac)
    ctx->pc = 0x1aaa78;
    entry_1aaa20(rdram, ctx, runtime);
}

void entry_1aaa8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa8c inside entry_1aaa20 (0x1aaa20 - 0x1aaaac)
    ctx->pc = 0x1aaa8c;
    entry_1aaa20(rdram, ctx, runtime);
}

void entry_1aaa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa90 inside entry_1aaa20 (0x1aaa20 - 0x1aaaac)
    ctx->pc = 0x1aaa90;
    entry_1aaa20(rdram, ctx, runtime);
}

void entry_1aaa94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaa94 inside entry_1aaa20 (0x1aaa20 - 0x1aaaac)
    ctx->pc = 0x1aaa94;
    entry_1aaa20(rdram, ctx, runtime);
}

void entry_1aaaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaaf0 inside FIncludeBlotForPeg__FP4BLOTT0 (0x1aaac8 - 0x1aab20)
    ctx->pc = 0x1aaaf0;
    FIncludeBlotForPeg__FP4BLOTT0(rdram, ctx, runtime);
}

void entry_1aab04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aab04 inside FIncludeBlotForPeg__FP4BLOTT0 (0x1aaac8 - 0x1aab20)
    ctx->pc = 0x1aab04;
    FIncludeBlotForPeg__FP4BLOTT0(rdram, ctx, runtime);
}

void entry_1aab14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aab14 inside FIncludeBlotForPeg__FP4BLOTT0 (0x1aaac8 - 0x1aab20)
    ctx->pc = 0x1aab14;
    FIncludeBlotForPeg__FP4BLOTT0(rdram, ctx, runtime);
}

void entry_1aab3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aab3c inside ResizeBlot__FP4BLOTff (0x1aab20 - 0x1aab54)
    ctx->pc = 0x1aab3c;
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime);
}

void entry_1aab4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aab4c inside ResizeBlot__FP4BLOTff (0x1aab20 - 0x1aab54)
    ctx->pc = 0x1aab4c;
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime);
}

void entry_1aabf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aabf8 inside RepositionBlot__FP4BLOT (0x1aab60 - 0x1aac18)
    ctx->pc = 0x1aabf8;
    RepositionBlot__FP4BLOT(rdram, ctx, runtime);
}

void entry_1aac44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aac44 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aac44;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aac5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aac5c inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aac5c;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aac78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aac78 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aac78;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aac94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aac94 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aac94;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aacb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aacb4 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aacb4;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aaccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaccc inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aaccc;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aace0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aace0 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aace0;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aace4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aace4 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aace4;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aad14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aad14 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aad14;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aad2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aad2c inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aad2c;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aad34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aad34 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aad34;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aad6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aad6c inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aad6c;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aad84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aad84 inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aad84;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aad8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aad8c inside entry_1aac18 (0x1aac18 - 0x1aada8)
    ctx->pc = 0x1aad8c;
    entry_1aac18(rdram, ctx, runtime);
}

void entry_1aadf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aadf4 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aadf4;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae0c inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae0c;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae18 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae18;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae28 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae28;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae34 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae34;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae40 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae40;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae44 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae44;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae48 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae48;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae64 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae64;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae6c inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae6c;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aae74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aae74 inside entry_1aada8 (0x1aada8 - 0x1aae7c)
    ctx->pc = 0x1aae74;
    entry_1aada8(rdram, ctx, runtime);
}

void entry_1aaef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaef8 inside RepositionBlotDependents__FP4BLOT (0x1aaec0 - 0x1aaf28)
    ctx->pc = 0x1aaef8;
    RepositionBlotDependents__FP4BLOT(rdram, ctx, runtime);
}

void entry_1aaf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaf2c inside entry_1aaf28 (0x1aaf28 - 0x1aaf58)
    ctx->pc = 0x1aaf2c;
    entry_1aaf28(rdram, ctx, runtime);
}

void entry_1aaf78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaf78 inside SetBlotClock__FP4BLOTPf (0x1aaf58 - 0x1aaf88)
    ctx->pc = 0x1aaf78;
    SetBlotClock__FP4BLOTPf(rdram, ctx, runtime);
}

void entry_1aaf7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aaf7c inside SetBlotClock__FP4BLOTPf (0x1aaf58 - 0x1aaf88)
    ctx->pc = 0x1aaf7c;
    SetBlotClock__FP4BLOTPf(rdram, ctx, runtime);
}

void entry_1ab044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab044 inside entry_1aafa4 (0x1aafa4 - 0x1ab058)
    ctx->pc = 0x1ab044;
    entry_1aafa4(rdram, ctx, runtime);
}

void entry_1ab048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab048 inside entry_1aafa4 (0x1aafa4 - 0x1ab058)
    ctx->pc = 0x1ab048;
    entry_1aafa4(rdram, ctx, runtime);
}

void entry_1ab0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab0d0 inside entry_1ab06c (0x1ab06c - 0x1ab108)
    ctx->pc = 0x1ab0d0;
    entry_1ab06c(rdram, ctx, runtime);
}

void entry_1ab0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab0d8 inside entry_1ab06c (0x1ab06c - 0x1ab108)
    ctx->pc = 0x1ab0d8;
    entry_1ab06c(rdram, ctx, runtime);
}

void entry_1ab0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab0e0 inside entry_1ab06c (0x1ab06c - 0x1ab108)
    ctx->pc = 0x1ab0e0;
    entry_1ab06c(rdram, ctx, runtime);
}

void entry_1ab110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab110 inside entry_1ab108 (0x1ab108 - 0x1ab118)
    ctx->pc = 0x1ab110;
    entry_1ab108(rdram, ctx, runtime);
}

void entry_1ab17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab17c inside entry_1ab174 (0x1ab174 - 0x1ab188)
    ctx->pc = 0x1ab17c;
    entry_1ab174(rdram, ctx, runtime);
}

void entry_1ab18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab18c inside entry_1ab188 (0x1ab188 - 0x1ab198)
    ctx->pc = 0x1ab18c;
    entry_1ab188(rdram, ctx, runtime);
}

void entry_1ab1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab1d8 inside DrawCtr__FP3CTR (0x1ab198 - 0x1ab21c)
    ctx->pc = 0x1ab1d8;
    DrawCtr__FP3CTR(rdram, ctx, runtime);
}

void entry_1ab3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab3c4 inside entry_1ab3bc (0x1ab3bc - 0x1ab408)
    ctx->pc = 0x1ab3c4;
    entry_1ab3bc(rdram, ctx, runtime);
}

void entry_1ab48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab48c inside entry_1ab458 (0x1ab458 - 0x1ab49c)
    ctx->pc = 0x1ab48c;
    entry_1ab458(rdram, ctx, runtime);
}

void entry_1ab5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab5f4 inside DtVisibleCtr__FP3CTR (0x1ab5d8 - 0x1ab600)
    ctx->pc = 0x1ab5f4;
    DtVisibleCtr__FP3CTR(rdram, ctx, runtime);
}

void entry_1ab6b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab6b8 inside entry_1ab674 (0x1ab674 - 0x1ab6ec)
    ctx->pc = 0x1ab6b8;
    entry_1ab674(rdram, ctx, runtime);
}

void entry_1ab6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab6e0 inside entry_1ab674 (0x1ab674 - 0x1ab6ec)
    ctx->pc = 0x1ab6e0;
    entry_1ab674(rdram, ctx, runtime);
}

void entry_1ab6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab6f4 inside entry_1ab6ec (0x1ab6ec - 0x1ab700)
    ctx->pc = 0x1ab6f4;
    entry_1ab6ec(rdram, ctx, runtime);
}

void entry_1ab704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab704 inside entry_1ab700 (0x1ab700 - 0x1ab710)
    ctx->pc = 0x1ab704;
    entry_1ab700(rdram, ctx, runtime);
}

void entry_1ab708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab708 inside entry_1ab700 (0x1ab700 - 0x1ab710)
    ctx->pc = 0x1ab708;
    entry_1ab700(rdram, ctx, runtime);
}

void entry_1ab7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab7cc inside entry_1ab7c8 (0x1ab7c8 - 0x1ab7dc)
    ctx->pc = 0x1ab7cc;
    entry_1ab7c8(rdram, ctx, runtime);
}

void entry_1ab848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ab848 inside entry_1ab80c (0x1ab80c - 0x1ab860)
    ctx->pc = 0x1ab848;
    entry_1ab80c(rdram, ctx, runtime);
}

void entry_1aba70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aba70 inside RebuildTimerAchzDraw__FP5TIMERf (0x1ab980 - 0x1abab4)
    ctx->pc = 0x1aba70;
    RebuildTimerAchzDraw__FP5TIMERf(rdram, ctx, runtime);
}

void entry_1aba88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aba88 inside RebuildTimerAchzDraw__FP5TIMERf (0x1ab980 - 0x1abab4)
    ctx->pc = 0x1aba88;
    RebuildTimerAchzDraw__FP5TIMERf(rdram, ctx, runtime);
}

void entry_1ababc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ababc inside entry_1abab4 (0x1abab4 - 0x1abb0c)
    ctx->pc = 0x1ababc;
    entry_1abab4(rdram, ctx, runtime);
}

void entry_1abb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abb10 inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abb10;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abb98 inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abb98;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abb9c inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abb9c;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abbac inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abbac;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abbe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abbe4 inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abbe4;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abbe8 inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abbe8;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abbf4 inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abbf4;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abbfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abbfc inside entry_1abb0c (0x1abb0c - 0x1abc28)
    ctx->pc = 0x1abbfc;
    entry_1abb0c(rdram, ctx, runtime);
}

void entry_1abc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abc9c inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abc9c;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abce0 inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abce0;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abcec inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abcec;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abd30 inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abd30;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abd40 inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abd40;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abd44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abd44 inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abd44;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abd58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abd58 inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abd58;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abd88 inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abd88;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abd8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abd8c inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abd8c;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abd90 inside entry_1abc94 (0x1abc94 - 0x1abda8)
    ctx->pc = 0x1abd90;
    entry_1abc94(rdram, ctx, runtime);
}

void entry_1abe38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abe38 inside SetTimerTimers__FP5TIMER6TIMERS (0x1abe20 - 0x1abe40)
    ctx->pc = 0x1abe38;
    SetTimerTimers__FP5TIMER6TIMERS(rdram, ctx, runtime);
}

void entry_1abf1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abf1c inside entry_1abe9c (0x1abe9c - 0x1abf9c)
    ctx->pc = 0x1abf1c;
    entry_1abe9c(rdram, ctx, runtime);
}

void entry_1abf38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abf38 inside entry_1abe9c (0x1abe9c - 0x1abf9c)
    ctx->pc = 0x1abf38;
    entry_1abe9c(rdram, ctx, runtime);
}

void entry_1abf40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1abf40 inside entry_1abe9c (0x1abe9c - 0x1abf9c)
    ctx->pc = 0x1abf40;
    entry_1abe9c(rdram, ctx, runtime);
}

void entry_1ac03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac03c inside entry_1abffc (0x1abffc - 0x1ac060)
    ctx->pc = 0x1ac03c;
    entry_1abffc(rdram, ctx, runtime);
}

void entry_1ac090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac090 inside FUN_001ac060 (0x1ac060 - 0x1ac0e8)
    ctx->pc = 0x1ac090;
    FUN_001ac060(rdram, ctx, runtime);
}

void entry_1ac098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac098 inside FUN_001ac060 (0x1ac060 - 0x1ac0e8)
    ctx->pc = 0x1ac098;
    FUN_001ac060(rdram, ctx, runtime);
}

void entry_1ac16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac16c inside FUN_001ac0e8 (0x1ac0e8 - 0x1ac1ac)
    ctx->pc = 0x1ac16c;
    FUN_001ac0e8(rdram, ctx, runtime);
}

void entry_1ac188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac188 inside FUN_001ac0e8 (0x1ac0e8 - 0x1ac1ac)
    ctx->pc = 0x1ac188;
    FUN_001ac0e8(rdram, ctx, runtime);
}

void entry_1ac314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac314 inside entry_1ac26c (0x1ac26c - 0x1ac47c)
    ctx->pc = 0x1ac314;
    entry_1ac26c(rdram, ctx, runtime);
}

void entry_1ac358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac358 inside entry_1ac26c (0x1ac26c - 0x1ac47c)
    ctx->pc = 0x1ac358;
    entry_1ac26c(rdram, ctx, runtime);
}

void entry_1ac398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac398 inside entry_1ac26c (0x1ac26c - 0x1ac47c)
    ctx->pc = 0x1ac398;
    entry_1ac26c(rdram, ctx, runtime);
}

void entry_1ac3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac3b0 inside entry_1ac26c (0x1ac26c - 0x1ac47c)
    ctx->pc = 0x1ac3b0;
    entry_1ac26c(rdram, ctx, runtime);
}

void entry_1ac3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac3f4 inside entry_1ac26c (0x1ac26c - 0x1ac47c)
    ctx->pc = 0x1ac3f4;
    entry_1ac26c(rdram, ctx, runtime);
}

void entry_1ac434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac434 inside entry_1ac26c (0x1ac26c - 0x1ac47c)
    ctx->pc = 0x1ac434;
    entry_1ac26c(rdram, ctx, runtime);
}

void entry_1ac508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac508 inside entry_1ac4fc (0x1ac4fc - 0x1ac57c)
    ctx->pc = 0x1ac508;
    entry_1ac4fc(rdram, ctx, runtime);
}

void entry_1ac624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac624 inside entry_1ac61c (0x1ac61c - 0x1ac638)
    ctx->pc = 0x1ac624;
    entry_1ac61c(rdram, ctx, runtime);
}

void entry_1ac680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac680 inside entry_1ac678 (0x1ac678 - 0x1ac69c)
    ctx->pc = 0x1ac680;
    entry_1ac678(rdram, ctx, runtime);
}

void entry_1ac68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac68c inside entry_1ac678 (0x1ac678 - 0x1ac69c)
    ctx->pc = 0x1ac68c;
    entry_1ac678(rdram, ctx, runtime);
}

void entry_1ac6d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac6d4 inside entry_1ac6c0 (0x1ac6c0 - 0x1ac6dc)
    ctx->pc = 0x1ac6d4;
    entry_1ac6c0(rdram, ctx, runtime);
}

void entry_1ac82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac82c inside entry_1ac814 (0x1ac814 - 0x1ac838)
    ctx->pc = 0x1ac82c;
    entry_1ac814(rdram, ctx, runtime);
}

void entry_1ac8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac8fc inside entry_1ac8f4 (0x1ac8f4 - 0x1ac910)
    ctx->pc = 0x1ac8fc;
    entry_1ac8f4(rdram, ctx, runtime);
}

void entry_1ac940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac940 inside entry_1ac938 (0x1ac938 - 0x1ac958)
    ctx->pc = 0x1ac940;
    entry_1ac938(rdram, ctx, runtime);
}

void entry_1ac980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac980 inside entry_1ac97c (0x1ac97c - 0x1ac990)
    ctx->pc = 0x1ac980;
    entry_1ac97c(rdram, ctx, runtime);
}

void entry_1ac9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ac9c4 inside entry_1ac9c0 (0x1ac9c0 - 0x1ac9cc)
    ctx->pc = 0x1ac9c4;
    entry_1ac9c0(rdram, ctx, runtime);
}

void entry_1aca14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aca14 inside entry_1ac9fc (0x1ac9fc - 0x1aca30)
    ctx->pc = 0x1aca14;
    entry_1ac9fc(rdram, ctx, runtime);
}

void entry_1aca18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aca18 inside entry_1ac9fc (0x1ac9fc - 0x1aca30)
    ctx->pc = 0x1aca18;
    entry_1ac9fc(rdram, ctx, runtime);
}

void entry_1aca54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aca54 inside FUN_001aca30 (0x1aca30 - 0x1aca5c)
    ctx->pc = 0x1aca54;
    FUN_001aca30(rdram, ctx, runtime);
}

void entry_1aca60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aca60 inside entry_1aca5c (0x1aca5c - 0x1aca68)
    ctx->pc = 0x1aca60;
    entry_1aca5c(rdram, ctx, runtime);
}

void entry_1aca94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aca94 inside FUN_001aca68 (0x1aca68 - 0x1aca9c)
    ctx->pc = 0x1aca94;
    FUN_001aca68(rdram, ctx, runtime);
}

void entry_1acb08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acb08 inside DrawTitle__FP5TITLE (0x1acaa8 - 0x1acb24)
    ctx->pc = 0x1acb08;
    DrawTitle__FP5TITLE(rdram, ctx, runtime);
}

void entry_1acb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acb1c inside DrawTitle__FP5TITLE (0x1acaa8 - 0x1acb24)
    ctx->pc = 0x1acb1c;
    DrawTitle__FP5TITLE(rdram, ctx, runtime);
}

void entry_1acb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acb2c inside entry_1acb24 (0x1acb24 - 0x1acb38)
    ctx->pc = 0x1acb2c;
    entry_1acb24(rdram, ctx, runtime);
}

void entry_1acb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acb88 inside entry_1acb38 (0x1acb38 - 0x1acbf4)
    ctx->pc = 0x1acb88;
    entry_1acb38(rdram, ctx, runtime);
}

void entry_1acb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acb9c inside entry_1acb38 (0x1acb38 - 0x1acbf4)
    ctx->pc = 0x1acb9c;
    entry_1acb38(rdram, ctx, runtime);
}

void entry_1acba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acba4 inside entry_1acb38 (0x1acb38 - 0x1acbf4)
    ctx->pc = 0x1acba4;
    entry_1acb38(rdram, ctx, runtime);
}

void entry_1acc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acc88 inside entry_1acc74 (0x1acc74 - 0x1acd18)
    ctx->pc = 0x1acc88;
    entry_1acc74(rdram, ctx, runtime);
}

void entry_1accc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1accc4 inside entry_1acc74 (0x1acc74 - 0x1acd18)
    ctx->pc = 0x1accc4;
    entry_1acc74(rdram, ctx, runtime);
}

void entry_1accdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1accdc inside entry_1acc74 (0x1acc74 - 0x1acd18)
    ctx->pc = 0x1accdc;
    entry_1acc74(rdram, ctx, runtime);
}

void entry_1acce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acce0 inside entry_1acc74 (0x1acc74 - 0x1acd18)
    ctx->pc = 0x1acce0;
    entry_1acc74(rdram, ctx, runtime);
}

void entry_1acd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acd48 inside entry_1acd34 (0x1acd34 - 0x1acd68)
    ctx->pc = 0x1acd48;
    entry_1acd34(rdram, ctx, runtime);
}

void entry_1acd6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acd6c inside entry_1acd68 (0x1acd68 - 0x1acda0)
    ctx->pc = 0x1acd6c;
    entry_1acd68(rdram, ctx, runtime);
}

void entry_1acd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acd70 inside entry_1acd68 (0x1acd68 - 0x1acda0)
    ctx->pc = 0x1acd70;
    entry_1acd68(rdram, ctx, runtime);
}

void entry_1ace24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ace24 inside entry_1ace1c (0x1ace1c - 0x1ace38)
    ctx->pc = 0x1ace24;
    entry_1ace1c(rdram, ctx, runtime);
}

void entry_1ace68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ace68 inside entry_1ace60 (0x1ace60 - 0x1ace90)
    ctx->pc = 0x1ace68;
    entry_1ace60(rdram, ctx, runtime);
}

void entry_1ace98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ace98 inside entry_1ace90 (0x1ace90 - 0x1aceac)
    ctx->pc = 0x1ace98;
    entry_1ace90(rdram, ctx, runtime);
}

void entry_1aceb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aceb4 inside entry_1aceac (0x1aceac - 0x1acecc)
    ctx->pc = 0x1aceb4;
    entry_1aceac(rdram, ctx, runtime);
}

void entry_1acebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acebc inside entry_1aceac (0x1aceac - 0x1acecc)
    ctx->pc = 0x1acebc;
    entry_1aceac(rdram, ctx, runtime);
}

void entry_1aced0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aced0 inside entry_1acecc (0x1acecc - 0x1acee0)
    ctx->pc = 0x1aced0;
    entry_1acecc(rdram, ctx, runtime);
}

void entry_1acf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acf30 inside FUN_001acee0 (0x1acee0 - 0x1acf40)
    ctx->pc = 0x1acf30;
    FUN_001acee0(rdram, ctx, runtime);
}

void entry_1acf38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acf38 inside FUN_001acee0 (0x1acee0 - 0x1acf40)
    ctx->pc = 0x1acf38;
    FUN_001acee0(rdram, ctx, runtime);
}

void entry_1acf44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acf44 inside entry_1acf40 (0x1acf40 - 0x1acf8c)
    ctx->pc = 0x1acf44;
    entry_1acf40(rdram, ctx, runtime);
}

void entry_1acf60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acf60 inside entry_1acf40 (0x1acf40 - 0x1acf8c)
    ctx->pc = 0x1acf60;
    entry_1acf40(rdram, ctx, runtime);
}

void entry_1acf7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acf7c inside entry_1acf40 (0x1acf40 - 0x1acf8c)
    ctx->pc = 0x1acf7c;
    entry_1acf40(rdram, ctx, runtime);
}

void entry_1acf84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acf84 inside entry_1acf40 (0x1acf40 - 0x1acf8c)
    ctx->pc = 0x1acf84;
    entry_1acf40(rdram, ctx, runtime);
}

void entry_1acf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acf90 inside entry_1acf8c (0x1acf8c - 0x1acfd8)
    ctx->pc = 0x1acf90;
    entry_1acf8c(rdram, ctx, runtime);
}

void entry_1acfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acfac inside entry_1acf8c (0x1acf8c - 0x1acfd8)
    ctx->pc = 0x1acfac;
    entry_1acf8c(rdram, ctx, runtime);
}

void entry_1acfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acfc8 inside entry_1acf8c (0x1acf8c - 0x1acfd8)
    ctx->pc = 0x1acfc8;
    entry_1acf8c(rdram, ctx, runtime);
}

void entry_1acfd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1acfd0 inside entry_1acf8c (0x1acf8c - 0x1acfd8)
    ctx->pc = 0x1acfd0;
    entry_1acf8c(rdram, ctx, runtime);
}

void entry_1ad028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad028 inside entry_1ad020 (0x1ad020 - 0x1ad058)
    ctx->pc = 0x1ad028;
    entry_1ad020(rdram, ctx, runtime);
}

void entry_1ad040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad040 inside entry_1ad020 (0x1ad020 - 0x1ad058)
    ctx->pc = 0x1ad040;
    entry_1ad020(rdram, ctx, runtime);
}

void entry_1ad05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad05c inside entry_1ad058 (0x1ad058 - 0x1ad068)
    ctx->pc = 0x1ad05c;
    entry_1ad058(rdram, ctx, runtime);
}

void entry_1ad0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad0ac inside entry_1ad0a4 (0x1ad0a4 - 0x1ad0c0)
    ctx->pc = 0x1ad0ac;
    entry_1ad0a4(rdram, ctx, runtime);
}

void entry_1ad0c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad0c4 inside entry_1ad0c0 (0x1ad0c0 - 0x1ad0d0)
    ctx->pc = 0x1ad0c4;
    entry_1ad0c0(rdram, ctx, runtime);
}

void entry_1ad174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad174 inside entry_1ad164 (0x1ad164 - 0x1ad190)
    ctx->pc = 0x1ad174;
    entry_1ad164(rdram, ctx, runtime);
}

void entry_1ad17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad17c inside entry_1ad164 (0x1ad164 - 0x1ad190)
    ctx->pc = 0x1ad17c;
    entry_1ad164(rdram, ctx, runtime);
}

void entry_1ad198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad198 inside entry_1ad190 (0x1ad190 - 0x1ad1a4)
    ctx->pc = 0x1ad198;
    entry_1ad190(rdram, ctx, runtime);
}

void entry_1ad1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad1b8 inside entry_1ad1b0 (0x1ad1b0 - 0x1ad1c8)
    ctx->pc = 0x1ad1b8;
    entry_1ad1b0(rdram, ctx, runtime);
}

void entry_1ad278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad278 inside entry_1ad274 (0x1ad274 - 0x1ad2b0)
    ctx->pc = 0x1ad278;
    entry_1ad274(rdram, ctx, runtime);
}

void entry_1ad29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad29c inside entry_1ad274 (0x1ad274 - 0x1ad2b0)
    ctx->pc = 0x1ad29c;
    entry_1ad274(rdram, ctx, runtime);
}

void entry_1ad2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad2a4 inside entry_1ad274 (0x1ad274 - 0x1ad2b0)
    ctx->pc = 0x1ad2a4;
    entry_1ad274(rdram, ctx, runtime);
}

void entry_1ad2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad2b4 inside entry_1ad2b0 (0x1ad2b0 - 0x1ad2f4)
    ctx->pc = 0x1ad2b4;
    entry_1ad2b0(rdram, ctx, runtime);
}

void entry_1ad2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad2d8 inside entry_1ad2b0 (0x1ad2b0 - 0x1ad2f4)
    ctx->pc = 0x1ad2d8;
    entry_1ad2b0(rdram, ctx, runtime);
}

void entry_1ad2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad2e4 inside entry_1ad2b0 (0x1ad2b0 - 0x1ad2f4)
    ctx->pc = 0x1ad2e4;
    entry_1ad2b0(rdram, ctx, runtime);
}

void entry_1ad2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad2e8 inside entry_1ad2b0 (0x1ad2b0 - 0x1ad2f4)
    ctx->pc = 0x1ad2e8;
    entry_1ad2b0(rdram, ctx, runtime);
}

void entry_1ad354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad354 inside entry_1ad350 (0x1ad350 - 0x1ad364)
    ctx->pc = 0x1ad354;
    entry_1ad350(rdram, ctx, runtime);
}

void entry_1ad35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad35c inside entry_1ad350 (0x1ad350 - 0x1ad364)
    ctx->pc = 0x1ad35c;
    entry_1ad350(rdram, ctx, runtime);
}

void entry_1ad39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad39c inside ShowTotalsQMARK (0x1ad378 - 0x1ad3a4)
    ctx->pc = 0x1ad39c;
    ShowTotalsQMARK(rdram, ctx, runtime);
}

void entry_1ad3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad3a8 inside entry_1ad3a4 (0x1ad3a4 - 0x1ad3b0)
    ctx->pc = 0x1ad3a8;
    entry_1ad3a4(rdram, ctx, runtime);
}

void entry_1ad3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad3dc inside HideTotalsQMARK (0x1ad3b0 - 0x1ad3e4)
    ctx->pc = 0x1ad3dc;
    HideTotalsQMARK(rdram, ctx, runtime);
}

void entry_1ad44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad44c inside DrawTotals__FP6TOTALS (0x1ad3f0 - 0x1ad4d0)
    ctx->pc = 0x1ad44c;
    DrawTotals__FP6TOTALS(rdram, ctx, runtime);
}

void entry_1ad478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad478 inside DrawTotals__FP6TOTALS (0x1ad3f0 - 0x1ad4d0)
    ctx->pc = 0x1ad478;
    DrawTotals__FP6TOTALS(rdram, ctx, runtime);
}

void entry_1ad480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad480 inside DrawTotals__FP6TOTALS (0x1ad3f0 - 0x1ad4d0)
    ctx->pc = 0x1ad480;
    DrawTotals__FP6TOTALS(rdram, ctx, runtime);
}

void entry_1ad550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad550 inside entry_1ad508 (0x1ad508 - 0x1ad5ac)
    ctx->pc = 0x1ad550;
    entry_1ad508(rdram, ctx, runtime);
}

void entry_1ad640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad640 inside entry_1ad63c (0x1ad63c - 0x1ad64c)
    ctx->pc = 0x1ad640;
    entry_1ad63c(rdram, ctx, runtime);
}

void entry_1ad680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad680 inside entry_1ad67c (0x1ad67c - 0x1ad6a8)
    ctx->pc = 0x1ad680;
    entry_1ad67c(rdram, ctx, runtime);
}

void entry_1ad754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad754 inside entry_1ad72c (0x1ad72c - 0x1ad784)
    ctx->pc = 0x1ad754;
    entry_1ad72c(rdram, ctx, runtime);
}

void entry_1ad78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad78c inside entry_1ad784 (0x1ad784 - 0x1ad79c)
    ctx->pc = 0x1ad78c;
    entry_1ad784(rdram, ctx, runtime);
}

void entry_1ad790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad790 inside entry_1ad784 (0x1ad784 - 0x1ad79c)
    ctx->pc = 0x1ad790;
    entry_1ad784(rdram, ctx, runtime);
}

void entry_1ad7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad7a0 inside entry_1ad79c (0x1ad79c - 0x1ad7b0)
    ctx->pc = 0x1ad7a0;
    entry_1ad79c(rdram, ctx, runtime);
}

void entry_1ad9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad9d0 inside FUN_001ad970 (0x1ad970 - 0x1ada48)
    ctx->pc = 0x1ad9d0;
    FUN_001ad970(rdram, ctx, runtime);
}

void entry_1ad9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ad9d4 inside FUN_001ad970 (0x1ad970 - 0x1ada48)
    ctx->pc = 0x1ad9d4;
    FUN_001ad970(rdram, ctx, runtime);
}

void entry_1ada88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ada88 inside entry_1ada84 (0x1ada84 - 0x1adab4)
    ctx->pc = 0x1ada88;
    entry_1ada84(rdram, ctx, runtime);
}

void entry_1adad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1adad8 inside entry_1adad4 (0x1adad4 - 0x1adae0)
    ctx->pc = 0x1adad8;
    entry_1adad4(rdram, ctx, runtime);
}

void entry_1adcc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1adcc8 inside entry_1adcc0 (0x1adcc0 - 0x1adcd0)
    ctx->pc = 0x1adcc8;
    entry_1adcc0(rdram, ctx, runtime);
}

void entry_1add00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1add00 inside entry_1adcf8 (0x1adcf8 - 0x1add18)
    ctx->pc = 0x1add00;
    entry_1adcf8(rdram, ctx, runtime);
}

void entry_1add1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1add1c inside entry_1add18 (0x1add18 - 0x1add28)
    ctx->pc = 0x1add1c;
    entry_1add18(rdram, ctx, runtime);
}

void entry_1adef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1adef0 inside entry_1adee8 (0x1adee8 - 0x1adef8)
    ctx->pc = 0x1adef0;
    entry_1adee8(rdram, ctx, runtime);
}

void entry_1adefc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1adefc inside entry_1adef8 (0x1adef8 - 0x1adf28)
    ctx->pc = 0x1adefc;
    entry_1adef8(rdram, ctx, runtime);
}

void entry_1adf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1adf90 inside entry_1adf88 (0x1adf88 - 0x1adfdc)
    ctx->pc = 0x1adf90;
    entry_1adf88(rdram, ctx, runtime);
}

void entry_1adfd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1adfd0 inside entry_1adf88 (0x1adf88 - 0x1adfdc)
    ctx->pc = 0x1adfd0;
    entry_1adf88(rdram, ctx, runtime);
}

void entry_1ae07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae07c inside entry_1ae074 (0x1ae074 - 0x1ae0bc)
    ctx->pc = 0x1ae07c;
    entry_1ae074(rdram, ctx, runtime);
}

void entry_1ae0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae0c0 inside entry_1ae0bc (0x1ae0bc - 0x1ae0cc)
    ctx->pc = 0x1ae0c0;
    entry_1ae0bc(rdram, ctx, runtime);
}

void entry_1ae160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae160 inside entry_1ae15c (0x1ae15c - 0x1ae168)
    ctx->pc = 0x1ae160;
    entry_1ae15c(rdram, ctx, runtime);
}

void entry_1ae1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae1d0 inside UpdateAttract__FP7ATTRACT (0x1ae178 - 0x1ae208)
    ctx->pc = 0x1ae1d0;
    UpdateAttract__FP7ATTRACT(rdram, ctx, runtime);
}

void entry_1ae1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae1fc inside UpdateAttract__FP7ATTRACT (0x1ae178 - 0x1ae208)
    ctx->pc = 0x1ae1fc;
    UpdateAttract__FP7ATTRACT(rdram, ctx, runtime);
}

void entry_1ae358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae358 inside entry_1ae354 (0x1ae354 - 0x1ae364)
    ctx->pc = 0x1ae358;
    entry_1ae354(rdram, ctx, runtime);
}

void entry_1ae454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae454 inside entry_1ae434 (0x1ae434 - 0x1ae46c)
    ctx->pc = 0x1ae454;
    entry_1ae434(rdram, ctx, runtime);
}

void entry_1ae564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae564 inside entry_1ae55c (0x1ae55c - 0x1ae588)
    ctx->pc = 0x1ae564;
    entry_1ae55c(rdram, ctx, runtime);
}

void entry_1ae58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae58c inside entry_1ae588 (0x1ae588 - 0x1ae59c)
    ctx->pc = 0x1ae58c;
    entry_1ae588(rdram, ctx, runtime);
}

void entry_1ae678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae678 inside FUN_001ae5e0 (0x1ae5e0 - 0x1ae6a0)
    ctx->pc = 0x1ae678;
    FUN_001ae5e0(rdram, ctx, runtime);
}

void entry_1ae738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae738 inside entry_1ae734 (0x1ae734 - 0x1ae758)
    ctx->pc = 0x1ae738;
    entry_1ae734(rdram, ctx, runtime);
}

void entry_1ae808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae808 inside FUN_001ae7f8 (0x1ae7f8 - 0x1ae810)
    ctx->pc = 0x1ae808;
    FUN_001ae7f8(rdram, ctx, runtime);
}

void entry_1ae890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae890 inside FUN_001ae820 (0x1ae820 - 0x1ae8fc)
    ctx->pc = 0x1ae890;
    FUN_001ae820(rdram, ctx, runtime);
}

void entry_1ae894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae894 inside FUN_001ae820 (0x1ae820 - 0x1ae8fc)
    ctx->pc = 0x1ae894;
    FUN_001ae820(rdram, ctx, runtime);
}

void entry_1ae898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae898 inside FUN_001ae820 (0x1ae820 - 0x1ae8fc)
    ctx->pc = 0x1ae898;
    FUN_001ae820(rdram, ctx, runtime);
}

void entry_1ae8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae8c4 inside FUN_001ae820 (0x1ae820 - 0x1ae8fc)
    ctx->pc = 0x1ae8c4;
    FUN_001ae820(rdram, ctx, runtime);
}

void entry_1ae918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ae918 inside entry_1ae914 (0x1ae914 - 0x1ae934)
    ctx->pc = 0x1ae918;
    entry_1ae914(rdram, ctx, runtime);
}

void entry_1aea48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aea48 inside entry_1aea40 (0x1aea40 - 0x1aea70)
    ctx->pc = 0x1aea48;
    entry_1aea40(rdram, ctx, runtime);
}

void entry_1aeab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeab8 inside FUN_001aea70 (0x1aea70 - 0x1aeb48)
    ctx->pc = 0x1aeab8;
    FUN_001aea70(rdram, ctx, runtime);
}

void entry_1aeae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeae0 inside FUN_001aea70 (0x1aea70 - 0x1aeb48)
    ctx->pc = 0x1aeae0;
    FUN_001aea70(rdram, ctx, runtime);
}

void entry_1aeb08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeb08 inside FUN_001aea70 (0x1aea70 - 0x1aeb48)
    ctx->pc = 0x1aeb08;
    FUN_001aea70(rdram, ctx, runtime);
}

void entry_1aec48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aec48 inside entry_1aec30 (0x1aec30 - 0x1aec80)
    ctx->pc = 0x1aec48;
    entry_1aec30(rdram, ctx, runtime);
}

void entry_1aed44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aed44 inside entry_1aed34 (0x1aed34 - 0x1aed54)
    ctx->pc = 0x1aed44;
    entry_1aed34(rdram, ctx, runtime);
}

void entry_1aed58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aed58 inside entry_1aed54 (0x1aed54 - 0x1aed78)
    ctx->pc = 0x1aed58;
    entry_1aed54(rdram, ctx, runtime);
}

void entry_1aed64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aed64 inside entry_1aed54 (0x1aed54 - 0x1aed78)
    ctx->pc = 0x1aed64;
    entry_1aed54(rdram, ctx, runtime);
}

void entry_1aeda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeda0 inside FCheckSensorObject__FP6SENSORP2SO (0x1aed78 - 0x1aedb4)
    ctx->pc = 0x1aeda0;
    FCheckSensorObject__FP6SENSORP2SO(rdram, ctx, runtime);
}

void entry_1aeda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeda8 inside FCheckSensorObject__FP6SENSORP2SO (0x1aed78 - 0x1aedb4)
    ctx->pc = 0x1aeda8;
    FCheckSensorObject__FP6SENSORP2SO(rdram, ctx, runtime);
}

void entry_1aedd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aedd0 inside entry_1aedb4 (0x1aedb4 - 0x1aeddc)
    ctx->pc = 0x1aedd0;
    entry_1aedb4(rdram, ctx, runtime);
}

void entry_1aedf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aedf4 inside entry_1aeddc (0x1aeddc - 0x1aee14)
    ctx->pc = 0x1aedf4;
    entry_1aeddc(rdram, ctx, runtime);
}

void entry_1aee08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aee08 inside entry_1aeddc (0x1aeddc - 0x1aee14)
    ctx->pc = 0x1aee08;
    entry_1aeddc(rdram, ctx, runtime);
}

void entry_1aee2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aee2c inside entry_1aee14 (0x1aee14 - 0x1aee50)
    ctx->pc = 0x1aee2c;
    entry_1aee14(rdram, ctx, runtime);
}

void entry_1aee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aee30 inside entry_1aee14 (0x1aee14 - 0x1aee50)
    ctx->pc = 0x1aee30;
    entry_1aee14(rdram, ctx, runtime);
}

void entry_1aee80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aee80 inside FIgnoreSensorObject__FP6SENSORP2SO (0x1aee50 - 0x1aee8c)
    ctx->pc = 0x1aee80;
    FIgnoreSensorObject__FP6SENSORP2SO(rdram, ctx, runtime);
}

void entry_1aeea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeea8 inside entry_1aee8c (0x1aee8c - 0x1aeec4)
    ctx->pc = 0x1aeea8;
    entry_1aee8c(rdram, ctx, runtime);
}

void entry_1aeeb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeeb8 inside entry_1aee8c (0x1aee8c - 0x1aeec4)
    ctx->pc = 0x1aeeb8;
    entry_1aee8c(rdram, ctx, runtime);
}

void entry_1aeee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeee0 inside entry_1aeec4 (0x1aeec4 - 0x1aef00)
    ctx->pc = 0x1aeee0;
    entry_1aeec4(rdram, ctx, runtime);
}

void entry_1aeee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeee4 inside entry_1aeec4 (0x1aeec4 - 0x1aef00)
    ctx->pc = 0x1aeee4;
    entry_1aeec4(rdram, ctx, runtime);
}

void entry_1aef58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aef58 inside entry_1aef48 (0x1aef48 - 0x1aef68)
    ctx->pc = 0x1aef58;
    entry_1aef48(rdram, ctx, runtime);
}

void entry_1aef94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aef94 inside entry_1aef7c (0x1aef7c - 0x1aefa0)
    ctx->pc = 0x1aef94;
    entry_1aef7c(rdram, ctx, runtime);
}

void entry_1aefec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aefec inside entry_1aefb4 (0x1aefb4 - 0x1af000)
    ctx->pc = 0x1aefec;
    entry_1aefb4(rdram, ctx, runtime);
}

void entry_1aeff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeff0 inside entry_1aefb4 (0x1aefb4 - 0x1af000)
    ctx->pc = 0x1aeff0;
    entry_1aefb4(rdram, ctx, runtime);
}

void entry_1aeff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aeff4 inside entry_1aefb4 (0x1aefb4 - 0x1af000)
    ctx->pc = 0x1aeff4;
    entry_1aefb4(rdram, ctx, runtime);
}

void entry_1af020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af020 inside AddSensorTriggerObject__FP6SENSOR3OID (0x1af000 - 0x1af028)
    ctx->pc = 0x1af020;
    AddSensorTriggerObject__FP6SENSOR3OID(rdram, ctx, runtime);
}

void entry_1af048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af048 inside AddSensorNoTriggerObject__FP6SENSOR3OID (0x1af028 - 0x1af050)
    ctx->pc = 0x1af048;
    AddSensorNoTriggerObject__FP6SENSOR3OID(rdram, ctx, runtime);
}

void entry_1af070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af070 inside AddSensorTriggerClass__FP6SENSOR3CID (0x1af050 - 0x1af078)
    ctx->pc = 0x1af070;
    AddSensorTriggerClass__FP6SENSOR3CID(rdram, ctx, runtime);
}

void entry_1af098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af098 inside AddSensorNoTriggerClass__FP6SENSOR3CID (0x1af078 - 0x1af0a0)
    ctx->pc = 0x1af098;
    AddSensorNoTriggerClass__FP6SENSOR3CID(rdram, ctx, runtime);
}

void entry_1af168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af168 inside entry_1af12c (0x1af12c - 0x1af174)
    ctx->pc = 0x1af168;
    entry_1af12c(rdram, ctx, runtime);
}

void entry_1af1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af1f0 inside entry_1af174 (0x1af174 - 0x1af208)
    ctx->pc = 0x1af1f0;
    entry_1af174(rdram, ctx, runtime);
}

void entry_1af24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af24c inside entry_1af208 (0x1af208 - 0x1af270)
    ctx->pc = 0x1af24c;
    entry_1af208(rdram, ctx, runtime);
}

void entry_1af268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af268 inside entry_1af208 (0x1af208 - 0x1af270)
    ctx->pc = 0x1af268;
    entry_1af208(rdram, ctx, runtime);
}

void entry_1af2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af2b8 inside entry_1af2b4 (0x1af2b4 - 0x1af2fc)
    ctx->pc = 0x1af2b8;
    entry_1af2b4(rdram, ctx, runtime);
}

void entry_1af2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af2d0 inside entry_1af2b4 (0x1af2b4 - 0x1af2fc)
    ctx->pc = 0x1af2d0;
    entry_1af2b4(rdram, ctx, runtime);
}

void entry_1af318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af318 inside entry_1af2fc (0x1af2fc - 0x1af380)
    ctx->pc = 0x1af318;
    entry_1af2fc(rdram, ctx, runtime);
}

void entry_1af390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af390 inside entry_1af380 (0x1af380 - 0x1af3b8)
    ctx->pc = 0x1af390;
    entry_1af380(rdram, ctx, runtime);
}

void entry_1af394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af394 inside entry_1af380 (0x1af380 - 0x1af3b8)
    ctx->pc = 0x1af394;
    entry_1af380(rdram, ctx, runtime);
}

void entry_1af400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af400 inside entry_1af3f0 (0x1af3f0 - 0x1af41c)
    ctx->pc = 0x1af400;
    entry_1af3f0(rdram, ctx, runtime);
}

void entry_1af438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af438 inside entry_1af41c (0x1af41c - 0x1af448)
    ctx->pc = 0x1af438;
    entry_1af41c(rdram, ctx, runtime);
}

void entry_1af46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af46c inside entry_1af468 (0x1af468 - 0x1af47c)
    ctx->pc = 0x1af46c;
    entry_1af468(rdram, ctx, runtime);
}

void entry_1af49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af49c inside entry_1af47c (0x1af47c - 0x1af4c4)
    ctx->pc = 0x1af49c;
    entry_1af47c(rdram, ctx, runtime);
}

void entry_1af4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af4a4 inside entry_1af47c (0x1af47c - 0x1af4c4)
    ctx->pc = 0x1af4a4;
    entry_1af47c(rdram, ctx, runtime);
}

void entry_1af4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af4b4 inside entry_1af47c (0x1af47c - 0x1af4c4)
    ctx->pc = 0x1af4b4;
    entry_1af47c(rdram, ctx, runtime);
}

void entry_1af528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af528 inside UpdateBusyLasenSenseTimes__Fv (0x1af508 - 0x1af5c8)
    ctx->pc = 0x1af528;
    UpdateBusyLasenSenseTimes__Fv(rdram, ctx, runtime);
}

void entry_1af544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af544 inside UpdateBusyLasenSenseTimes__Fv (0x1af508 - 0x1af5c8)
    ctx->pc = 0x1af544;
    UpdateBusyLasenSenseTimes__Fv(rdram, ctx, runtime);
}

void entry_1af578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af578 inside UpdateBusyLasenSenseTimes__Fv (0x1af508 - 0x1af5c8)
    ctx->pc = 0x1af578;
    UpdateBusyLasenSenseTimes__Fv(rdram, ctx, runtime);
}

void entry_1af5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af5ac inside UpdateBusyLasenSenseTimes__Fv (0x1af508 - 0x1af5c8)
    ctx->pc = 0x1af5ac;
    UpdateBusyLasenSenseTimes__Fv(rdram, ctx, runtime);
}

void entry_1af5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af5b4 inside UpdateBusyLasenSenseTimes__Fv (0x1af508 - 0x1af5c8)
    ctx->pc = 0x1af5b4;
    UpdateBusyLasenSenseTimes__Fv(rdram, ctx, runtime);
}

void entry_1af614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af614 inside entry_1af5e4 (0x1af5e4 - 0x1af640)
    ctx->pc = 0x1af614;
    entry_1af5e4(rdram, ctx, runtime);
}

void entry_1af624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af624 inside entry_1af5e4 (0x1af5e4 - 0x1af640)
    ctx->pc = 0x1af624;
    entry_1af5e4(rdram, ctx, runtime);
}

void entry_1af644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af644 inside entry_1af640 (0x1af640 - 0x1af734)
    ctx->pc = 0x1af644;
    entry_1af640(rdram, ctx, runtime);
}

void entry_1af71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af71c inside entry_1af640 (0x1af640 - 0x1af734)
    ctx->pc = 0x1af71c;
    entry_1af640(rdram, ctx, runtime);
}

void entry_1af720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af720 inside entry_1af640 (0x1af640 - 0x1af734)
    ctx->pc = 0x1af720;
    entry_1af640(rdram, ctx, runtime);
}

void entry_1af724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af724 inside entry_1af640 (0x1af640 - 0x1af734)
    ctx->pc = 0x1af724;
    entry_1af640(rdram, ctx, runtime);
}

void entry_1af760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af760 inside entry_1af734 (0x1af734 - 0x1af780)
    ctx->pc = 0x1af760;
    entry_1af734(rdram, ctx, runtime);
}

void entry_1af76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af76c inside entry_1af734 (0x1af734 - 0x1af780)
    ctx->pc = 0x1af76c;
    entry_1af734(rdram, ctx, runtime);
}

void entry_1af784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af784 inside entry_1af780 (0x1af780 - 0x1af794)
    ctx->pc = 0x1af784;
    entry_1af780(rdram, ctx, runtime);
}

void entry_1af7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af7ec inside entry_1af7e4 (0x1af7e4 - 0x1af7f8)
    ctx->pc = 0x1af7ec;
    entry_1af7e4(rdram, ctx, runtime);
}

void entry_1af800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af800 inside entry_1af7f8 (0x1af7f8 - 0x1af820)
    ctx->pc = 0x1af800;
    entry_1af7f8(rdram, ctx, runtime);
}

void entry_1af894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af894 inside entry_1af86c (0x1af86c - 0x1af8c0)
    ctx->pc = 0x1af894;
    entry_1af86c(rdram, ctx, runtime);
}

void entry_1af8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af8a0 inside entry_1af86c (0x1af86c - 0x1af8c0)
    ctx->pc = 0x1af8a0;
    entry_1af86c(rdram, ctx, runtime);
}

void entry_1af8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af8b8 inside entry_1af86c (0x1af86c - 0x1af8c0)
    ctx->pc = 0x1af8b8;
    entry_1af86c(rdram, ctx, runtime);
}

void entry_1af8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af8e0 inside entry_1af8cc (0x1af8cc - 0x1af908)
    ctx->pc = 0x1af8e0;
    entry_1af8cc(rdram, ctx, runtime);
}

void entry_1af924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af924 inside entry_1af908 (0x1af908 - 0x1af95c)
    ctx->pc = 0x1af924;
    entry_1af908(rdram, ctx, runtime);
}

void entry_1af940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af940 inside entry_1af908 (0x1af908 - 0x1af95c)
    ctx->pc = 0x1af940;
    entry_1af908(rdram, ctx, runtime);
}

void entry_1af96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af96c inside entry_1af95c (0x1af95c - 0x1afa4c)
    ctx->pc = 0x1af96c;
    entry_1af95c(rdram, ctx, runtime);
}

void entry_1af98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af98c inside entry_1af95c (0x1af95c - 0x1afa4c)
    ctx->pc = 0x1af98c;
    entry_1af95c(rdram, ctx, runtime);
}

void entry_1af9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1af9a8 inside entry_1af95c (0x1af95c - 0x1afa4c)
    ctx->pc = 0x1af9a8;
    entry_1af95c(rdram, ctx, runtime);
}

void entry_1afa1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afa1c inside entry_1af95c (0x1af95c - 0x1afa4c)
    ctx->pc = 0x1afa1c;
    entry_1af95c(rdram, ctx, runtime);
}

void entry_1afa34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afa34 inside entry_1af95c (0x1af95c - 0x1afa4c)
    ctx->pc = 0x1afa34;
    entry_1af95c(rdram, ctx, runtime);
}

void entry_1afa70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afa70 inside entry_1afa4c (0x1afa4c - 0x1afab8)
    ctx->pc = 0x1afa70;
    entry_1afa4c(rdram, ctx, runtime);
}

void entry_1afa74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afa74 inside entry_1afa4c (0x1afa4c - 0x1afab8)
    ctx->pc = 0x1afa74;
    entry_1afa4c(rdram, ctx, runtime);
}

void entry_1afa9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afa9c inside entry_1afa4c (0x1afa4c - 0x1afab8)
    ctx->pc = 0x1afa9c;
    entry_1afa4c(rdram, ctx, runtime);
}

void entry_1afaa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afaa0 inside entry_1afa4c (0x1afa4c - 0x1afab8)
    ctx->pc = 0x1afaa0;
    entry_1afa4c(rdram, ctx, runtime);
}

void entry_1afab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afab0 inside entry_1afa4c (0x1afa4c - 0x1afab8)
    ctx->pc = 0x1afab0;
    entry_1afa4c(rdram, ctx, runtime);
}

void entry_1afabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afabc inside entry_1afab8 (0x1afab8 - 0x1afaf8)
    ctx->pc = 0x1afabc;
    entry_1afab8(rdram, ctx, runtime);
}

void entry_1afb90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afb90 inside entry_1afb78 (0x1afb78 - 0x1afbb0)
    ctx->pc = 0x1afb90;
    entry_1afb78(rdram, ctx, runtime);
}

void entry_1afba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afba0 inside entry_1afb78 (0x1afb78 - 0x1afbb0)
    ctx->pc = 0x1afba0;
    entry_1afb78(rdram, ctx, runtime);
}

void entry_1afc48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afc48 inside entry_1afc34 (0x1afc34 - 0x1afc74)
    ctx->pc = 0x1afc48;
    entry_1afc34(rdram, ctx, runtime);
}

void entry_1afc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afc90 inside entry_1afc74 (0x1afc74 - 0x1afcac)
    ctx->pc = 0x1afc90;
    entry_1afc74(rdram, ctx, runtime);
}

void entry_1afcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afcbc inside entry_1afcac (0x1afcac - 0x1afde4)
    ctx->pc = 0x1afcbc;
    entry_1afcac(rdram, ctx, runtime);
}

void entry_1afcd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afcd0 inside entry_1afcac (0x1afcac - 0x1afde4)
    ctx->pc = 0x1afcd0;
    entry_1afcac(rdram, ctx, runtime);
}

void entry_1afdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afdf8 inside entry_1afde4 (0x1afde4 - 0x1afe10)
    ctx->pc = 0x1afdf8;
    entry_1afde4(rdram, ctx, runtime);
}

void entry_1afdfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afdfc inside entry_1afde4 (0x1afde4 - 0x1afe10)
    ctx->pc = 0x1afdfc;
    entry_1afde4(rdram, ctx, runtime);
}

void entry_1afe18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afe18 inside entry_1afe10 (0x1afe10 - 0x1afe28)
    ctx->pc = 0x1afe18;
    entry_1afe10(rdram, ctx, runtime);
}

void entry_1afec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afec0 inside entry_1afe74 (0x1afe74 - 0x1afef4)
    ctx->pc = 0x1afec0;
    entry_1afe74(rdram, ctx, runtime);
}

void entry_1afee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afee8 inside entry_1afe74 (0x1afe74 - 0x1afef4)
    ctx->pc = 0x1afee8;
    entry_1afe74(rdram, ctx, runtime);
}

void entry_1aff98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1aff98 inside entry_1aff94 (0x1aff94 - 0x1affa8)
    ctx->pc = 0x1aff98;
    entry_1aff94(rdram, ctx, runtime);
}

void entry_1affb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1affb0 inside entry_1affa8 (0x1affa8 - 0x1b002c)
    ctx->pc = 0x1affb0;
    entry_1affa8(rdram, ctx, runtime);
}

void entry_1affb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1affb4 inside entry_1affa8 (0x1affa8 - 0x1b002c)
    ctx->pc = 0x1affb4;
    entry_1affa8(rdram, ctx, runtime);
}

void entry_1affd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1affd4 inside entry_1affa8 (0x1affa8 - 0x1b002c)
    ctx->pc = 0x1affd4;
    entry_1affa8(rdram, ctx, runtime);
}

void entry_1affd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1affd8 inside entry_1affa8 (0x1affa8 - 0x1b002c)
    ctx->pc = 0x1affd8;
    entry_1affa8(rdram, ctx, runtime);
}

void entry_1afff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1afff0 inside entry_1affa8 (0x1affa8 - 0x1b002c)
    ctx->pc = 0x1afff0;
    entry_1affa8(rdram, ctx, runtime);
}

