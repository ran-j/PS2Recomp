// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_120004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120004: 0xc063582
    SET_GPR_U32(ctx, 31, 0x12000c);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_12000c
// Address: 0x12000c - 0x120024

void entry_12000c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12000c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x120010: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x120014: 0x27a500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 160));
    // 0x120018: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x12001c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x120024);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 164));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_120024
// Address: 0x120024 - 0x120060

void entry_120024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120024: 0x8fa300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x120028: 0x1860002f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 164)));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1200E8; return;
    }
    // 0x120030: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x120034: 0x8e480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x120038: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12003c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x120040: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x120044: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x120048: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    // 0x12004c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x120050: 0x8d030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x120054: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x120058: 0x60f809
    SET_GPR_U32(ctx, 31, 0x120060);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_120060
// Address: 0x120060 - 0x12009c

void entry_120060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120060: 0x8fa200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x120064: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x120068: 0x8fa300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 164)));
    // 0x12006c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x120070: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x120074: 0x8e440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x120078: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12007c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x120080: 0xc44cfffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[12] = *(float*)&val; }
    // 0x120084: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x120088: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12008c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x120090: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x120094: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12009c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12009c
// Address: 0x12009c - 0x1200b0

void entry_12009c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12009c: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1200a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1200a4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1200a8: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1200b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1200b0
// Address: 0x1200b0 - 0x1200c0

void entry_1200b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1200b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1200b4: 0x27a500a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 168));
    // 0x1200b8: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1200c0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1200c0
// Address: 0x1200c0 - 0x1200f4

void entry_1200c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1200c0) {
        switch (ctx->pc) {
            case 0x1200e8: ctx->pc = 0; goto label_1200e8;
            case 0x1200ec: ctx->pc = 0; goto label_1200ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1200c0: 0xc7a100a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[1] = *(float*)&val; }
    // 0x1200c4: 0x3c013c23
    SET_GPR_U32(ctx, 1, ((uint32_t)15395 << 16));
    // 0x1200c8: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x1200cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1200d0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1200d4: 0x0
    // NOP
    // 0x1200d8: 0x45010004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1200ec;
    }
    // 0x1200e0: 0x10000002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1200ec;
    }
label_1200e8:
    // 0x1200e8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1200ec:
    // 0x1200ec: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1200f4);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1200f4
// Address: 0x1200f4 - 0x120110

void entry_1200f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1200f4: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1200f8: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1200fc: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x120100: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x120104: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x120108: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAcrcTimes__FP4ACRCPiPPf
// Address: 0x120110 - 0x120120

void entry_120120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120120: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x120124: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12012c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x120130; return;
}


// Function: EvaluateAcrb__FP4ACRBP3ALOffiP7MATRIX3P6VECTOR
// Address: 0x120130 - 0x120174

void entry_120174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120174: 0x12000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_120184(rdram, ctx, runtime); return;
    }
    // 0x12017c: 0xc062288
    SET_GPR_U32(ctx, 31, 0x120184);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_120184
// Address: 0x120184 - 0x120198

void entry_120184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120184: 0x12200004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_120198(rdram, ctx, runtime); return;
    }
    // 0x12018c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x120190: 0xc07b78e
    SET_GPR_U32(ctx, 31, 0x120198);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertDeulToW__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_120198
// Address: 0x120198 - 0x1201b4

void entry_120198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120198: 0x12400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1201b4(rdram, ctx, runtime); return;
    }
    // 0x1201a0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1201a4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1201a8: 0x8c6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 180)));
    // 0x1201ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1201b4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1201b4
// Address: 0x1201b4 - 0x1201d0

void entry_1201b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1201b4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1201b8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1201bc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1201c0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1201c4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1201c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateAcrbEul__FP4ACRBP3ALOffiP6VECTORT5
// Address: 0x1201d0 - 0x1201e4

void entry_1201e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1201e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1201e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadAcrbFromBrx__FP4ACRBP18CBinaryInputStream
// Address: 0x1201f0 - 0x120218

void entry_120218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120218) {
        switch (ctx->pc) {
            case 0x120230: ctx->pc = 0; goto label_120230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120218: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x12021c: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x120220: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 16)));
        goto label_120230;
    }
    // 0x120228: 0x1000001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1202A4; return;
    }
label_120230:
    // 0x120230: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x120234: 0xc062288
    SET_GPR_U32(ctx, 31, 0x12023c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_12023c
// Address: 0x12023c - 0x12025c

void entry_12023c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12023c: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x120240: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x120244: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x120248: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12024c: 0x42180
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 6));
    // 0x120250: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x120254: 0xc062288
    SET_GPR_U32(ctx, 31, 0x12025c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967248));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_12025c
// Address: 0x12025c - 0x120270

void entry_12025c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12025c: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x120260: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x120264: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x120268: 0xc062454
    SET_GPR_U32(ctx, 31, 0x120270);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_120270
// Address: 0x120270 - 0x120280

void entry_120270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120270: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x120274: 0x27a500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 160));
    // 0x120278: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x120280);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_120280
// Address: 0x120280 - 0x1202c0

void entry_120280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120280) {
        switch (ctx->pc) {
            case 0x1202a4: ctx->pc = 0; goto label_1202a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120280: 0xc7a100a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[1] = *(float*)&val; }
    // 0x120284: 0x3c013c23
    SET_GPR_U32(ctx, 1, ((uint32_t)15395 << 16));
    // 0x120288: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x12028c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x120290: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120294: 0x0
    // NOP
    // 0x120298: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1202a4;
    }
    // 0x1202a0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1202a4:
    // 0x1202a4: 0xae420008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    // 0x1202a8: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1202ac: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1202b0: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1202b4: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1202b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAcrbTimes__FP4ACRBPiPPf
// Address: 0x1202c0 - 0x1202e0

void entry_1202e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1202e0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1202e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1202ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1202f0; return;
}


// Function: EvaluateAcsc__FP4ACSCP3ALOfiP7MATRIX3
// Address: 0x1202f0 - 0x120320

void entry_120320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120320: 0x1200000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12034C; return;
    }
    // 0x120328: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12032c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x120334);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_120334
// Address: 0x120334 - 0x120360

void entry_120334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120334) {
        switch (ctx->pc) {
            case 0x12034c: ctx->pc = 0; goto label_12034c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120334: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x120338: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x12033c: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x120340: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x120344: 0xe6010028
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    // 0x120348: 0xe6020014
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
label_12034c:
    // 0x12034c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x120350: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x120354: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12035c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x120360; return;
}


// Function: LoadAcscFromBrx__FP4ACSCP18CBinaryInputStream
// Address: 0x120360 - 0x120378

void entry_120378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120378: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12037c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x120384: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x120388; return;
}


// Function: GetAcscTimes__FP4ACSCPiPPf
// Address: 0x120388 - 0x120398

void entry_120398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120398: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12039c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1203a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1203a8; return;
}


// Function: EvaluateAcsb__FP4ACSBP3ALOfiP7MATRIX3
// Address: 0x1203a8 - 0x1203d8

void entry_1203d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1203d8: 0x1200000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x120404; return;
    }
    // 0x1203e0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1203e4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1203ec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1203ec
// Address: 0x1203ec - 0x120418

void entry_1203ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1203ec) {
        switch (ctx->pc) {
            case 0x120404: ctx->pc = 0; goto label_120404;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1203ec: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1203f0: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1203f4: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1203f8: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1203fc: 0xe6010028
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    // 0x120400: 0xe6020014
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
label_120404:
    // 0x120404: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x120408: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12040c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x120414: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x120418; return;
}


// Function: LoadAcsbFromBrx__FP4ACSBP18CBinaryInputStream
// Address: 0x120418 - 0x120430

void entry_120430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120430: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x120434: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12043c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x120440; return;
}


// Function: GetAcsbTimes__FP4ACSBPiPPf
// Address: 0x120440 - 0x120460

void entry_120460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120460: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x120464: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12046c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x120470; return;
}


// Function: EvaluateAcpbl__FP5ACPBLP3ALOffiP6VECTORT5
// Address: 0x120470 - 0x120504

void entry_120504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120504) {
        switch (ctx->pc) {
            case 0x120520: ctx->pc = 0; goto label_120520;
            case 0x120540: ctx->pc = 0; goto label_120540;
            case 0x1205a4: ctx->pc = 0; goto label_1205a4;
            case 0x1205b8: ctx->pc = 0; goto label_1205b8;
            case 0x1205d8: ctx->pc = 0; goto label_1205d8;
            case 0x12060c: ctx->pc = 0; goto label_12060c;
            case 0x12061c: ctx->pc = 0; goto label_12061c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120504: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x120508: 0x8e830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x12050c: 0x1e10c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 30), 3));
    // 0x120510: 0xc7a10030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[1] = *(float*)&val; }
    // 0x120514: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x120518: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x12051c: 0x46000d03
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[20] = ctx->f[1] / ctx->f[0];
label_120520:
    // 0x120520: 0x8e6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
    // 0x120524: 0x1840005f
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1206A4; return;
    }
    // 0x12052c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x120530: 0x3b1100b
    if (GPR_U32(ctx, 17) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 29));
    // 0x120534: 0xafa20038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 2));
    // 0x120538: 0x8e6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 176)));
    // 0x12053c: 0x0
    // NOP
label_120540:
    // 0x120540: 0x8e6300b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 184)));
    // 0x120544: 0x2421018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x120548: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12054c: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x120550: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120554: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120558: 0x0
    // NOP
    // 0x12055c: 0x4503004d
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
        ctx->pc = 0x120694; return;
    }
    // 0x120564: 0x8ee30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 20)));
    // 0x120568: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x12056c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x120570: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120574: 0x14800010
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1205b8;
    }
    // 0x12057c: 0x52200045
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
        ctx->pc = 0x120694; return;
    }
    // 0x120584: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x120588: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x12058c: 0xda230000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x120590: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x120594: 0x16c00003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 400));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        goto label_1205a4;
    }
    // 0x12059c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1205a0: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
label_1205a4:
    // 0x1205a4: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1205a8: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1205ac: 0x4be20848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1205b0: 0x10000037
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x120690; return;
    }
label_1205b8:
    // 0x1205b8: 0x56800007
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        goto label_1205d8;
    }
    // 0x1205c0: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1205c4: 0xc6610034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1205c8: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1205cc: 0x46010343
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[13] = ctx->f[0] / ctx->f[1];
    // 0x1205d0: 0x10000012
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12061c;
    }
label_1205d8:
    // 0x1205d8: 0x1e28c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 30), 3));
    // 0x1205dc: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1205e0: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1205e4: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1205e8: 0xc4620034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[2] = *(float*)&val; }
    // 0x1205ec: 0xc44d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1205f0: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1205f4: 0x460da002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[13]);
    // 0x1205f8: 0x46000b00
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1205fc: 0x460c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120600: 0x0
    // NOP
    // 0x120604: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
        goto label_12060c;
    }
label_12060c:
    // 0x12060c: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x120610: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x120614: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x120618: 0x46006b43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[0];
label_12061c:
    // 0x12061c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x120620: 0x46156b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[21]);
    // 0x120624: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x120628: 0x8fa60034
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x12062c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120630: 0x15400a
    if (GPR_U32(ctx, 21) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 0));
    // 0x120634: 0x8fa70038
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x120638: 0x60f809
    SET_GPR_U32(ctx, 31, 0x120640);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_120640
// Address: 0x120640 - 0x1206c8

void entry_120640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120640) {
        switch (ctx->pc) {
            case 0x120668: ctx->pc = 0; goto label_120668;
            case 0x120690: ctx->pc = 0; goto label_120690;
            case 0x120694: ctx->pc = 0; goto label_120694;
            case 0x1206a4: ctx->pc = 0; goto label_1206a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120640: 0x12200009
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_120668;
    }
    // 0x120648: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12064c: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x120650: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x120654: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x120658: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x12065c: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x120660: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x120664: 0xfa220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_120668:
    // 0x120668: 0x52a0000a
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
        goto label_120694;
    }
    // 0x120670: 0x8e100000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x120674: 0x48b01800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x120678: 0xdaa20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x12067c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x120680: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x120684: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x120688: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12068c: 0xfaa20000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_120690:
    // 0x120690: 0x8e6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
label_120694:
    // 0x120694: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x120698: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x12069c: 0x5440ffa8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 176)));
        ctx->pc = 0x120540; return;
    }
label_1206a4:
    // 0x1206a4: 0x12c00009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1206CC; return;
    }
    // 0x1206ac: 0x8ec20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1206b0: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x1206b4: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1206CC; return;
    }
    // 0x1206bc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1206c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1206c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1206c8
// Address: 0x1206c8 - 0x120700

void entry_1206c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1206c8) {
        switch (ctx->pc) {
            case 0x1206cc: ctx->pc = 0; goto label_1206cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1206c8: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_1206cc:
    // 0x1206cc: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1206d0: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1206d4: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1206d8: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1206dc: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1206e0: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1206e4: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1206e8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1206ec: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1206f0: 0xc7b500e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[21] = *(float*)&val; }
    // 0x1206f4: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x1206f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateAcrbl__FP5ACRBLP3ALOffiP7MATRIX3P6VECTOR
// Address: 0x120700 - 0x12079c

void entry_12079c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12079c) {
        switch (ctx->pc) {
            case 0x1207b8: ctx->pc = 0; goto label_1207b8;
            case 0x1207f0: ctx->pc = 0; goto label_1207f0;
            case 0x120840: ctx->pc = 0; goto label_120840;
            case 0x12084c: ctx->pc = 0; goto label_12084c;
            case 0x12086c: ctx->pc = 0; goto label_12086c;
            case 0x1208a4: ctx->pc = 0; goto label_1208a4;
            case 0x1208b4: ctx->pc = 0; goto label_1208b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12079c: 0xafa2011c
    WRITE32(ADD32(GPR_U32(ctx, 29), 284), GPR_U32(ctx, 2));
    // 0x1207a0: 0xc7a10110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[1] = *(float*)&val; }
    // 0x1207a4: 0x8e830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x1207a8: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1207ac: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1207b0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1207b4: 0x46000d43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[21] = ctx->f[1] / ctx->f[0];
label_1207b8:
    // 0x1207b8: 0x8e6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
    // 0x1207bc: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1207c0: 0x18400096
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x120A1C; return;
    }
    // 0x1207c8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1207cc: 0x27a30050
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1207d0: 0x3b1100b
    if (GPR_U32(ctx, 17) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 29));
    // 0x1207d4: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1207d8: 0xafa20120
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 2));
    // 0x1207dc: 0x4600a586
    ctx->f[22] = FPU_MOV_S(ctx->f[20]);
    // 0x1207e0: 0xafa30124
    WRITE32(ADD32(GPR_U32(ctx, 29), 292), GPR_U32(ctx, 3));
    // 0x1207e4: 0x27be0080
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1207e8: 0xafa40128
    WRITE32(ADD32(GPR_U32(ctx, 29), 296), GPR_U32(ctx, 4));
    // 0x1207ec: 0x8e6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 176)));
label_1207f0:
    // 0x1207f0: 0x8e6300b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 184)));
    // 0x1207f4: 0x2421018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1207f8: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1207fc: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x120800: 0x46160032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120804: 0x0
    // NOP
    // 0x120808: 0x45030080
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
        ctx->pc = 0x120A0C; return;
    }
    // 0x120810: 0x8ee30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 20)));
    // 0x120814: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x120818: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12081c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120820: 0x1480000a
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_12084c;
    }
    // 0x120828: 0x52200078
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
        ctx->pc = 0x120A0C; return;
    }
    // 0x120830: 0x16a00003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 464));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        goto label_120840;
    }
    // 0x120838: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x12083c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
label_120840:
    // 0x120840: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120844: 0x1000002e
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x120900; return;
    }
label_12084c:
    // 0x12084c: 0x16800007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 284)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        goto label_12086c;
    }
    // 0x120854: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x120858: 0xc6610034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 52)); ctx->f[1] = *(float*)&val; }
    // 0x12085c: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x120860: 0x46010343
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[13] = ctx->f[0] / ctx->f[1];
    // 0x120864: 0x10000013
    ctx->f[12] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1208b4;
    }
label_12086c:
    // 0x12086c: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x120870: 0x328c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 3), 3));
    // 0x120874: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x120878: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12087c: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x120880: 0xc44d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    // 0x120884: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120888: 0x460da802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[13]);
    // 0x12088c: 0xc4620034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[2] = *(float*)&val; }
    // 0x120890: 0x46000b00
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x120894: 0x460c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120898: 0x0
    // NOP
    // 0x12089c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
        goto label_1208a4;
    }
label_1208a4:
    // 0x1208a4: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x1208a8: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1208ac: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1208b0: 0x46006b43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[0];
label_1208b4:
    // 0x1208b4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1208b8: 0x46176b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[23]);
    // 0x1208bc: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1208c0: 0x8fa60118
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x1208c4: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1208c8: 0x16400a
    if (GPR_U32(ctx, 22) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 0));
    // 0x1208cc: 0x8fa70120
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1208d0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1208d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1208d8
// Address: 0x1208d8 - 0x12092c

void entry_1208d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1208d8) {
        switch (ctx->pc) {
            case 0x120900: ctx->pc = 0; goto label_120900;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1208d8: 0x12c00009
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_120900;
    }
    // 0x1208e0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1208e4: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1208e8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1208ec: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1208f0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1208f4: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1208f8: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1208fc: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
label_120900:
    // 0x120900: 0x52200042
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
        ctx->pc = 0x120A0C; return;
    }
    // 0x120908: 0x8ee20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 24)));
    // 0x12090c: 0x50400037
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1209EC; return;
    }
    // 0x120914: 0x4616a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120918: 0x0
    // NOP
    // 0x12091c: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x120934; return;
    }
    // 0x120924: 0xc062288
    SET_GPR_U32(ctx, 31, 0x12092c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_12092c
// Address: 0x12092c - 0x120940

void entry_12092c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12092c) {
        switch (ctx->pc) {
            case 0x120934: ctx->pc = 0; goto label_120934;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12092c: 0x1000002d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1209E4; return;
    }
label_120934:
    // 0x120934: 0x8fa50124
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 292)));
    // 0x120938: 0xc062288
    SET_GPR_U32(ctx, 31, 0x120940);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_120940
// Address: 0x120940 - 0x120950

void entry_120940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120940: 0x8fa40124
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 292)));
    // 0x120944: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x120948: 0xc062454
    SET_GPR_U32(ctx, 31, 0x120950);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_120950
// Address: 0x120950 - 0x120960

void entry_120950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120950: 0x8fa60128
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x120954: 0x27a50114
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 276));
    // 0x120958: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x120960);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_120960
// Address: 0x120960 - 0x120980

void entry_120960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120960: 0xc7a00114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 276)); ctx->f[0] = *(float*)&val; }
    // 0x120964: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x120968: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x12096c: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x120970: 0x8fa40128
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x120974: 0x460ca300
    ctx->f[12] = FPU_ADD_S(ctx->f[20], ctx->f[12]);
    // 0x120978: 0xc062214
    SET_GPR_U32(ctx, 31, 0x120980);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[12];
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_120980
// Address: 0x120980 - 0x120a38

void entry_120980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120980) {
        switch (ctx->pc) {
            case 0x1209e4: ctx->pc = 0; goto label_1209e4;
            case 0x1209ec: ctx->pc = 0; goto label_1209ec;
            case 0x120a08: ctx->pc = 0; goto label_120a08;
            case 0x120a0c: ctx->pc = 0; goto label_120a0c;
            case 0x120a1c: ctx->pc = 0; goto label_120a1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120980: 0xdba30080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x120984: 0xdba50090
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x120988: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12098c: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x120990: 0xdba60060
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x120994: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x120998: 0x4bc428bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x12099c: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1209a0: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1209a4: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1209a8: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1209ac: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1209b0: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1209b4: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1209b8: 0x4bc208ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1209bc: 0xfa240000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1209c0: 0xfa260010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1209c4: 0xfa230020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1209c8: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1209cc: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1209d0: 0xfba600f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1209d4: 0xfba600c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1209d8: 0xfba30100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1209dc: 0xfba300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1209e0: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
label_1209e4:
    // 0x1209e4: 0x10000008
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_120a08;
    }
label_1209ec:
    // 0x1209ec: 0x48b01800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x1209f0: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1209f4: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1209f8: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1209fc: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x120a00: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x120a04: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_120a08:
    // 0x120a08: 0x8e6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 180)));
label_120a0c:
    // 0x120a0c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x120a10: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x120a14: 0x5440ff76
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 176)));
        ctx->pc = 0x1207F0; return;
    }
label_120a1c:
    // 0x120a1c: 0x12200006
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_120a38(rdram, ctx, runtime); return;
    }
    // 0x120a24: 0x8ee20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 24)));
    // 0x120a28: 0x14400003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_120a38(rdram, ctx, runtime); return;
    }
    // 0x120a30: 0xc062288
    SET_GPR_U32(ctx, 31, 0x120a38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_120a38
// Address: 0x120a38 - 0x120a4c

void entry_120a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120a38: 0x12c00004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        entry_120a4c(rdram, ctx, runtime); return;
    }
    // 0x120a40: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x120a44: 0xc07b78e
    SET_GPR_U32(ctx, 31, 0x120a4c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ConvertDeulToW__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_120a4c
// Address: 0x120a4c - 0x120a68

void entry_120a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120a4c: 0x12a00006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        entry_120a68(rdram, ctx, runtime); return;
    }
    // 0x120a54: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x120a58: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x120a5c: 0x8c6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 180)));
    // 0x120a60: 0x40f809
    SET_GPR_U32(ctx, 31, 0x120a68);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_120a68
// Address: 0x120a68 - 0x120aa8

void entry_120a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120a68: 0x7bbf01c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x120a6c: 0x7bbe01b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x120a70: 0x7bb701a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x120a74: 0x7bb60190
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x120a78: 0x7bb50180
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x120a7c: 0x7bb40170
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x120a80: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x120a84: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x120a88: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x120a8c: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x120a90: 0xc7b701e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 488)); ctx->f[23] = *(float*)&val; }
    // 0x120a94: 0xc7b601e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[22] = *(float*)&val; }
    // 0x120a98: 0xc7b501d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[21] = *(float*)&val; }
    // 0x120a9c: 0xc7b401d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[20] = *(float*)&val; }
    // 0x120aa0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 496));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5
// Address: 0x120aa8 - 0x120b64

void entry_120b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120b64) {
        switch (ctx->pc) {
            case 0x120b80: ctx->pc = 0; goto label_120b80;
            case 0x120b98: ctx->pc = 0; goto label_120b98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120b64: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x120b68: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x120b6c: 0x1e10c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 30), 3));
    // 0x120b70: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x120b74: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x120b78: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x120b7c: 0x46000d83
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[22] = ctx->f[1] / ctx->f[0];
label_120b80:
    // 0x120b80: 0x8e4200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
    // 0x120b84: 0x1840005b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x120CF4; return;
    }
    // 0x120b8c: 0x4480c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 0);
    // 0x120b90: 0x8e4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 176)));
    // 0x120b94: 0x0
    // NOP
label_120b98:
    // 0x120b98: 0x8e4300b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 184)));
    // 0x120b9c: 0x2221018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x120ba0: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x120ba4: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x120ba8: 0x46180032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120bac: 0x0
    // NOP
    // 0x120bb0: 0x4503004c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
        ctx->pc = 0x120CE4; return;
    }
    // 0x120bb8: 0x8ea30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x120bbc: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x120bc0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x120bc4: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120bc8: 0x1480000d
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x120C00; return;
    }
    // 0x120bd0: 0x12800040
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x120CD4; return;
    }
    // 0x120bd8: 0x8e820224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 548)));
    // 0x120bdc: 0xc44c0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 144)); ctx->f[12] = *(float*)&val; }
    // 0x120be0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x120be8);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[20]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_120be8
// Address: 0x120be8 - 0x120c84

void entry_120be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120be8) {
        switch (ctx->pc) {
            case 0x120c00: ctx->pc = 0; goto label_120c00;
            case 0x120c20: ctx->pc = 0; goto label_120c20;
            case 0x120c54: ctx->pc = 0; goto label_120c54;
            case 0x120c64: ctx->pc = 0; goto label_120c64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120be8: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120bec: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x120bf0: 0x4601a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[1]);
    // 0x120bf4: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x120bf8: 0x10000034
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x120CCC; return;
    }
label_120c00:
    // 0x120c00: 0x56600007
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        goto label_120c20;
    }
    // 0x120c08: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x120c0c: 0xc6410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[1] = *(float*)&val; }
    // 0x120c10: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x120c14: 0x46010343
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[13] = ctx->f[0] / ctx->f[1];
    // 0x120c18: 0x10000012
    ctx->f[12] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_120c64;
    }
label_120c20:
    // 0x120c20: 0x1e28c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 30), 3));
    // 0x120c24: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x120c28: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x120c2c: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x120c30: 0xc4620034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[2] = *(float*)&val; }
    // 0x120c34: 0xc44d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    // 0x120c38: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120c3c: 0x460db002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[13]);
    // 0x120c40: 0x46000b00
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x120c44: 0x460c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120c48: 0x0
    // NOP
    // 0x120c4c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
        goto label_120c54;
    }
label_120c54:
    // 0x120c54: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x120c58: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x120c5c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x120c60: 0x46006b43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[0];
label_120c64:
    // 0x120c64: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x120c68: 0x46196b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[25]);
    // 0x120c6c: 0x8fa6000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x120c70: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x120c74: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120c78: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x120c7c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x120c84);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_120c84
// Address: 0x120c84 - 0x120ca0

void entry_120c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120c84) {
        switch (ctx->pc) {
            case 0x120c98: ctx->pc = 0; goto label_120c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120c84: 0x4618a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120c88: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_120c98;
    }
    // 0x120c90: 0x1000000a
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x120CBC; return;
    }
label_120c98:
    // 0x120c98: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x120ca0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_120ca0
// Address: 0x120ca0 - 0x120ca8

void entry_120ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x120ca0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x120ca8);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_120ca8
// Address: 0x120ca8 - 0x120cdc

void entry_120ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120ca8) {
        switch (ctx->pc) {
            case 0x120cbc: ctx->pc = 0; goto label_120cbc;
            case 0x120ccc: ctx->pc = 0; goto label_120ccc;
            case 0x120cd4: ctx->pc = 0; goto label_120cd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120ca8: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120cac: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x120cb0: 0x4601a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[1]);
    // 0x120cb4: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x120cb8: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
label_120cbc:
    // 0x120cbc: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x120cc0: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x120cc4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x120cc8: 0x4600bdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
label_120ccc:
    // 0x120ccc: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x120cd0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
label_120cd4:
    // 0x120cd4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x120cdc);
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_120cdc
// Address: 0x120cdc - 0x120d58

void entry_120cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120cdc) {
        switch (ctx->pc) {
            case 0x120ce4: ctx->pc = 0; goto label_120ce4;
            case 0x120cf4: ctx->pc = 0; goto label_120cf4;
            case 0x120d00: ctx->pc = 0; goto label_120d00;
            case 0x120d0c: ctx->pc = 0; goto label_120d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120cdc: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x120ce0: 0x8e4200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
label_120ce4:
    // 0x120ce4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x120ce8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x120cec: 0x5440ffaa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 176)));
        ctx->pc = 0x120B98; return;
    }
label_120cf4:
    // 0x120cf4: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x120cf8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
        goto label_120d00;
    }
label_120d00:
    // 0x120d00: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x120d04: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
        goto label_120d0c;
    }
label_120d0c:
    // 0x120d0c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x120d10: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x120d14: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x120d18: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x120d1c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x120d20: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x120d24: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x120d28: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x120d2c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x120d30: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x120d34: 0xc7b900e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[25] = *(float*)&val; }
    // 0x120d38: 0xc7b800e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[24] = *(float*)&val; }
    // 0x120d3c: 0xc7b700d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[23] = *(float*)&val; }
    // 0x120d40: 0xc7b600d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[22] = *(float*)&val; }
    // 0x120d44: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x120d48: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x120d4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x120d54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x120d58; return;
}


// Function: EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5
// Address: 0x120d58 - 0x120e0c

void entry_120e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120e0c) {
        switch (ctx->pc) {
            case 0x120e28: ctx->pc = 0; goto label_120e28;
            case 0x120e40: ctx->pc = 0; goto label_120e40;
            case 0x120ea0: ctx->pc = 0; goto label_120ea0;
            case 0x120ec0: ctx->pc = 0; goto label_120ec0;
            case 0x120ef4: ctx->pc = 0; goto label_120ef4;
            case 0x120f04: ctx->pc = 0; goto label_120f04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120e0c: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x120e10: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x120e14: 0x1e10c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 30), 3));
    // 0x120e18: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x120e1c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x120e20: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x120e24: 0x46000d03
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[20] = ctx->f[1] / ctx->f[0];
label_120e28:
    // 0x120e28: 0x8e4200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
    // 0x120e2c: 0x18400049
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x120F54; return;
    }
    // 0x120e34: 0x4480c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 0);
    // 0x120e38: 0x8e4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 176)));
    // 0x120e3c: 0x0
    // NOP
label_120e40:
    // 0x120e40: 0x8e4300b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 184)));
    // 0x120e44: 0x2221018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x120e48: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x120e4c: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120e50: 0x46180832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120e54: 0x0
    // NOP
    // 0x120e58: 0x4503003a
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
        ctx->pc = 0x120F44; return;
    }
    // 0x120e60: 0x8ea30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x120e64: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x120e68: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x120e6c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120e70: 0x1480000b
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_120ea0;
    }
    // 0x120e78: 0x52800032
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
        ctx->pc = 0x120F44; return;
    }
    // 0x120e80: 0x8ea20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 20)));
    // 0x120e84: 0x8e830274
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 628)));
    // 0x120e88: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x120e8c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x120e90: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x120e94: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x120e98: 0x10000029
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x120F40; return;
    }
label_120ea0:
    // 0x120ea0: 0x56600007
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        goto label_120ec0;
    }
    // 0x120ea8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x120eac: 0xc6410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[1] = *(float*)&val; }
    // 0x120eb0: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x120eb4: 0x46010343
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[13] = ctx->f[0] / ctx->f[1];
    // 0x120eb8: 0x10000012
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_120f04;
    }
label_120ec0:
    // 0x120ec0: 0x1e28c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 30), 3));
    // 0x120ec4: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x120ec8: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x120ecc: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x120ed0: 0xc4620034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[2] = *(float*)&val; }
    // 0x120ed4: 0xc44d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    // 0x120ed8: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120edc: 0x460da002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[13]);
    // 0x120ee0: 0x46000b00
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x120ee4: 0x460c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x120ee8: 0x0
    // NOP
    // 0x120eec: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
        goto label_120ef4;
    }
label_120ef4:
    // 0x120ef4: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x120ef8: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x120efc: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x120f00: 0x46006b43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[0];
label_120f04:
    // 0x120f04: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x120f08: 0x46176b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[23]);
    // 0x120f0c: 0x8fa6000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x120f10: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x120f14: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x120f18: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x120f1c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x120f24);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_120f24
// Address: 0x120f24 - 0x120fb0

void entry_120f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120f24) {
        switch (ctx->pc) {
            case 0x120f40: ctx->pc = 0; goto label_120f40;
            case 0x120f44: ctx->pc = 0; goto label_120f44;
            case 0x120f54: ctx->pc = 0; goto label_120f54;
            case 0x120f60: ctx->pc = 0; goto label_120f60;
            case 0x120f6c: ctx->pc = 0; goto label_120f6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120f24: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x120f28: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x120f2c: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x120f30: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x120f34: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x120f38: 0x4600ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x120f3c: 0x4601b580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[1]);
label_120f40:
    // 0x120f40: 0x8e4200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
label_120f44:
    // 0x120f44: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x120f48: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x120f4c: 0x5440ffbc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 176)));
        ctx->pc = 0x120E40; return;
    }
label_120f54:
    // 0x120f54: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x120f58: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
        goto label_120f60;
    }
label_120f60:
    // 0x120f60: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x120f64: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
        goto label_120f6c;
    }
label_120f6c:
    // 0x120f6c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x120f70: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x120f74: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x120f78: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x120f7c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x120f80: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x120f84: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x120f88: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x120f8c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x120f90: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x120f94: 0xc7b800e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[24] = *(float*)&val; }
    // 0x120f98: 0xc7b700d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[23] = *(float*)&val; }
    // 0x120f9c: 0xc7b600d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[22] = *(float*)&val; }
    // 0x120fa0: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x120fa4: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x120fa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PacpNew__F4ACVK
// Address: 0x120fb0 - 0x120ffc

void entry_120ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x120ffc) {
        switch (ctx->pc) {
            case 0x12100c: ctx->pc = 0; goto label_12100c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x120ffc: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x121000: 0x246396b8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940344));
    // 0x121004: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121038; return;
    }
label_12100c:
    // 0x12100c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x121014);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_121014
// Address: 0x121014 - 0x12102c

void entry_121014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121014) {
        switch (ctx->pc) {
            case 0x121024: ctx->pc = 0; goto label_121024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121014: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x121018: 0x246396c8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940360));
    // 0x12101c: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121038; return;
    }
label_121024:
    // 0x121024: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12102c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12102c
// Address: 0x12102c - 0x121050

void entry_12102c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12102c) {
        switch (ctx->pc) {
            case 0x121038: ctx->pc = 0; goto label_121038;
            case 0x121040: ctx->pc = 0; goto label_121040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12102c: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x121030: 0x246396d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940376));
    // 0x121034: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_121038:
    // 0x121038: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 16));
        goto label_121040;
    }
label_121040:
    // 0x121040: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121044: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121048: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PacrNew__F4ACVK
// Address: 0x121050 - 0x12109c

void entry_12109c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12109c) {
        switch (ctx->pc) {
            case 0x1210ac: ctx->pc = 0; goto label_1210ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12109c: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x1210a0: 0x246396e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940392));
    // 0x1210a4: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1210D8; return;
    }
label_1210ac:
    // 0x1210ac: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1210b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1210b4
// Address: 0x1210b4 - 0x1210cc

void entry_1210b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1210b4) {
        switch (ctx->pc) {
            case 0x1210c4: ctx->pc = 0; goto label_1210c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1210b4: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x1210b8: 0x246396f8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940408));
    // 0x1210bc: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1210D8; return;
    }
label_1210c4:
    // 0x1210c4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1210cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 28));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1210cc
// Address: 0x1210cc - 0x1210f0

void entry_1210cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1210cc) {
        switch (ctx->pc) {
            case 0x1210d8: ctx->pc = 0; goto label_1210d8;
            case 0x1210e0: ctx->pc = 0; goto label_1210e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1210cc: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x1210d0: 0x24639708
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940424));
    // 0x1210d4: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_1210d8:
    // 0x1210d8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 16));
        goto label_1210e0;
    }
label_1210e0:
    // 0x1210e0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1210e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1210e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PacsNew__F4ACVK
// Address: 0x1210f0 - 0x121120

void entry_121120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121120) {
        switch (ctx->pc) {
            case 0x121130: ctx->pc = 0; goto label_121130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121120: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x121124: 0x24639718
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940440));
    // 0x121128: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121144; return;
    }
label_121130:
    // 0x121130: 0xc063570
    SET_GPR_U32(ctx, 31, 0x121138);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_121138
// Address: 0x121138 - 0x121160

void entry_121138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121138) {
        switch (ctx->pc) {
            case 0x121144: ctx->pc = 0; goto label_121144;
            case 0x12114c: ctx->pc = 0; goto label_12114c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121138: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x12113c: 0x24639728
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940456));
    // 0x121140: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_121144:
    // 0x121144: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 16));
        goto label_12114c;
    }
label_12114c:
    // 0x12114c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121150: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121154: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12115c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x121160; return;
}


// Function: PacgNew__F4ACGK
// Address: 0x121160 - 0x12119c

void entry_12119c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12119c: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x1211a0: 0x24639668
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940264));
    // 0x1211a4: 0x1000001a
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121210; return;
    }
    // 0x1211ac: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1211b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1211b4
// Address: 0x1211b4 - 0x1211cc

void entry_1211b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1211b4: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x1211b8: 0x24639678
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940280));
    // 0x1211bc: 0x10000014
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121210; return;
    }
    // 0x1211c4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1211cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1211cc
// Address: 0x1211cc - 0x1211e4

void entry_1211cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1211cc: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x1211d0: 0x24639698
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940312));
    // 0x1211d4: 0x1000000e
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121210; return;
    }
    // 0x1211dc: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1211e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1211e4
// Address: 0x1211e4 - 0x1211fc

void entry_1211e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1211e4: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x1211e8: 0x246396a8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940328));
    // 0x1211ec: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121210; return;
    }
    // 0x1211f4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1211fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1211fc
// Address: 0x1211fc - 0x121228

void entry_1211fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1211fc) {
        switch (ctx->pc) {
            case 0x12120c: ctx->pc = 0; goto label_12120c;
            case 0x121210: ctx->pc = 0; goto label_121210;
            case 0x121218: ctx->pc = 0; goto label_121218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1211fc: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x121200: 0x24639688
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940296));
    // 0x121204: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_121210;
    }
label_12120c:
    // 0x12120c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_121210:
    // 0x121210: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 16));
        goto label_121218;
    }
label_121218:
    // 0x121218: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12121c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121220: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PactNew__FP2SWP3ALOP5VTACT
// Address: 0x121228 - 0x12124c

void entry_12124c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12124c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x121250: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x121254: 0xae120000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 18));
    // 0x121258: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12125c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x121264);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_121264
// Address: 0x121264 - 0x121280

void entry_121264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121264: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x121268: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12126c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x121270: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121274: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121278: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PactNewClone__FP3ACTP2SWP3ALO
// Address: 0x121280 - 0x1212a8

void entry_1212a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1212a8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1212ac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1212b0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1212b4: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1212b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1212c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1212c0
// Address: 0x1212c0 - 0x1212d8

void entry_1212c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1212c0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1212c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1212c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1212cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1212d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneAct__FP3ACTT0
// Address: 0x1212d8 - 0x121310

void entry_121310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121310: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x121314: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x121318: 0xb202000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12131c: 0xb6020008
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x121320: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x121324: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x121328: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12132c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121330: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitAct__FP3ACTP3ALO
// Address: 0x121338 - 0x121358

void entry_12138c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12138c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x121390: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x121394: 0x8e3001ec
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 492)));
    // 0x121398: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x12139c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1213a4);
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 496)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1213a4
// Address: 0x1213a4 - 0x1213e8

void entry_1213a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1213a4: 0x1650001a
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 16)) {
        entry_121410(rdram, ctx, runtime); return;
    }
    // 0x1213ac: 0x8e2201ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 492)));
    // 0x1213b0: 0x14400017
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_121410(rdram, ctx, runtime); return;
    }
    // 0x1213b8: 0x10400015
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_121410(rdram, ctx, runtime); return;
    }
    // 0x1213c0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1213c4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1213c8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1213cc: 0x1040000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121404; return;
    }
    // 0x1213d4: 0x26250440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1088));
    // 0x1213d8: 0x26260150
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 336));
    // 0x1213dc: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1213e0: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x1213e8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1213e8
// Address: 0x1213e8 - 0x1213fc

void entry_1213e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1213e8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1213ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1213f0: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1213f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1213fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1213fc
// Address: 0x1213fc - 0x121410

void entry_1213fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1213fc) {
        switch (ctx->pc) {
            case 0x121404: ctx->pc = 0; goto label_121404;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1213fc: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_121410(rdram, ctx, runtime); return;
    }
label_121404:
    // 0x121404: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x121408: 0xc049d3e
    SET_GPR_U32(ctx, 31, 0x121410);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    SetAloVelocityVec__FP3ALOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_121410
// Address: 0x121410 - 0x121458

void entry_121410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121410: 0x5654001d
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x121488; return;
    }
    // 0x121418: 0x8e2201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 496)));
    // 0x12141c: 0x5440001a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x121488; return;
    }
    // 0x121424: 0x32620002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 2));
    // 0x121428: 0x50400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x121488; return;
    }
    // 0x121430: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x121434: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x121438: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x12143c: 0x1040000d
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 352));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121474; return;
    }
    // 0x121444: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x121448: 0x26250460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1120));
    // 0x12144c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x121450: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x121458);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_121458
// Address: 0x121458 - 0x12146c

void entry_121458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121458: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12145c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x121460: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x121464: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12146c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12146c
// Address: 0x12146c - 0x121484

void entry_12146c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12146c) {
        switch (ctx->pc) {
            case 0x121474: ctx->pc = 0; goto label_121474;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12146c: 0x10000006
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121488; return;
    }
label_121474:
    // 0x121474: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x121478: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12147c: 0xc049d64
    SET_GPR_U32(ctx, 31, 0x121484);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    SetAloAngularVelocityVec__FP3ALOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_121484
// Address: 0x121484 - 0x121494

void entry_121484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121484) {
        switch (ctx->pc) {
            case 0x121488: ctx->pc = 0; goto label_121488;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121484: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_121488:
    // 0x121488: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12148c: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x121494);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6944));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_121494
// Address: 0x121494 - 0x1214b8

void entry_121494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121494: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x121498: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12149c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1214a0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1214a4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1214a8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1214ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1214b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1214b8; return;
}


// Function: GetActPositionGoal__FP3ACTfP6VECTORT2
// Address: 0x1214b8 - 0x1214fc

void entry_1214fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1214fc) {
        switch (ctx->pc) {
            case 0x121500: ctx->pc = 0; goto label_121500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1214fc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_121500:
    // 0x121500: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActRotationGoal__FP3ACTfP7MATRIX3P6VECTOR
// Address: 0x121508 - 0x121558

void entry_121558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121558: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12155c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x121564: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x121568; return;
}


// Function: GetActTwistGoal__FP3ACTPfT1
// Address: 0x121568 - 0x121580

void entry_1216ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1216ac: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1216b0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1216b4: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1216b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1216c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1216c0
// Address: 0x1216c0 - 0x1216d4

void entry_1216c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1216c0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1216c4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1216c8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1216cc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1216d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1216d4
// Address: 0x1216d4 - 0x121718

void entry_1216d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1216d4) {
        switch (ctx->pc) {
            case 0x1216d8: ctx->pc = 0; goto label_1216d8;
            case 0x1216fc: ctx->pc = 0; goto label_1216fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1216d4: 0x8e4201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 496)));
label_1216d8:
    // 0x1216d8: 0x1622001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x121744; return;
    }
    // 0x1216e0: 0x56600006
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_1216fc;
    }
    // 0x1216e8: 0x82230011
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 17)));
    // 0x1216ec: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1216f0: 0x14620015
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x121748; return;
    }
    // 0x1216f8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1216fc:
    // 0x1216fc: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x121700: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x121704: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x121708: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x12170c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x121710: 0x40f809
    SET_GPR_U32(ctx, 31, 0x121718);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_121718
// Address: 0x121718 - 0x12172c

void entry_121718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121718: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12171c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x121720: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x121724: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12172c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12172c
// Address: 0x12172c - 0x121740

void entry_12172c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12172c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x121730: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x121734: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x121738: 0x40f809
    SET_GPR_U32(ctx, 31, 0x121740);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_121740
// Address: 0x121740 - 0x121760

void entry_121740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121740) {
        switch (ctx->pc) {
            case 0x121744: ctx->pc = 0; goto label_121744;
            case 0x121748: ctx->pc = 0; goto label_121748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121740: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_121744:
    // 0x121744: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_121748:
    // 0x121748: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12174c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x121750: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x121754: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12175c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x121760; return;
}


// Function: CalculateAloPositionSpring__FP3ALOfP6VECTORN22
// Address: 0x121760 - 0x1218c0

void entry_121948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121948: 0x92420010
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x12194c: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x121950: 0x21600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 24));
    // 0x121954: 0x22603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 2), 24));
    // 0x121958: 0x2c830009
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 9));
    // 0x12195c: 0x106000b1
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121C24; return;
    }
    // 0x121964: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x121968: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x12196c: 0x24429990
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941072));
    // 0x121970: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x121974: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x121978: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x121980: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121984: 0x7e220100
    WRITE128(ADD32(GPR_U32(ctx, 17), 256), GPR_VEC(ctx, 2));
    // 0x121988: 0x100000a5
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121C20; return;
    }
    // 0x121990: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x121994: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x121998: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12199c: 0xc0485d8
    SET_GPR_U32(ctx, 31, 0x1219a4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    CalculateAloPositionSpring__FP3ALOfP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1219a4
// Address: 0x1219a4 - 0x121a98

void entry_1219a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1219a4) {
        switch (ctx->pc) {
            case 0x121a74: ctx->pc = 0; goto label_121a74;
            case 0x121a80: ctx->pc = 0; goto label_121a80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1219a4: 0xda210170
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 368)));
    // 0x1219a8: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1219ac: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1219b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1219b4: 0x4be118e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1219b8: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1219bc: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1219c0: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1219c4: 0xda220100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x1219c8: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1219cc: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1219d0: 0xfba50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1219d4: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1219d8: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x1219dc: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1219e0: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1219e4: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1219e8: 0x4be508bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1219ec: 0x4be41888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1219f0: 0xfa220100
    WRITE128(ADD32(GPR_U32(ctx, 17), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1219f4: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x1219f8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1219fc: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x121a00: 0x4be51048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121a04: 0xfba50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x121a08: 0x10000086
    WRITE128(ADD32(GPR_U32(ctx, 17), 336), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121C24; return;
    }
    // 0x121a10: 0xda220100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x121a14: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x121a18: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121a1c: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x121a20: 0x4be208ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x121a24: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x121a28: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x121a2c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x121a30: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x121a34: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x121a38: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x121a3c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121a40: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x121a44: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x121a48: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x121a4c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x121a50: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x121a54: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121a58: 0x4483a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 3);
    // 0x121a5c: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121a60: 0x0
    // NOP
    // 0x121a64: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_121a74;
    }
    // 0x121a6c: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_121a80;
    }
label_121a74:
    // 0x121a74: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x121a78: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x121a7c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_121a80:
    // 0x121a80: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x121a84: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x121a88: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121a8c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x121a90: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x121a98);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_121a98
// Address: 0x121a98 - 0x121adc

void entry_121a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121a98: 0x8e22021c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 540)));
    // 0x121a9c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x121aa0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x121aa4: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x121aa8: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x121aac: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x121ab0: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x121ab4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x121ab8: 0xe7a10050
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x121abc: 0x8e22021c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 540)));
    // 0x121ac0: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x121ac4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x121ac8: 0xe7a10054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x121acc: 0x8e22021c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 540)));
    // 0x121ad0: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x121ad4: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x121adc);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_121adc
// Address: 0x121adc - 0x121c14

void entry_121adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121adc) {
        switch (ctx->pc) {
            case 0x121b10: ctx->pc = 0; goto label_121b10;
            case 0x121b28: ctx->pc = 0; goto label_121b28;
            case 0x121b5c: ctx->pc = 0; goto label_121b5c;
            case 0x121be8: ctx->pc = 0; goto label_121be8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121adc: 0x82430010
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x121ae0: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x121ae4: 0x14620010
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_121b28;
    }
    // 0x121aec: 0xc6400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[0] = *(float*)&val; }
    // 0x121af0: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121af4: 0x0
    // NOP
    // 0x121af8: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[21]);
        goto label_121b10;
    }
    // 0x121b00: 0x46160001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[22]);
    // 0x121b04: 0x4614a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x121b08: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x121b0c: 0x46000803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[0] = ctx->f[1] / ctx->f[0];
label_121b10:
    // 0x121b10: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121b14: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_121b28;
    }
    // 0x121b1c: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    // 0x121b20: 0x46141003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[0] = ctx->f[2] / ctx->f[20];
    // 0x121b24: 0xe7a00070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
label_121b28:
    // 0x121b28: 0x4602a836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[21], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121b2c: 0x0
    // NOP
    // 0x121b30: 0x4500000a
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_121b5c;
    }
    // 0x121b38: 0x24040009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 9));
    // 0x121b3c: 0x7e230100
    WRITE128(ADD32(GPR_U32(ctx, 17), 256), GPR_VEC(ctx, 3));
    // 0x121b40: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121b44: 0x7e220150
    WRITE128(ADD32(GPR_U32(ctx, 17), 336), GPR_VEC(ctx, 2));
    // 0x121b48: 0x82430010
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x121b4c: 0x10640035
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x121C24; return;
    }
    // 0x121b54: 0x10000033
    WRITE8(ADD32(GPR_U32(ctx, 18), 16), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121C24; return;
    }
label_121b5c:
    // 0x121b5c: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x121b60: 0xda210100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x121b64: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x121b68: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x121b6c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x121b70: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121b74: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x121b78: 0xfa210100
    WRITE128(ADD32(GPR_U32(ctx, 17), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121b7c: 0x8fa30070
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x121b80: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x121b84: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x121b88: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x121b8c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x121b90: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121b94: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x121b98: 0x10000022
    WRITE128(ADD32(GPR_U32(ctx, 17), 336), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121C24; return;
    }
    // 0x121ba0: 0xc64d0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[13] = *(float*)&val; }
    // 0x121ba4: 0x46166b01
    ctx->f[12] = FPU_SUB_S(ctx->f[13], ctx->f[22]);
    // 0x121ba8: 0x46146034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121bac: 0x0
    // NOP
    // 0x121bb0: 0x4500000d
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_121be8;
    }
    // 0x121bb8: 0x4614b000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[20]);
    // 0x121bbc: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121bc0: 0x460d0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x121bc4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x121bc8: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x121bcc: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121bd0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x121bd4: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121bd8: 0xfa220100
    WRITE128(ADD32(GPR_U32(ctx, 17), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x121bdc: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121be0: 0x10000010
    WRITE128(ADD32(GPR_U32(ctx, 17), 336), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121C24; return;
    }
label_121be8:
    // 0x121be8: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x121bec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x121bf0: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x121bf4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x121bf8: 0x26240100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 256));
    // 0x121bfc: 0x26250150
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 336));
    // 0x121c00: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x121c04: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x121c08: 0x27a90030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    // 0x121c0c: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x121c14);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_121c14
// Address: 0x121c14 - 0x121c48

void entry_121c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121c14) {
        switch (ctx->pc) {
            case 0x121c20: ctx->pc = 0; goto label_121c20;
            case 0x121c24: ctx->pc = 0; goto label_121c24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121c14: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x121c18: 0x7e220100
    WRITE128(ADD32(GPR_U32(ctx, 17), 256), GPR_VEC(ctx, 2));
    // 0x121c1c: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_121c20:
    // 0x121c20: 0x7e230150
    WRITE128(ADD32(GPR_U32(ctx, 17), 336), GPR_VEC(ctx, 3));
label_121c24:
    // 0x121c24: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x121c28: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x121c2c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x121c30: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x121c34: 0xc7b600d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[22] = *(float*)&val; }
    // 0x121c38: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x121c3c: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x121c40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateAloRotationSpring__FP3ALOfP7MATRIX3P6VECTORT3
// Address: 0x121c48 - 0x121c9c

void entry_121c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121c9c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x121ca0: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x121ca4: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x121cac);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_121cac
// Address: 0x121cac - 0x121de0

void entry_121cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121cac) {
        switch (ctx->pc) {
            case 0x121d04: ctx->pc = 0; goto label_121d04;
            case 0x121d98: ctx->pc = 0; goto label_121d98;
            case 0x121db8: ctx->pc = 0; goto label_121db8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121cac: 0xc7a30060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[3] = *(float*)&val; }
    // 0x121cb0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x121cb4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x121cb8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x121cbc: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121cc0: 0x0
    // NOP
    // 0x121cc4: 0x4500000f
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_121d04;
    }
    // 0x121ccc: 0x8e220214
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 532)));
    // 0x121cd0: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x121cd4: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x121cd8: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x121cdc: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x121ce0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x121ce4: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x121ce8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x121cec: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x121cf0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x121cf4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x121cf8: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x121cfc: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121d00: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_121d04:
    // 0x121d04: 0x8e220218
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    // 0x121d08: 0x5040002b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        goto label_121db8;
    }
    // 0x121d10: 0xda420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x121d14: 0xda210160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 352)));
    // 0x121d18: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x121d1c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x121d20: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x121d24: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x121d28: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x121d2c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x121d30: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x121d34: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121d38: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x121d3c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x121d40: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x121d44: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x121d48: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121d4c: 0x44832000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 3);
    // 0x121d50: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121d54: 0x0
    // NOP
    // 0x121d58: 0x45020017
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        goto label_121db8;
    }
    // 0x121d60: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x121d64: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x121d68: 0x46041083
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[4];
    // 0x121d6c: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x121d70: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x121d74: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x121d78: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x121d7c: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x121d80: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x121d84: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x121d88: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x121d8c: 0x0
    // NOP
    // 0x121d90: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[0]);
        goto label_121d98;
    }
label_121d98:
    // 0x121d98: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x121d9c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x121da0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121da4: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x121da8: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121dac: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x121db0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121db4: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_121db8:
    // 0x121db8: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x121dbc: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
    // 0x121dc0: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x121dc4: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x121dc8: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x121dcc: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x121dd0: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x121dd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x121ddc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x121de0; return;
}


// Function: ProjectActRotation__FP3ACT
// Address: 0x121de0 - 0x121e7c

void entry_121e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121e7c: 0x8e420224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x121e80: 0x1040000d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121EB8; return;
    }
    // 0x121e88: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x121e8c: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x121e90: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x121EB8; return;
    }
    // 0x121e98: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x121e9c: 0x27a50100
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 256));
    // 0x121ea0: 0x27a60104
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 260));
    // 0x121ea4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x121ea8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x121eb0);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_121eb0
// Address: 0x121eb0 - 0x121f4c

void entry_121eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x121eb0) {
        switch (ctx->pc) {
            case 0x121eb8: ctx->pc = 0; goto label_121eb8;
            case 0x121ebc: ctx->pc = 0; goto label_121ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x121eb0: 0x10000002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 19), 17)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_121ebc;
    }
label_121eb8:
    // 0x121eb8: 0x92620011
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 19), 17)));
label_121ebc:
    // 0x121ebc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x121ec0: 0x21600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 24));
    // 0x121ec4: 0x22603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 2), 24));
    // 0x121ec8: 0x2c830009
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 9));
    // 0x121ecc: 0x1060015f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x121ed4: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x121ed8: 0x244299c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941120));
    // 0x121edc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x121ee0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x121ee4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x121eec: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x121ef0: 0x7e4200d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), GPR_VEC(ctx, 2));
    // 0x121ef4: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x121ef8: 0x7e4300e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 3));
    // 0x121efc: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x121f00: 0x7e4200f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 2));
    // 0x121f04: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x121f08: 0x12e00150
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x121f10: 0xc7a00100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[0] = *(float*)&val; }
    // 0x121f14: 0x8e420224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x121f18: 0xe4400090
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 144), *(uint32_t*)&val); }
    // 0x121f1c: 0x8e430224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x121f20: 0xc7a00104
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 260)); ctx->f[0] = *(float*)&val; }
    // 0x121f24: 0x10000149
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 148), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x121f2c: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x121f30: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x121f34: 0x7fa20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 2));
    // 0x121f38: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x121f3c: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x121f40: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x121f44: 0xc048712
    SET_GPR_U32(ctx, 31, 0x121f4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CalculateAloRotationSpring__FP3ALOfP7MATRIX3P6VECTORT3(rdram, ctx, runtime); return;
}


// Function: entry_121f4c
// Address: 0x121f4c - 0x121fa0

void entry_121f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121f4c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x121f50: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x121f54: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x121f58: 0xda410180
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 384)));
    // 0x121f5c: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x121f60: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x121f64: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x121f68: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x121f6c: 0x7ba20110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x121f70: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x121f74: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x121f78: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x121f7c: 0xdba40110
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x121f80: 0xda410160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x121f84: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x121f88: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x121f8c: 0x4be409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x121f90: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121f94: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x121f98: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x121fa0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_121fa0
// Address: 0x121fa0 - 0x122014

void entry_121fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x121fa0: 0xda4600d0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x121fa4: 0x264200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 208));
    // 0x121fa8: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x121fac: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x121fb0: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x121fb4: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x121fb8: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x121fbc: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x121fc0: 0x4bc6218a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121fc4: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x121fc8: 0xfba600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x121fcc: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x121fd0: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x121fd4: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x121fd8: 0x4bc1204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121fdc: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121fe0: 0xfba100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x121fe4: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x121fe8: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x121fec: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x121ff0: 0x4bc220ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x121ff4: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x121ff8: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x121ffc: 0xfa4600d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x122000: 0x7ba200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x122004: 0x7e4200e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 2));
    // 0x122008: 0x7ba300c0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x12200c: 0xc062428
    SET_GPR_U32(ctx, 31, 0x122014);
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 3));
    NormalizeRotateMatrix3__FP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_122014
// Address: 0x122014 - 0x122054

void entry_122014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122014: 0xdba30110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x122018: 0xda410160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x12201c: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x122020: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122024: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x122028: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12202c: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x122030: 0x12e00106
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x122038: 0x8e450224
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x12203c: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x122040: 0xc7ad0100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[13] = *(float*)&val; }
    // 0x122044: 0xc4ac0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 144)); ctx->f[12] = *(float*)&val; }
    // 0x122048: 0x8e440220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 544)));
    // 0x12204c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x122054);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 148));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_122054
// Address: 0x122054 - 0x12207c

void entry_122054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122054: 0x8e420224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x122058: 0x100000fc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 144), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x122060: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x122064: 0x264400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 208));
    // 0x122068: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12206c: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x122070: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x122074: 0xc062454
    SET_GPR_U32(ctx, 31, 0x12207c);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_12207c
// Address: 0x12207c - 0x122090

void entry_12207c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12207c: 0x27b00070
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 112));
    // 0x122080: 0x27a50108
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 264));
    // 0x122084: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x122088: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x122090);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_122090
// Address: 0x122090 - 0x1220a4

void entry_122090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122090: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x122094: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x122098: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12209c: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1220a4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1220a4
// Address: 0x1220a4 - 0x1220e8

void entry_1220a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1220a4: 0x8e420220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 544)));
    // 0x1220a8: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1220ac: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1220b0: 0x27a5010c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 268));
    // 0x1220b4: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1220b8: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1220bc: 0xc7ad0108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[13] = *(float*)&val; }
    // 0x1220c0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1220c4: 0xe7a10090
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x1220c8: 0x8e420220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 544)));
    // 0x1220cc: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1220d0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1220d4: 0xe7a10094
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 148), *(uint32_t*)&val); }
    // 0x1220d8: 0x8e420220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 544)));
    // 0x1220dc: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1220e0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1220e8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 152), *(uint32_t*)&val); }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1220e8
// Address: 0x1220e8 - 0x122188

void entry_1220e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1220e8) {
        switch (ctx->pc) {
            case 0x122124: ctx->pc = 0; goto label_122124;
            case 0x122140: ctx->pc = 0; goto label_122140;
            case 0x122144: ctx->pc = 0; goto label_122144;
            case 0x122180: ctx->pc = 0; goto label_122180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1220e8: 0x82630011
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 19), 17)));
    // 0x1220ec: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1220f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1220f4: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1220f8: 0x14620011
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_122140;
    }
    // 0x122100: 0xc6610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 24)); ctx->f[1] = *(float*)&val; }
    // 0x122104: 0x4601b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x122108: 0x0
    // NOP
    // 0x12210c: 0x45000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_122124;
    }
    // 0x122114: 0x46160841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[22]);
    // 0x122118: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x12211c: 0x46150840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[21]);
    // 0x122120: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
label_122124:
    // 0x122124: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x122128: 0x0
    // NOP
    // 0x12212c: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[0] = *(float*)&val; }
        goto label_122144;
    }
    // 0x122134: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x122138: 0x46156003
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[0] = ctx->f[12] / ctx->f[21];
    // 0x12213c: 0xe7a0010c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 268), *(uint32_t*)&val); }
label_122140:
    // 0x122140: 0xc7a00108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[0] = *(float*)&val; }
label_122144:
    // 0x122144: 0x460c0036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x122148: 0x0
    // NOP
    // 0x12214c: 0x4500000c
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_122180;
    }
    // 0x122154: 0x7e4200d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), GPR_VEC(ctx, 2));
    // 0x122158: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12215c: 0x7e4300e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 3));
    // 0x122160: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122164: 0x7e4200f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 2));
    // 0x122168: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12216c: 0x7e430160
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), GPR_VEC(ctx, 3));
    // 0x122170: 0x82620011
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 19), 17)));
    // 0x122174: 0x38420009
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 9));
    // 0x122178: 0x10000027
    SET_GPR_U32(ctx, 22, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x122218; return;
    }
label_122180:
    // 0x122180: 0xc062214
    SET_GPR_U32(ctx, 31, 0x122188);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_122188
// Address: 0x122188 - 0x1221f8

void entry_122188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122188: 0xda4600d0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x12218c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x122190: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x122194: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x122198: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12219c: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1221a0: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1221a4: 0x4bc6218a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1221a8: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1221ac: 0xfba600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1221b0: 0xda810010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x1221b4: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1221b8: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1221bc: 0x4bc1204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1221c0: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1221c4: 0xfba100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1221c8: 0xda820020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x1221cc: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1221d0: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1221d4: 0x4bc220ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1221d8: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1221dc: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1221e0: 0xfa4600d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1221e4: 0x7ba200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1221e8: 0x7e4200e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 2));
    // 0x1221ec: 0x7ba300c0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1221f0: 0xc062428
    SET_GPR_U32(ctx, 31, 0x1221f8);
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 3));
    NormalizeRotateMatrix3__FP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1221f8
// Address: 0x1221f8 - 0x122238

void entry_1221f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1221f8) {
        switch (ctx->pc) {
            case 0x122218: ctx->pc = 0; goto label_122218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1221f8: 0x8fa4010c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 268)));
    // 0x1221fc: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x122200: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x122204: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x122208: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x12220c: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122210: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122214: 0xfa410160
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), _mm_castps_si128(ctx->vu0_vf[1]));
label_122218:
    // 0x122218: 0x12e00010
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12225C; return;
    }
    // 0x122220: 0x8e450224
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x122224: 0xc7ad0100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[13] = *(float*)&val; }
    // 0x122228: 0xc4ac0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 144)); ctx->f[12] = *(float*)&val; }
    // 0x12222c: 0x8e440220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 544)));
    // 0x122230: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x122238);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 148));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_122238
// Address: 0x122238 - 0x122338

void entry_122238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122238) {
        switch (ctx->pc) {
            case 0x12225c: ctx->pc = 0; goto label_12225c;
            case 0x1222e0: ctx->pc = 0; goto label_1222e0;
            case 0x12230c: ctx->pc = 0; goto label_12230c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122238: 0x8e420224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x12223c: 0xe4400090
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 144), *(uint32_t*)&val); }
    // 0x122240: 0x8e430224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x122244: 0xc7a10100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[1] = *(float*)&val; }
    // 0x122248: 0xc4600090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 144)); ctx->f[0] = *(float*)&val; }
    // 0x12224c: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x122250: 0x0
    // NOP
    // 0x122254: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_12225c;
    }
label_12225c:
    // 0x12225c: 0x12c0007b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x122264: 0x10000079
    WRITE8(ADD32(GPR_U32(ctx, 19), 17), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x12226c: 0xc6600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 24)); ctx->f[0] = *(float*)&val; }
    // 0x122270: 0x46160501
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[22]);
    // 0x122274: 0x4615a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x122278: 0x0
    // NOP
    // 0x12227c: 0x45000051
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1223C4; return;
    }
    // 0x122284: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x122288: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12228c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x122290: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x122294: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x122298: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x12229c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1222a0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1222a4: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1222e0;
    }
    // 0x1222ac: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1222b0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1222b4: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1222b8: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1222bc: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1222e0;
    }
    // 0x1222c4: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1222c8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1222cc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1222d0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1222d4: 0x0
    // NOP
    // 0x1222d8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1222e0;
    }
label_1222e0:
    // 0x1222e0: 0x1060000a
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_12230c;
    }
    // 0x1222e8: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1222ec: 0x24848d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937904));
    // 0x1222f0: 0x7e4300d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), GPR_VEC(ctx, 3));
    // 0x1222f4: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1222f8: 0x7e4200e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 2));
    // 0x1222fc: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122300: 0x7e4300f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 3));
    // 0x122304: 0x10000027
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1223A4; return;
    }
label_12230c:
    // 0x12230c: 0x4615b000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[21]);
    // 0x122310: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x122314: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x122318: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x12231c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x122320: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x122324: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x122328: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12232c: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x122330: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x122338);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_122338
// Address: 0x122338 - 0x1223f8

void entry_122338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122338) {
        switch (ctx->pc) {
            case 0x1223a4: ctx->pc = 0; goto label_1223a4;
            case 0x1223c4: ctx->pc = 0; goto label_1223c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122338: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12233c: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x122340: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x122344: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122348: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12234c: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x122350: 0x4bc510bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x122354: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122358: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12235c: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x122360: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x122364: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122368: 0x4bc621bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x12236c: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x122370: 0x4bc6090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122374: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122378: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12237c: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122380: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122384: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122388: 0xfba400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12238c: 0xfa4500d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122390: 0x7ba20090
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x122394: 0x7e4200e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 2));
    // 0x122398: 0x7ba300a0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12239c: 0x7e4300f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 3));
    // 0x1223a0: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1223a4:
    // 0x1223a4: 0x12e00029
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x1223ac: 0x8e420224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x1223b0: 0xc7a00100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[0] = *(float*)&val; }
    // 0x1223b4: 0xe4400090
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 144), *(uint32_t*)&val); }
    // 0x1223b8: 0x8e430224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x1223bc: 0x10000023
    WRITE32(ADD32(GPR_U32(ctx, 3), 148), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
label_1223c4:
    // 0x1223c4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1223c8: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1223cc: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1223d0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1223d4: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1223d8: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1223dc: 0x264400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 208));
    // 0x1223e0: 0x26450160
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 352));
    // 0x1223e4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1223e8: 0x27a80040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1223ec: 0x27a90070
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1223f0: 0xc04c1d2
    SET_GPR_U32(ctx, 31, 0x1223f8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierMat__FfffP7MATRIX3P6VECTORT3T4T3T4T4(rdram, ctx, runtime); return;
}


// Function: entry_1223f8
// Address: 0x1223f8 - 0x12244c

void entry_1223f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1223f8: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1223fc: 0x7e4200d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), GPR_VEC(ctx, 2));
    // 0x122400: 0x7ba30050
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x122404: 0x7e4300e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 3));
    // 0x122408: 0x7ba20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12240c: 0x7e4200f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 2));
    // 0x122410: 0x7ba30070
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x122414: 0x12e0000d
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        entry_12244c(rdram, ctx, runtime); return;
    }
    // 0x12241c: 0x8e440224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x122420: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x122424: 0xc7b10100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[17] = *(float*)&val; }
    // 0x122428: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x12242c: 0xc48f0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 144)); ctx->f[15] = *(float*)&val; }
    // 0x122430: 0x24850094
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 148));
    // 0x122434: 0xc4900094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 148)); ctx->f[16] = *(float*)&val; }
    // 0x122438: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x12243c: 0xc7b20104
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 260)); ctx->f[18] = *(float*)&val; }
    // 0x122440: 0x24840090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 144));
    // 0x122444: 0xc04c0fc
    SET_GPR_U32(ctx, 31, 0x12244c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierFloat__FfffffffPfN27(rdram, ctx, runtime); return;
}


// Function: entry_12244c
// Address: 0x12244c - 0x122488

void entry_12244c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12244c: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x122450: 0x7bb70190
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x122454: 0x7bb60180
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x122458: 0x7bb50170
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x12245c: 0x7bb40160
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x122460: 0x7bb30150
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x122464: 0x7bb20140
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x122468: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x12246c: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x122470: 0xc7b601c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 448)); ctx->f[22] = *(float*)&val; }
    // 0x122474: 0xc7b501b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 440)); ctx->f[21] = *(float*)&val; }
    // 0x122478: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x12247c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 464));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x122484: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x122488; return;
}


// Function: ProjectActPose__FP3ACTi
// Address: 0x122488 - 0x1224ac

void entry_1224ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1224ac) {
        switch (ctx->pc) {
            case 0x1224cc: ctx->pc = 0; goto label_1224cc;
            case 0x1224e4: ctx->pc = 0; goto label_1224e4;
            case 0x122510: ctx->pc = 0; goto label_122510;
            case 0x122518: ctx->pc = 0; goto label_122518;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1224ac: 0x82230013
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 19)));
    // 0x1224b0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1224b4: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1224cc;
    }
    // 0x1224bc: 0x10620009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1224e4;
    }
    // 0x1224c4: 0x1000001f
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x122544; return;
    }
label_1224cc:
    // 0x1224cc: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1224d0: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1224d4: 0x8c440270
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 624)));
    // 0x1224d8: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1224dc: 0x10000017
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12253C; return;
    }
label_1224e4:
    // 0x1224e4: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1224e8: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1224ec: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1224f0: 0x8c830270
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 624)));
    // 0x1224f4: 0x8c850294
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 660)));
    // 0x1224f8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1224fc: 0x10a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_122510;
    }
    // 0x122504: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x122508: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[14] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_122518;
    }
label_122510:
    // 0x122510: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x122514: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
label_122518:
    // 0x122518: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x12251c: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x122520: 0x24840e60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 3680));
    // 0x122524: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x12252c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_12252c
// Address: 0x12252c - 0x122550

void entry_12252c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12252c) {
        switch (ctx->pc) {
            case 0x12253c: ctx->pc = 0; goto label_12253c;
            case 0x122544: ctx->pc = 0; goto label_122544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12252c: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x122530: 0x8c620270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 624)));
    // 0x122534: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x122538: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
label_12253c:
    // 0x12253c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122540: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_122544:
    // 0x122544: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122548: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PredictAloPosition__FP3ALOfP6VECTORT2
// Address: 0x122550 - 0x12259c

void entry_12259c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12259c) {
        switch (ctx->pc) {
            case 0x1225a4: ctx->pc = 0; goto label_1225a4;
            case 0x1225c4: ctx->pc = 0; goto label_1225c4;
            case 0x1225c8: ctx->pc = 0; goto label_1225c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12259c: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1225c8;
    }
label_1225a4:
    // 0x1225a4: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x1225a8: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1225ac: 0xf8c20000
    WRITE128(ADD32(GPR_U32(ctx, 6), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1225b0: 0x4be110d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1225b4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1225b8: 0xd8610100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 256)));
    // 0x1225bc: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1225c0: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1225c4:
    // 0x1225c4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1225c8:
    // 0x1225c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PredictAloRotation__FP3ALOfP7MATRIX3P6VECTOR
// Address: 0x1225d0 - 0x122634

void entry_122634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122634) {
        switch (ctx->pc) {
            case 0x12263c: ctx->pc = 0; goto label_12263c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122634: 0x10000024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1226C8; return;
    }
label_12263c:
    // 0x12263c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x122640: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x122644: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x122648: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x12264c: 0x4be110d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x122650: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x122654: 0xf8c20000
    WRITE128(ADD32(GPR_U32(ctx, 6), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x122658: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x122660);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_122660
// Address: 0x122660 - 0x1226d8

void entry_122660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122660) {
        switch (ctx->pc) {
            case 0x1226c4: ctx->pc = 0; goto label_1226c4;
            case 0x1226c8: ctx->pc = 0; goto label_1226c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122660: 0xda0500d0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x122664: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x122668: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12266c: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122670: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x122674: 0x4bc511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x122678: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x12267c: 0x4bc5214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122680: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122684: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122688: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x12268c: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x122690: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x122694: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122698: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12269c: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1226a0: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1226a4: 0x4bc111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1226a8: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1226ac: 0x4bc1208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1226b0: 0xfa250000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1226b4: 0xfa220020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1226b8: 0xfa230010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1226bc: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1226c0: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
label_1226c4:
    // 0x1226c4: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_1226c8:
    // 0x1226c8: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1226cc: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1226d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdaptAct__FP3ACT
// Address: 0x1226d8 - 0x122708

void entry_122724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122724) {
        switch (ctx->pc) {
            case 0x12276c: ctx->pc = 0; goto label_12276c;
            case 0x122770: ctx->pc = 0; goto label_122770;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122724: 0x7a220190
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 400)));
    // 0x122728: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
    // 0x12272c: 0x7a2301a0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 416)));
    // 0x122730: 0x7e030040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 3));
    // 0x122734: 0x7a2201b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 432)));
    // 0x122738: 0x7e020050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), GPR_VEC(ctx, 2));
    // 0x12273c: 0x7a2301c0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 448)));
    // 0x122740: 0x7e030060
    WRITE128(ADD32(GPR_U32(ctx, 16), 96), GPR_VEC(ctx, 3));
    // 0x122744: 0x8e230224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 548)));
    // 0x122748: 0x10600008
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_12276c;
    }
    // 0x122750: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x122754: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x122758: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_122770;
    }
    // 0x122760: 0xc460008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 140)); ctx->f[0] = *(float*)&val; }
    // 0x122764: 0xe6000080
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 128), *(uint32_t*)&val); }
    // 0x122768: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
label_12276c:
    // 0x12276c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_122770:
    // 0x122770: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x122774: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x122778: 0x7e020090
    WRITE128(ADD32(GPR_U32(ctx, 16), 144), GPR_VEC(ctx, 2));
    // 0x12277c: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x122780: 0x7e0300a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), GPR_VEC(ctx, 3));
    // 0x122784: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x122788: 0x7e0200b0
    WRITE128(ADD32(GPR_U32(ctx, 16), 176), GPR_VEC(ctx, 2));
    // 0x12278c: 0x8e23026c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 620)));
    // 0x122790: 0xae0300c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 192), GPR_U32(ctx, 3));
    // 0x122794: 0x8e220274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 628)));
    // 0x122798: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12279c: 0xae0200c4
    WRITE32(ADD32(GPR_U32(ctx, 16), 196), GPR_U32(ctx, 2));
    // 0x1227a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1227a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1227ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1227b0; return;
}


// Function: GetActvalPositionGoal__FP6ACTVALfP6VECTORT2
// Address: 0x1227b0 - 0x1227e4

void entry_1227e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1227e4) {
        switch (ctx->pc) {
            case 0x1227e8: ctx->pc = 0; goto label_1227e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1227e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1227e8:
    // 0x1227e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActvalRotationGoal__FP6ACTVALfP7MATRIX3P6VECTOR
// Address: 0x1227f0 - 0x122834

void entry_122834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122834: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122838: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActvalTwistGoal__FP6ACTVALPfT1
// Address: 0x122840 - 0x122858

void entry_1228ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1228ac) {
        switch (ctx->pc) {
            case 0x122900: ctx->pc = 0; goto label_122900;
            case 0x122904: ctx->pc = 0; goto label_122904;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1228ac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1228b0: 0x260301a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 416));
    // 0x1228b4: 0x24458d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1228b8: 0x26040190
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 400));
    // 0x1228bc: 0x2602026c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 620));
    // 0x1228c0: 0xae24001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 4));
    // 0x1228c4: 0xae230024
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 3));
    // 0x1228c8: 0xae220038
    WRITE32(ADD32(GPR_U32(ctx, 17), 56), GPR_U32(ctx, 2));
    // 0x1228cc: 0xae250020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 5));
    // 0x1228d0: 0xae250028
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 5));
    // 0x1228d4: 0x8e020274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 628)));
    // 0x1228d8: 0xae22003c
    WRITE32(ADD32(GPR_U32(ctx, 17), 60), GPR_U32(ctx, 2));
    // 0x1228dc: 0x8e030224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x1228e0: 0x10600008
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_122904;
    }
    // 0x1228e8: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x1228ec: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1228f0: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 140));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_122900;
    }
    // 0x1228f8: 0xae250030
    WRITE32(ADD32(GPR_U32(ctx, 17), 48), GPR_U32(ctx, 5));
    // 0x1228fc: 0xae22002c
    WRITE32(ADD32(GPR_U32(ctx, 17), 44), GPR_U32(ctx, 2));
label_122900:
    // 0x122900: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_122904:
    // 0x122904: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122908: 0x244283d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935504));
    // 0x12290c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122910: 0xae220034
    WRITE32(ADD32(GPR_U32(ctx, 17), 52), GPR_U32(ctx, 2));
    // 0x122914: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122918: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActrefPositionGoal__FP6ACTREFfP6VECTORT2
// Address: 0x122920 - 0x12295c

void entry_12295c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12295c) {
        switch (ctx->pc) {
            case 0x122960: ctx->pc = 0; goto label_122960;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12295c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_122960:
    // 0x122960: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActrefRotationGoal__FP6ACTREFfP7MATRIX3P6VECTOR
// Address: 0x122968 - 0x1229b4

void entry_1229b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1229b4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1229b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActrefTwistGoal__FP6ACTREFPfT1
// Address: 0x1229c0 - 0x1229e0

void entry_122a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122a2c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x122a30: 0x26050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 64));
    // 0x122a34: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x122a38: 0x26060090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 144));
    // 0x122a3c: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x122a40: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122a44: 0x7e020040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 2));
    // 0x122a48: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x122a4c: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x122a50: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x122a54: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
    // 0x122a58: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x122a5c: 0x7e030090
    WRITE128(ADD32(GPR_U32(ctx, 16), 144), GPR_VEC(ctx, 3));
    // 0x122a60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122a64: 0x78820010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x122a68: 0x7cc20010
    WRITE128(ADD32(GPR_U32(ctx, 6), 16), GPR_VEC(ctx, 2));
    // 0x122a6c: 0x78830020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x122a70: 0x7cc30020
    WRITE128(ADD32(GPR_U32(ctx, 6), 32), GPR_VEC(ctx, 3));
    // 0x122a74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x122a7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x122a80; return;
}


// Function: GetActadjPositionGoal__FP6ACTADJfP6VECTORT2
// Address: 0x122a80 - 0x122adc

void entry_122adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122adc) {
        switch (ctx->pc) {
            case 0x122ae4: ctx->pc = 0; goto label_122ae4;
            case 0x122ae8: ctx->pc = 0; goto label_122ae8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122adc: 0x10000006
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x122AF8; return;
    }
label_122ae4:
    // 0x122ae4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_122ae8:
    // 0x122ae8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x122aec: 0xc04852e
    SET_GPR_U32(ctx, 31, 0x122af4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetActPositionGoal__FP3ACTfP6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_122af4
// Address: 0x122af4 - 0x122b30

void entry_122af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122af4) {
        switch (ctx->pc) {
            case 0x122af8: ctx->pc = 0; goto label_122af8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122af4: 0xda220020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
label_122af8:
    // 0x122af8: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x122afc: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x122b00: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x122b04: 0xfa010000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x122b08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122b0c: 0xda220030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x122b10: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x122b14: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x122b18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122b1c: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x122b20: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122b24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x122b2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x122b30; return;
}


// Function: GetActadjRotationGoal__FP6ACTADJfP7MATRIX3P6VECTOR
// Address: 0x122b30 - 0x122b8c

void entry_122b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122b8c) {
        switch (ctx->pc) {
            case 0x122b94: ctx->pc = 0; goto label_122b94;
            case 0x122b98: ctx->pc = 0; goto label_122b98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122b8c: 0x10000006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 64));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x122BA8; return;
    }
label_122b94:
    // 0x122b94: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_122b98:
    // 0x122b98: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x122b9c: 0xc048542
    SET_GPR_U32(ctx, 31, 0x122ba4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetActRotationGoal__FP3ACTfP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_122ba4
// Address: 0x122ba4 - 0x122c48

void entry_122ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122ba4) {
        switch (ctx->pc) {
            case 0x122ba8: ctx->pc = 0; goto label_122ba8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122ba4: 0x26220040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 64));
label_122ba8:
    // 0x122ba8: 0xda250040
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x122bac: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x122bb0: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x122bb4: 0xda070000
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x122bb8: 0xda080010
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x122bbc: 0x4bc729bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x122bc0: 0x4bc710bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x122bc4: 0x4bc709ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122bc8: 0xda030020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x122bcc: 0x4bc829bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x122bd0: 0x4bc810bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x122bd4: 0x4bc80a0a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122bd8: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x122bdc: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x122be0: 0x4bc3094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122be4: 0xfa070000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x122be8: 0xfa050020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122bec: 0xfa080010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x122bf0: 0xfba70000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x122bf4: 0xfba80010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x122bf8: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122bfc: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x122c00: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x122c04: 0xda430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x122c08: 0xda240040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x122c0c: 0xd8460020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x122c10: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x122c14: 0xda220070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 112)));
    // 0x122c18: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x122c1c: 0x4bc308bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x122c20: 0x4bc330ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122c24: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x122c28: 0xfba70030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x122c2c: 0xfa430000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122c30: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x122c34: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x122c38: 0xfba80040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x122c3c: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122c40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActadjTwistGoal__FP6ACTADJPfT1
// Address: 0x122c48 - 0x122c94

void entry_122c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122c94) {
        switch (ctx->pc) {
            case 0x122c9c: ctx->pc = 0; goto label_122c9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122c94: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x122CA8; return;
    }
label_122c9c:
    // 0x122c9c: 0xc04855a
    SET_GPR_U32(ctx, 31, 0x122ca4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    GetActTwistGoal__FP3ACTPfT1(rdram, ctx, runtime); return;
}


// Function: entry_122ca4
// Address: 0x122ca4 - 0x122cb0

void entry_122ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122ca4) {
        switch (ctx->pc) {
            case 0x122ca8: ctx->pc = 0; goto label_122ca8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122ca4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_122ca8:
    // 0x122ca8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActadjScale__FP6ACTADJP7MATRIX3
// Address: 0x122cb0 - 0x122d04

void entry_122d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122d04) {
        switch (ctx->pc) {
            case 0x122d0c: ctx->pc = 0; goto label_122d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122d04: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 144));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x122D18; return;
    }
label_122d0c:
    // 0x122d0c: 0xc048560
    SET_GPR_U32(ctx, 31, 0x122d14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetActScale__FP3ACTP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_122d14
// Address: 0x122d14 - 0x122d90

void entry_122d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122d14) {
        switch (ctx->pc) {
            case 0x122d18: ctx->pc = 0; goto label_122d18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122d14: 0x26020090
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 144));
label_122d18:
    // 0x122d18: 0xda010090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x122d1c: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x122d20: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x122d24: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122d28: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122d2c: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x122d30: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x122d34: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122d38: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122d3c: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x122d40: 0x4bc510bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x122d44: 0x4bc5214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122d48: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x122d4c: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x122d50: 0x4bc6204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122d54: 0xfa230000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122d58: 0xfa210020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x122d5c: 0xfa250010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122d60: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x122d64: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x122d68: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x122d6c: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122d70: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x122d74: 0xfba50070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122d78: 0xfba50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122d7c: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x122d80: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x122d84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x122d8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x122d90; return;
}


// Function: GGetActadjPoseGoal__FP6ACTADJi
// Address: 0x122d90 - 0x122da0

void entry_122db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122db4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x122db8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x122dbc: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x122dc0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x122dc4: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x122dc8: 0xe6010020
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    // 0x122dcc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122dd0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122dd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x122ddc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x122de0; return;
}


// Function: GetActbankRotationGoal__FP7ACTBANKfP7MATRIX3P6VECTOR
// Address: 0x122de0 - 0x122ea8

void entry_122ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122ea8) {
        switch (ctx->pc) {
            case 0x122ee8: ctx->pc = 0; goto label_122ee8;
            case 0x122eec: ctx->pc = 0; goto label_122eec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122ea8: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x122eac: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x122eb0: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122eb4: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x122eb8: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122ebc: 0x8e310020
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x122ec0: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x122ec4: 0x48b11000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 17));
    // 0x122ec8: 0x4be1212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x122ecc: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x122ed0: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x122ed4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x122ed8: 0x4be0209c
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x122edc: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x122ee0: 0x4be510c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x122ee4: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
label_122ee8:
    // 0x122ee8: 0x26040150
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 336));
label_122eec:
    // 0x122eec: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x122ef0: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x122ef8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_122ef8
// Address: 0x122ef8 - 0x122f28

void entry_122ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122ef8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x122efc: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x122f00: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x122f04: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x122f08: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x122f0c: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x122f10: 0x7e630000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 3));
    // 0x122f14: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x122f18: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x122f1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x122f24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x122f28; return;
}


// Function: RetractActseg__FP6ACTSEGi
// Address: 0x122f28 - 0x122f54

void entry_122f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x122f54) {
        switch (ctx->pc) {
            case 0x122f60: ctx->pc = 0; goto label_122f60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x122f54: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x122f58: 0x50510001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 0));
        goto label_122f60;
    }
label_122f60:
    // 0x122f60: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x122f64: 0xc0484d6
    SET_GPR_U32(ctx, 31, 0x122f6c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RetractAct__FP3ACTi(rdram, ctx, runtime); return;
}


// Function: entry_122f6c
// Address: 0x122f6c - 0x122f88

void entry_122f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122f6c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x122f70: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122f74: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122f78: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x122f7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x122f84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x122f88; return;
}


// Function: CloneActseg__FP6ACTSEGT0
// Address: 0x122f88 - 0x122fb8

void entry_122fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x122fb8: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x122fbc: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x122fc0: 0xb2020027
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x122fc4: 0xb6020020
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x122fc8: 0xae11001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 17));
    // 0x122fcc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x122fd0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x122fd4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x122fd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActsegPositionGoal__FP6ACTSEGfP6VECTORT2
// Address: 0x122fe0 - 0x123068

void entry_123068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123068) {
        switch (ctx->pc) {
            case 0x123070: ctx->pc = 0; goto label_123070;
            case 0x123078: ctx->pc = 0; goto label_123078;
            case 0x1230c0: ctx->pc = 0; goto label_1230c0;
            case 0x1230c4: ctx->pc = 0; goto label_1230c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123068: 0x10000003
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_123078;
    }
label_123070:
    // 0x123070: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x123074: 0x82230010
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 16)));
label_123078:
    // 0x123078: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x12307c: 0x54620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        goto label_1230c4;
    }
    // 0x123084: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x123088: 0xc6200018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[0] = *(float*)&val; }
    // 0x12308c: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x123090: 0xc6030010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[3] = *(float*)&val; }
    // 0x123094: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x123098: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x12309c: 0x460300c1
    ctx->f[3] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1230a0: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1230a4: 0x0
    // NOP
    // 0x1230a8: 0x45000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1230c0;
    }
    // 0x1230b0: 0xc6000018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1230b4: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1230b8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1230bc: 0xe7a10000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
label_1230c0:
    // 0x1230c0: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1230c4:
    // 0x1230c4: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1230c8: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1230cc: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1230d0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1230d4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1230d8: 0xc60d0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[13] = *(float*)&val; }
    // 0x1230dc: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1230e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1230e8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1230e8
// Address: 0x1230e8 - 0x123100

void entry_1230e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1230e8) {
        switch (ctx->pc) {
            case 0x1230f0: ctx->pc = 0; goto label_1230f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1230e8: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x123104; return;
    }
label_1230f0:
    // 0x1230f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1230f4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1230f8: 0xc04852e
    SET_GPR_U32(ctx, 31, 0x123100);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GetActPositionGoal__FP3ACTfP6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_123100
// Address: 0x123100 - 0x123120

void entry_123100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123100) {
        switch (ctx->pc) {
            case 0x123104: ctx->pc = 0; goto label_123104;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123100: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_123104:
    // 0x123104: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x123108: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12310c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x123110: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123114: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123118: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActsegRotationGoal__FP6ACTSEGfP7MATRIX3P6VECTOR
// Address: 0x123120 - 0x1231b0

void entry_1231b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1231b0) {
        switch (ctx->pc) {
            case 0x1231b8: ctx->pc = 0; goto label_1231b8;
            case 0x1231c0: ctx->pc = 0; goto label_1231c0;
            case 0x123208: ctx->pc = 0; goto label_123208;
            case 0x12320c: ctx->pc = 0; goto label_12320c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1231b0: 0x10000003
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 17)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1231c0;
    }
label_1231b8:
    // 0x1231b8: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1231bc: 0x82230011
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 17)));
label_1231c0:
    // 0x1231c0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1231c4: 0x54620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
        goto label_12320c;
    }
    // 0x1231cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1231d0: 0xc6200018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1231d4: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1231d8: 0xc6030010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[3] = *(float*)&val; }
    // 0x1231dc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1231e0: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1231e4: 0x460300c1
    ctx->f[3] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1231e8: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1231ec: 0x0
    // NOP
    // 0x1231f0: 0x45000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_123208;
    }
    // 0x1231f8: 0xc6000018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1231fc: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x123200: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x123204: 0xe7a10000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
label_123208:
    // 0x123208: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
label_12320c:
    // 0x12320c: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x123210: 0xc60d0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[13] = *(float*)&val; }
    // 0x123214: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x123218: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12321c: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x123220: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x123224: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x123228: 0x40f809
    SET_GPR_U32(ctx, 31, 0x123230);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_123230
// Address: 0x123230 - 0x123248

void entry_123230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123230) {
        switch (ctx->pc) {
            case 0x123238: ctx->pc = 0; goto label_123238;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123230: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12324C; return;
    }
label_123238:
    // 0x123238: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12323c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x123240: 0xc048542
    SET_GPR_U32(ctx, 31, 0x123248);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GetActRotationGoal__FP3ACTfP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_123248
// Address: 0x123248 - 0x123270

void entry_123248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123248) {
        switch (ctx->pc) {
            case 0x12324c: ctx->pc = 0; goto label_12324c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123248: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_12324c:
    // 0x12324c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x123250: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x123254: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x123258: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12325c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123260: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123264: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12326c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123270; return;
}


// Function: GetActsegTwistGoal__FP6ACTSEGPfT1
// Address: 0x123270 - 0x1232c8

void entry_1232c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1232c8) {
        switch (ctx->pc) {
            case 0x1232d0: ctx->pc = 0; goto label_1232d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1232c8: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1232E0; return;
    }
label_1232d0:
    // 0x1232d0: 0x120202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1232d4: 0xc04855a
    SET_GPR_U32(ctx, 31, 0x1232dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    GetActTwistGoal__FP3ACTPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1232dc
// Address: 0x1232dc - 0x1232e8

void entry_1232dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1232dc) {
        switch (ctx->pc) {
            case 0x1232e0: ctx->pc = 0; goto label_1232e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1232dc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1232e0:
    // 0x1232e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActsegScale__FP6ACTSEGP7MATRIX3
// Address: 0x1232e8 - 0x123334

void entry_123334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123334) {
        switch (ctx->pc) {
            case 0x12333c: ctx->pc = 0; goto label_12333c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123334: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12334C; return;
    }
label_12333c:
    // 0x12333c: 0x100202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x123340: 0xc048560
    SET_GPR_U32(ctx, 31, 0x123348);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    GetActScale__FP3ACTP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_123348
// Address: 0x123348 - 0x123358

void entry_123348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123348) {
        switch (ctx->pc) {
            case 0x12334c: ctx->pc = 0; goto label_12334c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123348: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_12334c:
    // 0x12334c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x123354: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123358; return;
}


// Function: GGetActsegPoseGoal__FP6ACTSEGi
// Address: 0x123358 - 0x1233b0

void entry_1233b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1233b0: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1233b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1233b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BreakAlbrk__FP5ALBRK
// Address: 0x1233c0 - 0x1233e4

void entry_1233e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1233e4: 0xc04f49e
    SET_GPR_U32(ctx, 31, 0x1233ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BreakBrk__FP3BRK(rdram, ctx, runtime); return;
}


// Function: entry_1233ec
// Address: 0x1233ec - 0x123400

void entry_1233ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1233ec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1233f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1233f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1233fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123400; return;
}


// Function: SetAlbrkAlarm__FP5ALBRKP5ALARM
// Address: 0x123400 - 0x123408

void entry_12341c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12341c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x123420: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x123424: 0xae020550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    // 0x123428: 0xc0503fe
    SET_GPR_U32(ctx, 31, 0x123430);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    IchkAllocChkmgr__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_123430
// Address: 0x123430 - 0x123448

void entry_123430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123430: 0xae0206b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1712), GPR_U32(ctx, 2));
    // 0x123434: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123438: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12343c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x123444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123448; return;
}


// Function: PostAlarmLoad__FP5ALARM
// Address: 0x123448 - 0x12347c

void entry_12347c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12347c: 0xc049292
    SET_GPR_U32(ctx, 31, 0x123484);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_123484
// Address: 0x123484 - 0x1234cc

void entry_123484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123484) {
        switch (ctx->pc) {
            case 0x1234c0: ctx->pc = 0; goto label_1234c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123484: 0x26230034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 52));
    // 0x123488: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x12348c: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x123490: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x123494: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x123498: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x12349c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1234a0: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1234a4: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1234a8: 0x8e230034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1234ac: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1234b0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1234b4: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1234b8: 0x12000010
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1234FC; return;
    }
label_1234c0:
    // 0x1234c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1234c4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1234cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 136));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1234cc
// Address: 0x1234cc - 0x123514

void entry_1234cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1234cc) {
        switch (ctx->pc) {
            case 0x1234e0: ctx->pc = 0; goto label_1234e0;
            case 0x1234e4: ctx->pc = 0; goto label_1234e4;
            case 0x1234fc: ctx->pc = 0; goto label_1234fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1234cc: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1234e4;
    }
    // 0x1234d4: 0x8e220558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
    // 0x1234d8: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1368), GPR_U32(ctx, 16));
        goto label_1234e0;
    }
label_1234e0:
    // 0x1234e0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1234e4:
    // 0x1234e4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1234e8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1234ec: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1234f0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1234f4: 0x1600fff2
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1234C0; return;
    }
label_1234fc:
    // 0x1234fc: 0x8e240558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
    // 0x123500: 0x10800007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_123520(rdram, ctx, runtime); return;
    }
    // 0x123508: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12350c: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x123514);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_123514
// Address: 0x123514 - 0x123520

void entry_123514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123514: 0x8e240558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
    // 0x123518: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x123520);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1372), GPR_U32(ctx, 2));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_123520
// Address: 0x123520 - 0x123540

void entry_123520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123520: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x123524: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x123528: 0xae42b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 2));
    // 0x12352c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x123530: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123534: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123538: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneAlarm__FP5ALARMT0
// Address: 0x123540 - 0x12355c

void entry_12355c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12355c: 0xae1106b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1712), GPR_U32(ctx, 17));
    // 0x123560: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123564: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123568: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12356c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x123574: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123578; return;
}


// Function: UpdateAlarm__FP5ALARMf
// Address: 0x123578 - 0x123598

void entry_123598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123598: 0x8e230550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x12359c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1235a0: 0x54620014
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        ctx->pc = 0x1235F4; return;
    }
    // 0x1235a8: 0xc6220560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1376)); ctx->f[2] = *(float*)&val; }
    // 0x1235ac: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1235b0: 0x46001032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1235b4: 0x0
    // NOP
    // 0x1235b8: 0x4503000e
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        ctx->pc = 0x1235F4; return;
    }
    // 0x1235c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1235c4: 0xc6210554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1364)); ctx->f[1] = *(float*)&val; }
    // 0x1235c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1235cc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1235d0: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1235d4: 0x0
    // NOP
    // 0x1235d8: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1235F0; return;
    }
    // 0x1235e0: 0xc048e22
    SET_GPR_U32(ctx, 31, 0x1235e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetAlarmAlarms__FP5ALARM6ALARMS(rdram, ctx, runtime); return;
}


// Function: entry_1235e8
// Address: 0x1235e8 - 0x123614

void entry_1235e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1235e8) {
        switch (ctx->pc) {
            case 0x1235f0: ctx->pc = 0; goto label_1235f0;
            case 0x1235f4: ctx->pc = 0; goto label_1235f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1235e8: 0x10000030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1236AC; return;
    }
label_1235f0:
    // 0x1235f0: 0x8e260564
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
label_1235f4:
    // 0x1235f4: 0x58c00009
    if (GPR_S32(ctx, 6) <= 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
        ctx->pc = 0x12361C; return;
    }
    // 0x1235fc: 0x8e22061c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1564)));
    // 0x123600: 0x54460006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
        ctx->pc = 0x12361C; return;
    }
    // 0x123608: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12360c: 0xc048e22
    SET_GPR_U32(ctx, 31, 0x123614);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetAlarmAlarms__FP5ALARM6ALARMS(rdram, ctx, runtime); return;
}


// Function: entry_123614
// Address: 0x123614 - 0x123664

void entry_123614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123614) {
        switch (ctx->pc) {
            case 0x12361c: ctx->pc = 0; goto label_12361c;
            case 0x123650: ctx->pc = 0; goto label_123650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123614: 0x10000025
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1236AC; return;
    }
label_12361c:
    // 0x12361c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x123620: 0x14620022
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1236AC; return;
    }
    // 0x123628: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x12362c: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    // 0x123630: 0x8c822e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 11792)));
    // 0x123634: 0x8c432220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8736)));
    // 0x123638: 0x1465001d
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        ctx->pc = 0x1236B0; return;
    }
    // 0x123640: 0x18c0001a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 6) <= 0) {
        ctx->pc = 0x1236AC; return;
    }
    // 0x123648: 0x26320568
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1384));
    // 0x12364c: 0x0
    // NOP
label_123650:
    // 0x123650: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x123654: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x123658: 0x8e460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12365c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x123664);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_123664
// Address: 0x123664 - 0x12367c

void entry_123664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123664: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x123668: 0x5200000b
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        ctx->pc = 0x123698; return;
    }
    // 0x123670: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x123674: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x12367c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_12367c
// Address: 0x12367c - 0x123694

void entry_12367c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12367c: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        ctx->pc = 0x123698; return;
    }
    // 0x123684: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x123688: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x12368c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x123694);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_123694
// Address: 0x123694 - 0x1236c8

void entry_123694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123694) {
        switch (ctx->pc) {
            case 0x123698: ctx->pc = 0; goto label_123698;
            case 0x1236ac: ctx->pc = 0; goto label_1236ac;
            case 0x1236b0: ctx->pc = 0; goto label_1236b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123694: 0x8e220564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
label_123698:
    // 0x123698: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x12369c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1236a0: 0x1440ffeb
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x123650; return;
    }
    // 0x1236a8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1236ac:
    // 0x1236ac: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1236b0:
    // 0x1236b0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1236b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1236b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1236bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1236c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1236c8; return;
}


// Function: PostAlarmLoadCallbackHookup__FP5ALARM5MSGIDPv
// Address: 0x1236c8 - 0x123714

void entry_123714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123714: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x123718: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12373C; return;
    }
    // 0x123720: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x123728);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_123728
// Address: 0x123728 - 0x123738

void entry_123728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123728: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12373C; return;
    }
    // 0x123730: 0xc048d00
    SET_GPR_U32(ctx, 31, 0x123738);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetAlbrkAlarm__FP5ALBRKP5ALARM(rdram, ctx, runtime); return;
}


// Function: entry_123738
// Address: 0x123738 - 0x12377c

void entry_123738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123738) {
        switch (ctx->pc) {
            case 0x12373c: ctx->pc = 0; goto label_12373c;
            case 0x123750: ctx->pc = 0; goto label_123750;
            case 0x123768: ctx->pc = 0; goto label_123768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123738: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
label_12373c:
    // 0x12373c: 0x8e220564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
    // 0x123740: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x123744: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x123748: 0x1440ffed
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x123700; return;
    }
label_123750:
    // 0x123750: 0x8e220578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
    // 0x123754: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x123758: 0x1840001e
    WRITE32(ADD32(GPR_U32(ctx, 17), 1380), GPR_U32(ctx, 20));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1237D4; return;
    }
    // 0x123760: 0x263405c0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 1472));
    // 0x123764: 0x2633057c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 1404));
label_123768:
    // 0x123768: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x12376c: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x123770: 0x8e660000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x123774: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12377c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12377c
// Address: 0x12377c - 0x123790

void entry_12377c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12377c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x123780: 0x1200000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1237c0(rdram, ctx, runtime); return;
    }
    // 0x123788: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x123790);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 48));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_123790
// Address: 0x123790 - 0x1237c0

void entry_123790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123790: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1237c0(rdram, ctx, runtime); return;
    }
    // 0x123798: 0x8e2305bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1468)));
    // 0x12379c: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1237a0: 0x2821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1237a4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1237a8: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1237ac: 0xae2305bc
    WRITE32(ADD32(GPR_U32(ctx, 17), 1468), GPR_U32(ctx, 3));
    // 0x1237b0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1237b4: 0x8c430140
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1237b8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1237c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1237c0
// Address: 0x1237c0 - 0x1237fc

void entry_1237c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1237c0) {
        switch (ctx->pc) {
            case 0x1237d4: ctx->pc = 0; goto label_1237d4;
            case 0x1237e8: ctx->pc = 0; goto label_1237e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1237c0: 0x8e220578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
    // 0x1237c4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1237c8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1237cc: 0x1440ffe6
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x123768; return;
    }
label_1237d4:
    // 0x1237d4: 0x8e220600
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1536)));
    // 0x1237d8: 0x18400016
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x123834; return;
    }
    // 0x1237e0: 0x26330604
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 1540));
    // 0x1237e4: 0x0
    // NOP
label_1237e8:
    // 0x1237e8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1237ec: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x1237f0: 0x8e660000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1237f4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1237fc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1237fc
// Address: 0x1237fc - 0x123810

void entry_1237fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1237fc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x123800: 0x12000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_123820(rdram, ctx, runtime); return;
    }
    // 0x123808: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x123810);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_123810
// Address: 0x123810 - 0x123820

void entry_123810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123810: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_123820(rdram, ctx, runtime); return;
    }
    // 0x123818: 0xc072b50
    SET_GPR_U32(ctx, 31, 0x123820);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddStepguardAlarm__FP9STEPGUARDP5ALARM(rdram, ctx, runtime); return;
}


// Function: entry_123820
// Address: 0x123820 - 0x123844

void entry_123820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123820) {
        switch (ctx->pc) {
            case 0x123834: ctx->pc = 0; goto label_123834;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123820: 0x8e220600
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1536)));
    // 0x123824: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x123828: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x12382c: 0x1440ffee
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1237E8; return;
    }
label_123834:
    // 0x123834: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x123838: 0x8e2506b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1712)));
    // 0x12383c: 0xc050402
    SET_GPR_U32(ctx, 31, 0x123844);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_123844
// Address: 0x123844 - 0x123854

void entry_123844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123844: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12385C; return;
    }
    // 0x12384c: 0xc048e22
    SET_GPR_U32(ctx, 31, 0x123854);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetAlarmAlarms__FP5ALARM6ALARMS(rdram, ctx, runtime); return;
}


// Function: entry_123854
// Address: 0x123854 - 0x123864

void entry_123854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123854) {
        switch (ctx->pc) {
            case 0x12385c: ctx->pc = 0; goto label_12385c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123854: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x123868; return;
    }
label_12385c:
    // 0x12385c: 0xc048e22
    SET_GPR_U32(ctx, 31, 0x123864);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetAlarmAlarms__FP5ALARM6ALARMS(rdram, ctx, runtime); return;
}


// Function: entry_123864
// Address: 0x123864 - 0x123888

void entry_123864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123864) {
        switch (ctx->pc) {
            case 0x123868: ctx->pc = 0; goto label_123868;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123864: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_123868:
    // 0x123868: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12386c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x123870: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123874: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123878: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12387c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x123884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123888; return;
}


// Function: SetAlarmAlarms__FP5ALARM6ALARMS
// Address: 0x123888 - 0x1238d8

void entry_1238d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1238d8: 0xc06fc12
    SET_GPR_U32(ctx, 31, 0x1238e0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1572)));
    UnsetExcitement__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_1238e0
// Address: 0x1238e0 - 0x1238f8

void entry_1238e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1238e0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1238e4: 0x26260630
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1584));
    // 0x1238e8: 0x8e25062c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    // 0x1238ec: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1238f0: 0xc04fb2c
    SET_GPR_U32(ctx, 31, 0x1238f8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TriggerRsmg__FP2SWiP4RSMGP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_1238f8
// Address: 0x1238f8 - 0x123910

void entry_1238f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1238f8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1238fc: 0x56020005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1360), GPR_U32(ctx, 16));
        ctx->pc = 0x123914; return;
    }
    // 0x123904: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x123908: 0xc058340
    SET_GPR_U32(ctx, 31, 0x123910);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9176));
    OnGameAlarmDisabled__FP4GAME(rdram, ctx, runtime); return;
}


// Function: entry_123910
// Address: 0x123910 - 0x123968

void entry_123910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123910) {
        switch (ctx->pc) {
            case 0x123914: ctx->pc = 0; goto label_123914;
            case 0x123944: ctx->pc = 0; goto label_123944;
            case 0x123954: ctx->pc = 0; goto label_123954;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123910: 0xae300550
    WRITE32(ADD32(GPR_U32(ctx, 17), 1360), GPR_U32(ctx, 16));
label_123914:
    // 0x123914: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x123918: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12391c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x123920: 0x12030015
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1364), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x123978; return;
    }
    // 0x123928: 0x2a020002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    // 0x12392c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_123944;
    }
    // 0x123934: 0x12000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_123954;
    }
    // 0x12393c: 0x10000058
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x123AA0; return;
    }
label_123944:
    // 0x123944: 0x1202002a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1239F0; return;
    }
    // 0x12394c: 0x10000054
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x123AA0; return;
    }
label_123954:
    // 0x123954: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x123958: 0x10800003
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_123968(rdram, ctx, runtime); return;
    }
    // 0x123960: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x123968);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 538));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_123968
// Address: 0x123968 - 0x123970

void entry_123968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123968: 0xc048eca
    SET_GPR_U32(ctx, 31, 0x123970);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    EnableAlarmSensors__FP5ALARM(rdram, ctx, runtime); return;
}


// Function: entry_123970
// Address: 0x123970 - 0x12398c

void entry_123970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123970) {
        switch (ctx->pc) {
            case 0x123978: ctx->pc = 0; goto label_123978;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123970: 0x1000004a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x123A9C; return;
    }
label_123978:
    // 0x123978: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x12397c: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x123990; return;
    }
    // 0x123984: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x12398c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 544));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_12398c
// Address: 0x12398c - 0x123998

void entry_12398c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12398c) {
        switch (ctx->pc) {
            case 0x123990: ctx->pc = 0; goto label_123990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12398c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_123990:
    // 0x123990: 0xc048eec
    SET_GPR_U32(ctx, 31, 0x123998);
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    DisableAlarmSensors__FP5ALARM(rdram, ctx, runtime); return;
}


// Function: entry_123998
// Address: 0x123998 - 0x1239a8

void entry_123998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123998: 0x200902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12399c: 0x8e2506b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1712)));
    // 0x1239a0: 0xc050402
    SET_GPR_U32(ctx, 31, 0x1239a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 5152));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1239a8
// Address: 0x1239a8 - 0x1239c0

void entry_1239a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1239a8: 0x10400007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 22));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1239C8; return;
    }
    // 0x1239b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1239b4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1239b8: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1239c0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1239c0
// Address: 0x1239c0 - 0x1239dc

void entry_1239c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1239c0) {
        switch (ctx->pc) {
            case 0x1239c8: ctx->pc = 0; goto label_1239c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1239c0: 0x10000007
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1712)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1239E0; return;
    }
label_1239c8:
    // 0x1239c8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1239cc: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1239d0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1239d4: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1239dc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1239dc
// Address: 0x1239dc - 0x1239e8

void entry_1239dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1239dc) {
        switch (ctx->pc) {
            case 0x1239e0: ctx->pc = 0; goto label_1239e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1239dc: 0x8e2506b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1712)));
label_1239e0:
    // 0x1239e0: 0xc050410
    SET_GPR_U32(ctx, 31, 0x1239e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 5152));
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1239e8
// Address: 0x1239e8 - 0x123a04

void entry_1239e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1239e8) {
        switch (ctx->pc) {
            case 0x1239f0: ctx->pc = 0; goto label_1239f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1239e8: 0x1000002c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x123A9C; return;
    }
label_1239f0:
    // 0x1239f0: 0x8e24055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1372)));
    // 0x1239f4: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1576)));
        ctx->pc = 0x123A08; return;
    }
    // 0x1239fc: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x123a04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 543));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_123a04
// Address: 0x123a04 - 0x123a4c

void entry_123a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123a04) {
        switch (ctx->pc) {
            case 0x123a08: ctx->pc = 0; goto label_123a08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123a04: 0x8e220628
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1576)));
label_123a08:
    // 0x123a08: 0x14400010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1568));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_123a4c(rdram, ctx, runtime); return;
    }
    // 0x123a10: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x123a14: 0x24040015
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 21));
    // 0x123a18: 0x3c0145fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17914 << 16));
    // 0x123a1c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x123a20: 0x3c01459c
    SET_GPR_U32(ctx, 1, ((uint32_t)17820 << 16));
    // 0x123a24: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x123a28: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x123a2c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x123a30: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x123a34: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x123a38: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x123a3c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x123a40: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x123a44: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x123a4c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_123a4c
// Address: 0x123a4c - 0x123a54

void entry_123a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123a4c: 0xc06fbbe
    SET_GPR_U32(ctx, 31, 0x123a54);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 107));
    PexcSetExcitement__Fi(rdram, ctx, runtime); return;
}


// Function: entry_123a54
// Address: 0x123a54 - 0x123a60

void entry_123a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123a54: 0xae220624
    WRITE32(ADD32(GPR_U32(ctx, 17), 1572), GPR_U32(ctx, 2));
    // 0x123a58: 0xc048f08
    SET_GPR_U32(ctx, 31, 0x123a60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    NotifyAlarmSensorsOnTrigger__FP5ALARM(rdram, ctx, runtime); return;
}


// Function: entry_123a60
// Address: 0x123a60 - 0x123a78

void entry_123a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123a60: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x123a64: 0x26260630
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1584));
    // 0x123a68: 0x8e25062c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    // 0x123a6c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x123a70: 0xc04fb2c
    SET_GPR_U32(ctx, 31, 0x123a78);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    TriggerRsmg__FP2SWiP4RSMGP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_123a78
// Address: 0x123a78 - 0x123a8c

void entry_123a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123a78: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x123a7c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x123a80: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x123a84: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x123a8c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_123a8c
// Address: 0x123a8c - 0x123a98

void entry_123a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123a8c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x123a90: 0xc05833c
    SET_GPR_U32(ctx, 31, 0x123a98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9176));
    OnGameAlarmTriggered__FP4GAME(rdram, ctx, runtime); return;
}


// Function: entry_123a98
// Address: 0x123a98 - 0x123ab0

void entry_123a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123a98) {
        switch (ctx->pc) {
            case 0x123a9c: ctx->pc = 0; goto label_123a9c;
            case 0x123aa0: ctx->pc = 0; goto label_123aa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123a98: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_123a9c:
    // 0x123a9c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_123aa0:
    // 0x123aa0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123aa4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x123aa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TriggerAlarm__FP5ALARM4ALTK
// Address: 0x123ab0 - 0x123b08

void entry_123b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123b08) {
        switch (ctx->pc) {
            case 0x123b0c: ctx->pc = 0; goto label_123b0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123b08: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_123b0c:
    // 0x123b0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x123b14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123b18; return;
}


// Function: DisableAlarmAlbrk__FP5ALARM
// Address: 0x123b18 - 0x123b28

void entry_123b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123b80) {
        switch (ctx->pc) {
            case 0x123b84: ctx->pc = 0; goto label_123b84;
            case 0x123b94: ctx->pc = 0; goto label_123b94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123b80: 0x8e4205bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1468)));
label_123b84:
    // 0x123b84: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x123b88: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x123b8c: 0x1440fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x123B58; return;
    }
label_123b94:
    // 0x123b94: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x123b98: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x123b9c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123ba0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123ba4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x123ba8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DisableAlarmSensors__FP5ALARM
// Address: 0x123bb0 - 0x123bf4

void entry_123bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123bf4) {
        switch (ctx->pc) {
            case 0x123bf8: ctx->pc = 0; goto label_123bf8;
            case 0x123c08: ctx->pc = 0; goto label_123c08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123bf4: 0x8e4205bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1468)));
label_123bf8:
    // 0x123bf8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x123bfc: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x123c00: 0x1440fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x123BD8; return;
    }
label_123c08:
    // 0x123c08: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x123c0c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123c10: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123c14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x123c18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: NotifyAlarmSensorsOnTrigger__FP5ALARM
// Address: 0x123c20 - 0x123c64

void entry_123c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123c64) {
        switch (ctx->pc) {
            case 0x123c68: ctx->pc = 0; goto label_123c68;
            case 0x123c78: ctx->pc = 0; goto label_123c78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123c64: 0x8e4205bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1468)));
label_123c68:
    // 0x123c68: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x123c6c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x123c70: 0x1440fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x123C48; return;
    }
label_123c78:
    // 0x123c78: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x123c7c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123c80: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123c84: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x123c88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddAlarmAlbrk__FP5ALARM3OID
// Address: 0x123c90 - 0x123cb8

void entry_123d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123d34: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x123d38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FGetAlarmSensorList__FP5ALARMPv
// Address: 0x123d40 - 0x123d7c

void entry_123d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123d7c) {
        switch (ctx->pc) {
            case 0x123d8c: ctx->pc = 0; goto label_123d8c;
            case 0x123d9c: ctx->pc = 0; goto label_123d9c;
            case 0x123da0: ctx->pc = 0; goto label_123da0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123d7c: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1468)));
        goto label_123d8c;
    }
    // 0x123d84: 0x10000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_123da0;
    }
label_123d8c:
    // 0x123d8c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x123d90: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x123d94: 0x1440fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x123D70; return;
    }
label_123d9c:
    // 0x123d9c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_123da0:
    // 0x123da0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x123da4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x123da8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x123dac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x123db0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x123db4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x123dbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x123dc0; return;
}


// Function: FIsZeroV__FP6VECTOR
// Address: 0x123dc0 - 0x123e00

void entry_123eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123eec: 0x26040060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 96));
    // 0x123ef0: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x123ef8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 88));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_123ef8
// Address: 0x123ef8 - 0x123f5c

void entry_123ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x123ef8) {
        switch (ctx->pc) {
            case 0x123f28: ctx->pc = 0; goto label_123f28;
            case 0x123f50: ctx->pc = 0; goto label_123f50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x123ef8: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x123efc: 0x1040000a
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_123f28;
    }
    // 0x123f04: 0x3c03fcff
    SET_GPR_U32(ctx, 3, ((uint32_t)64767 << 16));
    // 0x123f08: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x123f0c: 0x3c040100
    SET_GPR_U32(ctx, 4, ((uint32_t)256 << 16));
    // 0x123f10: 0x3c05f3ff
    SET_GPR_U32(ctx, 5, ((uint32_t)62463 << 16));
    // 0x123f14: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x123f18: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x123f1c: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x123f20: 0x1000000b
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_123f50;
    }
label_123f28:
    // 0x123f28: 0x3c03fcff
    SET_GPR_U32(ctx, 3, ((uint32_t)64767 << 16));
    // 0x123f2c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x123f30: 0x3c050200
    SET_GPR_U32(ctx, 5, ((uint32_t)512 << 16));
    // 0x123f34: 0x3c06f3ff
    SET_GPR_U32(ctx, 6, ((uint32_t)62463 << 16));
    // 0x123f38: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x123f3c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x123f40: 0x3c040800
    SET_GPR_U32(ctx, 4, ((uint32_t)2048 << 16));
    // 0x123f44: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x123f48: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x123f4c: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
label_123f50:
    // 0x123f50: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x123f54: 0xc060b06
    SET_GPR_U32(ctx, 31, 0x123f5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_123f5c
// Address: 0x123f5c - 0x12403c

void entry_123f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x123f5c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x123f60: 0x3c030fff
    SET_GPR_U32(ctx, 3, ((uint32_t)4095 << 16));
    // 0x123f64: 0xc44099f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294941168)); ctx->f[0] = *(float*)&val; }
    // 0x123f68: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x123f6c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x123f70: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x123f74: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x123f78: 0x3c090026
    SET_GPR_U32(ctx, 9, ((uint32_t)38 << 16));
    // 0x123f7c: 0x3c0a0026
    SET_GPR_U32(ctx, 10, ((uint32_t)38 << 16));
    // 0x123f80: 0x24840e70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 3696));
    // 0x123f84: 0x24420e80
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3712));
    // 0x123f88: 0x24e70e90
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 3728));
    // 0x123f8c: 0x25080ea0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 3744));
    // 0x123f90: 0x25290eb0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 3760));
    // 0x123f94: 0x254a0ec0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 3776));
    // 0x123f98: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x123f9c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x123fa0: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x123fa4: 0xe6000084
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 132), *(uint32_t*)&val); }
    // 0x123fa8: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x123fac: 0xa20502ca
    WRITE8(ADD32(GPR_U32(ctx, 16), 714), (uint8_t)GPR_U32(ctx, 5));
    // 0x123fb0: 0x24c683d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294935504));
    // 0x123fb4: 0xa20b02c9
    WRITE8(ADD32(GPR_U32(ctx, 16), 713), (uint8_t)GPR_U32(ctx, 11));
    // 0x123fb8: 0x260c00d0
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 16), 208));
    // 0x123fbc: 0xae04020c
    WRITE32(ADD32(GPR_U32(ctx, 16), 524), GPR_U32(ctx, 4));
    // 0x123fc0: 0x260d0110
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 16), 272));
    // 0x123fc4: 0xae070214
    WRITE32(ADD32(GPR_U32(ctx, 16), 532), GPR_U32(ctx, 7));
    // 0x123fc8: 0x260b01a0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 16), 416));
    // 0x123fcc: 0xae080218
    WRITE32(ADD32(GPR_U32(ctx, 16), 536), GPR_U32(ctx, 8));
    // 0x123fd0: 0x260401e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 480));
    // 0x123fd4: 0xae09021c
    WRITE32(ADD32(GPR_U32(ctx, 16), 540), GPR_U32(ctx, 9));
    // 0x123fd8: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x123fdc: 0xae0a0220
    WRITE32(ADD32(GPR_U32(ctx, 16), 544), GPR_U32(ctx, 10));
    // 0x123fe0: 0xe6000080
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 128), *(uint32_t*)&val); }
    // 0x123fe4: 0xae030088
    WRITE32(ADD32(GPR_U32(ctx, 16), 136), GPR_U32(ctx, 3));
    // 0x123fe8: 0xae020210
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    // 0x123fec: 0xa20002c8
    WRITE8(ADD32(GPR_U32(ctx, 16), 712), (uint8_t)GPR_U32(ctx, 0));
    // 0x123ff0: 0x78c20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x123ff4: 0x7e0200d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 208), GPR_VEC(ctx, 2));
    // 0x123ff8: 0x78c30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x123ffc: 0x7d830010
    WRITE128(ADD32(GPR_U32(ctx, 12), 16), GPR_VEC(ctx, 3));
    // 0x124000: 0x78c20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x124004: 0x7d820020
    WRITE128(ADD32(GPR_U32(ctx, 12), 32), GPR_VEC(ctx, 2));
    // 0x124008: 0x78c30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x12400c: 0x7e030110
    WRITE128(ADD32(GPR_U32(ctx, 16), 272), GPR_VEC(ctx, 3));
    // 0x124010: 0x78c20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x124014: 0x7da20010
    WRITE128(ADD32(GPR_U32(ctx, 13), 16), GPR_VEC(ctx, 2));
    // 0x124018: 0x78c30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x12401c: 0x7da30020
    WRITE128(ADD32(GPR_U32(ctx, 13), 32), GPR_VEC(ctx, 3));
    // 0x124020: 0x78c20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x124024: 0x7e0201a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 416), GPR_VEC(ctx, 2));
    // 0x124028: 0x78c30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x12402c: 0x7d630010
    WRITE128(ADD32(GPR_U32(ctx, 11), 16), GPR_VEC(ctx, 3));
    // 0x124030: 0x78c20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x124034: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x12403c);
    WRITE128(ADD32(GPR_U32(ctx, 11), 32), GPR_VEC(ctx, 2));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_12403c
// Address: 0x12403c - 0x124050

void entry_12403c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12403c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x124040: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x124044: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12404c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x124050; return;
}


// Function: AddAloHierarchy__FP3ALO
// Address: 0x124050 - 0x1240a8

void entry_1240a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1240a8: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1240ac: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1240b0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1240b4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1240b8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1240bc: 0x1480fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x124098; return;
    }
    // 0x1240c4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1240c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1240cc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1240d0: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1240d4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1240dc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1240dc
// Address: 0x1240dc - 0x1240f8

void entry_1240dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1240dc: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1240e0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1240e4: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x1240e8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1240ec: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1240f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnAloAdd__FP3ALO
// Address: 0x1240f8 - 0x124118

void entry_124118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124118: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x12411c: 0x1460002e
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1241D8; return;
    }
    // 0x124124: 0x8e420294
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 660)));
    // 0x124128: 0x10400006
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124144; return;
    }
    // 0x124130: 0x26640078
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 120));
    // 0x124134: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x12413c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12413c
// Address: 0x12413c - 0x124150

void entry_12413c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12413c) {
        switch (ctx->pc) {
            case 0x124144: ctx->pc = 0; goto label_124144;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12413c: 0x10000035
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 492)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124214; return;
    }
label_124144:
    // 0x124144: 0x26640054
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 84));
    // 0x124148: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x124150);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_124150
// Address: 0x124150 - 0x124170

void entry_124150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124150: 0xde4202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 712)));
    // 0x124154: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x124158: 0x31db8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 22);
    // 0x12415c: 0x26640060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 96));
    // 0x124160: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x124164: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x124168: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x124170);
    WRITE64(ADD32(GPR_U32(ctx, 18), 712), GPR_U64(ctx, 2));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_124170
// Address: 0x124170 - 0x12418c

void entry_124170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124170: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x124174: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x124178: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x12417c: 0x10400003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 108));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12418c(rdram, ctx, runtime); return;
    }
    // 0x124184: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x12418c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12418c
// Address: 0x12418c - 0x1241c8

void entry_12418c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12418c) {
        switch (ctx->pc) {
            case 0x1241b8: ctx->pc = 0; goto label_1241b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12418c: 0x8e50006c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 108)));
    // 0x124190: 0xae520054
    WRITE32(ADD32(GPR_U32(ctx, 18), 84), GPR_U32(ctx, 18));
    // 0x124194: 0xae520064
    WRITE32(ADD32(GPR_U32(ctx, 18), 100), GPR_U32(ctx, 18));
    // 0x124198: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x12419c: 0x600001c
    WRITE32(ADD32(GPR_U32(ctx, 18), 96), GPR_U32(ctx, 18));
    if (GPR_S32(ctx, 16) < 0) {
        entry_124210(rdram, ctx, runtime); return;
    }
    // 0x1241a4: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1241a8: 0x24420070
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 112));
    // 0x1241ac: 0x528821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1241b0: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1241b4: 0x0
    // NOP
label_1241b8:
    // 0x1241b8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1241bc: 0x2631fffc
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967292));
    // 0x1241c0: 0xc057df6
    SET_GPR_U32(ctx, 31, 0x1241c8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    MergeSwGroup__FP2SWP3MRG(rdram, ctx, runtime); return;
}


// Function: entry_1241c8
// Address: 0x1241c8 - 0x124210

void entry_1241c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1241c8) {
        switch (ctx->pc) {
            case 0x1241d8: ctx->pc = 0; goto label_1241d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1241c8: 0x603fffb
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1241B8; return;
    }
    // 0x1241d0: 0x10000010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 492)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124214; return;
    }
label_1241d8:
    // 0x1241d8: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1241dc: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1241e0: 0x425f8
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 23);
    // 0x1241e4: 0xae420050
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 2));
    // 0x1241e8: 0xdc6302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 3), 712)));
    // 0x1241ec: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1241f0: 0x50600008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 492)));
        ctx->pc = 0x124214; return;
    }
    // 0x1241f8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1241fc: 0x8c420060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 96)));
    // 0x124200: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_124210(rdram, ctx, runtime); return;
    }
    // 0x124208: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124210);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124210
// Address: 0x124210 - 0x124234

void entry_124210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124210) {
        switch (ctx->pc) {
            case 0x124214: ctx->pc = 0; goto label_124214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124210: 0x8e4401ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 492)));
label_124214:
    // 0x124214: 0x10800011
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_12425c(rdram, ctx, runtime); return;
    }
    // 0x12421c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x124220: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x124224: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x124228: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x12422c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124234);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124234
// Address: 0x124234 - 0x124248

void entry_124234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124234: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x124238: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12423c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x124240: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124248);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124248
// Address: 0x124248 - 0x12425c

void entry_124248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124248: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12424c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124250: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x124254: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12425c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12425c
// Address: 0x12425c - 0x124280

void entry_12425c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12425c: 0x8e4401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 496)));
    // 0x124260: 0x10800011
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1242a8(rdram, ctx, runtime); return;
    }
    // 0x124268: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12426c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x124270: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124274: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x124278: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124280);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124280
// Address: 0x124280 - 0x124294

void entry_124280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124280: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x124284: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124288: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x12428c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124294);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124294
// Address: 0x124294 - 0x1242a8

void entry_124294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124294: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x124298: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12429c: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1242a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1242a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1242a8
// Address: 0x1242a8 - 0x1242cc

void entry_1242a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1242a8: 0xde4202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 712)));
    // 0x1242ac: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1242b0: 0x31d78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 21);
    // 0x1242b4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1242b8: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1242cc(rdram, ctx, runtime); return;
    }
    // 0x1242c0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1242c4: 0xc050ebe
    SET_GPR_U32(ctx, 31, 0x1242cc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    AddCmFadeObject(rdram, ctx, runtime); return;
}


// Function: entry_1242cc
// Address: 0x1242cc - 0x1242e4

void entry_1242cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1242cc: 0x8e450284
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 644)));
    // 0x1242d0: 0x50a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1242E8; return;
    }
    // 0x1242d8: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1242dc: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1242e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7168));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1242e4
// Address: 0x1242e4 - 0x1242fc

void entry_1242e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1242e4) {
        switch (ctx->pc) {
            case 0x1242e8: ctx->pc = 0; goto label_1242e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1242e4: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1242e8:
    // 0x1242e8: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1242ec: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x124300; return;
    }
    // 0x1242f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1242fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1242fc
// Address: 0x1242fc - 0x124310

void entry_1242fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1242fc) {
        switch (ctx->pc) {
            case 0x124300: ctx->pc = 0; goto label_124300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1242fc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_124300:
    // 0x124300: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x124304: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124308: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x124310);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_124310
// Address: 0x124310 - 0x124318

void entry_124310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124310: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x124318);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_124318
// Address: 0x124318 - 0x124338

void entry_124318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124318: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12431c: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x124320: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x124324: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x124328: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12432c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x124334: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x124338; return;
}


// Function: RemoveAloHierarchy__FP3ALO
// Address: 0x124338 - 0x124390

void entry_124390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124390: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x124394: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x124398: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12439c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1243a0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1243a4: 0x1480fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x124380; return;
    }
    // 0x1243ac: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1243b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1243b4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1243b8: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1243bc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1243c4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1243c4
// Address: 0x1243c4 - 0x1243e0

void entry_1243c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1243c4: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1243c8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1243cc: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x1243d0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1243d4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1243d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnAloRemove__FP3ALO
// Address: 0x1243e0 - 0x1243f8

void entry_1243f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1243f8: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1243fc: 0x14400027
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_12449c(rdram, ctx, runtime); return;
    }
    // 0x124404: 0x8e020294
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 660)));
    // 0x124408: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 120));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124420; return;
    }
    // 0x124410: 0xc054980
    SET_GPR_U32(ctx, 31, 0x124418);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_124418
// Address: 0x124418 - 0x12442c

void entry_124418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124418) {
        switch (ctx->pc) {
            case 0x124420: ctx->pc = 0; goto label_124420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124418: 0x10000021
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1244A0; return;
    }
label_124420:
    // 0x124420: 0x26240054
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 84));
    // 0x124424: 0xc054980
    SET_GPR_U32(ctx, 31, 0x12442c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12442c
// Address: 0x12442c - 0x124468

void entry_12442c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12442c: 0xde0302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x124430: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x124434: 0x215b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 22);
    // 0x124438: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12443c: 0x10400011
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 96));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_124484(rdram, ctx, runtime); return;
    }
    // 0x124444: 0x2402ffdf
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967263));
    // 0x124448: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x12444c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x124450: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x124454: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x124458: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12445c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124460: 0xc054980
    SET_GPR_U32(ctx, 31, 0x124468);
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_124468
// Address: 0x124468 - 0x124484

void entry_124468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124468: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12446c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x124470: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x124474: 0x10400003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 108));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_124484(rdram, ctx, runtime); return;
    }
    // 0x12447c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x124484);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_124484
// Address: 0x124484 - 0x124490

void entry_124484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124484: 0x8e050054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x124488: 0xc057dc4
    SET_GPR_U32(ctx, 31, 0x124490);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SplinterSwFreezeGroup__FP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_124490
// Address: 0x124490 - 0x12449c

void entry_124490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124490: 0xae000054
    WRITE32(ADD32(GPR_U32(ctx, 16), 84), GPR_U32(ctx, 0));
    // 0x124494: 0xc054910
    SET_GPR_U32(ctx, 31, 0x12449c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 96));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_12449c
// Address: 0x12449c - 0x1244c0

void entry_12449c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12449c) {
        switch (ctx->pc) {
            case 0x1244a0: ctx->pc = 0; goto label_1244a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12449c: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
label_1244a0:
    // 0x1244a0: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1244a4: 0x31d78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 21);
    // 0x1244a8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1244ac: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1244c0(rdram, ctx, runtime); return;
    }
    // 0x1244b4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1244b8: 0xc050ec8
    SET_GPR_U32(ctx, 31, 0x1244c0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    RemoveCmFadeObject(rdram, ctx, runtime); return;
}


// Function: entry_1244c0
// Address: 0x1244c0 - 0x1244d8

void entry_1244c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1244c0: 0x8e050284
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 644)));
    // 0x1244c4: 0x50a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
        ctx->pc = 0x1244DC; return;
    }
    // 0x1244cc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1244d0: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1244d8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7168));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1244d8
// Address: 0x1244d8 - 0x124508

void entry_1244d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1244d8) {
        switch (ctx->pc) {
            case 0x1244dc: ctx->pc = 0; goto label_1244dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1244d8: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
label_1244dc:
    // 0x1244dc: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1244e0: 0x31df8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 23);
    // 0x1244e4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1244e8: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_124508(rdram, ctx, runtime); return;
    }
    // 0x1244f0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1244f4: 0x8c420060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 96)));
    // 0x1244f8: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_124508(rdram, ctx, runtime); return;
    }
    // 0x124500: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124508);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124508
// Address: 0x124508 - 0x124510

void entry_124508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124508: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x124510);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_124510
// Address: 0x124510 - 0x124528

void entry_124510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124510: 0xae000050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 0));
    // 0x124514: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124518: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x12451c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124520: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x124528);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_124528
// Address: 0x124528 - 0x124540

void entry_124528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124528: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12452c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x124530: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x124534: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12453c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x124540; return;
}


// Function: UpdateAloOrig__FP3ALO
// Address: 0x124540 - 0x124588

void entry_124588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124588: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12458c: 0xc0623f6
    SET_GPR_U32(ctx, 31, 0x124594);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 464));
    DecomposeRotateMatrixEuler__FP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_124594
// Address: 0x124594 - 0x1245a8

void entry_124594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124594: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x124598: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12459c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1245a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloParent__FP3ALOT0
// Address: 0x1245a8 - 0x124628

void entry_124628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124628) {
        switch (ctx->pc) {
            case 0x124630: ctx->pc = 0; goto label_124630;
            case 0x124648: ctx->pc = 0; goto label_124648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124628: 0x10000007
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_124648;
    }
label_124630:
    // 0x124630: 0x7a230150
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x124634: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    // 0x124638: 0x7a220160
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 352)));
    // 0x12463c: 0x27b40020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 32));
    // 0x124640: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x124644: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
label_124648:
    // 0x124648: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12464c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x124650: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124658);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124658
// Address: 0x124658 - 0x12466c

void entry_124658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124658: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12465c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x124660: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x124664: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x12466c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 256));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_12466c
// Address: 0x12466c - 0x124680

void entry_12466c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12466c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124670: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x124674: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x124678: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x124680);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 208));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_124680
// Address: 0x124680 - 0x1246a4

void entry_124680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124680: 0x12400010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1246C4; return;
    }
    // 0x124688: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12468c: 0x26260140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 320));
    // 0x124690: 0x27a70080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    // 0x124694: 0x27a80090
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 144));
    // 0x124698: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12469c: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1246a4);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1246a4
// Address: 0x1246a4 - 0x1246dc

void entry_1246a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1246a4) {
        switch (ctx->pc) {
            case 0x1246c4: ctx->pc = 0; goto label_1246c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1246a4: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1246a8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1246ac: 0xdba30080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1246b0: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1246b4: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1246b8: 0x4be410ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1246bc: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1246c0: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
label_1246c4:
    // 0x1246c4: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1246c8: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1246cc: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1246d0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1246d4: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1246dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1246dc
// Address: 0x1246dc - 0x1246f0

void entry_1246dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1246dc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1246e0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1246e4: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1246e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1246f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1246f0
// Address: 0x1246f0 - 0x124708

void entry_1246f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1246f0: 0x27b00070
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1246f4: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1246f8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1246fc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x124700: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x124708);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_124708
// Address: 0x124708 - 0x12471c

void entry_124708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124708: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12470c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124710: 0x8c430094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 148)));
    // 0x124714: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12471c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12471c
// Address: 0x12471c - 0x124830

void entry_12471c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12471c) {
        switch (ctx->pc) {
            case 0x124778: ctx->pc = 0; goto label_124778;
            case 0x1247a4: ctx->pc = 0; goto label_1247a4;
            case 0x1247dc: ctx->pc = 0; goto label_1247dc;
            case 0x124818: ctx->pc = 0; goto label_124818;
            case 0x124824: ctx->pc = 0; goto label_124824;
            case 0x124828: ctx->pc = 0; goto label_124828;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12471c: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x124720: 0x2e430001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 18), 1));
    // 0x124724: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x124728: 0x1062003f
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_124828;
    }
    // 0x124730: 0x1640001c
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1247a4;
    }
    // 0x124738: 0x3c03fcff
    SET_GPR_U32(ctx, 3, ((uint32_t)64767 << 16));
    // 0x12473c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x124740: 0x3c050200
    SET_GPR_U32(ctx, 5, ((uint32_t)512 << 16));
    // 0x124744: 0x3c020c00
    SET_GPR_U32(ctx, 2, ((uint32_t)3072 << 16));
    // 0x124748: 0x832024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x12474c: 0x3c060400
    SET_GPR_U32(ctx, 6, ((uint32_t)1024 << 16));
    // 0x124750: 0x852025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x124754: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x124758: 0x10460007
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 6)) {
        goto label_124778;
    }
    // 0x124760: 0x3c02f3ff
    SET_GPR_U32(ctx, 2, ((uint32_t)62463 << 16));
    // 0x124764: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x124768: 0x3c030800
    SET_GPR_U32(ctx, 3, ((uint32_t)2048 << 16));
    // 0x12476c: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x124770: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x124774: 0xfe2202c8
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 2));
label_124778:
    // 0x124778: 0xde2402c8
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x12477c: 0x3c023000
    SET_GPR_U32(ctx, 2, ((uint32_t)12288 << 16));
    // 0x124780: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x124784: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x124788: 0x10430027
    SET_GPR_U32(ctx, 3, ((uint32_t)8192 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_124828;
    }
    // 0x124790: 0x3c02cfff
    SET_GPR_U32(ctx, 2, ((uint32_t)53247 << 16));
    // 0x124794: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x124798: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x12479c: 0x10000021
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_124824;
    }
label_1247a4:
    // 0x1247a4: 0x3c03fcff
    SET_GPR_U32(ctx, 3, ((uint32_t)64767 << 16));
    // 0x1247a8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1247ac: 0x3c050100
    SET_GPR_U32(ctx, 5, ((uint32_t)256 << 16));
    // 0x1247b0: 0x3c020c00
    SET_GPR_U32(ctx, 2, ((uint32_t)3072 << 16));
    // 0x1247b4: 0x832024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1247b8: 0x3c060400
    SET_GPR_U32(ctx, 6, ((uint32_t)1024 << 16));
    // 0x1247bc: 0x852025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1247c0: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1247c4: 0x10460005
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 6)) {
        goto label_1247dc;
    }
    // 0x1247cc: 0x3c02f3ff
    SET_GPR_U32(ctx, 2, ((uint32_t)62463 << 16));
    // 0x1247d0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1247d4: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1247d8: 0xfe2202c8
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 2));
label_1247dc:
    // 0x1247dc: 0xde2502c8
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x1247e0: 0x3c023000
    SET_GPR_U32(ctx, 2, ((uint32_t)12288 << 16));
    // 0x1247e4: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x1247e8: 0xa22024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1247ec: 0x1083000e
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_124828;
    }
    // 0x1247f4: 0x14820008
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_124818;
    }
    // 0x1247fc: 0xc6210080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 128)); ctx->f[1] = *(float*)&val; }
    // 0x124800: 0x3c015015
    SET_GPR_U32(ctx, 1, ((uint32_t)20501 << 16));
    // 0x124804: 0x342102f9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 761));
    // 0x124808: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x12480c: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x124810: 0x45000005
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_124828;
    }
label_124818:
    // 0x124818: 0x3c02cfff
    SET_GPR_U32(ctx, 2, ((uint32_t)53247 << 16));
    // 0x12481c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x124820: 0xa21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
label_124824:
    // 0x124824: 0xfe2202c8
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 2));
label_124828:
    // 0x124828: 0xc049150
    SET_GPR_U32(ctx, 31, 0x124830);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateAloOrig__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_124830
// Address: 0x124830 - 0x124844

void entry_124830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124830: 0xae320018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 18));
    // 0x124834: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x124838: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x12483c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x124844);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_124844
// Address: 0x124844 - 0x124868

void entry_124844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124844) {
        switch (ctx->pc) {
            case 0x124848: ctx->pc = 0; goto label_124848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124844: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_124848:
    // 0x124848: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x12484c: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x124850: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x124854: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x124858: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12485c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x124864: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x124868; return;
}


// Function: ApplyAloProxy__FP3ALOP5PROXY
// Address: 0x124868 - 0x124898

void entry_124898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124898: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12489c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1248a0: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1248a4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1248ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1248ac
// Address: 0x1248ac - 0x1248c4

void entry_1248ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1248ac: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1248b0: 0x260600d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1248b4: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1248b8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1248bc: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1248c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1248c4
// Address: 0x1248c4 - 0x1248d8

void entry_1248c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1248c4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1248c8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1248cc: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1248d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1248d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1248d8
// Address: 0x1248d8 - 0x1248f8

void entry_1248d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1248d8: 0x8e440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1248dc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1248e0: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1248e4: 0x27a80050
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1248e8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1248ec: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1248f0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1248f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1248f8
// Address: 0x1248f8 - 0x12490c

void entry_1248f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1248f8: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1248fc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x124900: 0x26060150
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 336));
    // 0x124904: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x12490c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_12490c
// Address: 0x12490c - 0x124920

void entry_12490c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12490c: 0x26060160
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 352));
    // 0x124910: 0x27a70070
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 112));
    // 0x124914: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x124918: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x124920);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_124920
// Address: 0x124920 - 0x124958

void entry_124920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124920: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x124924: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x124928: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12492c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124930: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x124934: 0x4be418e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x124938: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12493c: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x124940: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x124944: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x124948: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12494c: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x124950: 0x60f809
    SET_GPR_U32(ctx, 31, 0x124958);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_124958
// Address: 0x124958 - 0x12496c

void entry_124958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124958: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12495c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124960: 0x8cc20094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 148)));
    // 0x124964: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12496c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12496c
// Address: 0x12496c - 0x1249a8

void entry_12496c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12496c: 0x7a030100
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x124970: 0x7a0400d0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x124974: 0x7a0500e0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 16), 224)));
    // 0x124978: 0x7a0200f0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 240)));
    // 0x12497c: 0x7e030190
    WRITE128(ADD32(GPR_U32(ctx, 16), 400), GPR_VEC(ctx, 3));
    // 0x124980: 0x7e0201c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 448), GPR_VEC(ctx, 2));
    // 0x124984: 0x7e0401a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 416), GPR_VEC(ctx, 4));
    // 0x124988: 0x7e0501b0
    WRITE128(ADD32(GPR_U32(ctx, 16), 432), GPR_VEC(ctx, 5));
    // 0x12498c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x124990: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x124994: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x124998: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12499c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1249a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1249a8; return;
}


// Function: BindAlo__FP3ALO
// Address: 0x1249a8 - 0x1249bc

void entry_1249bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1249bc: 0xc049150
    SET_GPR_U32(ctx, 31, 0x1249c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateAloOrig__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1249c4
// Address: 0x1249c4 - 0x1249e8

void entry_1249c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1249c4: 0x8e050200
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x1249c8: 0x10a0000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1249f8(rdram, ctx, runtime); return;
    }
    // 0x1249d0: 0x8ca50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x1249d4: 0x10a20009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 556));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1249FC; return;
    }
    // 0x1249dc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1249e0: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1249e8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1249e8
// Address: 0x1249e8 - 0x1249f8

void entry_1249e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1249e8: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1249f8(rdram, ctx, runtime); return;
    }
    // 0x1249f0: 0xc04aa18
    SET_GPR_U32(ctx, 31, 0x1249f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0012a860(rdram, ctx, runtime); return;
}


// Function: entry_1249f8
// Address: 0x1249f8 - 0x124a04

void entry_1249f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1249f8) {
        switch (ctx->pc) {
            case 0x1249fc: ctx->pc = 0; goto label_1249fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1249f8: 0x2604022c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 556));
label_1249fc:
    // 0x1249fc: 0xc05960a
    SET_GPR_U32(ctx, 31, 0x124a04);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BindGlobset__FP7GLOBSETP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_124a04
// Address: 0x124a04 - 0x124a2c

void entry_124a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124a04) {
        switch (ctx->pc) {
            case 0x124a18: ctx->pc = 0; goto label_124a18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124a04: 0x8e100034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x124a08: 0x1200000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124A3C; return;
    }
    // 0x124a10: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x124a14: 0x0
    // NOP
label_124a18:
    // 0x124a18: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x124a1c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x124A30; return;
    }
    // 0x124a24: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124a2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124a2c
// Address: 0x124a2c - 0x124a48

void entry_124a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124a2c) {
        switch (ctx->pc) {
            case 0x124a30: ctx->pc = 0; goto label_124a30;
            case 0x124a3c: ctx->pc = 0; goto label_124a3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124a2c: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_124a30:
    // 0x124a30: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x124A18; return;
    }
    // 0x124a38: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_124a3c:
    // 0x124a3c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x124a40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostAloLoad__FP3ALO
// Address: 0x124a48 - 0x124a90

void entry_124a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124a90) {
        switch (ctx->pc) {
            case 0x124ab8: ctx->pc = 0; goto label_124ab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124a90: 0x8e2302a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 672)));
    // 0x124a94: 0x1060000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 556));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124AD4; return;
    }
    // 0x124a9c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x124aa0: 0x14400005
    SET_GPR_U32(ctx, 5, ((uint32_t)18 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_124ab8;
    }
    // 0x124aa8: 0x8c630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x124aac: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x124ab0: 0x10620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x124AD4; return;
    }
label_124ab8:
    // 0x124ab8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x124abc: 0x24a54cc0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 19648));
    // 0x124ac0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x124ac4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124ac8: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x124ad0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_124ad0
// Address: 0x124ad0 - 0x124adc

void entry_124ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124ad0) {
        switch (ctx->pc) {
            case 0x124ad4: ctx->pc = 0; goto label_124ad4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124ad0: 0x2624022c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 556));
label_124ad4:
    // 0x124ad4: 0xc0595ca
    SET_GPR_U32(ctx, 31, 0x124adc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PostGlobsetLoad__FP7GLOBSETP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_124adc
// Address: 0x124adc - 0x124af0

void entry_124adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124adc: 0x8e240284
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x124ae0: 0x50800021
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 684)));
        ctx->pc = 0x124B68; return;
    }
    // 0x124ae8: 0xc06c74e
    SET_GPR_U32(ctx, 31, 0x124af0);
    FShadowRadiusSet__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_124af0
// Address: 0x124af0 - 0x124b04

void entry_124af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124af0: 0x5440000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 644)));
        ctx->pc = 0x124B20; return;
    }
    // 0x124af8: 0xc62c02a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 680)); ctx->f[12] = *(float*)&val; }
    // 0x124afc: 0xc06c75c
    SET_GPR_U32(ctx, 31, 0x124b04);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    SetShadowNearRadius__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_124b04
// Address: 0x124b04 - 0x124b1c

void entry_124b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124b04: 0xc62002a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 680)); ctx->f[0] = *(float*)&val; }
    // 0x124b08: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x124b0c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x124b10: 0x8e240284
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x124b14: 0xc06c76a
    SET_GPR_U32(ctx, 31, 0x124b1c);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    SetShadowFarRadius__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_124b1c
// Address: 0x124b1c - 0x124b3c

void entry_124b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124b1c) {
        switch (ctx->pc) {
            case 0x124b20: ctx->pc = 0; goto label_124b20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124b1c: 0x8e220284
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 644)));
label_124b20:
    // 0x124b20: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x124b24: 0x8c4500b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x124b28: 0x10a3000c
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        entry_124b5c(rdram, ctx, runtime); return;
    }
    // 0x124b30: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x124b34: 0xc056912
    SET_GPR_U32(ctx, 31, 0x124b3c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_124b3c
// Address: 0x124b3c - 0x124b5c

void entry_124b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124b3c: 0x8e230284
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x124b40: 0xac6200b4
    WRITE32(ADD32(GPR_U32(ctx, 3), 180), GPR_U32(ctx, 2));
    // 0x124b44: 0x8e250284
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x124b48: 0x8ca400b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 180)));
    // 0x124b4c: 0x10800003
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_124b5c(rdram, ctx, runtime); return;
    }
    // 0x124b54: 0xc054b92
    SET_GPR_U32(ctx, 31, 0x124b5c);
    SetDyshShadow__FP4DYSHP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_124b5c
// Address: 0x124b5c - 0x124b64

void entry_124b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124b5c: 0xc06c6ce
    SET_GPR_U32(ctx, 31, 0x124b64);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    PostShadowLoad__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_124b64
// Address: 0x124b64 - 0x124bb4

void entry_124b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124b64) {
        switch (ctx->pc) {
            case 0x124b68: ctx->pc = 0; goto label_124b68;
            case 0x124b7c: ctx->pc = 0; goto label_124b7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124b64: 0x8e2302ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 684)));
label_124b68:
    // 0x124b68: 0x10600012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_124bb4(rdram, ctx, runtime); return;
    }
    // 0x124b70: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x124b74: 0x50620001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 684), GPR_U32(ctx, 0));
        goto label_124b7c;
    }
label_124b7c:
    // 0x124b7c: 0x8e2202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 684)));
    // 0x124b80: 0x1040000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_124bb4(rdram, ctx, runtime); return;
    }
    // 0x124b88: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x124b8c: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x124b90: 0x2445001c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 28));
    // 0x124b94: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x124b98: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x124b9c: 0xc44e000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[14] = *(float*)&val; }
    // 0x124ba0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124ba4: 0xc44f0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[15] = *(float*)&val; }
    // 0x124ba8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124bac: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x124bb4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[16] = *(float*)&val; }
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_124bb4
// Address: 0x124bb4 - 0x124bc8

void entry_124bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124bb4: 0x8e24026c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 620)));
    // 0x124bb8: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 708)));
        ctx->pc = 0x124BD0; return;
    }
    // 0x124bc0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x124bc8);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_124bc8
// Address: 0x124bc8 - 0x124be8

void entry_124bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124bc8) {
        switch (ctx->pc) {
            case 0x124bd0: ctx->pc = 0; goto label_124bd0;
            case 0x124be0: ctx->pc = 0; goto label_124be0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124bc8: 0xae2201f8
    WRITE32(ADD32(GPR_U32(ctx, 17), 504), GPR_U32(ctx, 2));
    // 0x124bcc: 0x8e3202c4
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 708)));
label_124bd0:
    // 0x124bd0: 0x52400020
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 708), GPR_U32(ctx, 0));
        ctx->pc = 0x124C54; return;
    }
    // 0x124bd8: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x124bdc: 0x0
    // NOP
label_124be0:
    // 0x124be0: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x124be8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_124be8
// Address: 0x124be8 - 0x124c04

void entry_124be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124be8: 0x14400009
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x124C10; return;
    }
    // 0x124bf0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x124bf4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x124bf8: 0x8e460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x124bfc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x124c04);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_124c04
// Address: 0x124c04 - 0x124c18

void entry_124c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124c04) {
        switch (ctx->pc) {
            case 0x124c10: ctx->pc = 0; goto label_124c10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124c04: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x124c08: 0x5200000f
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x124C48; return;
    }
label_124c10:
    // 0x124c10: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x124c18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_124c18
// Address: 0x124c18 - 0x124c34

void entry_124c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124c18: 0x10400007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124C38; return;
    }
    // 0x124c20: 0x12110005
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x124C38; return;
    }
    // 0x124c28: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x124c2c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124c34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124c34
// Address: 0x124c34 - 0x124c44

void entry_124c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124c34) {
        switch (ctx->pc) {
            case 0x124c38: ctx->pc = 0; goto label_124c38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124c34: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_124c38:
    // 0x124c38: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x124c3c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124c44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124c44
// Address: 0x124c44 - 0x124c80

void entry_124c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124c44) {
        switch (ctx->pc) {
            case 0x124c48: ctx->pc = 0; goto label_124c48;
            case 0x124c54: ctx->pc = 0; goto label_124c54;
            case 0x124c70: ctx->pc = 0; goto label_124c70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124c44: 0x8e520004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_124c48:
    // 0x124c48: 0x5640ffe5
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x124BE0; return;
    }
    // 0x124c50: 0xae2002c4
    WRITE32(ADD32(GPR_U32(ctx, 17), 708), GPR_U32(ctx, 0));
label_124c54:
    // 0x124c54: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x124c58: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x124c5c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x124c60: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x124c64: 0x1080000d
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124C9C; return;
    }
    // 0x124c6c: 0x0
    // NOP
label_124c70:
    // 0x124c70: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x124c74: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x124c78: 0x40f809
    SET_GPR_U32(ctx, 31, 0x124c80);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_124c80
// Address: 0x124c80 - 0x124cc0

void entry_124c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124c80) {
        switch (ctx->pc) {
            case 0x124c9c: ctx->pc = 0; goto label_124c9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124c80: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x124c84: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x124c88: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x124c8c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x124c90: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x124c94: 0x1480fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x124C70; return;
    }
label_124c9c:
    // 0x124c9c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x124ca0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x124ca4: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x124ca8: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x124cac: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x124cb0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x124cb4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x124cb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostAloLoadCallback__FP3ALO5MSGIDPv
// Address: 0x124cc0 - 0x124cfc

void entry_124cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124cfc) {
        switch (ctx->pc) {
            case 0x124d00: ctx->pc = 0; goto label_124d00;
            case 0x124d2c: ctx->pc = 0; goto label_124d2c;
            case 0x124d3c: ctx->pc = 0; goto label_124d3c;
            case 0x124d48: ctx->pc = 0; goto label_124d48;
            case 0x124d7c: ctx->pc = 0; goto label_124d7c;
            case 0x124d80: ctx->pc = 0; goto label_124d80;
            case 0x124d8c: ctx->pc = 0; goto label_124d8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124cfc: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_124d00:
    // 0x124d00: 0x12200036
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_124ddc(rdram, ctx, runtime); return;
    }
    // 0x124d08: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x124d0c: 0x1062000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_124d48;
    }
    // 0x124d14: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_124d2c;
    }
    // 0x124d1c: 0x10600007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_124d3c;
    }
    // 0x124d24: 0x1000002f
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124DE4; return;
    }
label_124d2c:
    // 0x124d2c: 0x10620017
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_124d8c;
    }
    // 0x124d34: 0x1000002b
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124DE4; return;
    }
label_124d3c:
    // 0x124d3c: 0xc640000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[0] = *(float*)&val; }
    // 0x124d40: 0x1000001a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_124dac(rdram, ctx, runtime); return;
    }
label_124d48:
    // 0x124d48: 0xc640000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[0] = *(float*)&val; }
    // 0x124d4c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x124d50: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x124d54: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x124d58: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x124d5c: 0x0
    // NOP
    // 0x124d60: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 52)); ctx->f[0] = *(float*)&val; }
        goto label_124d80;
    }
    // 0x124d68: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x124d6c: 0x0
    // NOP
    // 0x124d70: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_124d7c;
    }
    // 0x124d78: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_124d7c:
    // 0x124d7c: 0xc6200034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 52)); ctx->f[0] = *(float*)&val; }
label_124d80:
    // 0x124d80: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x124d84: 0x10000009
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_124dac(rdram, ctx, runtime); return;
    }
label_124d8c:
    // 0x124d8c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x124d90: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x124d94: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124d98: 0x26060100
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 256));
    // 0x124d9c: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x124da0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124da4: 0xc04b27a
    SET_GPR_U32(ctx, 31, 0x124dac);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FindAsegClosestPoint__FP4ASEGP3ALOP6VECTORfPfT2T2(rdram, ctx, runtime); return;
}


// Function: entry_124dac
// Address: 0x124dac - 0x124ddc

void entry_124dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124dac: 0x8e220040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x124db0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x124db4: 0xafb00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 16));
    // 0x124db8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x124dbc: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x124dc0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x124dc4: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x124dc8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x124dcc: 0xc64d0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[13] = *(float*)&val; }
    // 0x124dd0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x124dd4: 0xc04b0a2
    SET_GPR_U32(ctx, 31, 0x124ddc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplyAsegOvr__FP4ASEGP3ALOiP3OVRffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_124ddc
// Address: 0x124ddc - 0x124df8

void entry_124ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124ddc) {
        switch (ctx->pc) {
            case 0x124de4: ctx->pc = 0; goto label_124de4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124ddc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x124de0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_124de4:
    // 0x124de4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x124de8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x124dec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x124df4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x124df8; return;
}


// Function: SnipAloObjects__FP3ALOiP4SNIP
// Address: 0x124df8 - 0x124e5c

void entry_124e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124e5c) {
        switch (ctx->pc) {
            case 0x124e88: ctx->pc = 0; goto label_124e88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124e5c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x124e60: 0x52200015
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
        ctx->pc = 0x124EB8; return;
    }
    // 0x124e68: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x124e6c: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x124e70: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_124e88;
    }
    // 0x124e78: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x124e7c: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x124e80: 0xac510000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 17));
    // 0x124e84: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_124e88:
    // 0x124e88: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x124e8c: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x124EA0; return;
    }
    // 0x124e94: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x124e9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_124e9c
// Address: 0x124e9c - 0x124eb4

void entry_124e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124e9c) {
        switch (ctx->pc) {
            case 0x124ea0: ctx->pc = 0; goto label_124ea0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124e9c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_124ea0:
    // 0x124ea0: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x124ea4: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_124eb4(rdram, ctx, runtime); return;
    }
    // 0x124eac: 0xc060cbc
    SET_GPR_U32(ctx, 31, 0x124eb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SubscribeLoObject__FP2LOT0(rdram, ctx, runtime); return;
}


// Function: entry_124eb4
// Address: 0x124eb4 - 0x124ee8

void entry_124eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124eb4) {
        switch (ctx->pc) {
            case 0x124eb8: ctx->pc = 0; goto label_124eb8;
            case 0x124ec0: ctx->pc = 0; goto label_124ec0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124eb4: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
label_124eb8:
    // 0x124eb8: 0x1660ffdd
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x124E30; return;
    }
label_124ec0:
    // 0x124ec0: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x124ec4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x124ec8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x124ecc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x124ed0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x124ed4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x124ed8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x124edc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x124ee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x124ee8; return;
}


// Function: UpdateAloHierarchy__FP3ALOf
// Address: 0x124ee8 - 0x124f18

void entry_124f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124f18: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x124f20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_124f20
// Address: 0x124f20 - 0x124f84

void entry_124f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124f20) {
        switch (ctx->pc) {
            case 0x124f68: ctx->pc = 0; goto label_124f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124f20: 0x10400021
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124FA8; return;
    }
    // 0x124f28: 0x26030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
    // 0x124f2c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x124f30: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x124f34: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x124f38: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x124f3c: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x124f40: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x124f44: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x124f48: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x124f4c: 0x8e030034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x124f50: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x124f54: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x124f58: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x124f5c: 0x1080000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124F9C; return;
    }
    // 0x124f64: 0x0
    // NOP
label_124f68:
    // 0x124f68: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x124f6c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x124f70: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x124f74: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x124F88; return;
    }
    // 0x124f7c: 0xc0493ba
    SET_GPR_U32(ctx, 31, 0x124f84);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateAloHierarchy__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_124f84
// Address: 0x124f84 - 0x124fc0

void entry_124f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x124f84) {
        switch (ctx->pc) {
            case 0x124f88: ctx->pc = 0; goto label_124f88;
            case 0x124f9c: ctx->pc = 0; goto label_124f9c;
            case 0x124fa8: ctx->pc = 0; goto label_124fa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x124f84: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_124f88:
    // 0x124f88: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x124f8c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x124f90: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x124f94: 0x1480fff4
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x124F68; return;
    }
label_124f9c:
    // 0x124f9c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x124fa0: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x124fa4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_124fa8:
    // 0x124fa8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x124fac: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x124fb0: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x124fb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x124fbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x124fc0; return;
}


// Function: UpdateAlo__FP3ALOf
// Address: 0x124fc0 - 0x124fec

void entry_124fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x124fec: 0x8e040284
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 644)));
    // 0x124ff0: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 648)));
        ctx->pc = 0x125004; return;
    }
    // 0x124ff8: 0xc06c850
    SET_GPR_U32(ctx, 31, 0x125000);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    UpdateShadow__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_125000
// Address: 0x125000 - 0x125014

void entry_125000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125000) {
        switch (ctx->pc) {
            case 0x125004: ctx->pc = 0; goto label_125004;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125000: 0x8e020288
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 648)));
label_125004:
    // 0x125004: 0x10400003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_125014(rdram, ctx, runtime); return;
    }
    // 0x12500c: 0xc049ab2
    SET_GPR_U32(ctx, 31, 0x125014);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateAloThrob__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_125014
// Address: 0x125014 - 0x125070

void entry_125014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125014) {
        switch (ctx->pc) {
            case 0x125058: ctx->pc = 0; goto label_125058;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125014: 0x260301e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 480));
    // 0x125018: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x12501c: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x125020: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x125024: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x125028: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x12502c: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x125030: 0x27b10014
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 20));
    // 0x125034: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x125038: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x12503c: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x125040: 0x8e0301e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 480)));
    // 0x125044: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x125048: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12504c: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x125050: 0x1080000d
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x125088; return;
    }
label_125058:
    // 0x125058: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12505c: 0x8c42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x125060: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
        ctx->pc = 0x125074; return;
    }
    // 0x125068: 0x40f809
    SET_GPR_U32(ctx, 31, 0x125070);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_125070
// Address: 0x125070 - 0x1250a8

void entry_125070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125070) {
        switch (ctx->pc) {
            case 0x125074: ctx->pc = 0; goto label_125074;
            case 0x125088: ctx->pc = 0; goto label_125088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125070: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_125074:
    // 0x125074: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x125078: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12507c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x125080: 0x1480fff5
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x125058; return;
    }
label_125088:
    // 0x125088: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x12508c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x125090: 0xafb20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 18));
    // 0x125094: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x125098: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x12509c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1250a0: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1250a8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1250a8
// Address: 0x1250a8 - 0x1250c8

void entry_1250a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1250a8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1250ac: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1250b0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1250b4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1250b8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1250bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1250c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1250c8; return;
}


// Function: InvalidateAloLighting__FP3ALO
// Address: 0x1250c8 - 0x125108

void entry_125128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125128) {
        switch (ctx->pc) {
            case 0x12512c: ctx->pc = 0; goto label_12512c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125128: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_12512c:
    // 0x12512c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x125134: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x125138; return;
}


// Function: UpdateAloXfWorldHierarchy__FP3ALO
// Address: 0x125138 - 0x125338

void entry_125338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125338) {
        switch (ctx->pc) {
            case 0x125340: ctx->pc = 0; goto label_125340;
            case 0x125350: ctx->pc = 0; goto label_125350;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125338: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_125350;
    }
label_125340:
    // 0x125340: 0x3c020fff
    SET_GPR_U32(ctx, 2, ((uint32_t)4095 << 16));
    // 0x125344: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x125348: 0xae220088
    WRITE32(ADD32(GPR_U32(ctx, 17), 136), GPR_U32(ctx, 2));
    // 0x12534c: 0x8e240284
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
label_125350:
    // 0x125350: 0x50800019
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 52)));
        ctx->pc = 0x1253B8; return;
    }
    // 0x125358: 0xc06c778
    SET_GPR_U32(ctx, 31, 0x125360);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    SetShadowCastPosition__FP6SHADOWP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_125360
// Address: 0x125360 - 0x1253a8

void entry_125360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125360: 0x8e240284
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x125364: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x125368: 0x50400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 52)));
        ctx->pc = 0x1253B8; return;
    }
    // 0x125370: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x125374: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x125378: 0x5462000f
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 52)));
        ctx->pc = 0x1253B8; return;
    }
    // 0x125380: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x125384: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x125388: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12538c: 0xda210130
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x125390: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x125394: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x125398: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12539c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1253a0: 0xc06c7b2
    SET_GPR_U32(ctx, 31, 0x1253a8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    SetShadowCastNormal__FP6SHADOWP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1253a8
// Address: 0x1253a8 - 0x1253b4

void entry_1253a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1253a8: 0x8e240284
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x1253ac: 0xc06c81a
    SET_GPR_U32(ctx, 31, 0x1253b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 288));
    SetShadowFrustrumUp__FP6SHADOWP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1253b4
// Address: 0x1253b4 - 0x1253dc

void entry_1253b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1253b4) {
        switch (ctx->pc) {
            case 0x1253b8: ctx->pc = 0; goto label_1253b8;
            case 0x1253c8: ctx->pc = 0; goto label_1253c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1253b4: 0x8e300034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 52)));
label_1253b8:
    // 0x1253b8: 0x5200000c
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 548)));
        ctx->pc = 0x1253EC; return;
    }
    // 0x1253c0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1253c4: 0x0
    // NOP
label_1253c8:
    // 0x1253c8: 0x8c42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 92)));
    // 0x1253cc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x1253E0; return;
    }
    // 0x1253d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1253dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1253dc
// Address: 0x1253dc - 0x125438

void entry_1253dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1253dc) {
        switch (ctx->pc) {
            case 0x1253e0: ctx->pc = 0; goto label_1253e0;
            case 0x1253ec: ctx->pc = 0; goto label_1253ec;
            case 0x125420: ctx->pc = 0; goto label_125420;
            case 0x125424: ctx->pc = 0; goto label_125424;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1253dc: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_1253e0:
    // 0x1253e0: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1253C8; return;
    }
    // 0x1253e8: 0x8e250224
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 548)));
label_1253ec:
    // 0x1253ec: 0x10a0000c
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32800));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_125420;
    }
    // 0x1253f4: 0x8ca200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 176)));
    // 0x1253f8: 0x30428020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32800));
    // 0x1253fc: 0x14430009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_125424;
    }
    // 0x125404: 0x8ca30080
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 128)));
    // 0x125408: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12540c: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x125410: 0xac440064
    WRITE32(ADD32(GPR_U32(ctx, 2), 100), GPR_U32(ctx, 4));
    // 0x125414: 0x8ca30084
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 132)));
    // 0x125418: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x12541c: 0xac440064
    WRITE32(ADD32(GPR_U32(ctx, 2), 100), GPR_U32(ctx, 4));
label_125420:
    // 0x125420: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_125424:
    // 0x125424: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x125428: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12542c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x125434: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x125438; return;
}


// Function: PresetAloAccel__FP3ALOf
// Address: 0x125438 - 0x125440

void entry_1254c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1254c4: 0x12200008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1254E8; return;
    }
    // 0x1254cc: 0x82230010
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1254d0: 0x10620005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1254E8; return;
    }
    // 0x1254d8: 0xc048630
    SET_GPR_U32(ctx, 31, 0x1254e0);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    ProjectActPosition__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1254e0
// Address: 0x1254e0 - 0x1254f0

void entry_1254e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1254e0) {
        switch (ctx->pc) {
            case 0x1254e8: ctx->pc = 0; goto label_1254e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1254e0: 0x10000023
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x125570; return;
    }
label_1254e8:
    // 0x1254e8: 0xc048f70
    SET_GPR_U32(ctx, 31, 0x1254f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 336));
    FIsZeroV__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1254f0
// Address: 0x1254f0 - 0x125500

void entry_1254f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1254f0: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x125508; return;
    }
    // 0x1254f8: 0xc048f92
    SET_GPR_U32(ctx, 31, 0x125500);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 368));
    FIsZeroDv__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_125500
// Address: 0x125500 - 0x12558c

void entry_125500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125500) {
        switch (ctx->pc) {
            case 0x125508: ctx->pc = 0; goto label_125508;
            case 0x125570: ctx->pc = 0; goto label_125570;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125500: 0x1440001b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_125570;
    }
label_125508:
    // 0x125508: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x12550c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x125510: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x125514: 0xda030150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x125518: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x12551c: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x125520: 0xda020100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x125524: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x125528: 0xda050170
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 368)));
    // 0x12552c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x125530: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x125534: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x125538: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12553c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x125540: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x125544: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x125548: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x12554c: 0x4be418bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x125550: 0x4be12888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125554: 0xfa020100
    WRITE128(ADD32(GPR_U32(ctx, 16), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x125558: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12555c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x125560: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x125564: 0x4be128c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125568: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12556c: 0xfa030150
    WRITE128(ADD32(GPR_U32(ctx, 16), 336), _mm_castps_si128(ctx->vu0_vf[3]));
label_125570:
    // 0x125570: 0x12400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x125594; return;
    }
    // 0x125578: 0x82430011
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 17)));
    // 0x12557c: 0x10620005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x125594; return;
    }
    // 0x125584: 0xc048778
    SET_GPR_U32(ctx, 31, 0x12558c);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    ProjectActRotation__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_12558c
// Address: 0x12558c - 0x12559c

void entry_12558c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12558c) {
        switch (ctx->pc) {
            case 0x125594: ctx->pc = 0; goto label_125594;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12558c: 0x1000003e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x125688; return;
    }
label_125594:
    // 0x125594: 0xc048f80
    SET_GPR_U32(ctx, 31, 0x12559c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 352));
    FIsZeroW__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12559c
// Address: 0x12559c - 0x1255ac

void entry_12559c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12559c: 0x10400006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1255B8; return;
    }
    // 0x1255a4: 0xc048fa2
    SET_GPR_U32(ctx, 31, 0x1255ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 384));
    FIsZeroDw__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1255ac
// Address: 0x1255ac - 0x125618

void entry_1255ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1255ac) {
        switch (ctx->pc) {
            case 0x1255b8: ctx->pc = 0; goto label_1255b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1255ac: 0x14400036
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x125688; return;
    }
    // 0x1255b4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1255b8:
    // 0x1255b8: 0xda030160
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x1255bc: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1255c0: 0xda020180
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 384)));
    // 0x1255c4: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1255c8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1255cc: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1255d0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1255d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1255d8: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1255dc: 0x4be11088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1255e0: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1255e4: 0xfa020160
    WRITE128(ADD32(GPR_U32(ctx, 16), 352), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1255e8: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1255ec: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1255f0: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1255f4: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1255f8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1255fc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x125600: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x125604: 0x4be119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x125608: 0x4be110c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12560c: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x125610: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x125618);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_125618
// Address: 0x125618 - 0x125684

void entry_125618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125618: 0xda0400d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x12561c: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x125620: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x125624: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x125628: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12562c: 0xdba50040
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x125630: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x125634: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x125638: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12563c: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125640: 0xfba40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125644: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x125648: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x12564c: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x125650: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125654: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x125658: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x12565c: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x125660: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x125664: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x125668: 0x4bc128ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12566c: 0xfa0400d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125670: 0xfa0200e0
    WRITE128(ADD32(GPR_U32(ctx, 16), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x125674: 0xfa0300f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125678: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12567c: 0xc062428
    SET_GPR_U32(ctx, 31, 0x125684);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    NormalizeRotateMatrix3__FP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_125684
// Address: 0x125684 - 0x1256e0

void entry_125684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125684) {
        switch (ctx->pc) {
            case 0x125688: ctx->pc = 0; goto label_125688;
            case 0x1256c0: ctx->pc = 0; goto label_1256c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125684: 0x26030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
label_125688:
    // 0x125688: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x12568c: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x125690: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x125694: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x125698: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x12569c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1256a0: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1256a4: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1256a8: 0x8e030034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1256ac: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1256b0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1256b4: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1256b8: 0x1080000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1256F8; return;
    }
label_1256c0:
    // 0x1256c0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1256c4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1256c8: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1256cc: 0x10400004
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1256e0(rdram, ctx, runtime); return;
    }
    // 0x1256d4: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1256d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1256e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1256e0
// Address: 0x1256e0 - 0x125720

void entry_1256e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1256e0) {
        switch (ctx->pc) {
            case 0x1256f8: ctx->pc = 0; goto label_1256f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1256e0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1256e4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1256e8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1256ec: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1256f0: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1256C0; return;
    }
label_1256f8:
    // 0x1256f8: 0x1260000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x125724; return;
    }
    // 0x125700: 0x16800009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x125728; return;
    }
    // 0x125708: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12570c: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x125710: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
        ctx->pc = 0x125728; return;
    }
    // 0x125718: 0x40f809
    SET_GPR_U32(ctx, 31, 0x125720);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_125720
// Address: 0x125720 - 0x125750

void entry_125720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125720) {
        switch (ctx->pc) {
            case 0x125724: ctx->pc = 0; goto label_125724;
            case 0x125728: ctx->pc = 0; goto label_125728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125720: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_125724:
    // 0x125724: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
label_125728:
    // 0x125728: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x12572c: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x125730: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x125734: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x125738: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x12573c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x125740: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x125744: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12574c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x125750; return;
}


// Function: PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3
// Address: 0x125750 - 0x12584c

void entry_12584c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12584c) {
        switch (ctx->pc) {
            case 0x1258ac: ctx->pc = 0; goto label_1258ac;
            case 0x1258b0: ctx->pc = 0; goto label_1258b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12584c: 0xdba100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x125850: 0xdba70070
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x125854: 0xdba60080
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x125858: 0xdba50090
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12585c: 0x4bc139bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x125860: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x125864: 0x4bc1290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125868: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12586c: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x125870: 0xfba400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125874: 0x1220000d
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1258ac;
    }
    // 0x12587c: 0xdba300e0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x125880: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x125884: 0x4bc339bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x125888: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x12588c: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125890: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x125894: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x125898: 0x4bc40afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[4] = READ32(addr); }
    // 0x12589c: 0x4bc1206e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1258a0: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1258a4: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1258a8: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
label_1258ac:
    // 0x1258ac: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1258b0:
    // 0x1258b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1258b4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1258b8: 0x27a500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1258bc: 0x8c62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 156)));
    // 0x1258c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1258c8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1258c8
// Address: 0x1258c8 - 0x1259d8

void entry_1258c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1258c8) {
        switch (ctx->pc) {
            case 0x1258d8: ctx->pc = 0; goto label_1258d8;
            case 0x125900: ctx->pc = 0; goto label_125900;
            case 0x125968: ctx->pc = 0; goto label_125968;
            case 0x125974: ctx->pc = 0; goto label_125974;
            case 0x125990: ctx->pc = 0; goto label_125990;
            case 0x12599c: ctx->pc = 0; goto label_12599c;
            case 0x1259a8: ctx->pc = 0; goto label_1259a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1258c8: 0x16c00003
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        goto label_1258d8;
    }
    // 0x1258d0: 0x1220000b
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_125900;
    }
label_1258d8:
    // 0x1258d8: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1258dc: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1258e0: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1258e4: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1258e8: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1258ec: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1258f0: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1258f4: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1258f8: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1258fc: 0xdba40070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_125900:
    // 0x125900: 0x2673fffc
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967292));
    // 0x125904: 0xdba60080
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x125908: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x12590c: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x125910: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x125914: 0xdba500b0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x125918: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x12591c: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x125920: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125924: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x125928: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x12592c: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125930: 0xdba200c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x125934: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x125938: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12593c: 0x4bc2090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125940: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125944: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x125948: 0xfba40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12594c: 0xfba30130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125950: 0xfba30100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125954: 0xfba50140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x125958: 0xfba50110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x12595c: 0xfba40150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125960: 0x641ffaf
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x125820; return;
    }
label_125968:
    // 0x125968: 0x12800002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_125974;
    }
    // 0x125970: 0x7e820000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), GPR_VEC(ctx, 2));
label_125974:
    // 0x125974: 0x12a00006
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_125990;
    }
    // 0x12597c: 0x7ba40080
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x125980: 0x7ba30090
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x125984: 0x7ea20000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), GPR_VEC(ctx, 2));
    // 0x125988: 0x7ea30020
    WRITE128(ADD32(GPR_U32(ctx, 21), 32), GPR_VEC(ctx, 3));
    // 0x12598c: 0x7ea40010
    WRITE128(ADD32(GPR_U32(ctx, 21), 16), GPR_VEC(ctx, 4));
label_125990:
    // 0x125990: 0x12200002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_12599c;
    }
    // 0x125998: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
label_12599c:
    // 0x12599c: 0x12c00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_1259a8;
    }
    // 0x1259a4: 0x7ec20000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
label_1259a8:
    // 0x1259a8: 0x7bbf01d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1259ac: 0x7bb601c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1259b0: 0x7bb501b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1259b4: 0x7bb401a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1259b8: 0x7bb30190
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1259bc: 0x7bb20180
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1259c0: 0x7bb10170
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1259c4: 0x7bb00160
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1259c8: 0xc7b401e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[20] = *(float*)&val; }
    // 0x1259cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 496));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1259d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1259d8; return;
}


// Function: PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3
// Address: 0x1259d8 - 0x125a34

void entry_125a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125a34) {
        switch (ctx->pc) {
            case 0x125a4c: ctx->pc = 0; goto label_125a4c;
            case 0x125a78: ctx->pc = 0; goto label_125a78;
            case 0x125a80: ctx->pc = 0; goto label_125a80;
            case 0x125ac4: ctx->pc = 0; goto label_125ac4;
            case 0x125af0: ctx->pc = 0; goto label_125af0;
            case 0x125b54: ctx->pc = 0; goto label_125b54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125a34: 0x56400005
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_125a4c;
    }
    // 0x125a3c: 0x12000021
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_125ac4;
    }
    // 0x125a44: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_125a78;
    }
label_125a4c:
    // 0x125a4c: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x125a50: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x125a54: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x125a58: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x125a5c: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x125a60: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125a64: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x125a68: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x125a6c: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125a70: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_125a80;
    }
label_125a78:
    // 0x125a78: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x125a7c: 0x7fa30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 3));
label_125a80:
    // 0x125a80: 0x12000010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_125ac4;
    }
    // 0x125a88: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x125a8c: 0xda040000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x125a90: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x125a94: 0x4bc429bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x125a98: 0x4bc418bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x125a9c: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125aa0: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x125aa4: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x125aa8: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x125aac: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x125ab0: 0x4bc30afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[3] = READ32(addr); }
    // 0x125ab4: 0x4bc1186e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125ab8: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x125abc: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x125ac0: 0xfa020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_125ac4:
    // 0x125ac4: 0x1260000a
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_125af0;
    }
    // 0x125acc: 0xda630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x125ad0: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x125ad4: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x125ad8: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x125adc: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x125ae0: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x125ae4: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125ae8: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x125aec: 0xfa610000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_125af0:
    // 0x125af0: 0x12200018
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_125b54;
    }
    // 0x125af8: 0xda230000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x125afc: 0xda250010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x125b00: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x125b04: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x125b08: 0xda260020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x125b0c: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x125b10: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x125b14: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125b18: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x125b1c: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x125b20: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125b24: 0xfa230000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125b28: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x125b2c: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x125b30: 0x4bc6104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125b34: 0xfa250010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x125b38: 0xfa210020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x125b3c: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125b40: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x125b44: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x125b48: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x125b4c: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x125b50: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
label_125b54:
    // 0x125b54: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x125b58: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x125b5c: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x125b60: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x125b64: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x125b68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DupAloRo__FP3ALOP2ROT1
// Address: 0x125b70 - 0x125bcc

void entry_125bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125bcc) {
        switch (ctx->pc) {
            case 0x125bdc: ctx->pc = 0; goto label_125bdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125bcc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x125bd0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x125bd4: 0xe6000040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 64), *(uint32_t*)&val); }
    // 0x125bd8: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
label_125bdc:
    // 0x125bdc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x125be0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x125be4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x125bec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x125bf0; return;
}


// Function: RenderFastShadow__FP3ALOP2CMP2RO
// Address: 0x125bf0 - 0x125c40

void entry_125c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125c40: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x125c44: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x125c48: 0x24a583d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935504));
    // 0x125c4c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125c50: 0xc062304
    SET_GPR_U32(ctx, 31, 0x125c58);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_125c58
// Address: 0x125c58 - 0x125c78

void entry_125c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125c58: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x125c5c: 0x8c441d2c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7468)));
    // 0x125c60: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_125c78(rdram, ctx, runtime); return;
    }
    // 0x125c68: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x125c6c: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x125c70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x125c78);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_125c78
// Address: 0x125c78 - 0x125c90

void entry_125c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125c78: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x125c7c: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x125c80: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x125c84: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x125c88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderAloAll__FP3ALOP2CMP2RO
// Address: 0x125c90 - 0x125d9c

void entry_125d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125d9c: 0x104000fb
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12618c(rdram, ctx, runtime); return;
    }
    // 0x125da4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x125da8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x125dac: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x125db0: 0x0
    // NOP
    // 0x125db4: 0x4503000b
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 132)); ctx->f[13] = *(float*)&val; }
        ctx->pc = 0x125DE4; return;
    }
    // 0x125dbc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x125dc0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x125dc4: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x125dcc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_125dcc
// Address: 0x125dcc - 0x125e08

void entry_125dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125dcc) {
        switch (ctx->pc) {
            case 0x125de4: ctx->pc = 0; goto label_125de4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125dcc: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x125dd0: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125dd4: 0xc7a101b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[1] = *(float*)&val; }
    // 0x125dd8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x125ddc: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x125de0: 0xc66d0084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 132)); ctx->f[13] = *(float*)&val; }
label_125de4:
    // 0x125de4: 0xc6600080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 128)); ctx->f[0] = *(float*)&val; }
    // 0x125de8: 0x46006834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x125dec: 0x0
    // NOP
    // 0x125df0: 0x45000015
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x125E48; return;
    }
    // 0x125df8: 0xc66c02a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 680)); ctx->f[12] = *(float*)&val; }
    // 0x125dfc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x125e00: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x125e08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_125e08
// Address: 0x125e08 - 0x125e34

void entry_125e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125e08) {
        switch (ctx->pc) {
            case 0x125e10: ctx->pc = 0; goto label_125e10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125e08: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 432), GPR_U32(ctx, 0));
        goto label_125e10;
    }
label_125e10:
    // 0x125e10: 0xc7a001b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[0] = *(float*)&val; }
    // 0x125e14: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x125e18: 0x0
    // NOP
    // 0x125e1c: 0x4503000b
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 664)));
        ctx->pc = 0x125E4C; return;
    }
    // 0x125e24: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x125e28: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x125e2c: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x125e34);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_125e34
// Address: 0x125e34 - 0x125e60

void entry_125e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125e34) {
        switch (ctx->pc) {
            case 0x125e48: ctx->pc = 0; goto label_125e48;
            case 0x125e4c: ctx->pc = 0; goto label_125e4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125e34: 0xc7a00044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[0] = *(float*)&val; }
    // 0x125e38: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125e3c: 0xc7a101b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[1] = *(float*)&val; }
    // 0x125e40: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x125e44: 0xe7a00044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
label_125e48:
    // 0x125e48: 0x8e620298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 664)));
label_125e4c:
    // 0x125e4c: 0x1040000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x125E78; return;
    }
    // 0x125e54: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x125e58: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x125e60);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_125e60
// Address: 0x125e60 - 0x125eec

void entry_125e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125e60) {
        switch (ctx->pc) {
            case 0x125e78: ctx->pc = 0; goto label_125e78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125e60: 0x8e620298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 664)));
    // 0x125e64: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125e68: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x125e6c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x125e70: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x125e74: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
label_125e78:
    // 0x125e78: 0x52400049
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125e80: 0x8e630224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 548)));
    // 0x125e84: 0x50600046
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125e8c: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x125e90: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x125e94: 0x50400042
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125e9c: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x125ea0: 0x5040003f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125ea8: 0x8e620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x125eac: 0x5040003c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125eb4: 0x8c4401f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 500)));
    // 0x125eb8: 0x50800039
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125ec0: 0x8c420224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 548)));
    // 0x125ec4: 0x50400036
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125ecc: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x125ed0: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x125ed4: 0x50400032
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
        ctx->pc = 0x125FA0; return;
    }
    // 0x125edc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x125ee0: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x125ee4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x125eec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_125eec
// Address: 0x125eec - 0x125f28

void entry_125eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125eec: 0xc7a20060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[2] = *(float*)&val; }
    // 0x125ef0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x125ef4: 0xc7a10088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[1] = *(float*)&val; }
    // 0x125ef8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125efc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x125f00: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x125f04: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x125f08: 0xc7a30074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 116)); ctx->f[3] = *(float*)&val; }
    // 0x125f0c: 0x46010043
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[1];
    // 0x125f10: 0x46020083
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[2] = ctx->f[0] / ctx->f[2];
    // 0x125f14: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x125f18: 0xe7a10088
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    // 0x125f1c: 0xe7a20060
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x125f20: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x125f28);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 116), *(uint32_t*)&val); }
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_125f28
// Address: 0x125f28 - 0x125f98

void entry_125f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125f28: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x125f2c: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x125f30: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x125f34: 0x27a50090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    // 0x125f38: 0xdba30080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x125f3c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125f40: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x125f44: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x125f48: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x125f4c: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x125f50: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125f54: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x125f58: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x125f5c: 0x4bc4190a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125f60: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x125f64: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x125f68: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x125f6c: 0x4bc5184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x125f70: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x125f74: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125f78: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x125f7c: 0xfba200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x125f80: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x125f84: 0xfba40100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125f88: 0xfba400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x125f8c: 0xfba10110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x125f90: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x125f98);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_125f98
// Address: 0x125f98 - 0x125fb8

void entry_125f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125f98) {
        switch (ctx->pc) {
            case 0x125fa0: ctx->pc = 0; goto label_125fa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125f98: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125f9c: 0x8e6401f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 500)));
label_125fa0:
    // 0x125fa0: 0x1080001c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x126014; return;
    }
    // 0x125fa8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x125fac: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x125fb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x125fb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_125fb8
// Address: 0x125fb8 - 0x125fd0

void entry_125fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125fb8: 0x27b10080
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 128));
    // 0x125fbc: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x125fc0: 0x24848d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937904));
    // 0x125fc4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x125fc8: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x125fd0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_125fd0
// Address: 0x125fd0 - 0x125fe0

void entry_125fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125fd0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x125fd4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125fd8: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x125fe0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_125fe0
// Address: 0x125fe0 - 0x125ff0

void entry_125fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x125fe0: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x125fe4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125fe8: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x125ff0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_125ff0
// Address: 0x125ff0 - 0x12602c

void entry_125ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x125ff0) {
        switch (ctx->pc) {
            case 0x126014: ctx->pc = 0; goto label_126014;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x125ff0: 0x7ba500c0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x125ff4: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x125ff8: 0x7ba200d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x125ffc: 0x7ba300e0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x126000: 0x7ba400f0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x126004: 0x7fa50000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 5));
    // 0x126008: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x12600c: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x126010: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
label_126014:
    // 0x126014: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x126018: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12601c: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x126020: 0x8c6200a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 164)));
    // 0x126024: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12602c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12602c
// Address: 0x12602c - 0x126060

void entry_12602c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12602c) {
        switch (ctx->pc) {
            case 0x126040: ctx->pc = 0; goto label_126040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12602c: 0x16400011
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 52)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x126074; return;
    }
    // 0x126034: 0x5200004d
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 652)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x12616C; return;
    }
    // 0x12603c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_126040:
    // 0x126040: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x126044: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x126048: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_126060(rdram, ctx, runtime); return;
    }
    // 0x126050: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x126054: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x126058: 0x40f809
    SET_GPR_U32(ctx, 31, 0x126060);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_126060
// Address: 0x126060 - 0x1260c8

void entry_126060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126060) {
        switch (ctx->pc) {
            case 0x126074: ctx->pc = 0; goto label_126074;
            case 0x126090: ctx->pc = 0; goto label_126090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126060: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x126064: 0x5600fff6
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x126040; return;
    }
    // 0x12606c: 0x1000003f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 652)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12616C; return;
    }
label_126074:
    // 0x126074: 0x1200003c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 160));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x126168; return;
    }
    // 0x12607c: 0x27b600e0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 224));
    // 0x126080: 0x27b70130
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 304));
    // 0x126084: 0x27b40170
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 368));
    // 0x126088: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12608c: 0x0
    // NOP
label_126090:
    // 0x126090: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x126094: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x126098: 0x50400031
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x126160; return;
    }
    // 0x1260a0: 0x8e020224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x1260a4: 0x10400014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 256));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1260F8; return;
    }
    // 0x1260ac: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x1260b0: 0x3042000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 12));
    // 0x1260b4: 0x1040000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1260F4; return;
    }
    // 0x1260bc: 0x26050110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1260c0: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1260c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1260c8
// Address: 0x1260c8 - 0x1260d8

void entry_1260c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1260c8: 0x26640140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 320));
    // 0x1260cc: 0x26650110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 272));
    // 0x1260d0: 0xc0622d2
    SET_GPR_U32(ctx, 31, 0x1260d8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRotInverse__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1260d8
// Address: 0x1260d8 - 0x1260e8

void entry_1260d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1260d8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1260dc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1260e0: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x1260e8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1260e8
// Address: 0x1260e8 - 0x126104

void entry_1260e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1260e8) {
        switch (ctx->pc) {
            case 0x1260f4: ctx->pc = 0; goto label_1260f4;
            case 0x1260f8: ctx->pc = 0; goto label_1260f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1260e8: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1260ec: 0x10000007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12610C; return;
    }
label_1260f4:
    // 0x1260f4: 0x26040100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 256));
label_1260f8:
    // 0x1260f8: 0x260500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1260fc: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x126104);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_126104
// Address: 0x126104 - 0x126114

void entry_126104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126104) {
        switch (ctx->pc) {
            case 0x12610c: ctx->pc = 0; goto label_12610c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126104: 0x27a40130
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 304));
    // 0x126108: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_12610c:
    // 0x12610c: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x126114);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_126114
// Address: 0x126114 - 0x12615c

void entry_126114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126114: 0x7ba20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x126118: 0x7ba30140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x12611c: 0x7ba40150
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x126120: 0x7ba50160
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x126124: 0x7fa20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    // 0x126128: 0x7fa30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 3));
    // 0x12612c: 0x7fa40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 4));
    // 0x126130: 0x7fa50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 5));
    // 0x126134: 0xc6410040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 64)); ctx->f[1] = *(float*)&val; }
    // 0x126138: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12613c: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x126140: 0xe7a10090
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x126144: 0xc6400044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 68)); ctx->f[0] = *(float*)&val; }
    // 0x126148: 0xe7a00094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 148), *(uint32_t*)&val); }
    // 0x12614c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x126150: 0x8c4300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 160)));
    // 0x126154: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12615c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12615c
// Address: 0x12615c - 0x12618c

void entry_12615c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12615c) {
        switch (ctx->pc) {
            case 0x126160: ctx->pc = 0; goto label_126160;
            case 0x126168: ctx->pc = 0; goto label_126168;
            case 0x12616c: ctx->pc = 0; goto label_12616c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12615c: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_126160:
    // 0x126160: 0x5600ffcb
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x126090; return;
    }
label_126168:
    // 0x126168: 0xc661028c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 652)); ctx->f[1] = *(float*)&val; }
label_12616c:
    // 0x12616c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x126170: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126174: 0x0
    // NOP
    // 0x126178: 0x45000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_12618c(rdram, ctx, runtime); return;
    }
    // 0x126180: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x126184: 0xc0496fc
    SET_GPR_U32(ctx, 31, 0x12618c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderFastShadow__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_12618c
// Address: 0x12618c - 0x1261c0

void entry_12618c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12618c) {
        switch (ctx->pc) {
            case 0x126190: ctx->pc = 0; goto label_126190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12618c: 0x7bbf0250
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 592)));
label_126190:
    // 0x126190: 0x7bb70240
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x126194: 0x7bb60230
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x126198: 0x7bb50220
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x12619c: 0x7bb40210
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1261a0: 0x7bb30200
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1261a4: 0x7bb201f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x1261a8: 0x7bb101e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x1261ac: 0x7bb001d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1261b0: 0xc7b40260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 608)); ctx->f[20] = *(float*)&val; }
    // 0x1261b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 624));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1261bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1261c0; return;
}


// Function: RenderAloSelf__FP3ALOP2CMP2RO
// Address: 0x1261c0 - 0x1261ec

void entry_1261ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1261ec) {
        switch (ctx->pc) {
            case 0x12623c: ctx->pc = 0; goto label_12623c;
            case 0x126240: ctx->pc = 0; goto label_126240;
            case 0x126244: ctx->pc = 0; goto label_126244;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1261ec: 0x8e230224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 548)));
    // 0x1261f0: 0x50600014
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_126244;
    }
    // 0x1261f8: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x1261fc: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x126200: 0x50400010
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_126244;
    }
    // 0x126208: 0x1200000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_12623c;
    }
    // 0x126210: 0xac6200a4
    WRITE32(ADD32(GPR_U32(ctx, 3), 164), GPR_U32(ctx, 2));
    // 0x126214: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x126218: 0x8e240224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 548)));
    // 0x12621c: 0x7c820060
    WRITE128(ADD32(GPR_U32(ctx, 4), 96), GPR_VEC(ctx, 2));
    // 0x126220: 0x7a030010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x126224: 0x7c830070
    WRITE128(ADD32(GPR_U32(ctx, 4), 112), GPR_VEC(ctx, 3));
    // 0x126228: 0x7a020020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x12622c: 0x7c820080
    WRITE128(ADD32(GPR_U32(ctx, 4), 128), GPR_VEC(ctx, 2));
    // 0x126230: 0x7a030030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x126234: 0x10000002
    WRITE128(ADD32(GPR_U32(ctx, 4), 144), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_126240;
    }
label_12623c:
    // 0x12623c: 0xac6000a4
    WRITE32(ADD32(GPR_U32(ctx, 3), 164), GPR_U32(ctx, 0));
label_126240:
    // 0x126240: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_126244:
    // 0x126244: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x126248: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12624c: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x126250: 0x40f809
    SET_GPR_U32(ctx, 31, 0x126258);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_126258
// Address: 0x126258 - 0x126270

void entry_126258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126258: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12625c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x126260: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x126264: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x126268: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderAloGlobset__FP3ALOP2CMP2RO
// Address: 0x126270 - 0x1262cc

void entry_1262cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1262cc: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1262d0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1262d4: 0xc0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1262d8: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x1262e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_1262e0
// Address: 0x1262e0 - 0x12639c

void entry_1262e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1262e0) {
        switch (ctx->pc) {
            case 0x126310: ctx->pc = 0; goto label_126310;
            case 0x126364: ctx->pc = 0; goto label_126364;
            case 0x126388: ctx->pc = 0; goto label_126388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1262e0: 0x3c020016
    SET_GPR_U32(ctx, 2, ((uint32_t)22 << 16));
    // 0x1262e4: 0x8e440238
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 568)));
    // 0x1262e8: 0x24426690
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 26256));
    // 0x1262ec: 0x2643022c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 556));
    // 0x1262f0: 0xc7b50050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[21] = *(float*)&val; }
    // 0x1262f4: 0xc7b40054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[20] = *(float*)&val; }
    // 0x1262f8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1262fc: 0xafa30074
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 3));
    // 0x126300: 0x1880013e
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 18));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1267FC; return;
    }
    // 0x126308: 0x24020070
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 112));
    // 0x12630c: 0x0
    // NOP
label_126310:
    // 0x126310: 0x8e43023c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 572)));
    // 0x126314: 0x2a21018
    { int64_t result = (int64_t)GPR_S32(ctx, 21) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x126318: 0x8e460240
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 576)));
    // 0x12631c: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x126320: 0x10c00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_126364;
    }
    // 0x126328: 0x24030028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 40));
    // 0x12632c: 0xde4402c8
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 18), 712)));
    // 0x126330: 0x2a31018
    { int64_t result = (int64_t)GPR_S32(ctx, 21) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x126334: 0x3c050400
    SET_GPR_U32(ctx, 5, ((uint32_t)1024 << 16));
    // 0x126338: 0x461821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x12633c: 0x3c020c00
    SET_GPR_U32(ctx, 2, ((uint32_t)3072 << 16));
    // 0x126340: 0x60a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x126344: 0x822024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x126348: 0x14850006
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 5)) {
        goto label_126364;
    }
    // 0x126350: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x126354: 0x8e63021c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 540)));
    // 0x126358: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12635c: 0x54430123
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 568)));
        ctx->pc = 0x1267EC; return;
    }
label_126364:
    // 0x126364: 0xde4202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 712)));
    // 0x126368: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x12636c: 0x31cb8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 18);
    // 0x126370: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x126374: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_126388;
    }
    // 0x12637c: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x126380: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12639c(rdram, ctx, runtime); return;
    }
label_126388:
    // 0x126388: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12638c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x126390: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x126394: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x12639c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 96));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_12639c
// Address: 0x12639c - 0x126424

void entry_12639c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12639c: 0xde4202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 712)));
    // 0x1263a0: 0x3c033000
    SET_GPR_U32(ctx, 3, ((uint32_t)12288 << 16));
    // 0x1263a4: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1263a8: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x1263ac: 0xda610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1263b0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1263b4: 0x14440035
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x12648C; return;
    }
    // 0x1263bc: 0xc60c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1263c0: 0x4be00153
    // Unhandled VU0 Special1 function: 0x13
    // 0x1263c4: 0xda630050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 80)));
    // 0x1263c8: 0x44036000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[12]);
    // 0x1263cc: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1263d0: 0xda620060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 96)));
    // 0x1263d4: 0xda610070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 112)));
    // 0x1263d8: 0x4be619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1263dc: 0x4be610bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1263e0: 0x4be608be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[6] = READ32(addr); }
    // 0x1263e4: 0x4be428fc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1263e8: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1263ec: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1263f0: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1263f4: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1263f8: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x1263fc: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x126400: 0x144000f9
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1267e8(rdram, ctx, runtime); return;
    }
    // 0x126408: 0x27b10110
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 272));
    // 0x12640c: 0xc60d001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[13] = *(float*)&val; }
    // 0x126410: 0x48253000
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x126414: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x126418: 0xfba60120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x12641c: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x126424);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_126424
// Address: 0x126424 - 0x12646c

void entry_126424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126424: 0x104000f0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1267e8(rdram, ctx, runtime); return;
    }
    // 0x12642c: 0xc7a00110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[0] = *(float*)&val; }
    // 0x126430: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x126434: 0xe7a00050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x126438: 0x8e020060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x12643c: 0x5040002a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 48)));
        ctx->pc = 0x1264E8; return;
    }
    // 0x126444: 0xc60d0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[13] = *(float*)&val; }
    // 0x126448: 0xc600001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[0] = *(float*)&val; }
    // 0x12644c: 0x46006834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126450: 0x0
    // NOP
    // 0x126454: 0x45000023
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[6]));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1264E4; return;
    }
    // 0x12645c: 0xc60c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[12] = *(float*)&val; }
    // 0x126460: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x126464: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x12646c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_12646c
// Address: 0x12646c - 0x1265d0

void entry_12646c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12646c) {
        switch (ctx->pc) {
            case 0x12647c: ctx->pc = 0; goto label_12647c;
            case 0x12648c: ctx->pc = 0; goto label_12648c;
            case 0x1264e0: ctx->pc = 0; goto label_1264e0;
            case 0x1264e4: ctx->pc = 0; goto label_1264e4;
            case 0x1264e8: ctx->pc = 0; goto label_1264e8;
            case 0x126558: ctx->pc = 0; goto label_126558;
            case 0x126564: ctx->pc = 0; goto label_126564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12646c: 0x14400003
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12647c;
    }
    // 0x126474: 0x1000001b
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1264e4;
    }
label_12647c:
    // 0x12647c: 0xc7a00110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[0] = *(float*)&val; }
    // 0x126480: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x126484: 0x10000017
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1264e4;
    }
label_12648c:
    // 0x12648c: 0x56e00014
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
        goto label_1264e0;
    }
    // 0x126494: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x126498: 0x4be00153
    // Unhandled VU0 Special1 function: 0x13
    // 0x12649c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1264a0: 0xda630050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 80)));
    // 0x1264a4: 0xda620060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 96)));
    // 0x1264a8: 0xda610070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 112)));
    // 0x1264ac: 0x4be619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1264b0: 0x4be610bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1264b4: 0x4be608be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[6] = READ32(addr); }
    // 0x1264b8: 0x4be428fc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1264bc: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1264c0: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1264c4: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1264c8: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1264cc: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x1264d0: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x1264d4: 0x144000c4
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1267e8(rdram, ctx, runtime); return;
    }
    // 0x1264dc: 0xe7b50050
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
label_1264e0:
    // 0x1264e0: 0xe7b40054
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
label_1264e4:
    // 0x1264e4: 0x8e020030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 48)));
label_1264e8:
    // 0x1264e8: 0x1040003d
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1265E0; return;
    }
    // 0x1264f0: 0xd8440000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1264f4: 0xdac20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 16)));
    // 0x1264f8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1264fc: 0xdac10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 32)));
    // 0x126500: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x126504: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x126508: 0x4bc410bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x12650c: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x126510: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x126514: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x126518: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12651c: 0x4bc420aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x126520: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x126524: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x126528: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12652c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x126530: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x126534: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x126538: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x12653c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x126540: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x126544: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126548: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_126558;
    }
    // 0x126550: 0x10000004
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_126564;
    }
label_126558:
    // 0x126558: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x12655c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x126560: 0x4be0211c
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_126564:
    // 0x126564: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x126568: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x12656c: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x126570: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x126574: 0x24845c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x126578: 0xd8610080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x12657c: 0x4bc1206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x126580: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x126584: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x126588: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12658c: 0x8e050030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x126590: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x126594: 0x44836000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 3);
    // 0x126598: 0x24a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 16));
    // 0x12659c: 0x46006305
    ctx->f[12] = FPU_ABS_S(ctx->f[12]);
    // 0x1265a0: 0xc441000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[1] = *(float*)&val; }
    // 0x1265a4: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1265a8: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1265ac: 0x46016042
    ctx->f[1] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x1265b0: 0xc4a30010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 16)); ctx->f[3] = *(float*)&val; }
    // 0x1265b4: 0xfba60120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1265b8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1265bc: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1265c0: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1265c4: 0x46026302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    // 0x1265c8: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x1265d0);
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[12]);
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1265d0
// Address: 0x1265d0 - 0x12663c

void entry_1265d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1265d0) {
        switch (ctx->pc) {
            case 0x1265e0: ctx->pc = 0; goto label_1265e0;
            case 0x126614: ctx->pc = 0; goto label_126614;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1265d0: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x1265d4: 0xdba60120
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1265d8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1265dc: 0xe7a10050
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
label_1265e0:
    // 0x1265e0: 0x1280001c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x126654; return;
    }
    // 0x1265e8: 0xc6810014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1265ec: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1265f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1265f4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1265f8: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1265fc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126600: 0x0
    // NOP
    // 0x126604: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 16)); ctx->f[12] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_126614;
    }
    // 0x12660c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x126610: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
label_126614:
    // 0x126614: 0x460c6832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[13], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126618: 0x0
    // NOP
    // 0x12661c: 0x4501000a
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[0] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x126648; return;
    }
    // 0x126624: 0xc44e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[14] = *(float*)&val; }
    // 0x126628: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x12662c: 0xfba60120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x126630: 0x24840ed0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 3792));
    // 0x126634: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x12663c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_12663c
// Address: 0x12663c - 0x126730

void entry_12663c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12663c) {
        switch (ctx->pc) {
            case 0x126648: ctx->pc = 0; goto label_126648;
            case 0x126654: ctx->pc = 0; goto label_126654;
            case 0x126690: ctx->pc = 0; goto label_126690;
            case 0x1266ac: ctx->pc = 0; goto label_1266ac;
            case 0x126708: ctx->pc = 0; goto label_126708;
            case 0x12670c: ctx->pc = 0; goto label_12670c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12663c: 0xe6800010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 16), *(uint32_t*)&val); }
    // 0x126640: 0xdba60120
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x126644: 0xc7a00050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[0] = *(float*)&val; }
label_126648:
    // 0x126648: 0xc6810010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 16)); ctx->f[1] = *(float*)&val; }
    // 0x12664c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x126650: 0xe7a00050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
label_126654:
    // 0x126654: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x126658: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12665c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126660: 0x0
    // NOP
    // 0x126664: 0x45030061
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 568)));
        ctx->pc = 0x1267EC; return;
    }
    // 0x12666c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x126670: 0xc6010024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 36)); ctx->f[1] = *(float*)&val; }
    // 0x126674: 0xc44099f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294941172)); ctx->f[0] = *(float*)&val; }
    // 0x126678: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12667c: 0x0
    // NOP
    // 0x126680: 0x45010003
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_126690;
    }
    // 0x126688: 0x10000008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1266ac;
    }
label_126690:
    // 0x126690: 0x4bc630aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x126694: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x126698: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12669c: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1266a0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1266a4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1266a8: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
label_1266ac:
    // 0x1266ac: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x1266b0: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x1266b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1266b8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1266bc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1266c0: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1266c4: 0x46020832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1266c8: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1266cc: 0x4501000f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_12670c;
    }
    // 0x1266d4: 0x2443fffd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294967293));
    // 0x1266d8: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x1266dc: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12670c;
    }
    // 0x1266e4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1266e8: 0x24429a00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941184));
    // 0x1266ec: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1266f0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1266f4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1266fc: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_126708;
    }
    // 0x126704: 0x2402000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
label_126708:
    // 0x126708: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
label_12670c:
    // 0x12670c: 0x8e040038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x126710: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 104)));
        ctx->pc = 0x126734; return;
    }
    // 0x126718: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12671c: 0x8c420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x126720: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_126730(rdram, ctx, runtime); return;
    }
    // 0x126728: 0x40f809
    SET_GPR_U32(ctx, 31, 0x126730);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_126730
// Address: 0x126730 - 0x126778

void entry_126730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126730) {
        switch (ctx->pc) {
            case 0x126734: ctx->pc = 0; goto label_126734;
            case 0x126748: ctx->pc = 0; goto label_126748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126730: 0x8e020068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 104)));
label_126734:
    // 0x126734: 0x14400004
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_126748;
    }
    // 0x12673c: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x126740: 0x10400027
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1267E0; return;
    }
label_126748:
    // 0x126748: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12674c: 0x7ba40030
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x126750: 0x7ba50040
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x126754: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x126758: 0x7fa300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 3));
    // 0x12675c: 0x7fa400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 4));
    // 0x126760: 0x7fa500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 5));
    // 0x126764: 0x8e060068
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 104)));
    // 0x126768: 0x10c0000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 208));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x126798; return;
    }
    // 0x126770: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x126778);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_126778
// Address: 0x126778 - 0x1267b4

void entry_126778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126778) {
        switch (ctx->pc) {
            case 0x126798: ctx->pc = 0; goto label_126798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126778: 0x7ba200d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x12677c: 0x7ba300e0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x126780: 0x7ba400f0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x126784: 0x7ba50100
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x126788: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x12678c: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x126790: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
    // 0x126794: 0x7fa50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 5));
label_126798:
    // 0x126798: 0x8e060034
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x12679c: 0x10c00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1267b4(rdram, ctx, runtime); return;
    }
    // 0x1267a4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1267a8: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1267ac: 0xc049b7a
    SET_GPR_U32(ctx, 31, 0x1267b4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AdjustAloRtckMat__FP3ALOP2CM4RTCKP6VECTORP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1267b4
// Address: 0x1267b4 - 0x1267bc

void entry_1267b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1267b4: 0xc067504
    SET_GPR_U32(ctx, 31, 0x1267bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1267bc
// Address: 0x1267bc - 0x1267e8

void entry_1267bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1267bc) {
        switch (ctx->pc) {
            case 0x1267e0: ctx->pc = 0; goto label_1267e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1267bc: 0x7ba20090
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1267c0: 0x7ba300a0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1267c4: 0x7ba400b0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1267c8: 0x7ba500c0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1267cc: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1267d0: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x1267d4: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
    // 0x1267d8: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1267e8(rdram, ctx, runtime); return;
    }
label_1267e0:
    // 0x1267e0: 0xc067504
    SET_GPR_U32(ctx, 31, 0x1267e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1267e8
// Address: 0x1267e8 - 0x126814

void entry_1267e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1267e8) {
        switch (ctx->pc) {
            case 0x1267ec: ctx->pc = 0; goto label_1267ec;
            case 0x1267fc: ctx->pc = 0; goto label_1267fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1267e8: 0x8e420238
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 568)));
label_1267ec:
    // 0x1267ec: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1267f0: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x1267f4: 0x1440fec6
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 112));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x126310; return;
    }
label_1267fc:
    // 0x1267fc: 0x13c0001f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12687C; return;
    }
    // 0x126804: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x126808: 0x8c4300ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 172)));
    // 0x12680c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x126814);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_126814
// Address: 0x126814 - 0x12684c

void entry_126814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126814) {
        switch (ctx->pc) {
            case 0x126830: ctx->pc = 0; goto label_126830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126814: 0x8e4201f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 504)));
    // 0x126818: 0x10400019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x126880; return;
    }
    // 0x126820: 0x8e42026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 620)));
    // 0x126824: 0x18400016
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x126880; return;
    }
    // 0x12682c: 0x8e4201f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 504)));
label_126830:
    // 0x126830: 0x102880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 16), 2));
    // 0x126834: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x126838: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12683c: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 628)));
        ctx->pc = 0x126854; return;
    }
    // 0x126844: 0xc048922
    SET_GPR_U32(ctx, 31, 0x12684c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ProjectActPose__FP3ACTi(rdram, ctx, runtime); return;
}


// Function: entry_12684c
// Address: 0x12684c - 0x1268b8

void entry_12684c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12684c) {
        switch (ctx->pc) {
            case 0x126854: ctx->pc = 0; goto label_126854;
            case 0x12686c: ctx->pc = 0; goto label_12686c;
            case 0x12687c: ctx->pc = 0; goto label_12687c;
            case 0x126880: ctx->pc = 0; goto label_126880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12684c: 0x10000007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 620)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12686c;
    }
label_126854:
    // 0x126854: 0x8e430270
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 624)));
    // 0x126858: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x12685c: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x126860: 0xa31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x126864: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x126868: 0x8e42026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 620)));
label_12686c:
    // 0x12686c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x126870: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x126874: 0x5440ffee
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 504)));
        ctx->pc = 0x126830; return;
    }
label_12687c:
    // 0x12687c: 0x7bbf01c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
label_126880:
    // 0x126880: 0x7bbe01b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x126884: 0x7bb701a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x126888: 0x7bb60190
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x12688c: 0x7bb50180
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x126890: 0x7bb40170
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x126894: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x126898: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x12689c: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1268a0: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1268a4: 0xc7b501d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[21] = *(float*)&val; }
    // 0x1268a8: 0xc7b401d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[20] = *(float*)&val; }
    // 0x1268ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 480));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1268b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1268b8; return;
}


// Function: RenderAloLine__FP3ALOP2CMP6VECTORT2ff
// Address: 0x1268b8 - 0x126a08

void entry_126a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126a08: 0xe7b40080
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x126a0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x126a10: 0xe7b40084
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 132), *(uint32_t*)&val); }
    // 0x126a14: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x126a18: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x126a1c: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x126a20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x126a28);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_126a28
// Address: 0x126a28 - 0x126a48

void entry_126a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126a28: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x126a2c: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x126a30: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x126a34: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x126a38: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x126a3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x126a44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x126a48; return;
}


// Function: SetAloOverrideCel__FP3ALOG4RGBA
// Address: 0x126a48 - 0x126a90

void entry_126a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126a90) {
        switch (ctx->pc) {
            case 0x126a9c: ctx->pc = 0; goto label_126a9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126a90: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x126a94: 0x5600fff8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x126A78; return;
    }
label_126a9c:
    // 0x126a9c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x126aa0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x126aa4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x126aa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00126ab0
// Address: 0x126ab0 - 0x126ac8

void FUN_00126ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126ab0: 0x8c820264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 612)));
    // 0x126ab4: 0xac850268
    WRITE32(ADD32(GPR_U32(ctx, 4), 616), GPR_U32(ctx, 5));
    // 0x126ab8: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x126abc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 612), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x126ac4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x126ac8; return;
}


// Function: UpdateAloThrob__FP3ALOf
// Address: 0x126ac8 - 0x126af0

void entry_126af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126af0: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x126af4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x126af8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x126afc: 0xc60c0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[12] = *(float*)&val; }
    // 0x126b00: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x126b04: 0xc081500
    SET_GPR_U32(ctx, 31, 0x126b0c);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[12];
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_126b0c
// Address: 0x126b0c - 0x126b64

void entry_126b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126b0c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x126b10: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x126b14: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x126b18: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x126b1c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x126b20: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x126b24: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x126b28: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x126b2c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x126b30: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x126b34: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x126b38: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x126b3c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x126b40: 0xda040010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x126b44: 0x48a61000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 6));
    // 0x126b48: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x126b4c: 0x4be320d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x126b50: 0xda010020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x126b54: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x126b58: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x126b5c: 0xc06d160
    SET_GPR_U32(ctx, 31, 0x126b64);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    ConvertUserHsvToUserRgb__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_126b64
// Address: 0x126b64 - 0x126ba8

void entry_126b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126b64: 0xc7a20010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[2] = *(float*)&val; }
    // 0x126b68: 0x24060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    // 0x126b6c: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    // 0x126b70: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x126b74: 0x460010e4
    *(int32_t*)&ctx->f[3] = FPU_CVT_W_S(ctx->f[2]);
    // 0x126b78: 0x44031800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[3]);
    // 0x126b7c: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x126b80: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x126b84: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x126b88: 0xa3a60023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 6));
    // 0x126b8c: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x126b90: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x126b94: 0xa3a30020
    WRITE8(ADD32(GPR_U32(ctx, 29), 32), (uint8_t)GPR_U32(ctx, 3));
    // 0x126b98: 0xa3a50021
    WRITE8(ADD32(GPR_U32(ctx, 29), 33), (uint8_t)GPR_U32(ctx, 5));
    // 0x126b9c: 0xa3a20022
    WRITE8(ADD32(GPR_U32(ctx, 29), 34), (uint8_t)GPR_U32(ctx, 2));
    // 0x126ba0: 0xc049a92
    SET_GPR_U32(ctx, 31, 0x126ba8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    SetAloOverrideCel__FP3ALOG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_126ba8
// Address: 0x126ba8 - 0x126bc0

void entry_126ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126ba8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x126bac: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x126bb0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x126bb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x126bbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x126bc0; return;
}


// Function: SetAloBlotContext__FP3ALOP4BLOT
// Address: 0x126bc0 - 0x126c38

void entry_126c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126c38) {
        switch (ctx->pc) {
            case 0x126c48: ctx->pc = 0; goto label_126c48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126c38: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x126c3c: 0x5600fff8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x126C20; return;
    }
    // 0x126c44: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_126c48:
    // 0x126c48: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x126c4c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x126c50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureAloFader__FP3ALO
// Address: 0x126c58 - 0x126c7c

void entry_126c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126c7c: 0xae020298
    WRITE32(ADD32(GPR_U32(ctx, 16), 664), GPR_U32(ctx, 2));
    // 0x126c80: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x126c88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_126c88
// Address: 0x126c88 - 0x126cb8

void entry_126c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126c88) {
        switch (ctx->pc) {
            case 0x126ca0: ctx->pc = 0; goto label_126ca0;
            case 0x126ca4: ctx->pc = 0; goto label_126ca4;
            case 0x126ca8: ctx->pc = 0; goto label_126ca8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126c88: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 664)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_126ca0;
    }
    // 0x126c90: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x126c94: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x126c98: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_126ca4;
    }
label_126ca0:
    // 0x126ca0: 0xac400004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 0));
label_126ca4:
    // 0x126ca4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_126ca8:
    // 0x126ca8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x126cac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x126cb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x126cb8; return;
}


// Function: FadeAloIn__FP3ALOf
// Address: 0x126cb8 - 0x126cd4

void entry_126cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126cd4) {
        switch (ctx->pc) {
            case 0x126ce8: ctx->pc = 0; goto label_126ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126cd4: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_126ce8;
    }
    // 0x126cdc: 0x8e020298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 664)));
    // 0x126ce0: 0x1040001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x126D50; return;
    }
label_126ce8:
    // 0x126ce8: 0xc049b16
    SET_GPR_U32(ctx, 31, 0x126cf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EnsureAloFader__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_126cf0
// Address: 0x126cf0 - 0x126d00

void entry_126cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126cf0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x126cf4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x126cf8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x126d00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_126d00
// Address: 0x126d00 - 0x126d60

void entry_126d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126d00) {
        switch (ctx->pc) {
            case 0x126d3c: ctx->pc = 0; goto label_126d3c;
            case 0x126d48: ctx->pc = 0; goto label_126d48;
            case 0x126d50: ctx->pc = 0; goto label_126d50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126d00: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x126d04: 0x4603a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126d08: 0x0
    // NOP
    // 0x126d0c: 0x4500000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 664)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_126d3c;
    }
    // 0x126d14: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x126d18: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x126d1c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x126d20: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x126d24: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x126d28: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x126d2c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x126d30: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x126d34: 0x10000004
    ctx->f[0] = std::max(ctx->f[3], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_126d48;
    }
label_126d3c:
    // 0x126d3c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x126d40: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x126d44: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
label_126d48:
    // 0x126d48: 0xe4400008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x126d4c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_126d50:
    // 0x126d50: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x126d54: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x126d58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FadeAloOut__FP3ALOf
// Address: 0x126d60 - 0x126d7c

void entry_126d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126d7c: 0x10400015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x126DD4; return;
    }
    // 0x126d84: 0xc049b16
    SET_GPR_U32(ctx, 31, 0x126d8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EnsureAloFader__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_126d8c
// Address: 0x126d8c - 0x126de8

void entry_126d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126d8c) {
        switch (ctx->pc) {
            case 0x126dc0: ctx->pc = 0; goto label_126dc0;
            case 0x126dcc: ctx->pc = 0; goto label_126dcc;
            case 0x126dd4: ctx->pc = 0; goto label_126dd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126d8c: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x126d90: 0x4602a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x126d94: 0x0
    // NOP
    // 0x126d98: 0x45000009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 664)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_126dc0;
    }
    // 0x126da0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x126da4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x126da8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x126dac: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x126db0: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x126db4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x126db8: 0x10000004
    ctx->f[0] = std::min(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_126dcc;
    }
label_126dc0:
    // 0x126dc0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x126dc4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x126dc8: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
label_126dcc:
    // 0x126dcc: 0xe4400008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x126dd0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_126dd4:
    // 0x126dd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x126dd8: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x126ddc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x126de4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x126de8; return;
}


// Function: AdjustAloRtckMat__FP3ALOP2CM4RTCKP6VECTORP7MATRIX4
// Address: 0x126de8 - 0x126e48

void entry_126e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126e48: 0x7a020030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x126e4c: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x126e50: 0xc6450000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[5] = *(float*)&val; }
    // 0x126e54: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x126e58: 0x7fa200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 2));
    // 0x126e5c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x126e60: 0x7a020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x126e64: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x126e68: 0xc6440004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[4] = *(float*)&val; }
    // 0x126e6c: 0x24848d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937904));
    // 0x126e70: 0xc6400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[0] = *(float*)&val; }
    // 0x126e74: 0xc7a300b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[3] = *(float*)&val; }
    // 0x126e78: 0xc7a100b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 180)); ctx->f[1] = *(float*)&val; }
    // 0x126e7c: 0xc7a200b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[2] = *(float*)&val; }
    // 0x126e80: 0x460518c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[5]);
    // 0x126e84: 0x46040841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[4]);
    // 0x126e88: 0x7a070000
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x126e8c: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x126e90: 0x7a030020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x126e94: 0x7fa70080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 7));
    // 0x126e98: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x126e9c: 0x7fa300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 3));
    // 0x126ea0: 0xe7a300b0
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x126ea4: 0xe7a100b4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
    // 0x126ea8: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x126eb0);
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 184), *(uint32_t*)&val); }
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_126eb0
// Address: 0x126eb0 - 0x126ec4

void entry_126eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126eb0: 0x27b400d0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 208));
    // 0x126eb4: 0x27a60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 128));
    // 0x126eb8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x126ebc: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x126ec4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_126ec4
// Address: 0x126ec4 - 0x126f14

void entry_126ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126ec4: 0xdba300f0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x126ec8: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x126ecc: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x126ed0: 0x26a500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 21), 160));
    // 0x126ed4: 0x4bc118aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x126ed8: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x126edc: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x126ee0: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x126ee4: 0x7ba200e0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x126ee8: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x126eec: 0x7ba30100
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x126ef0: 0x7ba700d0
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x126ef4: 0x4be218ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x126ef8: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x126efc: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x126f00: 0x7e070000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 7));
    // 0x126f04: 0x7e020010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 2));
    // 0x126f08: 0x7e030030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    // 0x126f0c: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x126f14);
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_126f14
// Address: 0x126f14 - 0x126f24

void entry_126f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126f14: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x126f18: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x126f1c: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x126f24);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_126f24
// Address: 0x126f24 - 0x126f34

void entry_126f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126f24: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x126f28: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x126f2c: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x126f34);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_126f34
// Address: 0x126f34 - 0x126f78

void entry_126f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x126f34: 0x7ba300d0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x126f38: 0x7ba400e0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x126f3c: 0x7ba500f0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x126f40: 0x7ba20100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x126f44: 0x7e030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 3));
    // 0x126f48: 0x7e020030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 2));
    // 0x126f4c: 0x7e040010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 4));
    // 0x126f50: 0x7e050020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 5));
    // 0x126f54: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x126f58: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x126f5c: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x126f60: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x126f64: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x126f68: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x126f6c: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x126f70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneAloHierarchy__FP3ALOT0
// Address: 0x126f78 - 0x126fc0

void entry_126fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126fc0) {
        switch (ctx->pc) {
            case 0x126fd8: ctx->pc = 0; goto label_126fd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126fc0: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x126fc4: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x126fc8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x126fcc: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x126fd0: 0x1060000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x127004; return;
    }
label_126fd8:
    // 0x126fd8: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x126fdc: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x126fe0: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x126fe8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_126fe8
// Address: 0x126fe8 - 0x12702c

void entry_126fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x126fe8) {
        switch (ctx->pc) {
            case 0x127004: ctx->pc = 0; goto label_127004;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x126fe8: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x126fec: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x126ff0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x126ff4: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x126ff8: 0x80182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x126ffc: 0x1460fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x126FD8; return;
    }
label_127004:
    // 0x127004: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x127008: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12700c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x127010: 0x10400007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x127030; return;
    }
    // 0x127018: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x12701c: 0x14400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x127030; return;
    }
    // 0x127024: 0xc06ed60
    SET_GPR_U32(ctx, 31, 0x12702c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RecalcSoLocked__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_12702c
// Address: 0x12702c - 0x127048

void entry_12702c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12702c) {
        switch (ctx->pc) {
            case 0x127030: ctx->pc = 0; goto label_127030;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12702c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_127030:
    // 0x127030: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x127034: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x127038: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12703c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x127040: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneAlo__FP3ALOT0
// Address: 0x127048 - 0x1270e4

void entry_1270e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1270e4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1270e8: 0x2624022c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 556));
    // 0x1270ec: 0xc059648
    SET_GPR_U32(ctx, 31, 0x1270f4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 556));
    CloneGlobset__FP7GLOBSETP3ALOT0(rdram, ctx, runtime); return;
}


// Function: entry_1270f4
// Address: 0x1270f4 - 0x127108

void entry_1270f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1270f4: 0x8e250224
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 548)));
    // 0x1270f8: 0x10a00004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12710C; return;
    }
    // 0x127100: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x127108);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_127108
// Address: 0x127108 - 0x127114

void entry_127108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127108) {
        switch (ctx->pc) {
            case 0x12710c: ctx->pc = 0; goto label_12710c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127108: 0xae220224
    WRITE32(ADD32(GPR_U32(ctx, 17), 548), GPR_U32(ctx, 2));
label_12710c:
    // 0x12710c: 0xc054910
    SET_GPR_U32(ctx, 31, 0x127114);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 52));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_127114
// Address: 0x127114 - 0x1271b4

void entry_127114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127114: 0x6ba40007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x127118: 0x6fa40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12711c: 0xb224004f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 79); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x127120: 0xb6240048
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 72); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x127124: 0x6ba80017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x127128: 0x6fa80010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x12712c: 0xb2280047
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 71); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x127130: 0xb6280040
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 64); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x127134: 0x2405ffdf
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967263));
    // 0x127138: 0x52c38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 16);
    // 0x12713c: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x127140: 0x52c38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 16);
    // 0x127144: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x127148: 0x6ba60027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x12714c: 0x6fa60020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x127150: 0xb226005f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 95); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x127154: 0xb6260058
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 88); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x127158: 0x10197c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) << (32 + 5));
    // 0x12715c: 0x6ba60037
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x127160: 0x6fa60030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x127164: 0x8fa70038
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x127168: 0xb2260067
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 103); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12716c: 0xb6260060
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 96); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x127170: 0xae270068
    WRITE32(ADD32(GPR_U32(ctx, 17), 104), GPR_U32(ctx, 7));
    // 0x127174: 0xae330054
    WRITE32(ADD32(GPR_U32(ctx, 17), 84), GPR_U32(ctx, 19));
    // 0x127178: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x12717c: 0xae340050
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 20));
    // 0x127180: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x127184: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x127188: 0xfe2202c8
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 2));
    // 0x12718c: 0x6ba30047
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 71); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x127190: 0x6fa30040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x127194: 0x8fa50048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x127198: 0xb22301e7
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 487); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12719c: 0xb62301e0
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 480); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1271a0: 0xae2501e8
    WRITE32(ADD32(GPR_U32(ctx, 17), 488), GPR_U32(ctx, 5));
    // 0x1271a4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1271a8: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x1271ac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1271b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1271b4
// Address: 0x1271b4 - 0x1271cc

void entry_1271b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1271b4: 0x8e4401fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 508)));
    // 0x1271b8: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 512)));
        ctx->pc = 0x1271E0; return;
    }
    // 0x1271c0: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1271c4: 0xc0484a0
    SET_GPR_U32(ctx, 31, 0x1271cc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PactNewClone__FP3ACTP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1271cc
// Address: 0x1271cc - 0x1271dc

void entry_1271cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1271cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1271d0: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1271d4: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x1271dc);
    WRITE32(ADD32(GPR_U32(ctx, 17), 508), GPR_U32(ctx, 2));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1271dc
// Address: 0x1271dc - 0x1271f4

void entry_1271dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1271dc) {
        switch (ctx->pc) {
            case 0x1271e0: ctx->pc = 0; goto label_1271e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1271dc: 0x8e440200
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 512)));
label_1271e0:
    // 0x1271e0: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 516)));
        ctx->pc = 0x127208; return;
    }
    // 0x1271e8: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1271ec: 0xc0484a0
    SET_GPR_U32(ctx, 31, 0x1271f4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PactNewClone__FP3ACTP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1271f4
// Address: 0x1271f4 - 0x127204

void entry_1271f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1271f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1271f8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1271fc: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x127204);
    WRITE32(ADD32(GPR_U32(ctx, 17), 512), GPR_U32(ctx, 2));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_127204
// Address: 0x127204 - 0x12721c

void entry_127204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127204) {
        switch (ctx->pc) {
            case 0x127208: ctx->pc = 0; goto label_127208;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127204: 0x8e440204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 516)));
label_127208:
    // 0x127208: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 644)));
        ctx->pc = 0x127230; return;
    }
    // 0x127210: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x127214: 0xc0484a0
    SET_GPR_U32(ctx, 31, 0x12721c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PactNewClone__FP3ACTP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12721c
// Address: 0x12721c - 0x12722c

void entry_12721c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12721c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x127220: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x127224: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x12722c);
    WRITE32(ADD32(GPR_U32(ctx, 17), 516), GPR_U32(ctx, 2));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_12722c
// Address: 0x12722c - 0x127244

void entry_12722c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12722c) {
        switch (ctx->pc) {
            case 0x127230: ctx->pc = 0; goto label_127230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12722c: 0x8e420284
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 644)));
label_127230:
    // 0x127230: 0x50400011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 684)));
        ctx->pc = 0x127278; return;
    }
    // 0x127238: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x12723c: 0xc06d7b0
    SET_GPR_U32(ctx, 31, 0x127244);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7156));
    PvAllocSlotheapImpl__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_127244
// Address: 0x127244 - 0x127258

void entry_127244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127244: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x127248: 0x8e450284
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 644)));
    // 0x12724c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x127250: 0xc063600
    SET_GPR_U32(ctx, 31, 0x127258);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 736));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_127258
// Address: 0x127258 - 0x127260

void entry_127258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127258: 0xc054914
    SET_GPR_U32(ctx, 31, 0x127260);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 184));
    ClearDle__FP3DLE(rdram, ctx, runtime); return;
}


// Function: entry_127260
// Address: 0x127260 - 0x127274

void entry_127260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127260: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x127264: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x127268: 0xae300284
    WRITE32(ADD32(GPR_U32(ctx, 17), 644), GPR_U32(ctx, 16));
    // 0x12726c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x127274);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7168));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_127274
// Address: 0x127274 - 0x127288

void entry_127274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127274) {
        switch (ctx->pc) {
            case 0x127278: ctx->pc = 0; goto label_127278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127274: 0x8e4502ac
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 684)));
label_127278:
    // 0x127278: 0x50a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 648)));
        ctx->pc = 0x127290; return;
    }
    // 0x127280: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x127288);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 36));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_127288
// Address: 0x127288 - 0x1272a0

void entry_127288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127288) {
        switch (ctx->pc) {
            case 0x127290: ctx->pc = 0; goto label_127290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127288: 0xae2202ac
    WRITE32(ADD32(GPR_U32(ctx, 17), 684), GPR_U32(ctx, 2));
    // 0x12728c: 0x8e450288
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 648)));
label_127290:
    // 0x127290: 0x50a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
        ctx->pc = 0x1272A8; return;
    }
    // 0x127298: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x1272a0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 64));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_1272a0
// Address: 0x1272a0 - 0x1272c4

void entry_1272a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1272a0) {
        switch (ctx->pc) {
            case 0x1272a8: ctx->pc = 0; goto label_1272a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1272a0: 0xae220288
    WRITE32(ADD32(GPR_U32(ctx, 17), 648), GPR_U32(ctx, 2));
    // 0x1272a4: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
label_1272a8:
    // 0x1272a8: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1272ac: 0x31d78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 21);
    // 0x1272b0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1272b4: 0x10400009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1272DC; return;
    }
    // 0x1272bc: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1272c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1272c4
// Address: 0x1272c4 - 0x1272d8

void entry_1272c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1272c4: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1272d8(rdram, ctx, runtime); return;
    }
    // 0x1272cc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1272d0: 0xc050ebe
    SET_GPR_U32(ctx, 31, 0x1272d8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    AddCmFadeObject(rdram, ctx, runtime); return;
}


// Function: entry_1272d8
// Address: 0x1272d8 - 0x1272f4

void entry_1272d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1272d8) {
        switch (ctx->pc) {
            case 0x1272dc: ctx->pc = 0; goto label_1272dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1272d8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1272dc:
    // 0x1272dc: 0x8e25020c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 524)));
    // 0x1272e0: 0x24420e70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3696));
    // 0x1272e4: 0x10a20005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1272FC; return;
    }
    // 0x1272ec: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x1272f4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_1272f4
// Address: 0x1272f4 - 0x127314

void entry_1272f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1272f4) {
        switch (ctx->pc) {
            case 0x1272fc: ctx->pc = 0; goto label_1272fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1272f4: 0xae22020c
    WRITE32(ADD32(GPR_U32(ctx, 17), 524), GPR_U32(ctx, 2));
    // 0x1272f8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1272fc:
    // 0x1272fc: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x127300: 0x24420e80
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3712));
    // 0x127304: 0x10a20005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12731C; return;
    }
    // 0x12730c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x127314);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_127314
// Address: 0x127314 - 0x127334

void entry_127314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127314) {
        switch (ctx->pc) {
            case 0x12731c: ctx->pc = 0; goto label_12731c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127314: 0xae220210
    WRITE32(ADD32(GPR_U32(ctx, 17), 528), GPR_U32(ctx, 2));
    // 0x127318: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_12731c:
    // 0x12731c: 0x8e250214
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 532)));
    // 0x127320: 0x24420e90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3728));
    // 0x127324: 0x10a20005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12733C; return;
    }
    // 0x12732c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x127334);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_127334
// Address: 0x127334 - 0x127354

void entry_127334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127334) {
        switch (ctx->pc) {
            case 0x12733c: ctx->pc = 0; goto label_12733c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127334: 0xae220214
    WRITE32(ADD32(GPR_U32(ctx, 17), 532), GPR_U32(ctx, 2));
    // 0x127338: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_12733c:
    // 0x12733c: 0x8e250218
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 536)));
    // 0x127340: 0x24420ea0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3744));
    // 0x127344: 0x10a20005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12735C; return;
    }
    // 0x12734c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x127354);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_127354
// Address: 0x127354 - 0x127378

void entry_127354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127354) {
        switch (ctx->pc) {
            case 0x12735c: ctx->pc = 0; goto label_12735c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127354: 0xae220218
    WRITE32(ADD32(GPR_U32(ctx, 17), 536), GPR_U32(ctx, 2));
    // 0x127358: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_12735c:
    // 0x12735c: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x127360: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x127364: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x127368: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12736c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x127370: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleAloMessage__FP3ALO5MSGIDPv
// Address: 0x127378 - 0x1273e4

void entry_1273e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1273e4) {
        switch (ctx->pc) {
            case 0x1273e8: ctx->pc = 0; goto label_1273e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1273e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1273e8:
    // 0x1273e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TranslateAloToPos__FP3ALOP6VECTOR
// Address: 0x1273f0 - 0x12742c

void entry_12742c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12742c) {
        switch (ctx->pc) {
            case 0x127430: ctx->pc = 0; goto label_127430;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12742c: 0x8e0401ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 492)));
label_127430:
    // 0x127430: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x127444; return;
    }
    // 0x127438: 0xc0489b6
    SET_GPR_U32(ctx, 31, 0x127440);
    AdaptAct__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_127440
// Address: 0x127440 - 0x127458

void entry_127440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127440) {
        switch (ctx->pc) {
            case 0x127444: ctx->pc = 0; goto label_127444;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127440: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_127444:
    // 0x127444: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x127448: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x12744c: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x127450: 0x40f809
    SET_GPR_U32(ctx, 31, 0x127458);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_127458
// Address: 0x127458 - 0x127468

void entry_127458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127458: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12745c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x127460: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00127468
// Address: 0x127468 - 0x127478

void entry_1274b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1274b8) {
        switch (ctx->pc) {
            case 0x1274bc: ctx->pc = 0; goto label_1274bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1274b8: 0x8e0401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 496)));
label_1274bc:
    // 0x1274bc: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1274D0; return;
    }
    // 0x1274c4: 0xc0489b6
    SET_GPR_U32(ctx, 31, 0x1274cc);
    AdaptAct__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1274cc
// Address: 0x1274cc - 0x1274e4

void entry_1274cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1274cc) {
        switch (ctx->pc) {
            case 0x1274d0: ctx->pc = 0; goto label_1274d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1274cc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1274d0:
    // 0x1274d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1274d4: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1274d8: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x1274dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1274e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1274e4
// Address: 0x1274e4 - 0x1274f8

void entry_1274e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1274e4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1274e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1274ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1274f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1274f8; return;
}


// Function: SetAloVelocityVec__FP3ALOP6VECTOR
// Address: 0x1274f8 - 0x127528

void entry_127528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127528: 0xc048f70
    SET_GPR_U32(ctx, 31, 0x127530);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsZeroV__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_127530
// Address: 0x127530 - 0x127540

void entry_127530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127530: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x127544; return;
    }
    // 0x127538: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x127540);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_127540
// Address: 0x127540 - 0x127558

void entry_127540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127540) {
        switch (ctx->pc) {
            case 0x127544: ctx->pc = 0; goto label_127544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127540: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_127544:
    // 0x127544: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x127548: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12754c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x127554: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x127558; return;
}


// Function: SetAloVelocityXYZ__FP3ALOfff
// Address: 0x127558 - 0x127580

void entry_127580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127580: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x127584: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12758c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x127590; return;
}


// Function: SetAloAngularVelocityVec__FP3ALOP6VECTOR
// Address: 0x127590 - 0x1275c0

void entry_1275c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1275c0: 0xc048f80
    SET_GPR_U32(ctx, 31, 0x1275c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsZeroW__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1275c8
// Address: 0x1275c8 - 0x1275d8

void entry_1275c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1275c8: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1275DC; return;
    }
    // 0x1275d0: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1275d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1275d8
// Address: 0x1275d8 - 0x1275f0

void entry_1275d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1275d8) {
        switch (ctx->pc) {
            case 0x1275dc: ctx->pc = 0; goto label_1275dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1275d8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1275dc:
    // 0x1275dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1275e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1275e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1275ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1275f0; return;
}


// Function: SetAloAngularVelocityXYZ__FP3ALOfff
// Address: 0x1275f0 - 0x127618

void entry_127618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127618: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12761c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x127624: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x127628; return;
}


// Function: SetAloVelocityLocal__FP3ALOP6VECTOR
// Address: 0x127628 - 0x127668

void entry_127668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127668: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12766c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x127674: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x127678; return;
}


// Function: GetAloVelocityLocal__FP3ALOP6VECTOR
// Address: 0x127678 - 0x1276c0

void entry_127700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127700: 0x27b20050
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 80));
    // 0x127704: 0x8e850018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x127708: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12770c: 0x26a60110
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 21), 272));
    // 0x127710: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x127718);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_127718
// Address: 0x127718 - 0x127750

void entry_127718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127718: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x12771c: 0x27b30040
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 64));
    // 0x127720: 0x8ea40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 24)));
    // 0x127724: 0x26a80160
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 21), 352));
    // 0x127728: 0x8e850018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x12772c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x127730: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x127734: 0x220582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x127738: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12773c: 0x26a70150
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 336));
    // 0x127740: 0xafb30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 19));
    // 0x127744: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x127748: 0xc04a0cc
    SET_GPR_U32(ctx, 31, 0x127750);
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    ConvertAloMovement__FP3ALOT0P6VECTORN82(rdram, ctx, runtime); return;
}


// Function: entry_127750
// Address: 0x127750 - 0x127764

void entry_127750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127750: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x127754: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x127758: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x12775c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x127764);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_127764
// Address: 0x127764 - 0x127778

void entry_127764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127764: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x127768: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12776c: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x127770: 0x40f809
    SET_GPR_U32(ctx, 31, 0x127778);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_127778
// Address: 0x127778 - 0x12778c

void entry_127778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127778: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x12777c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x127780: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x127784: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12778c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12778c
// Address: 0x12778c - 0x1277a0

void entry_12778c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12778c: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x127790: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x127794: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x127798: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1277a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1277a0
// Address: 0x1277a0 - 0x127828

void entry_1277a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1277a0) {
        switch (ctx->pc) {
            case 0x1277f4: ctx->pc = 0; goto label_1277f4;
            case 0x127800: ctx->pc = 0; goto label_127800;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1277a0: 0x8e840224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 548)));
    // 0x1277a4: 0x50800013
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 52)));
        goto label_1277f4;
    }
    // 0x1277ac: 0x8c8200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 176)));
    // 0x1277b0: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1277b4: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 52)));
        goto label_1277f4;
    }
    // 0x1277bc: 0x8ea30224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 548)));
    // 0x1277c0: 0x5060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 52)));
        goto label_1277f4;
    }
    // 0x1277c8: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x1277cc: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1277d0: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 52)));
        goto label_1277f4;
    }
    // 0x1277d8: 0xc4600090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 144)); ctx->f[0] = *(float*)&val; }
    // 0x1277dc: 0xe4800090
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 144), *(uint32_t*)&val); }
    // 0x1277e0: 0x8ea20224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 548)));
    // 0x1277e4: 0x8e830224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 548)));
    // 0x1277e8: 0xc4400094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 148)); ctx->f[0] = *(float*)&val; }
    // 0x1277ec: 0xe4600094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 148), *(uint32_t*)&val); }
    // 0x1277f0: 0x8e900034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 52)));
label_1277f4:
    // 0x1277f4: 0x12000024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x127888; return;
    }
    // 0x1277fc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_127800:
    // 0x127800: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x127804: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x127808: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x12780c: 0x5440001b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x12787C; return;
    }
    // 0x127814: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x127818: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x12781c: 0x8e060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x127820: 0xc056906
    SET_GPR_U32(ctx, 31, 0x127828);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_127828
// Address: 0x127828 - 0x127878

void entry_127828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127828) {
        switch (ctx->pc) {
            case 0x12786c: ctx->pc = 0; goto label_12786c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127828: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12782c: 0x50a00013
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x12787C; return;
    }
    // 0x127834: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x127838: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12783c: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x127840: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x127844: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x12787C; return;
    }
    // 0x12784c: 0x8e020224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x127850: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_12786c;
    }
    // 0x127858: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x12785c: 0x3042000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 12));
    // 0x127860: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x12787C; return;
    }
    // 0x127868: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_12786c:
    // 0x12786c: 0x8c62008c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 140)));
    // 0x127870: 0x40f809
    SET_GPR_U32(ctx, 31, 0x127878);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_127878
// Address: 0x127878 - 0x1278a8

void entry_127878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127878) {
        switch (ctx->pc) {
            case 0x12787c: ctx->pc = 0; goto label_12787c;
            case 0x127888: ctx->pc = 0; goto label_127888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127878: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_12787c:
    // 0x12787c: 0x5600ffe0
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x127800; return;
    }
    // 0x127884: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_127888:
    // 0x127888: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x12788c: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x127890: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x127894: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x127898: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12789c: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1278a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateAloMovement__FP3ALOT0P6VECTORN42
// Address: 0x1278a8 - 0x12798c

void entry_12798c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12798c) {
        switch (ctx->pc) {
            case 0x12799c: ctx->pc = 0; goto label_12799c;
            case 0x1279ac: ctx->pc = 0; goto label_1279ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12798c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x127990: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x127994: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127998: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
label_12799c:
    // 0x12799c: 0x17c00003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_1279ac;
    }
    // 0x1279a4: 0x12400009
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1279CC; return;
    }
label_1279ac:
    // 0x1279ac: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1279b0: 0x26060180
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 384));
    // 0x1279b4: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1279bc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1279bc
// Address: 0x1279bc - 0x127a10

void entry_1279bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1279bc) {
        switch (ctx->pc) {
            case 0x1279cc: ctx->pc = 0; goto label_1279cc;
            case 0x1279dc: ctx->pc = 0; goto label_1279dc;
            case 0x1279ec: ctx->pc = 0; goto label_1279ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1279bc: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1279c0: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1279c4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1279c8: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
label_1279cc:
    // 0x1279cc: 0x16600003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 29), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        goto label_1279dc;
    }
    // 0x1279d4: 0x5240003d
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967292));
        ctx->pc = 0x127ACC; return;
    }
label_1279dc:
    // 0x1279dc: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 176)));
        goto label_1279ec;
    }
    // 0x1279e4: 0x8e22fffc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294967292)));
    // 0x1279e8: 0x24420140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 320));
label_1279ec:
    // 0x1279ec: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1279f0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1279f4: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1279f8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1279fc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127a00: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x127a04: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127a08: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x127a10);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_127a10
// Address: 0x127a10 - 0x127a4c

void entry_127a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x127a10: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x127a14: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x127a18: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x127a1c: 0x4bc208ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127a20: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x127a24: 0x1260000d
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x127A5C; return;
    }
    // 0x127a2c: 0xda610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x127a30: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x127a34: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127a38: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x127a3c: 0xfa610000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127a40: 0x26060150
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 336));
    // 0x127a44: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x127a4c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_127a4c
// Address: 0x127a4c - 0x127ab8

void entry_127a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127a4c) {
        switch (ctx->pc) {
            case 0x127a5c: ctx->pc = 0; goto label_127a5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127a4c: 0xda610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x127a50: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x127a54: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127a58: 0xfa610000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_127a5c:
    // 0x127a5c: 0x1240001a
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x127AC8; return;
    }
    // 0x127a64: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x127a68: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x127a6c: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x127a70: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x127a74: 0x4bc222fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x127a78: 0x4bc4112e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127a7c: 0x4a24212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x127a80: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x127a84: 0x4be40868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127a88: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x127a8c: 0x26060170
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 368));
    // 0x127a90: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127a94: 0x4bc21afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x127a98: 0x4bc310ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127a9c: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x127aa0: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127aa4: 0xfba40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x127aa8: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127aac: 0x27a70080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    // 0x127ab0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x127ab8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_127ab8
// Address: 0x127ab8 - 0x127b20

void entry_127ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127ab8) {
        switch (ctx->pc) {
            case 0x127ac8: ctx->pc = 0; goto label_127ac8;
            case 0x127acc: ctx->pc = 0; goto label_127acc;
            case 0x127ad8: ctx->pc = 0; goto label_127ad8;
            case 0x127ae4: ctx->pc = 0; goto label_127ae4;
            case 0x127af0: ctx->pc = 0; goto label_127af0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127ab8: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x127abc: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x127ac0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127ac4: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_127ac8:
    // 0x127ac8: 0x2631fffc
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967292));
label_127acc:
    // 0x127acc: 0x23d102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 29)));
    // 0x127ad0: 0x1040ffa3
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x127960; return;
    }
label_127ad8:
    // 0x127ad8: 0x12e00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_127ae4;
    }
    // 0x127ae0: 0x7ee20000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), GPR_VEC(ctx, 2));
label_127ae4:
    // 0x127ae4: 0x13c00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        goto label_127af0;
    }
    // 0x127aec: 0x7fc20000
    WRITE128(ADD32(GPR_U32(ctx, 30), 0), GPR_VEC(ctx, 2));
label_127af0:
    // 0x127af0: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x127af4: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x127af8: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x127afc: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x127b00: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x127b04: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x127b08: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x127b0c: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x127b10: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x127b14: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x127b18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3
// Address: 0x127b20 - 0x127e10

void entry_127e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127e10) {
        switch (ctx->pc) {
            case 0x127e2c: ctx->pc = 0; goto label_127e2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127e10: 0x26d6fff0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 4294967280));
    // 0x127e14: 0x26b5fff0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4294967280));
    // 0x127e18: 0x27defff0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 4294967280));
    // 0x127e1c: 0x26f7fffc
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 4294967292));
    // 0x127e20: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x127e24: 0x601ff98
    SET_GPR_VEC(ctx, 13, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x127C88; return;
    }
label_127e2c:
    // 0x127e2c: 0x7bbf01d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x127e30: 0x7bbe01c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x127e34: 0x7bb701b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x127e38: 0x7bb601a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x127e3c: 0x7bb50190
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x127e40: 0x7bb40180
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x127e44: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x127e48: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x127e4c: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x127e50: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x127e54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 480));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x127e5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x127e60; return;
}


// Function: CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2
// Address: 0x127e60 - 0x127ec0

void entry_127ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x127ec0) {
        switch (ctx->pc) {
            case 0x127ed8: ctx->pc = 0; goto label_127ed8;
            case 0x127f04: ctx->pc = 0; goto label_127f04;
            case 0x127f0c: ctx->pc = 0; goto label_127f0c;
            case 0x127f5c: ctx->pc = 0; goto label_127f5c;
            case 0x127f8c: ctx->pc = 0; goto label_127f8c;
            case 0x127ffc: ctx->pc = 0; goto label_127ffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x127ec0: 0x56400005
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_127ed8;
    }
    // 0x127ec8: 0x12000024
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_127f5c;
    }
    // 0x127ed0: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_127f04;
    }
label_127ed8:
    // 0x127ed8: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x127edc: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x127ee0: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x127ee4: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x127ee8: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x127eec: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127ef0: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x127ef4: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127ef8: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x127efc: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_127f0c;
    }
label_127f04:
    // 0x127f04: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x127f08: 0x7fa30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 3));
label_127f0c:
    // 0x127f0c: 0x12000013
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_127f5c;
    }
    // 0x127f14: 0xda040000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x127f18: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x127f1c: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x127f20: 0x4bc429bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x127f24: 0x4bc410bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x127f28: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127f2c: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x127f30: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x127f34: 0x4be418e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x127f38: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x127f3c: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x127f40: 0x4bc208ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127f44: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x127f48: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x127f4c: 0x4be21868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x127f50: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x127f54: 0xfa010000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127f58: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
label_127f5c:
    // 0x127f5c: 0x1260000b
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_127f8c;
    }
    // 0x127f64: 0xda630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x127f68: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x127f6c: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x127f70: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x127f74: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x127f78: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127f7c: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x127f80: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x127f84: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x127f88: 0xfa610000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_127f8c:
    // 0x127f8c: 0x1220001b
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_127ffc;
    }
    // 0x127f94: 0xda250000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x127f98: 0xda260010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x127f9c: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x127fa0: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x127fa4: 0xda240020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x127fa8: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x127fac: 0x4bc518bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x127fb0: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127fb4: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x127fb8: 0x4bc618bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x127fbc: 0x4bc6118a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127fc0: 0xfa250000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x127fc4: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x127fc8: 0x4bc418bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x127fcc: 0x4bc4104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x127fd0: 0xfa260010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x127fd4: 0xfa210020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127fd8: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x127fdc: 0xfba50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x127fe0: 0xfba600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x127fe4: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x127fe8: 0xfba100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127fec: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x127ff0: 0xfba50060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x127ff4: 0xfba60070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x127ff8: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
label_127ffc:
    // 0x127ffc: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x128000: 0x7bb30120
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x128004: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x128008: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x12800c: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x128010: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertAloPos__FP3ALOT0P6VECTORT2
// Address: 0x128018 - 0x1280c0

void entry_1281e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1281e0) {
        switch (ctx->pc) {
            case 0x128208: ctx->pc = 0; goto label_128208;
            case 0x128220: ctx->pc = 0; goto label_128220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1281e0: 0x7ba20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1281e4: 0x7ba30070
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1281e8: 0x7ba40080
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1281ec: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x1281f0: 0x7e040020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 4));
    // 0x1281f4: 0x7e030010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 3));
    // 0x1281f8: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1281fc: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x128200: 0x10000007
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_128220;
    }
label_128208:
    // 0x128208: 0x78c20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x12820c: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x128210: 0x78c30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x128214: 0x7e030010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 3));
    // 0x128218: 0x78c20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x12821c: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
label_128220:
    // 0x128220: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x128224: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x128228: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FDrivenAlo__FP3ALO
// Address: 0x128230 - 0x128278

void entry_1282bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1282bc) {
        switch (ctx->pc) {
            case 0x1282d4: ctx->pc = 0; goto label_1282d4;
            case 0x1282d8: ctx->pc = 0; goto label_1282d8;
            case 0x1282f8: ctx->pc = 0; goto label_1282f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1282bc: 0x8e0401ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 492)));
    // 0x1282c0: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 496)));
        goto label_1282d8;
    }
    // 0x1282c8: 0x80820010
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1282cc: 0x5051fff8
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        ctx->pc = 0x1282B0; return;
    }
label_1282d4:
    // 0x1282d4: 0x8e0401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 496)));
label_1282d8:
    // 0x1282d8: 0x10800010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12831C; return;
    }
    // 0x1282e0: 0x80830011
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 17)));
    // 0x1282e4: 0x1462000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x128320; return;
    }
    // 0x1282ec: 0x24110005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1282f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1282f4: 0x0
    // NOP
label_1282f8:
    // 0x1282f8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1282fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x128304);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_128304
// Address: 0x128304 - 0x128330

void entry_128304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128304) {
        switch (ctx->pc) {
            case 0x12831c: ctx->pc = 0; goto label_12831c;
            case 0x128320: ctx->pc = 0; goto label_128320;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128304: 0x8e0401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 496)));
    // 0x128308: 0x10800005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_128320;
    }
    // 0x128310: 0x80820011
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 17)));
    // 0x128314: 0x5051fff8
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        ctx->pc = 0x1282F8; return;
    }
label_12831c:
    // 0x12831c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_128320:
    // 0x128320: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x128324: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x128328: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertAloMovement__FP3ALOT0P6VECTORN82
// Address: 0x128330 - 0x128384

void entry_128384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128384: 0x12400006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1283a0(rdram, ctx, runtime); return;
    }
    // 0x12838c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x128390: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128394: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x128398: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1283a0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1283a0
// Address: 0x1283a0 - 0x1283b8

void entry_1283a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1283a0: 0x12800005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        entry_1283b8(rdram, ctx, runtime); return;
    }
    // 0x1283a8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1283ac: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1283b0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1283b8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1283b8
// Address: 0x1283b8 - 0x1283d0

void entry_1283b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1283b8: 0x12a00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        entry_1283d0(rdram, ctx, runtime); return;
    }
    // 0x1283c0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1283c4: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1283c8: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1283d0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1283d0
// Address: 0x1283d0 - 0x1283e8

void entry_1283d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1283d0: 0x12c00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        entry_1283e8(rdram, ctx, runtime); return;
    }
    // 0x1283d8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1283dc: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1283e0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1283e8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1283e8
// Address: 0x1283e8 - 0x12841c

void entry_1283e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1283e8: 0x12000020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12846C; return;
    }
    // 0x1283f0: 0x27a80050
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1283f4: 0x27a90060
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1283f8: 0x27aa0070
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1283fc: 0x8fa60080
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x128400: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x128404: 0x12380a
    if (GPR_U32(ctx, 18) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 0));
    // 0x128408: 0x14400a
    if (GPR_U32(ctx, 20) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 0));
    // 0x12840c: 0x15480a
    if (GPR_U32(ctx, 21) == 0) SET_GPR_U32(ctx, 9, GPR_U32(ctx, 0));
    // 0x128410: 0x16500a
    if (GPR_U32(ctx, 22) == 0) SET_GPR_U32(ctx, 10, GPR_U32(ctx, 0));
    // 0x128414: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x12841c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_12841c
// Address: 0x12841c - 0x1284a8

void entry_12841c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12841c) {
        switch (ctx->pc) {
            case 0x128430: ctx->pc = 0; goto label_128430;
            case 0x128444: ctx->pc = 0; goto label_128444;
            case 0x128458: ctx->pc = 0; goto label_128458;
            case 0x12846c: ctx->pc = 0; goto label_12846c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12841c: 0x12400004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_128430;
    }
    // 0x128424: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x128428: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12842c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_128430:
    // 0x128430: 0x12800004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_128444;
    }
    // 0x128438: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12843c: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x128440: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_128444:
    // 0x128444: 0x12a00004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_128458;
    }
    // 0x12844c: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x128450: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x128454: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_128458:
    // 0x128458: 0x12c00004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_12846c;
    }
    // 0x128460: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x128464: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x128468: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_12846c:
    // 0x12846c: 0x12600024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 312)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128500; return;
    }
    // 0x128474: 0x27a90060
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 96));
    // 0x128478: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x12847c: 0x27a80050
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 80));
    // 0x128480: 0x2480a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 9, GPR_U32(ctx, 0));
    // 0x128484: 0x27aa0070
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 112));
    // 0x128488: 0x8fa20140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x12848c: 0x17380a
    if (GPR_U32(ctx, 23) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 0));
    // 0x128490: 0x8fa60080
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x128494: 0x1e400a
    if (GPR_U32(ctx, 30) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 0));
    // 0x128498: 0x2500a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 10, GPR_U32(ctx, 0));
    // 0x12849c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1284a0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1284a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1284a8
// Address: 0x1284a8 - 0x128518

void entry_1284a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1284a8) {
        switch (ctx->pc) {
            case 0x1284bc: ctx->pc = 0; goto label_1284bc;
            case 0x1284d0: ctx->pc = 0; goto label_1284d0;
            case 0x1284e8: ctx->pc = 0; goto label_1284e8;
            case 0x128500: ctx->pc = 0; goto label_128500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1284a8: 0x12e00004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_1284bc;
    }
    // 0x1284b0: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1284b4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1284b8: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1284bc:
    // 0x1284bc: 0x13c00004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        goto label_1284d0;
    }
    // 0x1284c4: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1284c8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1284cc: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1284d0:
    // 0x1284d0: 0x8fa20138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 312)));
    // 0x1284d4: 0x10400004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1284e8;
    }
    // 0x1284dc: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1284e0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1284e4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_1284e8:
    // 0x1284e8: 0x8fa20140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1284ec: 0x10400004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_128500;
    }
    // 0x1284f4: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1284f8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1284fc: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_128500:
    // 0x128500: 0x12e00005
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        entry_128518(rdram, ctx, runtime); return;
    }
    // 0x128508: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12850c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128510: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x128518);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_128518
// Address: 0x128518 - 0x128530

void entry_128518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128518: 0x13c00005
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        entry_128530(rdram, ctx, runtime); return;
    }
    // 0x128520: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128524: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128528: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x128530);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_128530
// Address: 0x128530 - 0x12854c

void entry_128530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128530: 0x8fa20138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 312)));
    // 0x128534: 0x10400005
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12854c(rdram, ctx, runtime); return;
    }
    // 0x12853c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128540: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128544: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x12854c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_12854c
// Address: 0x12854c - 0x128568

void entry_12854c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12854c: 0x8fa20140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x128550: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_128568(rdram, ctx, runtime); return;
    }
    // 0x128558: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12855c: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x128560: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x128568);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_128568
// Address: 0x128568 - 0x128598

void entry_128568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128568: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x12856c: 0x7bbe0110
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x128570: 0x7bb70100
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x128574: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x128578: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x12857c: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x128580: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x128584: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x128588: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12858c: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x128590: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25
// Address: 0x128598 - 0x128618

void entry_128618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128618) {
        switch (ctx->pc) {
            case 0x128620: ctx->pc = 0; goto label_128620;
            case 0x128638: ctx->pc = 0; goto label_128638;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128618: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_128638;
    }
label_128620:
    // 0x128620: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x128624: 0x7a040100
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x128628: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x12862c: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x128630: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
    // 0x128634: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
label_128638:
    // 0x128638: 0x12400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128660; return;
    }
    // 0x128640: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x128644: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x128648: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x12864c: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x128650: 0x40f809
    SET_GPR_U32(ctx, 31, 0x128658);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_128658
// Address: 0x128658 - 0x128884

void entry_128658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128658) {
        switch (ctx->pc) {
            case 0x128660: ctx->pc = 0; goto label_128660;
            case 0x12868c: ctx->pc = 0; goto label_12868c;
            case 0x1286a0: ctx->pc = 0; goto label_1286a0;
            case 0x128718: ctx->pc = 0; goto label_128718;
            case 0x128768: ctx->pc = 0; goto label_128768;
            case 0x128794: ctx->pc = 0; goto label_128794;
            case 0x1287ac: ctx->pc = 0; goto label_1287ac;
            case 0x1287b0: ctx->pc = 0; goto label_1287b0;
            case 0x1287b4: ctx->pc = 0; goto label_1287b4;
            case 0x1287d8: ctx->pc = 0; goto label_1287d8;
            case 0x128828: ctx->pc = 0; goto label_128828;
            case 0x128838: ctx->pc = 0; goto label_128838;
            case 0x128854: ctx->pc = 0; goto label_128854;
            case 0x128858: ctx->pc = 0; goto label_128858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128658: 0x1000000c
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12868c;
    }
label_128660:
    // 0x128660: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x128664: 0x7a0500d0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x128668: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x12866c: 0x7a0400e0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 224)));
    // 0x128670: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x128674: 0x7a0300f0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 240)));
    // 0x128678: 0x7fa50060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 5));
    // 0x12867c: 0x7fa40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 4));
    // 0x128680: 0x7fa30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 3));
    // 0x128684: 0x7fa60050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 6));
    // 0x128688: 0xda020100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
label_12868c:
    // 0x12868c: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x128690: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x128694: 0x16800002
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        goto label_1286a0;
    }
    // 0x12869c: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
label_1286a0:
    // 0x1286a0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1286a4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1286a8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1286ac: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1286b0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1286b4: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1286b8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1286bc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1286c0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1286c4: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1286c8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1286cc: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1286d0: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1286d4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1286d8: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1286dc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1286e0: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1286e4: 0x44822800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 2);
    // 0x1286e8: 0xde0402c8
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1286ec: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1286f0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1286f4: 0x410b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) << 2);
    // 0x1286f8: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1286fc: 0x30430003
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 2), 3));
    // 0x128700: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_128718;
    }
    // 0x128708: 0x10620017
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_128768;
    }
    // 0x128710: 0x10000028
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1287b4;
    }
label_128718:
    // 0x128718: 0x3c0141c8
    SET_GPR_U32(ctx, 1, ((uint32_t)16840 << 16));
    // 0x12871c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x128720: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x128724: 0x0
    // NOP
    // 0x128728: 0x45020022
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
        goto label_1287b4;
    }
    // 0x128730: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x128734: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x128738: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12873c: 0x0
    // NOP
    // 0x128740: 0x4500001b
    SET_GPR_U32(ctx, 3, ((uint32_t)16384 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1287b0;
    }
    // 0x128748: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12874c: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x128750: 0x34423fff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 16383));
    // 0x128754: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x128758: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x12875c: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x128760: 0x10000012
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1287ac;
    }
label_128768:
    // 0x128768: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x12876c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x128770: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x128774: 0x45010007
    if ((ctx->fcr31 & 0x800000)) {
        goto label_128794;
    }
    // 0x12877c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x128780: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x128784: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x128788: 0x0
    // NOP
    // 0x12878c: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
        goto label_1287b4;
    }
label_128794:
    // 0x128794: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x128798: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x12879c: 0x34423fff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 16383));
    // 0x1287a0: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1287a4: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1287a8: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
label_1287ac:
    // 0x1287ac: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
label_1287b0:
    // 0x1287b0: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
label_1287b4:
    // 0x1287b4: 0x210b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 2);
    // 0x1287b8: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1287bc: 0x30440003
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 2), 3));
    // 0x1287c0: 0x10800005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1287d8;
    }
    // 0x1287c8: 0x10820030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12888C; return;
    }
    // 0x1287d0: 0x1000003d
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1288C8; return;
    }
label_1287d8:
    // 0x1287d8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1287dc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1287e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1287e4: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1287e8: 0x4500001a
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_128854;
    }
    // 0x1287f0: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1287f4: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1287f8: 0x46002802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x1287fc: 0xc6220000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[2] = *(float*)&val; }
    // 0x128800: 0xc6630000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[3] = *(float*)&val; }
    // 0x128804: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x128808: 0x46012842
    ctx->f[1] = FPU_MUL_S(ctx->f[5], ctx->f[1]);
    // 0x12880c: 0x46011000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x128810: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x128814: 0x0
    // NOP
    // 0x128818: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_128828;
    }
    // 0x128820: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_128838;
    }
label_128828:
    // 0x128828: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12882c: 0x0
    // NOP
    // 0x128830: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[4]);
        goto label_128838;
    }
label_128838:
    // 0x128838: 0x46050003
    if (ctx->f[5] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[5];
    // 0x12883c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x128840: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x128844: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x128848: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12884c: 0x10000002
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_128858;
    }
label_128854:
    // 0x128854: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
label_128858:
    // 0x128858: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12885c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x128860: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x128864: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x128868: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x12886c: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x128870: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x128874: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x128878: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x12887c: 0xc051538
    SET_GPR_U32(ctx, 31, 0x128884);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    DecomposeSphere(rdram, ctx, runtime); return;
}


// Function: entry_128884
// Address: 0x128884 - 0x1288a8

void entry_128884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128884) {
        switch (ctx->pc) {
            case 0x12888c: ctx->pc = 0; goto label_12888c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128884: 0x1000000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1288C4; return;
    }
label_12888c:
    // 0x12888c: 0x12400008
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1288B0; return;
    }
    // 0x128894: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x128898: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x12889c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1288a0: 0xc051538
    SET_GPR_U32(ctx, 31, 0x1288a8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    DecomposeSphere(rdram, ctx, runtime); return;
}


// Function: entry_1288a8
// Address: 0x1288a8 - 0x1288f0

void entry_1288a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1288a8) {
        switch (ctx->pc) {
            case 0x1288b0: ctx->pc = 0; goto label_1288b0;
            case 0x1288bc: ctx->pc = 0; goto label_1288bc;
            case 0x1288c0: ctx->pc = 0; goto label_1288c0;
            case 0x1288c4: ctx->pc = 0; goto label_1288c4;
            case 0x1288c8: ctx->pc = 0; goto label_1288c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1288a8: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1288c0;
    }
label_1288b0:
    // 0x1288b0: 0x12800002
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 21), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1288bc;
    }
    // 0x1288b8: 0xae800000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 0));
label_1288bc:
    // 0x1288bc: 0xaec00000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 0));
label_1288c0:
    // 0x1288c0: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
label_1288c4:
    // 0x1288c4: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_1288c8:
    // 0x1288c8: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1288cc: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1288d0: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1288d4: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1288d8: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1288dc: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1288e0: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x1288e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1288ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1288f0; return;
}


// Function: FGetAloChildrenList__FP3ALOPv
// Address: 0x1288f0 - 0x12894c

void entry_12894c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12894c) {
        switch (ctx->pc) {
            case 0x128960: ctx->pc = 0; goto label_128960;
            case 0x128978: ctx->pc = 0; goto label_128978;
            case 0x128980: ctx->pc = 0; goto label_128980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12894c: 0x14400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_128960;
    }
    // 0x128954: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x128958: 0x10000009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_128980;
    }
label_128960:
    // 0x128960: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x128964: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x128968: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x12896c: 0xafa40010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 4));
    // 0x128970: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x128940; return;
    }
label_128978:
    // 0x128978: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x12897c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_128980:
    // 0x128980: 0xae23b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 3));
    // 0x128984: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x128988: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12898c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x128990: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PactsegNewAlo__FP3ALO
// Address: 0x128998 - 0x1289b4

void entry_1289b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1289b4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1289b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadAloFromBrx__FP3ALOP18CBinaryInputStream
// Address: 0x1289c0 - 0x1289f0

void entry_1289f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1289f0: 0x26250100
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 256));
    // 0x1289f4: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1289fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1289fc
// Address: 0x1289fc - 0x128a04

void entry_1289fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1289fc: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x128a04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128a04
// Address: 0x128a04 - 0x128a2c

void entry_128a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128a04: 0xde2302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x128a08: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x128a0c: 0x3c04fcff
    SET_GPR_U32(ctx, 4, ((uint32_t)64767 << 16));
    // 0x128a10: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x128a14: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x128a18: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x128a1c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x128a20: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128a24: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x128a2c);
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 3));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128a2c
// Address: 0x128a2c - 0x128a54

void entry_128a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128a2c: 0xde2302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x128a30: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x128a34: 0x3c04f3ff
    SET_GPR_U32(ctx, 4, ((uint32_t)62463 << 16));
    // 0x128a38: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x128a3c: 0x216b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 26);
    // 0x128a40: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x128a44: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x128a48: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128a4c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x128a54);
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 3));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128a54
// Address: 0x128a54 - 0x128a7c

void entry_128a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128a54: 0xde2302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x128a58: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x128a5c: 0x3c04cfff
    SET_GPR_U32(ctx, 4, ((uint32_t)53247 << 16));
    // 0x128a60: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x128a64: 0x21738
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 28);
    // 0x128a68: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x128a6c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x128a70: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128a74: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x128a7c);
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 3));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128a7c
// Address: 0x128a7c - 0x128a88

void entry_128a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128a7c: 0xae220088
    WRITE32(ADD32(GPR_U32(ctx, 17), 136), GPR_U32(ctx, 2));
    // 0x128a80: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x128a88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128a88
// Address: 0x128a88 - 0x128a94

void entry_128a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128a88: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128a8c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x128a94);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 128), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128a94
// Address: 0x128a94 - 0x128aa0

void entry_128a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128a94: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128a98: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x128aa0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 132), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128aa0
// Address: 0x128aa0 - 0x128aac

void entry_128aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128aa0: 0xe62002a4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 676), *(uint32_t*)&val); }
    // 0x128aa4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x128aac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128aac
// Address: 0x128aac - 0x128b08

void entry_128aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128aac) {
        switch (ctx->pc) {
            case 0x128ad8: ctx->pc = 0; goto label_128ad8;
            case 0x128b00: ctx->pc = 0; goto label_128b00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128aac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x128ab0: 0xc6210080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 128)); ctx->f[1] = *(float*)&val; }
    // 0x128ab4: 0xc4429a1c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294941212)); ctx->f[2] = *(float*)&val; }
    // 0x128ab8: 0x46020832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x128abc: 0x0
    // NOP
    // 0x128ac0: 0x45000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 680), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_128ad8;
    }
    // 0x128ac8: 0x3c015015
    SET_GPR_U32(ctx, 1, ((uint32_t)20501 << 16));
    // 0x128acc: 0x342102f9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 761));
    // 0x128ad0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x128ad4: 0xe6200080
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 128), *(uint32_t*)&val); }
label_128ad8:
    // 0x128ad8: 0xc6200084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 132)); ctx->f[0] = *(float*)&val; }
    // 0x128adc: 0x46020032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x128ae0: 0x0
    // NOP
    // 0x128ae4: 0x45000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_128b00;
    }
    // 0x128aec: 0xc6210080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 128)); ctx->f[1] = *(float*)&val; }
    // 0x128af0: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x128af4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x128af8: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x128afc: 0xe6200084
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 132), *(uint32_t*)&val); }
label_128b00:
    // 0x128b00: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x128b08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128b08
// Address: 0x128b08 - 0x128b18

void entry_128b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128b08: 0x2624022c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 556));
    // 0x128b0c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128b10: 0xc058a24
    SET_GPR_U32(ctx, 31, 0x128b18);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadGlobsetFromBrx__FP7GLOBSETP18CBinaryInputStreamP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_128b18
// Address: 0x128b18 - 0x128b24

void entry_128b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128b18: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128b1c: 0xc04a304
    SET_GPR_U32(ctx, 31, 0x128b24);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadAloAloxFromBrx__FP3ALOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128b24
// Address: 0x128b24 - 0x128b3c

void entry_128b24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128b24: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x128b28: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x128b2c: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128B40; return;
    }
    // 0x128b34: 0x40f809
    SET_GPR_U32(ctx, 31, 0x128b3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_128b3c
// Address: 0x128b3c - 0x128b48

void entry_128b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128b3c) {
        switch (ctx->pc) {
            case 0x128b40: ctx->pc = 0; goto label_128b40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128b3c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_128b40:
    // 0x128b40: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x128b48);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128b48
// Address: 0x128b48 - 0x128b54

void entry_128b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128b48: 0x220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    // 0x128b4c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x128b54);
    WRITE32(ADD32(GPR_U32(ctx, 17), 696), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_128b54
// Address: 0x128b54 - 0x128b80

void entry_128b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128b54) {
        switch (ctx->pc) {
            case 0x128b68: ctx->pc = 0; goto label_128b68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128b54: 0x8e2302b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 696)));
    // 0x128b58: 0x18600021
    WRITE32(ADD32(GPR_U32(ctx, 17), 700), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x128BE0; return;
    }
    // 0x128b60: 0x8e2302bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 700)));
    // 0x128b64: 0x0
    // NOP
label_128b68:
    // 0x128b68: 0x1010c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    // 0x128b6c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x128b70: 0x26140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 1));
    // 0x128b74: 0x629021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x128b78: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x128b80);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128b80
// Address: 0x128b80 - 0x128b90

void entry_128b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128b80: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x128b84: 0x8e24026c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 620)));
    // 0x128b88: 0xc063540
    SET_GPR_U32(ctx, 31, 0x128b90);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_128b90
// Address: 0x128b90 - 0x128ba8

void entry_128b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128b90) {
        switch (ctx->pc) {
            case 0x128ba0: ctx->pc = 0; goto label_128ba0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128b90: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    // 0x128b94: 0x8e22026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 620)));
    // 0x128b98: 0x5840000d
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 696)));
        ctx->pc = 0x128BD0; return;
    }
label_128ba0:
    // 0x128ba0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x128ba8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128ba8
// Address: 0x128ba8 - 0x128bf0

void entry_128ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128ba8) {
        switch (ctx->pc) {
            case 0x128bd0: ctx->pc = 0; goto label_128bd0;
            case 0x128be0: ctx->pc = 0; goto label_128be0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128ba8: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x128bac: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x128bb0: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x128bb4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x128bb8: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x128bbc: 0x8e22026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 620)));
    // 0x128bc0: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x128bc4: 0x1440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x128BA0; return;
    }
    // 0x128bcc: 0x8e2202b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 696)));
label_128bd0:
    // 0x128bd0: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x128bd4: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x128bd8: 0x5440ffe3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 700)));
        ctx->pc = 0x128B68; return;
    }
label_128be0:
    // 0x128be0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x128be4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128be8: 0xc047b2e
    SET_GPR_U32(ctx, 31, 0x128bf0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadSwObjectsFromBrx__FP2SWP3ALOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128bf0
// Address: 0x128bf0 - 0x128c10

void entry_128bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128bf0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x128bf4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x128bf8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x128bfc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x128c00: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x128c04: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x128c08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadAloAloxFromBrx__FP3ALOP18CBinaryInputStream
// Address: 0x128c10 - 0x128c3c

void entry_128c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128c3c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x128c40: 0x12400055
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128D98; return;
    }
    // 0x128c48: 0xc063570
    SET_GPR_U32(ctx, 31, 0x128c50);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_128c50
// Address: 0x128c50 - 0x128cac

void entry_128c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128c50: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x128c54: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x128c58: 0xae900224
    WRITE32(ADD32(GPR_U32(ctx, 20), 548), GPR_U32(ctx, 16));
    // 0x128c5c: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x128c60: 0xae1200b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 176), GPR_U32(ctx, 18));
    // 0x128c64: 0x26130030
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 48));
    // 0x128c68: 0x32450001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 18), 1));
    // 0x128c6c: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x128c70: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x128c74: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x128c78: 0x7e030010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 3));
    // 0x128c7c: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x128c80: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
    // 0x128c84: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x128c88: 0x7e030030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    // 0x128c8c: 0x78820010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x128c90: 0x7e620010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), GPR_VEC(ctx, 2));
    // 0x128c94: 0x78830020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x128c98: 0x10a00004
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_128cac(rdram, ctx, runtime); return;
    }
    // 0x128ca0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128ca4: 0xc04dfac
    SET_GPR_U32(ctx, 31, 0x128cac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReadMatrix__18CBinaryInputStreamP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_128cac
// Address: 0x128cac - 0x128cc0

void entry_128cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128cac: 0x32420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 2));
    // 0x128cb0: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_128cc0(rdram, ctx, runtime); return;
    }
    // 0x128cb8: 0xc04dfac
    SET_GPR_U32(ctx, 31, 0x128cc0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ReadMatrix__18CBinaryInputStreamP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_128cc0
// Address: 0x128cc0 - 0x128cd4

void entry_128cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128cc0: 0x3242000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 12));
    // 0x128cc4: 0x1040000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128CF8; return;
    }
    // 0x128ccc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x128cd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128cd4
// Address: 0x128cd4 - 0x128cf0

void entry_128cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128cd4: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x128cd8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x128cdc: 0x10c20005
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x128CF4; return;
    }
    // 0x128ce4: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x128ce8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x128cf0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_128cf0
// Address: 0x128cf0 - 0x128d08

void entry_128cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128cf0) {
        switch (ctx->pc) {
            case 0x128cf4: ctx->pc = 0; goto label_128cf4;
            case 0x128cf8: ctx->pc = 0; goto label_128cf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128cf0: 0xae020060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 2));
label_128cf4:
    // 0x128cf4: 0x32420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 16));
label_128cf8:
    // 0x128cf8: 0x10400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128D10; return;
    }
    // 0x128d00: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x128d08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128d08
// Address: 0x128d08 - 0x128d20

void entry_128d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128d08) {
        switch (ctx->pc) {
            case 0x128d10: ctx->pc = 0; goto label_128d10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128d08: 0xae020060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 2));
    // 0x128d0c: 0x32420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 32));
label_128d10:
    // 0x128d10: 0x10400012
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128D5C; return;
    }
    // 0x128d18: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x128d20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128d20
// Address: 0x128d20 - 0x128d30

void entry_128d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128d20: 0xae020084
    WRITE32(ADD32(GPR_U32(ctx, 16), 132), GPR_U32(ctx, 2));
    // 0x128d24: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128d28: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x128d30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 96));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_128d30
// Address: 0x128d30 - 0x128d3c

void entry_128d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128d30: 0x26050070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 112));
    // 0x128d34: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x128d3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_128d3c
// Address: 0x128d3c - 0x128d44

void entry_128d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128d3c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x128d44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128d44
// Address: 0x128d44 - 0x128d4c

void entry_128d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128d44: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x128d4c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_128d4c
// Address: 0x128d4c - 0x128d6c

void entry_128d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128d4c) {
        switch (ctx->pc) {
            case 0x128d5c: ctx->pc = 0; goto label_128d5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128d4c: 0xae000098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
    // 0x128d50: 0xe6000090
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 144), *(uint32_t*)&val); }
    // 0x128d54: 0xe600008c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 140), *(uint32_t*)&val); }
    // 0x128d58: 0x32420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 64));
label_128d5c:
    // 0x128d5c: 0x10400008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128D80; return;
    }
    // 0x128d64: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x128d6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128d6c
// Address: 0x128d6c - 0x128d78

void entry_128d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128d6c: 0xae020060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 2));
    // 0x128d70: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x128d78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128d78
// Address: 0x128d78 - 0x128d90

void entry_128d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128d78) {
        switch (ctx->pc) {
            case 0x128d80: ctx->pc = 0; goto label_128d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128d78: 0xae020064
    WRITE32(ADD32(GPR_U32(ctx, 16), 100), GPR_U32(ctx, 2));
    // 0x128d7c: 0x32420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 128));
label_128d80:
    // 0x128d80: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128D98; return;
    }
    // 0x128d88: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x128d90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_128d90
// Address: 0x128d90 - 0x128db8

void entry_128d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128d90) {
        switch (ctx->pc) {
            case 0x128d98: ctx->pc = 0; goto label_128d98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128d90: 0xae0200a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 160), GPR_U32(ctx, 2));
    // 0x128d94: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_128d98:
    // 0x128d98: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x128d9c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x128da0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x128da4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x128da8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x128dac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x128db4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x128db8; return;
}


// Function: BindAloAlox__FP3ALO
// Address: 0x128db8 - 0x128dfc

void entry_128dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128dfc) {
        switch (ctx->pc) {
            case 0x128e08: ctx->pc = 0; goto label_128e08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128dfc: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x128e00: 0xae020060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 2));
    // 0x128e04: 0xae030064
    WRITE32(ADD32(GPR_U32(ctx, 16), 100), GPR_U32(ctx, 3));
label_128e08:
    // 0x128e08: 0x8e0200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 176)));
    // 0x128e0c: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x128e10: 0x1040000b
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128E40; return;
    }
    // 0x128e18: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x128e1c: 0xc056912
    SET_GPR_U32(ctx, 31, 0x128e24);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 132)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_128e24
// Address: 0x128e24 - 0x128e3c

void entry_128e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128e24: 0xae020084
    WRITE32(ADD32(GPR_U32(ctx, 16), 132), GPR_U32(ctx, 2));
    // 0x128e28: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128e2c: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x128e30: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x128e34: 0xc056a1a
    SET_GPR_U32(ctx, 31, 0x128e3c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 128), GPR_U32(ctx, 3));
    PaloFindLoCommonParent__FP2LOT0(rdram, ctx, runtime); return;
}


// Function: entry_128e3c
// Address: 0x128e3c - 0x128e5c

void entry_128e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128e3c) {
        switch (ctx->pc) {
            case 0x128e40: ctx->pc = 0; goto label_128e40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128e3c: 0xae020088
    WRITE32(ADD32(GPR_U32(ctx, 16), 136), GPR_U32(ctx, 2));
label_128e40:
    // 0x128e40: 0x8e0200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 176)));
    // 0x128e44: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x128e48: 0x1040000a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x128E74; return;
    }
    // 0x128e50: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x128e54: 0xc056912
    SET_GPR_U32(ctx, 31, 0x128e5c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_128e5c
// Address: 0x128e5c - 0x128e70

void entry_128e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x128e5c: 0xae020060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 2));
    // 0x128e60: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x128e64: 0x8e050064
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 100)));
    // 0x128e68: 0xc056912
    SET_GPR_U32(ctx, 31, 0x128e70);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_128e70
// Address: 0x128e70 - 0x128e88

void entry_128e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x128e70) {
        switch (ctx->pc) {
            case 0x128e74: ctx->pc = 0; goto label_128e74;
            case 0x128e78: ctx->pc = 0; goto label_128e78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x128e70: 0xae020064
    WRITE32(ADD32(GPR_U32(ctx, 16), 100), GPR_U32(ctx, 2));
label_128e74:
    // 0x128e74: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_128e78:
    // 0x128e78: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x128e7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x128e80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustAloRotation__FP3ALOP7MATRIX3P6VECTOR
// Address: 0x128e88 - 0x128fd0

void entry_129080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129080) {
        switch (ctx->pc) {
            case 0x1290a4: ctx->pc = 0; goto label_1290a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129080: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x129084: 0x7ba30040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x129088: 0x7ba40050
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12908c: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x129090: 0x7e040020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 4));
    // 0x129094: 0x7e030010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 3));
    // 0x129098: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x12909c: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x1290a0: 0x7fa40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 4));
label_1290a4:
    // 0x1290a4: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1290a8: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1290ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1290b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1290b8; return;
}


// Function: SetAloInitialVelocity__FP3ALOP6VECTOR
// Address: 0x1290b8 - 0x1290e0

void entry_12912c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12912c) {
        switch (ctx->pc) {
            case 0x129160: ctx->pc = 0; goto label_129160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12912c: 0xae0202a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 672), GPR_U32(ctx, 2));
    // 0x129130: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x129134: 0xac430004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    // 0x129138: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12913c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x129140: 0x8e0202a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 672)));
    // 0x129144: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x129148: 0x8e0302a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 672)));
    // 0x12914c: 0xac60000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 0));
    // 0x129150: 0x8e0202a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 672)));
    // 0x129154: 0xe4400010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
    // 0x129158: 0x8e0202a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 672)));
    // 0x12915c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_129160:
    // 0x129160: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129164: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12916c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129170; return;
}


// Function: SetAloFastShadowRadius__FP3ALOf
// Address: 0x129170 - 0x129188

void entry_1291f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1291f8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1291fc: 0xc06c6b2
    SET_GPR_U32(ctx, 31, 0x129204);
    WRITE32(ADD32(GPR_U32(ctx, 16), 644), GPR_U32(ctx, 2));
    InitShadow__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_129204
// Address: 0x129204 - 0x129214

void entry_129204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129204: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x129208: 0x8e050284
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 644)));
    // 0x12920c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x129214);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7168));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_129214
// Address: 0x129214 - 0x129228

void entry_129214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129214) {
        switch (ctx->pc) {
            case 0x12921c: ctx->pc = 0; goto label_12921c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129214: 0x8e020284
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 644)));
    // 0x129218: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12921c:
    // 0x12921c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129220: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloCastShadow__FP3ALOi
// Address: 0x129228 - 0x129244

void entry_129244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129244) {
        switch (ctx->pc) {
            case 0x12924c: ctx->pc = 0; goto label_12924c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129244: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12927C; return;
    }
label_12924c:
    // 0x12924c: 0x8e050284
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 644)));
    // 0x129250: 0x10a0000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12927C; return;
    }
    // 0x129258: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x12925c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x129264);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7168));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_129264
// Address: 0x129264 - 0x129274

void entry_129264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129264: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x129268: 0x8e050284
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 644)));
    // 0x12926c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x129274);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8960));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_129274
// Address: 0x129274 - 0x129288

void entry_129274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129274) {
        switch (ctx->pc) {
            case 0x12927c: ctx->pc = 0; goto label_12927c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129274: 0xae000284
    WRITE32(ADD32(GPR_U32(ctx, 16), 644), GPR_U32(ctx, 0));
    // 0x129278: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12927c:
    // 0x12927c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129280: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloShadowShader__FP3ALO3OID
// Address: 0x129288 - 0x12929c

void entry_12929c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12929c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1292a0: 0xc06c73e
    SET_GPR_U32(ctx, 31, 0x1292a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetShadowShader__FP6SHADOW3OID(rdram, ctx, runtime); return;
}


// Function: entry_1292a8
// Address: 0x1292a8 - 0x1292b8

void entry_1292a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1292a8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1292ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1292b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloShadowNearRadius__FP3ALOf
// Address: 0x1292b8 - 0x1292cc

void entry_1292cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1292cc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1292d0: 0xc06c75c
    SET_GPR_U32(ctx, 31, 0x1292d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetShadowNearRadius__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_1292d8
// Address: 0x1292d8 - 0x1292e8

void entry_1292d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1292d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1292dc: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1292e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloShadowFarRadius__FP3ALOf
// Address: 0x1292e8 - 0x1292fc

void entry_1292fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1292fc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x129300: 0xc06c76a
    SET_GPR_U32(ctx, 31, 0x129308);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetShadowFarRadius__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_129308
// Address: 0x129308 - 0x129318

void entry_129308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129308: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12930c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x129310: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloShadowNearCast__FP3ALOf
// Address: 0x129318 - 0x12932c

void entry_12932c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12932c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x129330: 0xc06c7ec
    SET_GPR_U32(ctx, 31, 0x129338);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetShadowNearCast__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_129338
// Address: 0x129338 - 0x129348

void entry_129338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129338: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12933c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x129340: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloShadowFarCast__FP3ALOf
// Address: 0x129348 - 0x12935c

void entry_12935c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12935c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x129360: 0xc06c7f8
    SET_GPR_U32(ctx, 31, 0x129368);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetShadowFarCast__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_129368
// Address: 0x129368 - 0x129378

void entry_129368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129368: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12936c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x129370: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloShadowConeAngle__FP3ALOf
// Address: 0x129378 - 0x12938c

void entry_12938c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12938c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x129390: 0xc06c804
    SET_GPR_U32(ctx, 31, 0x129398);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetShadowConeAngle__FP6SHADOWf(rdram, ctx, runtime); return;
}


// Function: entry_129398
// Address: 0x129398 - 0x1293a8

void entry_129398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129398: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12939c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1293a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloShadowFrustrumUp__FP3ALOP6VECTOR
// Address: 0x1293a8 - 0x1293bc

void entry_1293bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1293bc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1293c0: 0xc06c81a
    SET_GPR_U32(ctx, 31, 0x1293c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetShadowFrustrumUp__FP6SHADOWP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1293c8
// Address: 0x1293c8 - 0x1293d8

void entry_1293c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1293c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1293cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1293d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloDynamicShadowObject__FP3ALO3OID
// Address: 0x1293d8 - 0x1293ec

void entry_1293ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1293ec: 0xac5000b0
    WRITE32(ADD32(GPR_U32(ctx, 2), 176), GPR_U32(ctx, 16));
    // 0x1293f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1293f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1293f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PshadowInferAlo__FP3ALO
// Address: 0x129400 - 0x129428

void entry_129428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129428) {
        switch (ctx->pc) {
            case 0x129430: ctx->pc = 0; goto label_129430;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129428: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12942c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_129430:
    // 0x129430: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129434: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12943c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129440; return;
}


// Function: GetAloCastShadow__FP3ALOPi
// Address: 0x129440 - 0x129450

void entry_129494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129494: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x129498: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12949c: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1294a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1294a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1294ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1294b0; return;
}


// Function: GetAloShadowFarRadius__FP3ALOPf
// Address: 0x1294b0 - 0x1294c4

void entry_1294c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1294c4: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1294c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1294cc: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1294d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1294d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1294dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1294e0; return;
}


// Function: GetAloShadowNearCast__FP3ALOPf
// Address: 0x1294e0 - 0x1294f4

void entry_1294f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1294f4: 0xc4400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1294f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1294fc: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x129500: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129504: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12950c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129510; return;
}


// Function: GetAloShadowFarCast__FP3ALOPf
// Address: 0x129510 - 0x129524

void entry_129524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129524: 0xc4400044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[0] = *(float*)&val; }
    // 0x129528: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12952c: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x129530: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129534: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12953c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129540; return;
}


// Function: GetAloShadowConeAngle__FP3ALOPf
// Address: 0x129540 - 0x129554

void entry_129554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129554: 0xc4400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[0] = *(float*)&val; }
    // 0x129558: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x12955c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x129560: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x129564: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x12956c);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_12956c
// Address: 0x12956c - 0x129598

void entry_12956c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12956c: 0x3c014265
    SET_GPR_U32(ctx, 1, ((uint32_t)16997 << 16));
    // 0x129570: 0x34212ee0
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 12000));
    // 0x129574: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x129578: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12957c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x129580: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x129584: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x129588: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12958c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x129594: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129598; return;
}


// Function: GetAloShadowFrustrumUp__FP3ALOP6VECTOR
// Address: 0x129598 - 0x1295ac

void entry_1295ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1295ac: 0x78430030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1295b0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1295b4: 0x7e030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 3));
    // 0x1295b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1295bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1295c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1295c8; return;
}


// Function: GetAloEuler__FP3ALOP6VECTOR
// Address: 0x1295c8 - 0x129604

void entry_129604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129604: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x129608: 0xc0623f6
    SET_GPR_U32(ctx, 31, 0x129610);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixEuler__FP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129610
// Address: 0x129610 - 0x129648

void entry_129610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129610) {
        switch (ctx->pc) {
            case 0x129620: ctx->pc = 0; goto label_129620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129610: 0x3c014265
    SET_GPR_U32(ctx, 1, ((uint32_t)16997 << 16));
    // 0x129614: 0x34212ee0
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 12000));
    // 0x129618: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12961c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_129620:
    // 0x129620: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x129624: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x129628: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x12962c: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x129630: 0x441fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_129620;
    }
    // 0x129638: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12963c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x129640: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloEuler__FP3ALOP6VECTOR
// Address: 0x129648 - 0x1296a0

void entry_1296a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1296a0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1296a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1296a8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1296ac: 0x8c6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 180)));
    // 0x1296b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1296b8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1296b8
// Address: 0x1296b8 - 0x1296cc

void entry_1296b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1296b8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1296bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1296c0: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1296c4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1296cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1296cc
// Address: 0x1296cc - 0x1296e0

void entry_1296cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1296cc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1296d0: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1296d4: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1296d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureAloActRestore__FP3ALO
// Address: 0x1296e0 - 0x129710

void entry_129710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129710: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x129714: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x129718: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x129720);
    WRITE32(ADD32(GPR_U32(ctx, 16), 508), GPR_U32(ctx, 2));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_129720
// Address: 0x129720 - 0x129730

void entry_129720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129720) {
        switch (ctx->pc) {
            case 0x129724: ctx->pc = 0; goto label_129724;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129720: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_129724:
    // 0x129724: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129728: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureAloActla__FP3ALO
// Address: 0x129730 - 0x129760

void entry_129760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129760: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x129764: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x129768: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x129770);
    WRITE32(ADD32(GPR_U32(ctx, 16), 512), GPR_U32(ctx, 2));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_129770
// Address: 0x129770 - 0x129780

void entry_129770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129770) {
        switch (ctx->pc) {
            case 0x129774: ctx->pc = 0; goto label_129774;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129770: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_129774:
    // 0x129774: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129778: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RecacheAloActList__FP3ALO
// Address: 0x129780 - 0x1297c0

void entry_1297c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1297c0) {
        switch (ctx->pc) {
            case 0x1297e0: ctx->pc = 0; goto label_1297e0;
            case 0x1297f8: ctx->pc = 0; goto label_1297f8;
            case 0x129810: ctx->pc = 0; goto label_129810;
            case 0x12982c: ctx->pc = 0; goto label_12982c;
            case 0x129868: ctx->pc = 0; goto label_129868;
            case 0x129894: ctx->pc = 0; goto label_129894;
            case 0x129898: ctx->pc = 0; goto label_129898;
            case 0x1298b0: ctx->pc = 0; goto label_1298b0;
            case 0x1298b8: ctx->pc = 0; goto label_1298b8;
            case 0x1298d0: ctx->pc = 0; goto label_1298d0;
            case 0x1298e4: ctx->pc = 0; goto label_1298e4;
            case 0x1298e8: ctx->pc = 0; goto label_1298e8;
            case 0x1298f0: ctx->pc = 0; goto label_1298f0;
            case 0x129900: ctx->pc = 0; goto label_129900;
            case 0x129910: ctx->pc = 0; goto label_129910;
            case 0x129920: ctx->pc = 0; goto label_129920;
            case 0x129938: ctx->pc = 0; goto label_129938;
            case 0x129958: ctx->pc = 0; goto label_129958;
            case 0x12995c: ctx->pc = 0; goto label_12995c;
            case 0x12996c: ctx->pc = 0; goto label_12996c;
            case 0x129970: ctx->pc = 0; goto label_129970;
            case 0x129984: ctx->pc = 0; goto label_129984;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1297c0: 0x8e0601e0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 480)));
    // 0x1297c4: 0x10c0004a
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 504)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1298f0;
    }
    // 0x1297cc: 0x3c020022
    SET_GPR_U32(ctx, 2, ((uint32_t)34 << 16));
    // 0x1297d0: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1297d4: 0x244a97c0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 2), 4294940608));
    // 0x1297d8: 0x2409001c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1297dc: 0x0
    // NOP
label_1297e0:
    // 0x1297e0: 0x16200005
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_1297f8;
    }
    // 0x1297e8: 0x80c20010
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x1297ec: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1297f0: 0x21027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1297f4: 0x2880a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 0));
label_1297f8:
    // 0x1297f8: 0x16400005
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_129810;
    }
    // 0x129800: 0x80c20011
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 17)));
    // 0x129804: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x129808: 0x21027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x12980c: 0x2900a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 0));
label_129810:
    // 0x129810: 0x56600006
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 19)));
        goto label_12982c;
    }
    // 0x129818: 0x80c20012
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 18)));
    // 0x12981c: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x129820: 0x21027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x129824: 0x2980a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 0));
    // 0x129828: 0x80c20013
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 19)));
label_12982c:
    // 0x12982c: 0x504b002e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 11)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
        goto label_1298e8;
    }
    // 0x129834: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x129838: 0x544a001d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 10)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 620)));
        goto label_1298b0;
    }
    // 0x129840: 0x8cc2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 28)));
    // 0x129844: 0x8cc40028
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 40)));
    // 0x129848: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12984c: 0x892018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x129850: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x129854: 0x443821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x129858: 0x8ce30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 20)));
    // 0x12985c: 0x18600021
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1298e4;
    }
    // 0x129864: 0x0
    // NOP
label_129868:
    // 0x129868: 0x8ce20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 24)));
    // 0x12986c: 0x52080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 5), 2));
    // 0x129870: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x129874: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x129878: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 20)));
        goto label_129898;
    }
    // 0x129880: 0x8e0201f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 504)));
    // 0x129884: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x129888: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12988c: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 6));
        goto label_129894;
    }
label_129894:
    // 0x129894: 0x8ce20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 20)));
label_129898:
    // 0x129898: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x12989c: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x1298a0: 0x1440fff1
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 504)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_129868;
    }
    // 0x1298a8: 0x1000000f
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1298e8;
    }
label_1298b0:
    // 0x1298b0: 0x1840000c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1298e4;
    }
label_1298b8:
    // 0x1298b8: 0x8e0201f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 504)));
    // 0x1298bc: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1298c0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1298c4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1298c8: 0x50800001
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 6));
        goto label_1298d0;
    }
label_1298d0:
    // 0x1298d0: 0x8e02026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 620)));
    // 0x1298d4: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1298d8: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x1298dc: 0x1440fff6
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 504)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1298b8;
    }
label_1298e4:
    // 0x1298e4: 0x8cc60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
label_1298e8:
    // 0x1298e8: 0x14c0ffbd
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_1297e0;
    }
label_1298f0:
    // 0x1298f0: 0x12200003
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_129900;
    }
    // 0x1298f8: 0x82220010
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1298fc: 0x2880a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 0));
label_129900:
    // 0x129900: 0x12400003
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_129910;
    }
    // 0x129908: 0x82420011
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 17)));
    // 0x12990c: 0x2900a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 0));
label_129910:
    // 0x129910: 0x12600003
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_129920;
    }
    // 0x129918: 0x82620012
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 19), 18)));
    // 0x12991c: 0x2980a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 0));
label_129920:
    // 0x129920: 0x51000013
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 492)));
        goto label_129970;
    }
    // 0x129928: 0x8e02026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 620)));
    // 0x12992c: 0x1840000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_12996c;
    }
    // 0x129934: 0x8e0301f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 504)));
label_129938:
    // 0x129938: 0x51080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 2));
    // 0x12993c: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x129940: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x129944: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 620)));
        goto label_12995c;
    }
    // 0x12994c: 0x80420013
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 19)));
    // 0x129950: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
        goto label_129958;
    }
label_129958:
    // 0x129958: 0x8e02026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 620)));
label_12995c:
    // 0x12995c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x129960: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x129964: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 504)));
        goto label_129938;
    }
label_12996c:
    // 0x12996c: 0x8e0201ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 492)));
label_129970:
    // 0x129970: 0x16220004
    WRITE32(ADD32(GPR_U32(ctx, 16), 500), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_129984;
    }
    // 0x129978: 0x8e0201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 496)));
    // 0x12997c: 0x12420012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1299C8; return;
    }
label_129984:
    // 0x129984: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x12998c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12998c
// Address: 0x12998c - 0x1299a8

void entry_12998c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12998c: 0x8e0201ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 492)));
    // 0x129990: 0x52220006
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 496)));
        ctx->pc = 0x1299AC; return;
    }
    // 0x129998: 0x12200003
    WRITE32(ADD32(GPR_U32(ctx, 16), 492), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_1299a8(rdram, ctx, runtime); return;
    }
    // 0x1299a0: 0xc0489b6
    SET_GPR_U32(ctx, 31, 0x1299a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AdaptAct__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1299a8
// Address: 0x1299a8 - 0x1299c4

void entry_1299a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1299a8) {
        switch (ctx->pc) {
            case 0x1299ac: ctx->pc = 0; goto label_1299ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1299a8: 0x8e0201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 496)));
label_1299ac:
    // 0x1299ac: 0x12420006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1299C8; return;
    }
    // 0x1299b4: 0x12400004
    WRITE32(ADD32(GPR_U32(ctx, 16), 496), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1299C8; return;
    }
    // 0x1299bc: 0xc0489b6
    SET_GPR_U32(ctx, 31, 0x1299c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AdaptAct__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_1299c4
// Address: 0x1299c4 - 0x1299e0

void entry_1299c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1299c4) {
        switch (ctx->pc) {
            case 0x1299c8: ctx->pc = 0; goto label_1299c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1299c4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1299c8:
    // 0x1299c8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1299cc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1299d0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1299d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1299d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InsertAloAct__FP3ALOP3ACT
// Address: 0x1299e0 - 0x129a38

void entry_129a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129a38: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x129a3c: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x129a40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x129a48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_129a48
// Address: 0x129a48 - 0x129a58

void entry_129a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129a48: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129a4c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129a50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ResortAloActList__FP3ALO
// Address: 0x129a58 - 0x129ad4

void entry_129ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129ad4) {
        switch (ctx->pc) {
            case 0x129af4: ctx->pc = 0; goto label_129af4;
            case 0x129b08: ctx->pc = 0; goto label_129b08;
            case 0x129b38: ctx->pc = 0; goto label_129b38;
            case 0x129b50: ctx->pc = 0; goto label_129b50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129ad4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x129ad8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x129adc: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x129ae0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x129ae4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x129ae8: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x129aec: 0x14c0fff4
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x129AC0; return;
    }
label_129af4:
    // 0x129af4: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x129af8: 0x6200019
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_S32(ctx, 17) < 0) {
        ctx->pc = 0x129B60; return;
    }
    // 0x129b00: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x129b04: 0x0
    // NOP
label_129b08:
    // 0x129b08: 0x8e4501e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 480)));
    // 0x129b0c: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x129b10: 0x2630ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x129b14: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x129b18: 0x10a0000d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 480));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_129b50;
    }
    // 0x129b20: 0x8ca20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 20)));
    // 0x129b24: 0x8cc30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 20)));
    // 0x129b28: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x129b2c: 0x10400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_129b50;
    }
    // 0x129b34: 0x8ca50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
label_129b38:
    // 0x129b38: 0x10a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_129b50;
    }
    // 0x129b40: 0x8ca20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 20)));
    // 0x129b44: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x129b48: 0x5440fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
        goto label_129b38;
    }
label_129b50:
    // 0x129b50: 0xc054950
    SET_GPR_U32(ctx, 31, 0x129b58);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InsertDlEntryBefore__FP2DLPvT1(rdram, ctx, runtime); return;
}


// Function: entry_129b58
// Address: 0x129b58 - 0x129b70

void entry_129b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129b58) {
        switch (ctx->pc) {
            case 0x129b60: ctx->pc = 0; goto label_129b60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129b58: 0x621ffeb
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x129B08; return;
    }
label_129b60:
    // 0x129b60: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x129b64: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x129b68: 0x60f809
    SET_GPR_U32(ctx, 31, 0x129b70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_129b70
// Address: 0x129b70 - 0x129b98

void entry_129b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129b70: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x129b74: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x129b78: 0xae82b314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    // 0x129b7c: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x129b80: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x129b84: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x129b88: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x129b8c: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x129b90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PasegaFindAlo__FP3ALO3OID
// Address: 0x129b98 - 0x129bec

void entry_129bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129bec) {
        switch (ctx->pc) {
            case 0x129bf8: ctx->pc = 0; goto label_129bf8;
            case 0x129c00: ctx->pc = 0; goto label_129c00;
            case 0x129c04: ctx->pc = 0; goto label_129c04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129bec: 0x14400005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_129c04;
    }
    // 0x129bf4: 0x8e100034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 52)));
label_129bf8:
    // 0x129bf8: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x129BD0; return;
    }
label_129c00:
    // 0x129c00: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_129c04:
    // 0x129c04: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x129c08: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x129c0c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x129c10: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129c14: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129c18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsmaFindAlo__FP3ALO3OID
// Address: 0x129c20 - 0x129c74

void entry_129c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129c74) {
        switch (ctx->pc) {
            case 0x129c80: ctx->pc = 0; goto label_129c80;
            case 0x129c88: ctx->pc = 0; goto label_129c88;
            case 0x129c8c: ctx->pc = 0; goto label_129c8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129c74: 0x14400005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_129c8c;
    }
    // 0x129c7c: 0x8e100010
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 16)));
label_129c80:
    // 0x129c80: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x129C58; return;
    }
label_129c88:
    // 0x129c88: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_129c8c:
    // 0x129c8c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x129c90: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x129c94: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x129c98: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129c9c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129ca0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PasegaFindAloNearest__FP3ALO
// Address: 0x129ca8 - 0x129d00

void entry_129d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129d3c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x129d40: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x129d44: 0xae120014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 18));
    // 0x129d48: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x129d50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_129d50
// Address: 0x129d50 - 0x129d70

void entry_129d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129d50) {
        switch (ctx->pc) {
            case 0x129d54: ctx->pc = 0; goto label_129d54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129d50: 0xae700000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 16));
label_129d54:
    // 0x129d54: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x129d58: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x129d5c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129d60: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129d64: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129d68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIsAloStatic__FP3ALO
// Address: 0x129d70 - 0x129d88

void entry_129d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129d88: 0x10400017
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x129DE8; return;
    }
    // 0x129d90: 0xc048f80
    SET_GPR_U32(ctx, 31, 0x129d98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 352));
    FIsZeroW__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129d98
// Address: 0x129d98 - 0x129dd0

void entry_129d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129d98) {
        switch (ctx->pc) {
            case 0x129da8: ctx->pc = 0; goto label_129da8;
            case 0x129db8: ctx->pc = 0; goto label_129db8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129d98: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 52)));
        goto label_129da8;
    }
    // 0x129da0: 0x10000011
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x129DE8; return;
    }
label_129da8:
    // 0x129da8: 0x1200000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x129DE8; return;
    }
    // 0x129db0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x129db4: 0x0
    // NOP
label_129db8:
    // 0x129db8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x129dbc: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x129dc0: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x129DDC; return;
    }
    // 0x129dc8: 0xc04a75c
    SET_GPR_U32(ctx, 31, 0x129dd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsAloStatic__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_129dd0
// Address: 0x129dd0 - 0x129df8

void entry_129dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129dd0) {
        switch (ctx->pc) {
            case 0x129ddc: ctx->pc = 0; goto label_129ddc;
            case 0x129de8: ctx->pc = 0; goto label_129de8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129dd0: 0x10400005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_129de8;
    }
    // 0x129dd8: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_129ddc:
    // 0x129ddc: 0x5600fff6
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x129DB8; return;
    }
    // 0x129de4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_129de8:
    // 0x129de8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129dec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129df0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ResolveAlo__FP3ALO
// Address: 0x129df8 - 0x129e10

void entry_129e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129e38: 0x7bb20010
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129e3c: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x129e40: 0xc046344
    SET_GPR_U32(ctx, 31, 0x129e48);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129e48
// Address: 0x129e48 - 0x129e54

void entry_129e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129e48: 0x7ba50020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129e4c: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x129e54);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 18)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129e54
// Address: 0x129e54 - 0x129e60

void entry_129e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129e54: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x129e58: 0xc046348
    SET_GPR_U32(ctx, 31, 0x129e60);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129e60
// Address: 0x129e60 - 0x129e6c

void entry_129e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129e60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x129e64: 0xc04a7a2
    SET_GPR_U32(ctx, 31, 0x129e6c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetAloPositionSpringDetail__FP3ALOP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_129e6c
// Address: 0x129e6c - 0x129e88

void entry_129e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129e6c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x129e70: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x129e74: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x129e78: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x129e7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x129e84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129e88; return;
}


// Function: SetAloPositionSpringDetail__FP3ALOP3CLQ
// Address: 0x129e88 - 0x129eb8

void entry_129eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129eb8) {
        switch (ctx->pc) {
            case 0x129ec0: ctx->pc = 0; goto label_129ec0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129eb8: 0xae02020c
    WRITE32(ADD32(GPR_U32(ctx, 16), 524), GPR_U32(ctx, 2));
    // 0x129ebc: 0x8e03020c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 524)));
label_129ec0:
    // 0x129ec0: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x129ec4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129ec8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129ecc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129ed0: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x129ed4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x129edc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129ee0; return;
}


// Function: SetAloPositionDamping__FP3ALOf
// Address: 0x129ee0 - 0x129f08

void entry_129f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129f08: 0x7bb20010
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129f0c: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x129f10: 0xc046344
    SET_GPR_U32(ctx, 31, 0x129f18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129f18
// Address: 0x129f18 - 0x129f24

void entry_129f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129f18: 0x7ba50020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129f1c: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x129f24);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 18)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129f24
// Address: 0x129f24 - 0x129f30

void entry_129f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129f24: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x129f28: 0xc046348
    SET_GPR_U32(ctx, 31, 0x129f30);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129f30
// Address: 0x129f30 - 0x129f3c

void entry_129f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129f30: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x129f34: 0xc04a7d6
    SET_GPR_U32(ctx, 31, 0x129f3c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetAloPositionDampingDetail__FP3ALOP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_129f3c
// Address: 0x129f3c - 0x129f58

void entry_129f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129f3c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x129f40: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x129f44: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x129f48: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x129f4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x129f54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129f58; return;
}


// Function: SetAloPositionDampingDetail__FP3ALOP3CLQ
// Address: 0x129f58 - 0x129f88

void entry_129f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x129f88) {
        switch (ctx->pc) {
            case 0x129f90: ctx->pc = 0; goto label_129f90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x129f88: 0xae020210
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    // 0x129f8c: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
label_129f90:
    // 0x129f90: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x129f94: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129f98: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129f9c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x129fa0: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x129fa4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x129fac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x129fb0; return;
}


// Function: SetAloRotationSpring__FP3ALOf
// Address: 0x129fb0 - 0x129fd8

void entry_129fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129fd8: 0x7bb20010
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x129fdc: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x129fe0: 0xc046344
    SET_GPR_U32(ctx, 31, 0x129fe8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129fe8
// Address: 0x129fe8 - 0x129ff4

void entry_129fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129fe8: 0x7ba50020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x129fec: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x129ff4);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 18)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_129ff4
// Address: 0x129ff4 - 0x12a000

void entry_129ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x129ff4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x129ff8: 0xc046348
    SET_GPR_U32(ctx, 31, 0x12a000);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12a000
// Address: 0x12a000 - 0x12a00c

void entry_12a000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a000: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12a004: 0xc04a80a
    SET_GPR_U32(ctx, 31, 0x12a00c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetAloRotationSpringDetail__FP3ALOP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_12a00c
// Address: 0x12a00c - 0x12a028

void entry_12a00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a00c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12a010: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12a014: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12a018: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12a01c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a024: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a028; return;
}


// Function: SetAloRotationSpringDetail__FP3ALOP3CLQ
// Address: 0x12a028 - 0x12a058

void entry_12a058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12a058) {
        switch (ctx->pc) {
            case 0x12a060: ctx->pc = 0; goto label_12a060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12a058: 0xae020214
    WRITE32(ADD32(GPR_U32(ctx, 16), 532), GPR_U32(ctx, 2));
    // 0x12a05c: 0x8e030214
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 532)));
label_12a060:
    // 0x12a060: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12a064: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a068: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a06c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a070: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x12a074: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a07c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a080; return;
}


// Function: SetAloRotationDamping__FP3ALOf
// Address: 0x12a080 - 0x12a0a8

void entry_12a0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a0a8: 0x7bb20010
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a0ac: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x12a0b0: 0xc046344
    SET_GPR_U32(ctx, 31, 0x12a0b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12a0b8
// Address: 0x12a0b8 - 0x12a0c4

void entry_12a0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a0b8: 0x7ba50020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a0bc: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x12a0c4);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 18)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12a0c4
// Address: 0x12a0c4 - 0x12a0d0

void entry_12a0c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a0c4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12a0c8: 0xc046348
    SET_GPR_U32(ctx, 31, 0x12a0d0);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12a0d0
// Address: 0x12a0d0 - 0x12a0dc

void entry_12a0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a0d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12a0d4: 0xc04a83e
    SET_GPR_U32(ctx, 31, 0x12a0dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetAloRotationDampingDetail__FP3ALOP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_12a0dc
// Address: 0x12a0dc - 0x12a0f8

void entry_12a0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a0dc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12a0e0: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12a0e4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12a0e8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12a0ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a0f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a0f8; return;
}


// Function: SetAloRotationDampingDetail__FP3ALOP3CLQ
// Address: 0x12a0f8 - 0x12a128

void entry_12a128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12a128) {
        switch (ctx->pc) {
            case 0x12a130: ctx->pc = 0; goto label_12a130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12a128: 0xae020218
    WRITE32(ADD32(GPR_U32(ctx, 16), 536), GPR_U32(ctx, 2));
    // 0x12a12c: 0x8e030218
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 536)));
label_12a130:
    // 0x12a130: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12a134: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a138: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a13c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a140: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x12a144: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a14c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a150; return;
}


// Function: SetAloPositionSmooth__FP3ALOf
// Address: 0x12a150 - 0x12a194

void entry_12a194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a194: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a198: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloPositionSmoothMaxAccel__FP3ALOf
// Address: 0x12a1a0 - 0x12a1f0

void entry_12a1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a1f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a1f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a1fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a200; return;
}


// Function: SetAloPositionSmoothDetail__FP3ALOP4SMPA
// Address: 0x12a200 - 0x12a230

void entry_12a230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12a230) {
        switch (ctx->pc) {
            case 0x12a234: ctx->pc = 0; goto label_12a234;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12a230: 0xae02021c
    WRITE32(ADD32(GPR_U32(ctx, 16), 540), GPR_U32(ctx, 2));
label_12a234:
    // 0x12a234: 0x8e02021c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 540)));
    // 0x12a238: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a23c: 0x6a230007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a240: 0x6e230000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a244: 0x6a24000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12a248: 0x6e240008
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12a24c: 0xb0430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a250: 0xb4430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a254: 0xb044000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a258: 0xb4440008
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a25c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a260: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a264: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a26c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a270; return;
}


// Function: SetAloRotationSmooth__FP3ALOf
// Address: 0x12a270 - 0x12a2b4

void entry_12a2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a2b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a2b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloRotationSmoothMaxAccel__FP3ALOf
// Address: 0x12a2c0 - 0x12a310

void entry_12a310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a310: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a314: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a31c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a320; return;
}


// Function: SetAloRotationSmoothDetail__FP3ALOP4SMPA
// Address: 0x12a320 - 0x12a350

void entry_12a350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12a350) {
        switch (ctx->pc) {
            case 0x12a354: ctx->pc = 0; goto label_12a354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12a350: 0xae020220
    WRITE32(ADD32(GPR_U32(ctx, 16), 544), GPR_U32(ctx, 2));
label_12a354:
    // 0x12a354: 0x8e020220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 544)));
    // 0x12a358: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a35c: 0x6a230007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a360: 0x6e230000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a364: 0x6a24000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12a368: 0x6e240008
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12a36c: 0xb0430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a370: 0xb4430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a374: 0xb044000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a378: 0xb4440008
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a37c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a380: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a384: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a38c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a390; return;
}


// Function: SetAloDefaultAckPos__FP3ALO3ACK
// Address: 0x12a390 - 0x12a398

void entry_12a3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a3bc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a3c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0012a3c8
// Address: 0x12a3c8 - 0x12a3d8

void FUN_0012a3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a3c8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x12a3cc: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x12a3d0: 0xc04a8fa
    SET_GPR_U32(ctx, 31, 0x12a3d8);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 5)));
    FUN_0012a3e8(rdram, ctx, runtime); return;
}


// Function: entry_12a3d8
// Address: 0x12a3d8 - 0x12a3e8

void entry_12a3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a3d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a3dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a3e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a3e8; return;
}


// Function: FUN_0012a3e8
// Address: 0x12a3e8 - 0x12a418

void FUN_0012a3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a3e8: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x12a3ec: 0x30a50003
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 3));
    // 0x12a3f0: 0x2403fcff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x12a3f4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x12a3f8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x12a3fc: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x12a400: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x12a404: 0x52a3c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 8));
    // 0x12a408: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12a40c: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x12a410: 0x3e00008
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0012a418
// Address: 0x12a418 - 0x12a430

void FUN_0012a418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a418: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x12a41c: 0x2123e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 8));
    // 0x12a420: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x12a424: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a42c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a430; return;
}


// Function: SetAloRestorePositionAck__FP3ALO3ACK
// Address: 0x12a430 - 0x12a44c

void entry_12a44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a44c: 0x8e0301fc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 508)));
    // 0x12a450: 0xa0710010
    WRITE8(ADD32(GPR_U32(ctx, 3), 16), (uint8_t)GPR_U32(ctx, 17));
    // 0x12a454: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12a458: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x12a45c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12a464);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12a464
// Address: 0x12a464 - 0x12a478

void entry_12a464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a464: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a468: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a46c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a470: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloRestoreRotation__FP3ALOi
// Address: 0x12a478 - 0x12a494

void entry_12a494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a494: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a498: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloRestoreRotationAck__FP3ALO3ACK
// Address: 0x12a4a0 - 0x12a4bc

void entry_12a4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a4bc: 0x8e0301fc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 508)));
    // 0x12a4c0: 0xa0710011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 17));
    // 0x12a4c4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12a4c8: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x12a4cc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12a4d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12a4d4
// Address: 0x12a4d4 - 0x12a4e8

void entry_12a4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a4d4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a4d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a4dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a4e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0012a4e8
// Address: 0x12a4e8 - 0x12a504

void FUN_0012a4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a4e8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x12a4ec: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x12a4f0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x12a4f4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x12a4f8: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x12a4fc: 0xc04a5b8
    SET_GPR_U32(ctx, 31, 0x12a504);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    EnsureAloActRestore__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12a504
// Address: 0x12a504 - 0x12a514

void entry_12a504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a504: 0x8e0201fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 508)));
    // 0x12a508: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12a50c: 0xc04a696
    SET_GPR_U32(ctx, 31, 0x12a514);
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 17));
    ResortAloActList__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12a514
// Address: 0x12a514 - 0x12a528

void entry_12a514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a514: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a518: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a51c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a520: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloLookAt__FP3ALO3ACK
// Address: 0x12a528 - 0x12a544

void entry_12a544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a544: 0x8e250200
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 512)));
    // 0x12a548: 0x24030009
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 9));
    // 0x12a54c: 0x3a020003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 16), 3));
    // 0x12a550: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x12a554: 0xa0b00011
    WRITE8(ADD32(GPR_U32(ctx, 5), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x12a558: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12a55c: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x12a560: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12a568);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12a568
// Address: 0x12a568 - 0x12a580

void entry_12a568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a568: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a56c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a570: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a574: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a57c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a580; return;
}


// Function: SetAloLookAtIgnore__FP3ALOf
// Address: 0x12a580 - 0x12a59c

void entry_12a59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a59c: 0x8e020200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a5a0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a5a4: 0xe4540040
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 64), *(uint32_t*)&val); }
    // 0x12a5a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a5ac: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x12a5b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloLookAtIgnore__FP3ALOPf
// Address: 0x12a5b8 - 0x12a5d0

void entry_12a5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a5ec: 0x8e030200
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a5f0: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12a5f4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a5f8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a5fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a600: 0x7c620050
    WRITE128(ADD32(GPR_U32(ctx, 3), 80), GPR_VEC(ctx, 2));
    // 0x12a604: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a60c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a610; return;
}


// Function: GetAloLookAtPanFunction__FP3ALOP3CLQ
// Address: 0x12a610 - 0x12a630

void entry_12a64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a64c: 0x8e020200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a650: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a654: 0x6a230007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a658: 0x6e230000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a65c: 0xb0430067
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 103); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a660: 0xb4430060
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 96); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a664: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a668: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a66c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a674: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a678; return;
}


// Function: GetAloLookAtPanLimits__FP3ALOP2LM
// Address: 0x12a678 - 0x12a6a0

void entry_12a6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a6bc: 0x8e030200
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a6c0: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12a6c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a6c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a6cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a6d0: 0x7c620070
    WRITE128(ADD32(GPR_U32(ctx, 3), 112), GPR_VEC(ctx, 2));
    // 0x12a6d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a6dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a6e0; return;
}


// Function: GetAloLookAtTiltFunction__FP3ALOP3CLQ
// Address: 0x12a6e0 - 0x12a700

void entry_12a71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a71c: 0x8e020200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a720: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a724: 0x6a230007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a728: 0x6e230000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12a72c: 0xb0430087
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 135); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a730: 0xb4430080
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 128); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12a734: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a738: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a73c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a744: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a748; return;
}


// Function: GetAloLookAtTiltLimits__FP3ALOP2LM
// Address: 0x12a748 - 0x12a770

void entry_12a78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a78c: 0x8e020200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a790: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a794: 0xac510044
    WRITE32(ADD32(GPR_U32(ctx, 2), 68), GPR_U32(ctx, 17));
    // 0x12a798: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a79c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a7a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloLookAtEnabledPriority__FP3ALOPi
// Address: 0x12a7a8 - 0x12a7c0

void entry_12a7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a7dc: 0x8e020200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a7e0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a7e4: 0xac510048
    WRITE32(ADD32(GPR_U32(ctx, 2), 72), GPR_U32(ctx, 17));
    // 0x12a7e8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a7ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a7f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloLookAtDisabledPriority__FP3ALOPi
// Address: 0x12a7f8 - 0x12a810

void FUN_0012a810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a810: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x12a814: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x12a818: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x12a81c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x12a820: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x12a824: 0xc04a5cc
    SET_GPR_U32(ctx, 31, 0x12a82c);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    EnsureAloActla__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12a82c
// Address: 0x12a82c - 0x12a848

void entry_12a82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a82c: 0x8e020200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 512)));
    // 0x12a830: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a834: 0xac510020
    WRITE32(ADD32(GPR_U32(ctx, 2), 32), GPR_U32(ctx, 17));
    // 0x12a838: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a83c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a840: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0012a848
// Address: 0x12a848 - 0x12a860

void FUN_0012a848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12a848) {
        switch (ctx->pc) {
            case 0x12a858: ctx->pc = 0; goto label_12a858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12a848: 0x8c820200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 512)));
    // 0x12a84c: 0x10400002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12a858;
    }
    // 0x12a854: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
label_12a858:
    // 0x12a858: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0012a860
// Address: 0x12a860 - 0x12a878

void FUN_0012a860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a860: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x12a864: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x12a868: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x12a86c: 0x24c68d30
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937904));
    // 0x12a870: 0xc0614fc
    SET_GPR_U32(ctx, 31, 0x12a878);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 512)));
    SetActlaTarget__FP5ACTLAP3ALOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12a878
// Address: 0x12a878 - 0x12a888

void entry_12a878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a878: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a87c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a888; return;
}


// Function: FUN_0012a888
// Address: 0x12a888 - 0x12a8a0

void FUN_0012a888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a888: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x12a88c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x12a890: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x12a894: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x12a898: 0xc06151a
    SET_GPR_U32(ctx, 31, 0x12a8a0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 512)));
    PaloGetActlaTarget__FP5ACTLA(rdram, ctx, runtime); return;
}


// Function: entry_12a8a0
// Address: 0x12a8a0 - 0x12a8b8

void entry_12a8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a8a0: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x12a8a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a8a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a8ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a8b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a8b8; return;
}


// Function: FUN_0012a8b8
// Address: 0x12a8b8 - 0x12a8c8

void FUN_0012a8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a8b8: 0x8c820200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 512)));
    // 0x12a8bc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 2), 76), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a8c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a8c8; return;
}


// Function: FUN_0012a8c8
// Address: 0x12a8c8 - 0x12a8d8

void FUN_0012a8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a8c8: 0x8c830200
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 512)));
    // 0x12a8cc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12a8d0: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 3), 76), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloRotationMatchesVelocity__FP3ALOff3ACK
// Address: 0x12a8d8 - 0x12a91c

void entry_12a91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a91c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12a920: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12a924: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x12a92c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 516), GPR_U32(ctx, 2));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_12a92c
// Address: 0x12a92c - 0x12a954

void entry_12a92c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a92c: 0x8e030204
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 516)));
    // 0x12a930: 0xa0710011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 17));
    // 0x12a934: 0x8e020204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 516)));
    // 0x12a938: 0xe454001c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 28), *(uint32_t*)&val); }
    // 0x12a93c: 0x8e030204
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 516)));
    // 0x12a940: 0xe4750020
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 3), 32), *(uint32_t*)&val); }
    // 0x12a944: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12a948: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x12a94c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12a954);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12a954
// Address: 0x12a954 - 0x12a970

void entry_12a954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a954: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12a958: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a95c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a960: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x12a964: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x12a968: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PtargetEnsureAlo__FP3ALO
// Address: 0x12a970 - 0x12a994

void entry_12a994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12a994: 0x14400008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12A9B8; return;
    }
    // 0x12a99c: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x12a9a0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12a9a4: 0x24040075
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 117));
    // 0x12a9a8: 0x2407022a
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 554));
    // 0x12a9ac: 0xc047960
    SET_GPR_U32(ctx, 31, 0x12a9b4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_12a9b4
// Address: 0x12a9b4 - 0x12a9c8

void entry_12a9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12a9b4) {
        switch (ctx->pc) {
            case 0x12a9b8: ctx->pc = 0; goto label_12a9b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12a9b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12a9b8:
    // 0x12a9b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a9bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a9c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12a9c8; return;
}


// Function: SetAloTargetAttacks__FP3ALOi
// Address: 0x12a9c8 - 0x12a9dc

void entry_12a9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12a9dc) {
        switch (ctx->pc) {
            case 0x12a9ec: ctx->pc = 0; goto label_12a9ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12a9dc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12a9e0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12a9e4: 0x56020001
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 136), GPR_U32(ctx, 16));
        goto label_12a9ec;
    }
label_12a9ec:
    // 0x12a9ec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12a9f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12a9f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12a9fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12aa00; return;
}


// Function: SetAloTargetRadius__FP3ALOf
// Address: 0x12aa00 - 0x12aa14

void entry_12aa14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12aa14: 0xe454008c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 140), *(uint32_t*)&val); }
    // 0x12aa18: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12aa1c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x12aa20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloTargetHitTest__FP3ALOi
// Address: 0x12aa28 - 0x12aa3c

void entry_12aa3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12aa3c: 0xac500090
    WRITE32(ADD32(GPR_U32(ctx, 2), 144), GPR_U32(ctx, 16));
    // 0x12aa40: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12aa44: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12aa48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloScrollingMasterSpeeds__FP3ALOff
// Address: 0x12aa50 - 0x12aab4

void entry_12aab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12aab4) {
        switch (ctx->pc) {
            case 0x12aab8: ctx->pc = 0; goto label_12aab8;
            case 0x12aac8: ctx->pc = 0; goto label_12aac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12aab4: 0x8e22027c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 636)));
label_12aab8:
    // 0x12aab8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x12aabc: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12aac0: 0x5440fff3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 640)));
        ctx->pc = 0x12AA90; return;
    }
label_12aac8:
    // 0x12aac8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12aacc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12aad0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12aad4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12aad8: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x12aadc: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x12aae0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloEyesClosed__FP3ALOf
// Address: 0x12aae8 - 0x12ab40

void entry_12ab40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ab40) {
        switch (ctx->pc) {
            case 0x12ab44: ctx->pc = 0; goto label_12ab44;
            case 0x12ab54: ctx->pc = 0; goto label_12ab54;
            case 0x12ab68: ctx->pc = 0; goto label_12ab68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ab40: 0x8e22027c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 636)));
label_12ab44:
    // 0x12ab44: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x12ab48: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12ab4c: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 640)));
        ctx->pc = 0x12AB20; return;
    }
label_12ab54:
    // 0x12ab54: 0x8e300034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x12ab58: 0x1200000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12AB90; return;
    }
    // 0x12ab60: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12ab64: 0x0
    // NOP
label_12ab68:
    // 0x12ab68: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12ab6c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x12ab70: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12ab80(rdram, ctx, runtime); return;
    }
    // 0x12ab78: 0xc04aaba
    SET_GPR_U32(ctx, 31, 0x12ab80);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetAloEyesClosed__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_12ab80
// Address: 0x12ab80 - 0x12aba8

void entry_12ab80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ab80) {
        switch (ctx->pc) {
            case 0x12ab90: ctx->pc = 0; goto label_12ab90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ab80: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x12ab84: 0x5600fff8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x12AB68; return;
    }
    // 0x12ab8c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_12ab90:
    // 0x12ab90: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12ab94: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12ab98: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ab9c: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x12aba0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureAloSfx__FP3ALO
// Address: 0x12aba8 - 0x12abc4

void entry_12abc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12abc4) {
        switch (ctx->pc) {
            case 0x12abc8: ctx->pc = 0; goto label_12abc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12abc4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_12abc8:
    // 0x12abc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloSfxid__FP3ALO5SFXID
// Address: 0x12abd0 - 0x12abec

void entry_12abec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12abec: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12abf0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12abf4: 0xac510000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 17));
    // 0x12abf8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12abfc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12ac00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloSfxidSpl__FP3ALO5SFXID
// Address: 0x12ac08 - 0x12ac24

void entry_12ac24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ac24: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12ac28: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12ac2c: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x12ac34);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_12ac34
// Address: 0x12ac34 - 0x12ac70

void entry_12ac34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ac34: 0x8e0302ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12ac38: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12ac3c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12ac40: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12ac44: 0xac710000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 17));
    // 0x12ac48: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12ac4c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12ac50: 0x24480014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 20));
    // 0x12ac54: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x12ac58: 0x2445001c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 28));
    // 0x12ac5c: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x12ac60: 0xc44e000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[14] = *(float*)&val; }
    // 0x12ac64: 0xc44f0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[15] = *(float*)&val; }
    // 0x12ac68: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x12ac70);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[16] = *(float*)&val; }
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_12ac70
// Address: 0x12ac70 - 0x12ac88

void entry_12ac70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ac70: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12ac74: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ac78: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12ac7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12ac84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12ac88; return;
}


// Function: GetAloSfxid__FP3ALOP5SFXID
// Address: 0x12ac88 - 0x12aca0

void entry_12acbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12acbc: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12acc0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12acc4: 0xe4540004
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x12acc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12accc: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x12acd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloSStart__FP3ALOPf
// Address: 0x12acd8 - 0x12acf8

void entry_12ad14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ad14: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12ad18: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ad1c: 0xe4540008
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x12ad20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12ad24: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x12ad28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloSndRepeat__FP3ALOP2LM
// Address: 0x12ad30 - 0x12ad4c

void entry_12ad4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ad4c: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12ad50: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12ad54: 0x6a230007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12ad58: 0x6e230000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12ad5c: 0xb043001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12ad60: 0xb4430014
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 20); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12ad64: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ad68: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12ad6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12ad74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12ad78; return;
}


// Function: GetAloSFull__FP3ALOPf
// Address: 0x12ad78 - 0x12ad98

void entry_12adb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12adb4: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12adb8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12adbc: 0xe454000c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x12adc0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12adc4: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x12adc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloUDoppler__FP3ALOf
// Address: 0x12add0 - 0x12adec

void entry_12adec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12adec: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12adf0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12adf4: 0xe4540020
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 32), *(uint32_t*)&val); }
    // 0x12adf8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12adfc: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x12ae00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloUDoppler__FP3ALOPf
// Address: 0x12ae08 - 0x12ae20

void entry_12ae48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ae48) {
        switch (ctx->pc) {
            case 0x12ae4c: ctx->pc = 0; goto label_12ae4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ae48: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_12ae4c:
    // 0x12ae4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12ae54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12ae58; return;
}


// Function: GetAloUVolume__FP3ALOPf
// Address: 0x12ae58 - 0x12ae78

void entry_12ae94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ae94: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12ae98: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ae9c: 0xe4540010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
    // 0x12aea0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12aea4: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x12aea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloUPitchSpl__FP3ALOf
// Address: 0x12aeb0 - 0x12aed8

void entry_12aed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12aed8) {
        switch (ctx->pc) {
            case 0x12aedc: ctx->pc = 0; goto label_12aedc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12aed8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_12aedc:
    // 0x12aedc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12aee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12aee8; return;
}


// Function: GetAloUPitch__FP3ALOPf
// Address: 0x12aee8 - 0x12af00

void entry_12af74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12af74: 0x8e0302ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12af78: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12af7c: 0xac710000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 17));
    // 0x12af80: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12af84: 0xe4540004
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x12af88: 0x8e0302ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12af8c: 0xe4750008
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 3), 8), *(uint32_t*)&val); }
    // 0x12af90: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12af94: 0xe456000c
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x12af98: 0x8e0302ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12af9c: 0x6a420007
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x12afa0: 0x6e420000
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x12afa4: 0xb062001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12afa8: 0xb4620014
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 20); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12afac: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12afb0: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x12afb8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_12afb8
// Address: 0x12afb8 - 0x12afec

void entry_12afb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12afb8: 0x8e0202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 684)));
    // 0x12afbc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12afc0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12afc4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12afc8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12afcc: 0x24480014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 20));
    // 0x12afd0: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x12afd4: 0x2445001c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 28));
    // 0x12afd8: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x12afdc: 0xc44e000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[14] = *(float*)&val; }
    // 0x12afe0: 0xc44f0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[15] = *(float*)&val; }
    // 0x12afe4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x12afec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[16] = *(float*)&val; }
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_12afec
// Address: 0x12afec - 0x12b010

void entry_12afec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12afec: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12aff0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12aff4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12aff8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12affc: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x12b000: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x12b004: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x12b008: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StopAloSound__FP3ALO
// Address: 0x12b010 - 0x12b030

void entry_12b030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b030) {
        switch (ctx->pc) {
            case 0x12b034: ctx->pc = 0; goto label_12b034;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b030: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_12b034:
    // 0x12b034: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b03c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b040; return;
}


// Function: EnsureAloThrob__FP3ALO
// Address: 0x12b040 - 0x12b064

void entry_12b064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b064) {
        switch (ctx->pc) {
            case 0x12b0a0: ctx->pc = 0; goto label_12b0a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b064: 0xae020288
    WRITE32(ADD32(GPR_U32(ctx, 16), 648), GPR_U32(ctx, 2));
    // 0x12b068: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x12b06c: 0x24a51000
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4096));
    // 0x12b070: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12b074: 0x78a30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x12b078: 0x7c430000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    // 0x12b07c: 0x78a40010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x12b080: 0x7c440010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 4));
    // 0x12b084: 0x78a30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x12b088: 0x7c430020
    WRITE128(ADD32(GPR_U32(ctx, 2), 32), GPR_VEC(ctx, 3));
    // 0x12b08c: 0x78a40030
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 5), 48)));
    // 0x12b090: 0x7c440030
    WRITE128(ADD32(GPR_U32(ctx, 2), 48), GPR_VEC(ctx, 4));
    // 0x12b094: 0x8e020288
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 648)));
    // 0x12b098: 0xac460000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 6));
    // 0x12b09c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12b0a0:
    // 0x12b0a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b0a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b0ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b0b0; return;
}


// Function: SetAloThrobKind__FP3ALO6THROBK
// Address: 0x12b0b0 - 0x12b0cc

void entry_12b0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b0cc) {
        switch (ctx->pc) {
            case 0x12b114: ctx->pc = 0; goto label_12b114;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b0cc: 0x8e020288
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 648)));
    // 0x12b0d0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12b0d4: 0xac510000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 17));
    // 0x12b0d8: 0x8e050288
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 648)));
    // 0x12b0dc: 0x8ca40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x12b0e0: 0x1083000c
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_12b114;
    }
    // 0x12b0e8: 0x42180
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 6));
    // 0x12b0ec: 0x24630f00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 3840));
    // 0x12b0f0: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x12b0f4: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12b0f8: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x12b0fc: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x12b100: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x12b104: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x12b108: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
    // 0x12b10c: 0x78830030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 48)));
    // 0x12b110: 0x7ca30030
    WRITE128(ADD32(GPR_U32(ctx, 5), 48), GPR_VEC(ctx, 3));
label_12b114:
    // 0x12b114: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12b118: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b11c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b120: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloThrobKind__FP3ALOP6THROBK
// Address: 0x12b128 - 0x12b140

void entry_12b15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b15c: 0x8e030288
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 648)));
    // 0x12b160: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12b164: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12b168: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b16c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b170: 0x7c620010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 2));
    // 0x12b174: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b17c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b180; return;
}


// Function: GetAloThrobInColor__FP3ALOP6VECTOR
// Address: 0x12b180 - 0x12b1a0

void entry_12b1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b1bc: 0x8e030288
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 648)));
    // 0x12b1c0: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12b1c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12b1c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b1cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b1d0: 0x7c620020
    WRITE128(ADD32(GPR_U32(ctx, 3), 32), GPR_VEC(ctx, 2));
    // 0x12b1d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b1dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b1e0; return;
}


// Function: GetAloThrobOutColor__FP3ALOP6VECTOR
// Address: 0x12b1e0 - 0x12b200

void entry_12b21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b21c: 0x8e020288
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 648)));
    // 0x12b220: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b224: 0xe4540030
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 48), *(uint32_t*)&val); }
    // 0x12b228: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b22c: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x12b230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloThrobDtInOut__FP3ALOPf
// Address: 0x12b238 - 0x12b250

void entry_12b3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b3a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12b3a8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12b3ac: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x12b3b4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 704), GPR_U32(ctx, 2));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_12b3b4
// Address: 0x12b3b4 - 0x12b408

void entry_12b3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b3b4) {
        switch (ctx->pc) {
            case 0x12b3b8: ctx->pc = 0; goto label_12b3b8;
            case 0x12b3f0: ctx->pc = 0; goto label_12b3f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b3b4: 0x8e0302c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 704)));
label_12b3b8:
    // 0x12b3b8: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x12b3bc: 0x2606026c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 620));
    // 0x12b3c0: 0x1128c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 3));
    // 0x12b3c4: 0x80620013
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 19)));
    // 0x12b3c8: 0xa0640013
    WRITE8(ADD32(GPR_U32(ctx, 3), 19), (uint8_t)GPR_U32(ctx, 4));
    // 0x12b3cc: 0x38420003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 3));
    // 0x12b3d0: 0x8e0302c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 704)));
    // 0x12b3d4: 0x2382b
    SET_GPR_U32(ctx, 7, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x12b3d8: 0xac660038
    WRITE32(ADD32(GPR_U32(ctx, 3), 56), GPR_U32(ctx, 6));
    // 0x12b3dc: 0x8e0402bc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 700)));
    // 0x12b3e0: 0x8e0302c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 704)));
    // 0x12b3e4: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x12b3e8: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x12b3ec: 0xac62003c
    WRITE32(ADD32(GPR_U32(ctx, 3), 60), GPR_U32(ctx, 2));
label_12b3f0:
    // 0x12b3f0: 0x10e00006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12B40C; return;
    }
    // 0x12b3f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12b3fc: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x12b400: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12b408);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12b408
// Address: 0x12b408 - 0x12b420

void entry_12b408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b408) {
        switch (ctx->pc) {
            case 0x12b40c: ctx->pc = 0; goto label_12b40c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b408: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_12b40c:
    // 0x12b40c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b410: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b414: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b41c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b420; return;
}


// Function: SetAloForceCameraFade__FP3ALOi
// Address: 0x12b420 - 0x12b484

void entry_12b484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b484: 0x1040000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12B4B8; return;
    }
    // 0x12b48c: 0x12200006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12B4A8; return;
    }
    // 0x12b494: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12b498: 0xc050ebe
    SET_GPR_U32(ctx, 31, 0x12b4a0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    AddCmFadeObject(rdram, ctx, runtime); return;
}


// Function: entry_12b4a0
// Address: 0x12b4a0 - 0x12b4b4

void entry_12b4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b4a0) {
        switch (ctx->pc) {
            case 0x12b4a8: ctx->pc = 0; goto label_12b4a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b4a0: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12B4B8; return;
    }
label_12b4a8:
    // 0x12b4a8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12b4ac: 0xc050ec8
    SET_GPR_U32(ctx, 31, 0x12b4b4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    RemoveCmFadeObject(rdram, ctx, runtime); return;
}


// Function: entry_12b4b4
// Address: 0x12b4b4 - 0x12b4c8

void entry_12b4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b4b4) {
        switch (ctx->pc) {
            case 0x12b4b8: ctx->pc = 0; goto label_12b4b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b4b4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_12b4b8:
    // 0x12b4b8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b4bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b4c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAloRealClock__FP3ALOi
// Address: 0x12b4c8 - 0x12b4fc

void entry_12b4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b4fc: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 660), GPR_U32(ctx, 17));
        ctx->pc = 0x12B53C; return;
    }
    // 0x12b504: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x12b508: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 660), GPR_U32(ctx, 17));
        ctx->pc = 0x12B53C; return;
    }
    // 0x12b510: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12b514: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x12b518: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12b520);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12b520
// Address: 0x12b520 - 0x12b534

void entry_12b520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b520: 0xae110294
    WRITE32(ADD32(GPR_U32(ctx, 16), 660), GPR_U32(ctx, 17));
    // 0x12b524: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12b528: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x12b52c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12b534);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12b534
// Address: 0x12b534 - 0x12b550

void entry_12b534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b534) {
        switch (ctx->pc) {
            case 0x12b53c: ctx->pc = 0; goto label_12b53c;
            case 0x12b540: ctx->pc = 0; goto label_12b540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b534: 0x10000002
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12b540;
    }
label_12b53c:
    // 0x12b53c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_12b540:
    // 0x12b540: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b544: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b548: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0012b550
// Address: 0x12b550 - 0x12b590

void FUN_0012b550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b550) {
        switch (ctx->pc) {
            case 0x12b56c: ctx->pc = 0; goto label_12b56c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b550: 0x10a00006
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_12b56c;
    }
    // 0x12b558: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x12b55c: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x12b560: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12b564: 0x3e00008
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
label_12b56c:
    // 0x12b56c: 0x2403fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x12b570: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x12b574: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x12b578: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x12b57c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x12b580: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12b584: 0x3e00008
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b58c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b590; return;
}


// Function: FUN_0012b590
// Address: 0x12b590 - 0x12b5b8

void FUN_0012b590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b590) {
        switch (ctx->pc) {
            case 0x12b5b0: ctx->pc = 0; goto label_12b5b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b590: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x12b594: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x12b598: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x12b59c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12b5a0: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12b5b0;
    }
    // 0x12b5a8: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
label_12b5b0:
    // 0x12b5b0: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0012b5b8
// Address: 0x12b5b8 - 0x12b614

void FUN_0012b5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b5b8) {
        switch (ctx->pc) {
            case 0x12b5f0: ctx->pc = 0; goto label_12b5f0;
            case 0x12b604: ctx->pc = 0; goto label_12b604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b5b8: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x12b5bc: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x12b5c0: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x12b5c4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x12b5c8: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x12b5cc: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x12b5d0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x12b5d4: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x12b5d8: 0x12220005
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_12b5f0;
    }
    // 0x12b5e0: 0x12420003
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        goto label_12b5f0;
    }
    // 0x12b5e8: 0x16320028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x12B68C; return;
    }
label_12b5f0:
    // 0x12b5f0: 0x56200004
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 548)));
        goto label_12b604;
    }
    // 0x12b5f8: 0x52400008
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x12B61C; return;
    }
    // 0x12b600: 0x8e020224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 548)));
label_12b604:
    // 0x12b604: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x12B61C; return;
    }
    // 0x12b60c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12b614);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12b614
// Address: 0x12b614 - 0x12b674

void entry_12b614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b614) {
        switch (ctx->pc) {
            case 0x12b61c: ctx->pc = 0; goto label_12b61c;
            case 0x12b634: ctx->pc = 0; goto label_12b634;
            case 0x12b63c: ctx->pc = 0; goto label_12b63c;
            case 0x12b658: ctx->pc = 0; goto label_12b658;
            case 0x12b65c: ctx->pc = 0; goto label_12b65c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b614: 0xae020224
    WRITE32(ADD32(GPR_U32(ctx, 16), 548), GPR_U32(ctx, 2));
    // 0x12b618: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
label_12b61c:
    // 0x12b61c: 0x12220005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_12b634;
    }
    // 0x12b624: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x12b628: 0xac710060
    WRITE32(ADD32(GPR_U32(ctx, 3), 96), GPR_U32(ctx, 17));
    // 0x12b62c: 0x10000003
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12b63c;
    }
label_12b634:
    // 0x12b634: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x12b638: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
label_12b63c:
    // 0x12b63c: 0xac6200b0
    WRITE32(ADD32(GPR_U32(ctx, 3), 176), GPR_U32(ctx, 2));
    // 0x12b640: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x12b644: 0x12420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        goto label_12b658;
    }
    // 0x12b64c: 0xac720060
    WRITE32(ADD32(GPR_U32(ctx, 3), 96), GPR_U32(ctx, 18));
    // 0x12b650: 0x10000002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12b65c;
    }
label_12b658:
    // 0x12b658: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
label_12b65c:
    // 0x12b65c: 0xac6200b0
    WRITE32(ADD32(GPR_U32(ctx, 3), 176), GPR_U32(ctx, 2));
    // 0x12b660: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12b664: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12b668: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x12b66c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x12b674);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 256));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_12b674
// Address: 0x12b674 - 0x12b688

void entry_12b674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b674: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12b678: 0x260700d0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 208));
    // 0x12b67c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12b680: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x12b688);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 272));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_12b688
// Address: 0x12b688 - 0x12b6a0

void entry_12b688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b688) {
        switch (ctx->pc) {
            case 0x12b68c: ctx->pc = 0; goto label_12b68c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b688: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_12b68c:
    // 0x12b68c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12b690: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b694: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b698: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0012B6A0
// Address: 0x12b6a0 - 0x12b6b8

void FUN_0012b6b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b6b8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x12b6bc: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x12b6c0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x12b6c4: 0xc048fb4
    SET_GPR_U32(ctx, 31, 0x12b6cc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12b6cc
// Address: 0x12b6cc - 0x12b760

void entry_12b6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b6cc) {
        switch (ctx->pc) {
            case 0x12b700: ctx->pc = 0; goto label_12b700;
            case 0x12b718: ctx->pc = 0; goto label_12b718;
            case 0x12b72c: ctx->pc = 0; goto label_12b72c;
            case 0x12b730: ctx->pc = 0; goto label_12b730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b6cc: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x12b6d0: 0x3c030015
    SET_GPR_U32(ctx, 3, ((uint32_t)21 << 16));
    // 0x12b6d4: 0x3c04ffff
    SET_GPR_U32(ctx, 4, ((uint32_t)65535 << 16));
    // 0x12b6d8: 0x24638d64
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937956));
    // 0x12b6dc: 0x34420018
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 24));
    // 0x12b6e0: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x12b6e4: 0x3c08edb8
    SET_GPR_U32(ctx, 8, ((uint32_t)60856 << 16));
    // 0x12b6e8: 0xae0202d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 724), GPR_U32(ctx, 2));
    // 0x12b6ec: 0xae0302d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 3));
    // 0x12b6f0: 0x260902dc
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 732));
    // 0x12b6f4: 0xae0402d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 4));
    // 0x12b6f8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12b6fc: 0x35088320
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 33568));
label_12b700:
    // 0x12b700: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x12b704: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x12b708: 0x43880
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 4), 2));
    // 0x12b70c: 0x24860001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1));
    // 0x12b710: 0x41842
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 4), 1));
    // 0x12b714: 0x0
    // NOP
label_12b718:
    // 0x12b718: 0x30820001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 1));
    // 0x12b71c: 0x10400003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12b72c;
    }
    // 0x12b724: 0x10000002
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12b730;
    }
label_12b72c:
    // 0x12b72c: 0x42042
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), 1));
label_12b730:
    // 0x12b730: 0x4a1fff9
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 4), 1));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_12b718;
    }
    // 0x12b738: 0x1271821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 7)));
    // 0x12b73c: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x12b740: 0x28a20100
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 256));
    // 0x12b744: 0x1440ffee
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12b700;
    }
    // 0x12b74c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b750: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b754: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b75c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b760; return;
}


// Function: anticrack_itm_firewall
// Address: 0x12b760 - 0x12b85c

void entry_12b85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b85c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b860: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartupAseg__Fv
// Address: 0x12b868 - 0x12b870

void entry_12b884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b884: 0x2604006c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 108));
    // 0x12b888: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x12b890);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 60));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_12b890
// Address: 0x12b890 - 0x12b8c8

void entry_12b890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b890: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12b894: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x12b898: 0x26020080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 128));
    // 0x12b89c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12b8a0: 0xe6000080
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 128), *(uint32_t*)&val); }
    // 0x12b8a4: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x12b8a8: 0xac400004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 0));
    // 0x12b8ac: 0xe6000098
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 152), *(uint32_t*)&val); }
    // 0x12b8b0: 0xae000090
    WRITE32(ADD32(GPR_U32(ctx, 16), 144), GPR_U32(ctx, 0));
    // 0x12b8b4: 0xe6000094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    // 0x12b8b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12b8bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12b8c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12b8c8; return;
}


// Function: LoadAsegFromBrx__FP4ASEGP18CBinaryInputStream
// Address: 0x12b8c8 - 0x12b90c

void entry_12b90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b90c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12b910: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12b918);
    WRITE32(ADD32(GPR_U32(ctx, 19), 64), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12b918
// Address: 0x12b918 - 0x12b93c

void entry_12b918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b918: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x12b91c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x12b920: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x12b924: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x12b928: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12b92c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12b930: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x12b934: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x12b93c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 52), *(uint32_t*)&val); }
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12b93c
// Address: 0x12b93c - 0x12b948

void entry_12b93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b93c: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x12b940: 0xc063540
    SET_GPR_U32(ctx, 31, 0x12b948);
    WRITE32(ADD32(GPR_U32(ctx, 19), 160), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12b948
// Address: 0x12b948 - 0x12b960

void entry_12b948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b948) {
        switch (ctx->pc) {
            case 0x12b958: ctx->pc = 0; goto label_12b958;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b948: 0x8e6300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 160)));
    // 0x12b94c: 0x1860000d
    WRITE32(ADD32(GPR_U32(ctx, 19), 164), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x12B984; return;
    }
    // 0x12b954: 0x0
    // NOP
label_12b958:
    // 0x12b958: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12b960);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12b960
// Address: 0x12b960 - 0x12b990

void entry_12b960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b960) {
        switch (ctx->pc) {
            case 0x12b984: ctx->pc = 0; goto label_12b984;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b960: 0x8e6400a4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 164)));
    // 0x12b964: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x12b968: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x12b96c: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x12b970: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x12b974: 0x8e6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 160)));
    // 0x12b978: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12b97c: 0x1440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12B958; return;
    }
label_12b984:
    // 0x12b984: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12b988: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12b990);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12b990
// Address: 0x12b990 - 0x12b9cc

void entry_12b990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b990: 0x267e0058
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 88));
    // 0x12b994: 0x26630054
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 84));
    // 0x12b998: 0x2404001c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 28));
    // 0x12b99c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x12b9a0: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12b9a4: 0xae620038
    WRITE32(ADD32(GPR_U32(ctx, 19), 56), GPR_U32(ctx, 2));
    // 0x12b9a8: 0x26630060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 96));
    // 0x12b9ac: 0x2662005c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 92));
    // 0x12b9b0: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x12b9b4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x12b9b8: 0x26630068
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 104));
    // 0x12b9bc: 0x26620064
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 100));
    // 0x12b9c0: 0xafa30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    // 0x12b9c4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12b9cc);
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12b9cc
// Address: 0x12b9cc - 0x12b9f0

void entry_12b9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12b9cc) {
        switch (ctx->pc) {
            case 0x12b9d8: ctx->pc = 0; goto label_12b9d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12b9cc: 0x8e630038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 56)));
    // 0x12b9d0: 0x18600072
    WRITE32(ADD32(GPR_U32(ctx, 19), 60), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x12BB9C; return;
    }
label_12b9d8:
    // 0x12b9d8: 0x2402001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 28));
    // 0x12b9dc: 0x8e63003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 60)));
    // 0x12b9e0: 0x2821018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12b9e4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12b9e8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12b9f0);
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12b9f0
// Address: 0x12b9f0 - 0x12b9fc

void entry_12b9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b9f0: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x12b9f4: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12b9fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12b9fc
// Address: 0x12b9fc - 0x12ba14

void entry_12b9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12b9fc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12ba00: 0x32020001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 1));
    // 0x12ba04: 0x1040000e
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BA40; return;
    }
    // 0x12ba0c: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12ba14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12ba14
// Address: 0x12ba14 - 0x12ba1c

void entry_12ba14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ba14: 0xc0483ec
    SET_GPR_U32(ctx, 31, 0x12ba1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PacpNew__F4ACVK(rdram, ctx, runtime); return;
}


// Function: entry_12ba1c
// Address: 0x12ba1c - 0x12ba3c

void entry_12ba1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ba1c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12ba20: 0xae240004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 4));
    // 0x12ba24: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12ba28: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x12ba2c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 2));
        ctx->pc = 0x12BA40; return;
    }
    // 0x12ba34: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12ba3c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12ba3c
// Address: 0x12ba3c - 0x12ba50

void entry_12ba3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ba3c) {
        switch (ctx->pc) {
            case 0x12ba40: ctx->pc = 0; goto label_12ba40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ba3c: 0x32020002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 2));
label_12ba40:
    // 0x12ba40: 0x1040000e
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BA7C; return;
    }
    // 0x12ba48: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12ba50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12ba50
// Address: 0x12ba50 - 0x12ba58

void entry_12ba50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ba50: 0xc048414
    SET_GPR_U32(ctx, 31, 0x12ba58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PacrNew__F4ACVK(rdram, ctx, runtime); return;
}


// Function: entry_12ba58
// Address: 0x12ba58 - 0x12ba78

void entry_12ba58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ba58: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12ba5c: 0xae240008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 4));
    // 0x12ba60: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12ba64: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12ba68: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 4));
        ctx->pc = 0x12BA7C; return;
    }
    // 0x12ba70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12ba78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12ba78
// Address: 0x12ba78 - 0x12ba8c

void entry_12ba78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ba78) {
        switch (ctx->pc) {
            case 0x12ba7c: ctx->pc = 0; goto label_12ba7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ba78: 0x32020004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 4));
label_12ba7c:
    // 0x12ba7c: 0x1040000e
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BAB8; return;
    }
    // 0x12ba84: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12ba8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12ba8c
// Address: 0x12ba8c - 0x12ba94

void entry_12ba8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ba8c: 0xc04843c
    SET_GPR_U32(ctx, 31, 0x12ba94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PacsNew__F4ACVK(rdram, ctx, runtime); return;
}


// Function: entry_12ba94
// Address: 0x12ba94 - 0x12bab4

void entry_12ba94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ba94: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12ba98: 0xae24000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 4));
    // 0x12ba9c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12baa0: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x12baa4: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 8));
        ctx->pc = 0x12BAB8; return;
    }
    // 0x12baac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12bab4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12bab4
// Address: 0x12bab4 - 0x12bac8

void entry_12bab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12bab4) {
        switch (ctx->pc) {
            case 0x12bab8: ctx->pc = 0; goto label_12bab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12bab4: 0x32020008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 8));
label_12bab8:
    // 0x12bab8: 0x1040000e
    SET_GPR_U32(ctx, 22, AND32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BAF4; return;
    }
    // 0x12bac0: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12bac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bac8
// Address: 0x12bac8 - 0x12bad0

void entry_12bac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bac8: 0xc048458
    SET_GPR_U32(ctx, 31, 0x12bad0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PacgNew__F4ACGK(rdram, ctx, runtime); return;
}


// Function: entry_12bad0
// Address: 0x12bad0 - 0x12baf0

void entry_12bad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bad0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12bad4: 0xae240010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 4));
    // 0x12bad8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12badc: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x12bae0: 0x10400004
    SET_GPR_U32(ctx, 22, AND32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BAF4; return;
    }
    // 0x12bae8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12baf0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12baf0
// Address: 0x12baf0 - 0x12bb0c

void entry_12baf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12baf0) {
        switch (ctx->pc) {
            case 0x12baf4: ctx->pc = 0; goto label_12baf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12baf0: 0x32160020
    SET_GPR_U32(ctx, 22, AND32(GPR_U32(ctx, 16), 32));
label_12baf4:
    // 0x12baf4: 0x32020010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 16));
    // 0x12baf8: 0x10400023
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 20), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BB88; return;
    }
    // 0x12bb00: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12bb04: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x12bb0c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bb0c
// Address: 0x12bb0c - 0x12bb18

void entry_12bb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bb0c: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x12bb10: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12bb18);
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12bb18
// Address: 0x12bb18 - 0x12bb30

void entry_12bb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12bb18) {
        switch (ctx->pc) {
            case 0x12bb28: ctx->pc = 0; goto label_12bb28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12bb18: 0x8e230014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x12bb1c: 0x1860001a
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x12BB88; return;
    }
    // 0x12bb24: 0x2414ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 4294967295));
label_12bb28:
    // 0x12bb28: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12bb30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bb30
// Address: 0x12bb30 - 0x12bb40

void entry_12bb30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bb30: 0x50540011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x12BB78; return;
    }
    // 0x12bb38: 0xc048458
    SET_GPR_U32(ctx, 31, 0x12bb40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PacgNew__F4ACGK(rdram, ctx, runtime); return;
}


// Function: entry_12bb40
// Address: 0x12bb40 - 0x12bb74

void entry_12bb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bb40: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x12bb44: 0x102080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 2));
    // 0x12bb48: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x12bb4c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x12bb50: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x12bb54: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x12bb58: 0x8c840000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12bb5c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12bb60: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x12bb64: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x12BB78; return;
    }
    // 0x12bb6c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12bb74);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12bb74
// Address: 0x12bb74 - 0x12bbb0

void entry_12bb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12bb74) {
        switch (ctx->pc) {
            case 0x12bb78: ctx->pc = 0; goto label_12bb78;
            case 0x12bb88: ctx->pc = 0; goto label_12bb88;
            case 0x12bb9c: ctx->pc = 0; goto label_12bb9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12bb74: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_12bb78:
    // 0x12bb78: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x12bb7c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12bb80: 0x1440ffe9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BB28; return;
    }
label_12bb88:
    // 0x12bb88: 0x8e620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 56)));
    // 0x12bb8c: 0x2a0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x12bb90: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x12bb94: 0x1440ff90
    if (GPR_U32(ctx, 22) != 0) SET_GPR_U32(ctx, 23, GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12B9D8; return;
    }
label_12bb9c:
    // 0x12bb9c: 0x12e00005
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BBB4; return;
    }
    // 0x12bba4: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x12bba8: 0xc04b4aa
    SET_GPR_U32(ctx, 31, 0x12bbb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    StripAsegChn__FP4ASEGP3CHN(rdram, ctx, runtime); return;
}


// Function: entry_12bbb0
// Address: 0x12bbb0 - 0x12bbc8

void entry_12bbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12bbb0) {
        switch (ctx->pc) {
            case 0x12bbb4: ctx->pc = 0; goto label_12bbb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12bbb0: 0x8fa70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_12bbb4:
    // 0x12bbb4: 0x3c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x12bbb8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12bbbc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12bbc0: 0xc04af0e
    SET_GPR_U32(ctx, 31, 0x12bbc8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    LoadAsegEventsFromBrx__FP4ASEGP18CBinaryInputStreamiPiPP2EA(rdram, ctx, runtime); return;
}


// Function: entry_12bbc8
// Address: 0x12bbc8 - 0x12bbe0

void entry_12bbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bbc8: 0x8fa70004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12bbcc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12bbd0: 0x8fa80008
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x12bbd4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12bbd8: 0xc04af0e
    SET_GPR_U32(ctx, 31, 0x12bbe0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    LoadAsegEventsFromBrx__FP4ASEGP18CBinaryInputStreamiPiPP2EA(rdram, ctx, runtime); return;
}


// Function: entry_12bbe0
// Address: 0x12bbe0 - 0x12bbf8

void entry_12bbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bbe0: 0x8fa7000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x12bbe4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12bbe8: 0x8fa80010
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12bbec: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12bbf0: 0xc04af0e
    SET_GPR_U32(ctx, 31, 0x12bbf8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    LoadAsegEventsFromBrx__FP4ASEGP18CBinaryInputStreamiPiPP2EA(rdram, ctx, runtime); return;
}


// Function: entry_12bbf8
// Address: 0x12bbf8 - 0x12bc04

void entry_12bbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bbf8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12bbfc: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x12bc04);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bc04
// Address: 0x12bc04 - 0x12bc38

void entry_12bc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bc04: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x12bc08: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12bc0c: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12bc10: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12bc14: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12bc18: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12bc1c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12bc20: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12bc24: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12bc28: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12bc2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12bc34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12bc38; return;
}


// Function: LoadAsegEventsFromBrx__FP4ASEGP18CBinaryInputStreamiPiPP2EA
// Address: 0x12bc38 - 0x12bc78

void entry_12bc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bc78: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x12bc7c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12bc84);
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12bc84
// Address: 0x12bc84 - 0x12bca8

void entry_12bc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12bc84) {
        switch (ctx->pc) {
            case 0x12bc98: ctx->pc = 0; goto label_12bc98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12bc84: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    // 0x12bc88: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x12bc8c: 0x18400122
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x12C118; return;
    }
    // 0x12bc94: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
label_12bc98:
    // 0x12bc98: 0x121100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 4));
    // 0x12bc9c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bca0: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12bca8);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bca8
// Address: 0x12bca8 - 0x12bcb8

void entry_12bca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bca8: 0x12c0000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12BCD4; return;
    }
    // 0x12bcb0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bcb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bcb8
// Address: 0x12bcb8 - 0x12bd08

void entry_12bcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12bcb8) {
        switch (ctx->pc) {
            case 0x12bcd4: ctx->pc = 0; goto label_12bcd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12bcb8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x12bcbc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x12bcc0: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x12bcc4: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x12bcc8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12bccc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x12bcd0: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_12bcd4:
    // 0x12bcd4: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12bcd8: 0x2c62003c
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 60));
    // 0x12bcdc: 0x10400108
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12bce4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x12bce8: 0x24429a20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941216));
    // 0x12bcec: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12bcf0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12bcf4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x12bcfc: 0x26050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    // 0x12bd00: 0xc04e154
    SET_GPR_U32(ctx, 31, 0x12bd08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Unknown2__18CBinaryInputStreamPPv(rdram, ctx, runtime); return;
}


// Function: entry_12bd08
// Address: 0x12bd08 - 0x12bd1c

void entry_12bd08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bd08: 0x100000fe
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C104; return;
    }
    // 0x12bd10: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bd14: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bd1c);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bd1c
// Address: 0x12bd1c - 0x12bd28

void entry_12bd1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bd1c: 0xa7a20002
    WRITE16(ADD32(GPR_U32(ctx, 29), 2), (uint16_t)GPR_U32(ctx, 2));
    // 0x12bd20: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bd28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bd28
// Address: 0x12bd28 - 0x12bd34

void entry_12bd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bd28: 0xa7a20010
    WRITE16(ADD32(GPR_U32(ctx, 29), 16), (uint16_t)GPR_U32(ctx, 2));
    // 0x12bd2c: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x12bd34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bd34
// Address: 0x12bd34 - 0x12bd40

void entry_12bd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bd34: 0xafa20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    // 0x12bd38: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x12bd40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bd40
// Address: 0x12bd40 - 0x12bd4c

void entry_12bd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bd40: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x12bd44: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12bd4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bd4c
// Address: 0x12bd4c - 0x12bd58

void entry_12bd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bd4c: 0xe7a00024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x12bd50: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12bd58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bd58
// Address: 0x12bd58 - 0x12bd64

void entry_12bd58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bd58: 0xe7a0001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 28), *(uint32_t*)&val); }
    // 0x12bd5c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12bd64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bd64
// Address: 0x12bd64 - 0x12be08

void entry_12bd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12bd64) {
        switch (ctx->pc) {
            case 0x12bd80: ctx->pc = 0; goto label_12bd80;
            case 0x12bd9c: ctx->pc = 0; goto label_12bd9c;
            case 0x12bdf8: ctx->pc = 0; goto label_12bdf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12bd64: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12bd68: 0x2645ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x12bd6c: 0xe7a00020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x12bd70: 0xa7a20000
    WRITE16(ADD32(GPR_U32(ctx, 29), 0), (uint16_t)GPR_U32(ctx, 2));
    // 0x12bd74: 0xa7a0000e
    WRITE16(ADD32(GPR_U32(ctx, 29), 14), (uint16_t)GPR_U32(ctx, 0));
    // 0x12bd78: 0x10000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12bd9c;
    }
label_12bd80:
    // 0x12bd80: 0x24a20001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 1));
    // 0x12bd84: 0x31840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 1));
    // 0x12bd88: 0xa4820000
    WRITE16(ADD32(GPR_U32(ctx, 4), 0), (uint16_t)GPR_U32(ctx, 2));
    // 0x12bd8c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x12bd90: 0x97a20002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 2)));
    // 0x12bd94: 0x10000018
    WRITE16(ADD32(GPR_U32(ctx, 3), 2), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12bdf8;
    }
label_12bd9c:
    // 0x12bd9c: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x12bda0: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x12bda4: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x12bda8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12bdac: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12bdb0: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12bdb4: 0x45000010
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12bdf8;
    }
    // 0x12bdbc: 0x480000e
    if (GPR_S32(ctx, 4) < 0) {
        goto label_12bdf8;
    }
    // 0x12bdc4: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x12bdc8: 0x1440fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12bd9c;
    }
    // 0x12bdd0: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x12bdd4: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x12bdd8: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12bddc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x12bde0: 0xae820000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
    // 0x12bde4: 0x8c640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12bde8: 0x84830000
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12bdec: 0x28620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    // 0x12bdf0: 0x1440ffe3
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12bd80;
    }
label_12bdf8:
    // 0x12bdf8: 0x566000c2
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        ctx->pc = 0x12C104; return;
    }
    // 0x12be00: 0xc063540
    SET_GPR_U32(ctx, 31, 0x12be08);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12be08
// Address: 0x12be08 - 0x12be68

void entry_12be08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12be08: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x12be0c: 0x6ba30007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12be10: 0x6fa30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12be14: 0x6ba4000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12be18: 0x6fa40008
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12be1c: 0x6ba50017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x12be20: 0x6fa50010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x12be24: 0x6ba6001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x12be28: 0x6fa60018
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x12be2c: 0xb0430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be30: 0xb4430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be34: 0xb044000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be38: 0xb4440008
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be3c: 0xb0450017
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be40: 0xb4450010
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be44: 0xb046001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be48: 0xb4460018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be4c: 0x6ba30027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12be50: 0x6fa30020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12be54: 0xb0430027
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12be58: 0x100000a9
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12be60: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12be68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12be68
// Address: 0x12be68 - 0x12be94

void entry_12be68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12be68: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x12be6c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x12be70: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x12be74: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x12be78: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12be7c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12be80: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x12be84: 0x10000082
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C090; return;
    }
    // 0x12be8c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12be94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12be94
// Address: 0x12be94 - 0x12bea0

void entry_12be94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12be94: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x12be98: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x12bea0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bea0
// Address: 0x12bea0 - 0x12beb0

void entry_12bea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bea0: 0x10000097
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12bea8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12beb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12beb0
// Address: 0x12beb0 - 0x12bebc

void entry_12beb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12beb0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12beb4: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12bebc);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bebc
// Address: 0x12bebc - 0x12bec8

void entry_12bebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bebc: 0xa602000c
    WRITE16(ADD32(GPR_U32(ctx, 16), 12), (uint16_t)GPR_U32(ctx, 2));
    // 0x12bec0: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x12bec8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bec8
// Address: 0x12bec8 - 0x12bed8

void entry_12bec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bec8: 0x1000008d
    WRITE16(ADD32(GPR_U32(ctx, 16), 14), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12bed0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12bed8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12bed8
// Address: 0x12bed8 - 0x12bee4

void entry_12bed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bed8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bedc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bee4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bee4
// Address: 0x12bee4 - 0x12bef4

void entry_12bee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bee4: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12bee8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12beec: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12bef4);
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bef4
// Address: 0x12bef4 - 0x12bf04

void entry_12bef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bef4: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12bef8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12befc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12bf04);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bf04
// Address: 0x12bf04 - 0x12bf18

void entry_12bf04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf04: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12bf08: 0x1000007d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12bf10: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bf18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bf18
// Address: 0x12bf18 - 0x12bf24

void entry_12bf18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf18: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x12bf1c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12bf24);
    WRITE16(ADD32(GPR_U32(ctx, 16), 8), (uint16_t)GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12bf24
// Address: 0x12bf24 - 0x12bf38

void entry_12bf24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf24: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12bf28: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x12bf2c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bf30: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bf38);
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bf38
// Address: 0x12bf38 - 0x12bf5c

void entry_12bf38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf38: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x12bf3c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12bf40: 0x24040020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    // 0x12bf44: 0xac620008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 2));
    // 0x12bf48: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x12bf4c: 0xac45000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 5));
    // 0x12bf50: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x12bf54: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12bf5c);
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 0));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12bf5c
// Address: 0x12bf5c - 0x12bf78

void entry_12bf5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf5c: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x12bf60: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bf64: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x12bf68: 0xac620004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    // 0x12bf6c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x12bf70: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x12bf78);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_12bf78
// Address: 0x12bf78 - 0x12bf88

void entry_12bf78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf78: 0x10000062
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C104; return;
    }
    // 0x12bf80: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x12bf88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bf88
// Address: 0x12bf88 - 0x12bf98

void entry_12bf88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf88: 0x10000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C01C; return;
    }
    // 0x12bf90: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12bf98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12bf98
// Address: 0x12bf98 - 0x12bfa4

void entry_12bf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bf98: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bf9c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bfa4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bfa4
// Address: 0x12bfa4 - 0x12bfb4

void entry_12bfa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bfa4: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12bfa8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bfac: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bfb4);
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bfb4
// Address: 0x12bfb4 - 0x12bfc4

void entry_12bfb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bfb4: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12bfb8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bfbc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12bfc4);
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bfc4
// Address: 0x12bfc4 - 0x12bfdc

void entry_12bfc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bfc4: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12bfc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12bfcc: 0x10000027
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C06C; return;
    }
    // 0x12bfd4: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bfdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bfdc
// Address: 0x12bfdc - 0x12bfe8

void entry_12bfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bfdc: 0xa6020008
    WRITE16(ADD32(GPR_U32(ctx, 16), 8), (uint16_t)GPR_U32(ctx, 2));
    // 0x12bfe0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bfe8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bfe8
// Address: 0x12bfe8 - 0x12bff8

void entry_12bfe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bfe8: 0x10000045
    WRITE16(ADD32(GPR_U32(ctx, 16), 10), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12bff0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12bff8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12bff8
// Address: 0x12bff8 - 0x12c008

void entry_12bff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12bff8: 0x10000041
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12c000: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x12c008);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c008
// Address: 0x12c008 - 0x12c018

void entry_12c008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c008: 0x1000003d
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12c010: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c018);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c018
// Address: 0x12c018 - 0x12c024

void entry_12c018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c018) {
        switch (ctx->pc) {
            case 0x12c01c: ctx->pc = 0; goto label_12c01c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c018: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
label_12c01c:
    // 0x12c01c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c024);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c024
// Address: 0x12c024 - 0x12c034

void entry_12c024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c024: 0x10000036
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12c02c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x12c034);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12c034
// Address: 0x12c034 - 0x12c040

void entry_12c034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c034: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12c038: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c040);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c040
// Address: 0x12c040 - 0x12c050

void entry_12c040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c040: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12c044: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12c048: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c050);
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c050
// Address: 0x12c050 - 0x12c060

void entry_12c050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c050: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12c054: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12c058: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c060);
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c060
// Address: 0x12c060 - 0x12c074

void entry_12c060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c060) {
        switch (ctx->pc) {
            case 0x12c06c: ctx->pc = 0; goto label_12c06c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c060: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12c064: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12c068: 0xac620008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 2));
label_12c06c:
    // 0x12c06c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12c074);
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c074
// Address: 0x12c074 - 0x12c088

void entry_12c074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c074: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12c078: 0x10000021
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12c080: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c088);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c088
// Address: 0x12c088 - 0x12c098

void entry_12c088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c088) {
        switch (ctx->pc) {
            case 0x12c090: ctx->pc = 0; goto label_12c090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c088: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x12c08c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_12c090:
    // 0x12c090: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12c098);
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c098
// Address: 0x12c098 - 0x12c0a8

void entry_12c098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c098: 0x10000019
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12c0a0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c0a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c0a8
// Address: 0x12c0a8 - 0x12c0b4

void entry_12c0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c0a8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12c0ac: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c0b4);
    WRITE16(ADD32(GPR_U32(ctx, 16), 8), (uint16_t)GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c0b4
// Address: 0x12c0b4 - 0x12c0c0

void entry_12c0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c0b4: 0xa602000a
    WRITE16(ADD32(GPR_U32(ctx, 16), 10), (uint16_t)GPR_U32(ctx, 2));
    // 0x12c0b8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c0c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c0c0
// Address: 0x12c0c0 - 0x12c0d0

void entry_12c0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c0c0: 0x1000000f
    WRITE16(ADD32(GPR_U32(ctx, 16), 12), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C100; return;
    }
    // 0x12c0c8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c0d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c0d0
// Address: 0x12c0d0 - 0x12c0dc

void entry_12c0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c0d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12c0d4: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x12c0dc);
    WRITE16(ADD32(GPR_U32(ctx, 16), 8), (uint16_t)GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c0dc
// Address: 0x12c0dc - 0x12c0ec

void entry_12c0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c0dc: 0xa602000a
    WRITE16(ADD32(GPR_U32(ctx, 16), 10), (uint16_t)GPR_U32(ctx, 2));
    // 0x12c0e0: 0x2605000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 12));
    // 0x12c0e4: 0xc04e128
    SET_GPR_U32(ctx, 31, 0x12c0ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ReadStringSw__18CBinaryInputStreamPPc(rdram, ctx, runtime); return;
}


// Function: entry_12c0ec
// Address: 0x12c0ec - 0x12c0fc

void entry_12c0ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c0ec: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C104; return;
    }
    // 0x12c0f4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x12c0fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_12c0fc
// Address: 0x12c0fc - 0x12c140

void entry_12c0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c0fc) {
        switch (ctx->pc) {
            case 0x12c100: ctx->pc = 0; goto label_12c100;
            case 0x12c104: ctx->pc = 0; goto label_12c104;
            case 0x12c118: ctx->pc = 0; goto label_12c118;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c0fc: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
label_12c100:
    // 0x12c100: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
label_12c104:
    // 0x12c104: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x12c108: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x12c10c: 0x5440fee2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
        ctx->pc = 0x12BC98; return;
    }
    // 0x12c114: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_12c118:
    // 0x12c118: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12c11c: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12c120: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12c124: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12c128: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12c12c: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12c130: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12c134: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12c13c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12c140; return;
}


// Function: CloneAseg__FP4ASEGP2LO
// Address: 0x12c140 - 0x12c150

void entry_12c150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c150: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12c154: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12c15c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12c160; return;
}


// Function: PostAsegLoad__FP4ASEG
// Address: 0x12c160 - 0x12c174

void entry_12c174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c174) {
        switch (ctx->pc) {
            case 0x12c1bc: ctx->pc = 0; goto label_12c1bc;
            case 0x12c1cc: ctx->pc = 0; goto label_12c1cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c174: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x12c178: 0x26030080
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 128));
    // 0x12c17c: 0x8c8223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 9160)));
    // 0x12c180: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x12c184: 0xc441000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[1] = *(float*)&val; }
    // 0x12c188: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x12c18c: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x12c190: 0xc6030080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 128)); ctx->f[3] = *(float*)&val; }
    // 0x12c194: 0xc6040090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 144)); ctx->f[4] = *(float*)&val; }
    // 0x12c198: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x12c19c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x12c1a0: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x12c1a4: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12c1a8: 0x0
    // NOP
    // 0x12c1ac: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 148)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12c1bc;
    }
    // 0x12c1b4: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12c1cc;
    }
label_12c1bc:
    // 0x12c1bc: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12c1c0: 0x0
    // NOP
    // 0x12c1c4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_12c1cc;
    }
label_12c1cc:
    // 0x12c1cc: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x12c1d0: 0x10400008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 152), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12c1f4(rdram, ctx, runtime); return;
    }
    // 0x12c1d8: 0x3c050013
    SET_GPR_U32(ctx, 5, ((uint32_t)19 << 16));
    // 0x12c1dc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x12c1e0: 0x24a5c208
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294951432));
    // 0x12c1e4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12c1e8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12c1ec: 0xc076f18
    SET_GPR_U32(ctx, 31, 0x12c1f4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_12c1f4
// Address: 0x12c1f4 - 0x12c208

void entry_12c1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c1f4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12c1f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12c1fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12c204: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12c208; return;
}


// Function: PostAsegLoadCallback__FP4ASEG5MSGIDPv
// Address: 0x12c208 - 0x12c234

void entry_12c234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c234: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C258; return;
    }
    // 0x12c23c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x12c240: 0x8e060040
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x12c244: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12c24c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12c24c
// Address: 0x12c24c - 0x12c278

void entry_12c24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c24c) {
        switch (ctx->pc) {
            case 0x12c254: ctx->pc = 0; goto label_12c254;
            case 0x12c258: ctx->pc = 0; goto label_12c258;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c24c: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12c258;
    }
label_12c254:
    // 0x12c254: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_12c258:
    // 0x12c258: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x12c25c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12c260: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12c264: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12c268: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12c26c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12c270: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x12c278);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12c278
// Address: 0x12c278 - 0x12c288

void entry_12c278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c278: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12c27c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12c280: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyAsegOvr__FP4ASEGP3ALOiP3OVRffiPP5ASEGA
// Address: 0x12c288 - 0x12c2e8

void entry_12c2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c2e8) {
        switch (ctx->pc) {
            case 0x12c2f4: ctx->pc = 0; goto label_12c2f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c2e8: 0x12000002
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_12c2f4;
    }
    // 0x12c2f0: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
label_12c2f4:
    // 0x12c2f4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c2f8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x12c2fc: 0xe4550014
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 20), *(uint32_t*)&val); }
    // 0x12c300: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12c304: 0xac550008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 21));
    // 0x12c308: 0xac51000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 17));
    // 0x12c30c: 0xc6a0007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 124)); ctx->f[0] = *(float*)&val; }
    // 0x12c310: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x12c318);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 28), *(uint32_t*)&val); }
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_12c318
// Address: 0x12c318 - 0x12c324

void entry_12c318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c318: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c31c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x12c324);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 108));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12c324
// Address: 0x12c324 - 0x12c338

void entry_12c324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c324: 0x8ea20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 80)));
    // 0x12c328: 0x10400005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C340; return;
    }
    // 0x12c330: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x12c338);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 7024));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12c338
// Address: 0x12c338 - 0x12c348

void entry_12c338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c338) {
        switch (ctx->pc) {
            case 0x12c340: ctx->pc = 0; goto label_12c340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c338: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12c348(rdram, ctx, runtime); return;
    }
label_12c340:
    // 0x12c340: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x12c348);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 7012));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12c348
// Address: 0x12c348 - 0x12c350

void entry_12c348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c348: 0xc063582
    SET_GPR_U32(ctx, 31, 0x12c350);
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_12c350
// Address: 0x12c350 - 0x12c37c

void entry_12c350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c350: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x12c354: 0x231f00b
    if (GPR_U32(ctx, 17) != 0) SET_GPR_U32(ctx, 30, GPR_U32(ctx, 17));
    // 0x12c358: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x12c35c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12c360: 0x8ea400a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 160)));
    // 0x12c364: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x12c368: 0x30630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 2));
    // 0x12c36c: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
    // 0x12c370: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x12c374: 0xc063596
    SET_GPR_U32(ctx, 31, 0x12c37c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 3));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_12c37c
// Address: 0x12c37c - 0x12c3c4

void entry_12c37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c37c) {
        switch (ctx->pc) {
            case 0x12c3a0: ctx->pc = 0; goto label_12c3a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c37c: 0x27a40004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 4));
    // 0x12c380: 0x27a50008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 8));
    // 0x12c384: 0xafa40020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 4));
    // 0x12c388: 0xafa50024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 5));
    // 0x12c38c: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x12c390: 0x8ea200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 160)));
    // 0x12c394: 0x58400011
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 156)));
        ctx->pc = 0x12C3DC; return;
    }
    // 0x12c39c: 0x8fb00018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 24)));
label_12c3a0:
    // 0x12c3a0: 0x8ea300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 164)));
    // 0x12c3a4: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x12c3a8: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x12c3ac: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x12c3b0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12c3b4: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x12c3b8: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12c3bc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12c3c4);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12c3c4
// Address: 0x12c3c4 - 0x12c460

void entry_12c3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c3c4) {
        switch (ctx->pc) {
            case 0x12c3dc: ctx->pc = 0; goto label_12c3dc;
            case 0x12c3f8: ctx->pc = 0; goto label_12c3f8;
            case 0x12c428: ctx->pc = 0; goto label_12c428;
            case 0x12c44c: ctx->pc = 0; goto label_12c44c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c3c4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x12c3c8: 0x8ea200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 160)));
    // 0x12c3cc: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x12c3d0: 0x1440fff3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C3A0; return;
    }
    // 0x12c3d8: 0x8ea2009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 156)));
label_12c3dc:
    // 0x12c3dc: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12c3e0: 0x8ea30038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x12c3e4: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x12c3e8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12c3ec: 0x1860009d
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x12C664; return;
    }
    // 0x12c3f4: 0x2402001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 28));
label_12c3f8:
    // 0x12c3f8: 0x8ea3003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 60)));
    // 0x12c3fc: 0x2c21018
    { int64_t result = (int64_t)GPR_S32(ctx, 22) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12c400: 0x26c40001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 1));
    // 0x12c404: 0xafa40028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 4));
    // 0x12c408: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12c40c: 0x8fa5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x12c410: 0x62a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12c414: 0x18a0000d
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_12c44c;
    }
    // 0x12c41c: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12c420: 0x80182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x12c424: 0x0
    // NOP
label_12c428:
    // 0x12c428: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12c42c: 0x1262003f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12C52C; return;
    }
    // 0x12c434: 0x24a40008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 8));
    // 0x12c438: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x12c43c: 0x8fa5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x12c440: 0xc5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 5)));
    // 0x12c444: 0x1440fff8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12c428;
    }
label_12c44c:
    // 0x12c44c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x12c450: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x12c454: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12c458: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12c460);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12c460
// Address: 0x12c460 - 0x12c49c

void entry_12c460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c460) {
        switch (ctx->pc) {
            case 0x12c478: ctx->pc = 0; goto label_12c478;
            case 0x12c47c: ctx->pc = 0; goto label_12c47c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c460: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12c464: 0x16400019
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C4CC; return;
    }
    // 0x12c46c: 0x10000003
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12c47c;
    }
    // 0x12c474: 0x0
    // NOP
label_12c478:
    // 0x12c478: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_12c47c:
    // 0x12c47c: 0x8ea200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 160)));
    // 0x12c480: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x12c484: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C4A8; return;
    }
    // 0x12c48c: 0x8e070000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12c490: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12c494: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12c49c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12c49c
// Address: 0x12c49c - 0x12c4c0

void entry_12c49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c49c) {
        switch (ctx->pc) {
            case 0x12c4a8: ctx->pc = 0; goto label_12c4a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c49c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12c4a0: 0x5240fff5
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
        ctx->pc = 0x12C478; return;
    }
label_12c4a8:
    // 0x12c4a8: 0x16400008
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C4CC; return;
    }
    // 0x12c4b0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x12c4b4: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12c4b8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12c4c0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12c4c0
// Address: 0x12c4c0 - 0x12c4d4

void entry_12c4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c4c0) {
        switch (ctx->pc) {
            case 0x12c4cc: ctx->pc = 0; goto label_12c4cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c4c0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12c4c4: 0x52400063
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 29), 40)));
        ctx->pc = 0x12C654; return;
    }
label_12c4cc:
    // 0x12c4cc: 0xc04a266
    SET_GPR_U32(ctx, 31, 0x12c4d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PactsegNewAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12c4d4
// Address: 0x12c4d4 - 0x12c524

void entry_12c4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c4d4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12c4d8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c4dc: 0xae160028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 22));
    // 0x12c4e0: 0xae02001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 2));
    // 0x12c4e4: 0x8ea30078
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 120)));
    // 0x12c4e8: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    // 0x12c4ec: 0x8ea20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x12c4f0: 0x2c2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), GPR_S32(ctx, 2)));
    // 0x12c4f4: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
        ctx->pc = 0x12C534; return;
    }
    // 0x12c4fc: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x12c500: 0x14400025
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C598; return;
    }
    // 0x12c508: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x12c50c: 0x54400020
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
        ctx->pc = 0x12C590; return;
    }
    // 0x12c514: 0x8ea40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 20)));
    // 0x12c518: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12c51c: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x12c524);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6944));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_12c524
// Address: 0x12c524 - 0x12c558

void entry_12c524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c524) {
        switch (ctx->pc) {
            case 0x12c52c: ctx->pc = 0; goto label_12c52c;
            case 0x12c534: ctx->pc = 0; goto label_12c534;
            case 0x12c550: ctx->pc = 0; goto label_12c550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c524: 0x1000004b
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C654; return;
    }
label_12c52c:
    // 0x12c52c: 0x1000ffe7
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C4CC; return;
    }
label_12c534:
    // 0x12c534: 0x30620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 1));
    // 0x12c538: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12c550;
    }
    // 0x12c540: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x12c544: 0xa2020011
    WRITE8(ADD32(GPR_U32(ctx, 16), 17), (uint8_t)GPR_U32(ctx, 2));
    // 0x12c548: 0x10000003
    WRITE8(ADD32(GPR_U32(ctx, 16), 16), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12c558(rdram, ctx, runtime); return;
    }
label_12c550:
    // 0x12c550: 0xc048570
    SET_GPR_U32(ctx, 31, 0x12c558);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_12c558
// Address: 0x12c558 - 0x12c5bc

void entry_12c558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c558) {
        switch (ctx->pc) {
            case 0x12c570: ctx->pc = 0; goto label_12c570;
            case 0x12c590: ctx->pc = 0; goto label_12c590;
            case 0x12c598: ctx->pc = 0; goto label_12c598;
            case 0x12c59c: ctx->pc = 0; goto label_12c59c;
            case 0x12c5ac: ctx->pc = 0; goto label_12c5ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c558: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x12c55c: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
        goto label_12c570;
    }
    // 0x12c564: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12c568: 0xa2040010
    WRITE8(ADD32(GPR_U32(ctx, 16), 16), (uint8_t)GPR_U32(ctx, 4));
    // 0x12c56c: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
label_12c570:
    // 0x12c570: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
        goto label_12c590;
    }
    // 0x12c578: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x12c57c: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
        goto label_12c590;
    }
    // 0x12c584: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12c588: 0xa2050011
    WRITE8(ADD32(GPR_U32(ctx, 16), 17), (uint8_t)GPR_U32(ctx, 5));
    // 0x12c58c: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
label_12c590:
    // 0x12c590: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12c59c;
    }
label_12c598:
    // 0x12c598: 0xa2020012
    WRITE8(ADD32(GPR_U32(ctx, 16), 18), (uint8_t)GPR_U32(ctx, 2));
label_12c59c:
    // 0x12c59c: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x12c5a0: 0x10400002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12c5ac;
    }
    // 0x12c5a8: 0xa2030013
    WRITE8(ADD32(GPR_U32(ctx, 16), 19), (uint8_t)GPR_U32(ctx, 3));
label_12c5ac:
    // 0x12c5ac: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c5b0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12c5b4: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x12c5bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 68));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12c5bc
// Address: 0x12c5bc - 0x12c5c8

void entry_12c5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c5bc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12c5c0: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x12c5c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_12c5c8
// Address: 0x12c5c8 - 0x12c66c

void entry_12c5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c5c8) {
        switch (ctx->pc) {
            case 0x12c5e8: ctx->pc = 0; goto label_12c5e8;
            case 0x12c608: ctx->pc = 0; goto label_12c608;
            case 0x12c654: ctx->pc = 0; goto label_12c654;
            case 0x12c664: ctx->pc = 0; goto label_12c664;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c5c8: 0x8e450050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x12c5cc: 0x54a0000e
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 5), 712)));
        goto label_12c608;
    }
    // 0x12c5d4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12c5d8: 0x8ca20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x12c5dc: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 5), 712)));
        goto label_12c608;
    }
    // 0x12c5e4: 0x8ca50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 24)));
label_12c5e8:
    // 0x12c5e8: 0x8ca20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x12c5ec: 0x0
    // NOP
    // 0x12c5f0: 0x0
    // NOP
    // 0x12c5f4: 0x0
    // NOP
    // 0x12c5f8: 0x0
    // NOP
    // 0x12c5fc: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 24)));
        goto label_12c5e8;
    }
    // 0x12c604: 0xdca302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 5), 712)));
label_12c608:
    // 0x12c608: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x12c60c: 0x427f8
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 31);
    // 0x12c610: 0x641024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x12c614: 0x1440000f
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12c654;
    }
    // 0x12c61c: 0x8fa60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c620: 0x8cc2005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 92)));
    // 0x12c624: 0x2c420020
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 32));
    // 0x12c628: 0x1040000a
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12c654;
    }
    // 0x12c630: 0xfca202c8
    WRITE64(ADD32(GPR_U32(ctx, 5), 712), GPR_U64(ctx, 2));
    // 0x12c634: 0x8cc3005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 92)));
    // 0x12c638: 0x8cc40060
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 96)));
    // 0x12c63c: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x12c640: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x12c644: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x12c648: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x12c64c: 0xacc3005c
    WRITE32(ADD32(GPR_U32(ctx, 6), 92), GPR_U32(ctx, 3));
    // 0x12c650: 0x8fb60028
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 29), 40)));
label_12c654:
    // 0x12c654: 0x8fa4001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x12c658: 0x2c4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), GPR_S32(ctx, 4)));
    // 0x12c65c: 0x1440ff66
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 28));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C3F8; return;
    }
label_12c664:
    // 0x12c664: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x12c66c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_12c66c
// Address: 0x12c66c - 0x12c6d8

void entry_12c66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c66c) {
        switch (ctx->pc) {
            case 0x12c698: ctx->pc = 0; goto label_12c698;
            case 0x12c6c8: ctx->pc = 0; goto label_12c6c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c66c: 0x8fa60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c670: 0x8cc2005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 92)));
    // 0x12c674: 0x18400014
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_12c6c8;
    }
    // 0x12c67c: 0x2408bfff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294950911));
    // 0x12c680: 0x84438
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 8) << 16);
    // 0x12c684: 0x3508ffff
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 65535));
    // 0x12c688: 0x84438
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 8) << 16);
    // 0x12c68c: 0x3508ffff
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 65535));
    // 0x12c690: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x12c694: 0x8cc20060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 96)));
label_12c698:
    // 0x12c698: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x12c69c: 0xe0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x12c6a0: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x12c6a4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12c6a8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12c6ac: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x12c6b0: 0x481024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x12c6b4: 0xfc8202c8
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    // 0x12c6b8: 0x8cc3005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 92)));
    // 0x12c6bc: 0xa3182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 3)));
    // 0x12c6c0: 0x5460fff5
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 96)));
        goto label_12c698;
    }
label_12c6c8:
    // 0x12c6c8: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c6cc: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x12c6d0: 0xc057e2c
    SET_GPR_U32(ctx, 31, 0x12c6d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 84));
    AddSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime); return;
}


// Function: entry_12c6d8
// Address: 0x12c6d8 - 0x12c6ec

void entry_12c6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c6d8: 0x8ea2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 76)));
    // 0x12c6dc: 0x10400003
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12c6ec(rdram, ctx, runtime); return;
    }
    // 0x12c6e4: 0xc04b512
    SET_GPR_U32(ctx, 31, 0x12c6ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetAsegaHandsOff__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_12c6ec
// Address: 0x12c6ec - 0x12c718

void entry_12c6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c6ec) {
        switch (ctx->pc) {
            case 0x12c700: ctx->pc = 0; goto label_12c700;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c6ec: 0x8ea20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 84)));
    // 0x12c6f0: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12c6f4: 0x1840000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x12C728; return;
    }
    // 0x12c6fc: 0x8ea20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 88)));
label_12c700:
    // 0x12c700: 0x102900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 16), 4));
    // 0x12c704: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12c708: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12c70c: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x12c710: 0xc04b574
    SET_GPR_U32(ctx, 31, 0x12c718);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    HandleAsegaEvent__FP5ASEGAP2EAPi(rdram, ctx, runtime); return;
}


// Function: entry_12c718
// Address: 0x12c718 - 0x12c734

void entry_12c718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c718) {
        switch (ctx->pc) {
            case 0x12c728: ctx->pc = 0; goto label_12c728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c718: 0x8ea20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 84)));
    // 0x12c71c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12c720: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 88)));
        ctx->pc = 0x12C700; return;
    }
label_12c728:
    // 0x12c728: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12c72c: 0xc04bc64
    SET_GPR_U32(ctx, 31, 0x12c734);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    SnapAsega__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_12c734
// Address: 0x12c734 - 0x12c74c

void entry_12c734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c734: 0x8fa5002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x12c738: 0x10a00006
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C754; return;
    }
    // 0x12c740: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x12c744: 0xc04b938
    SET_GPR_U32(ctx, 31, 0x12c74c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    HandleAsegaEventsFF__FP5ASEGAP4ASEGPi(rdram, ctx, runtime); return;
}


// Function: entry_12c74c
// Address: 0x12c74c - 0x12c75c

void entry_12c74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c74c) {
        switch (ctx->pc) {
            case 0x12c754: ctx->pc = 0; goto label_12c754;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c74c: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12C760; return;
    }
label_12c754:
    // 0x12c754: 0xc04b52a
    SET_GPR_U32(ctx, 31, 0x12c75c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12c75c
// Address: 0x12c75c - 0x12c778

void entry_12c75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c75c) {
        switch (ctx->pc) {
            case 0x12c760: ctx->pc = 0; goto label_12c760;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c75c: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_12c760:
    // 0x12c760: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x12c764: 0x8fa70024
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x12c768: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    // 0x12c76c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x12c770: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x12c778);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_12c778
// Address: 0x12c778 - 0x12c7b0

void entry_12c778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c778: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x12c77c: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x12c780: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x12c784: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12c788: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12c78c: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12c790: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12c794: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12c798: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12c79c: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12c7a0: 0xc7b500e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[21] = *(float*)&val; }
    // 0x12c7a4: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x12c7a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA
// Address: 0x12c7b0 - 0x12c7cc

void entry_12c7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c7cc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12c7d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PasegaApplyAseg__FP4ASEGP3ALOffi
// Address: 0x12c7d8 - 0x12c7f4

void entry_12c7f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c7f4: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12c7f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12c7fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12c804: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12c808; return;
}


// Function: PasegaFindAseg__FP4ASEGP3ALO
// Address: 0x12c808 - 0x12c840

void entry_12c888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c888) {
        switch (ctx->pc) {
            case 0x12c898: ctx->pc = 0; goto label_12c898;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c888: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12c898;
    }
    // 0x12c890: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12c8b8(rdram, ctx, runtime); return;
    }
label_12c898:
    // 0x12c898: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x12c89c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12c8a0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12c8a4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12c8a8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12c8ac: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12c8b0: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x12c8b8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12c8b8
// Address: 0x12c8b8 - 0x12c8cc

void entry_12c8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c8b8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12c8bc: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x12c8c0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x12c8c4: 0xc04bc28
    SET_GPR_U32(ctx, 31, 0x12c8cc);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime); return;
}


// Function: entry_12c8cc
// Address: 0x12c8cc - 0x12c8f8

void entry_12c8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c8cc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12c8d0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12c8d4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12c8d8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12c8dc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12c8e0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12c8e4: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x12c8e8: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x12c8ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12c8f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12c8f8; return;
}


// Function: PasegaEnsureAseg__FP4ASEGP3ALO4SEEKffi
// Address: 0x12c8f8 - 0x12c908

void entry_12c908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c908: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12c90c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12c910: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA
// Address: 0x12c918 - 0x12c960

void entry_12c960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12c960) {
        switch (ctx->pc) {
            case 0x12c964: ctx->pc = 0; goto label_12c964;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12c960: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
label_12c964:
    // 0x12c964: 0x12200007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_12c984(rdram, ctx, runtime); return;
    }
    // 0x12c96c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12c970: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x12c974: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x12c978: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12c97c: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x12c984);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12c984
// Address: 0x12c984 - 0x12c9a8

void entry_12c984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12c984: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12c988: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12c98c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12c990: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12c994: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12c998: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x12c99c: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x12c9a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FWipingAseg__FP4ASEG
// Address: 0x12c9a8 - 0x12c9e8

void entry_12ca60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ca60) {
        switch (ctx->pc) {
            case 0x12ca78: ctx->pc = 0; goto label_12ca78;
            case 0x12ca88: ctx->pc = 0; goto label_12ca88;
            case 0x12caa0: ctx->pc = 0; goto label_12caa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ca60: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12ca64: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12ca68: 0x5480000d
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        goto label_12caa0;
    }
    // 0x12ca70: 0x56800001
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 0));
        goto label_12ca78;
    }
label_12ca78:
    // 0x12ca78: 0x12a00003
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_12ca88;
    }
    // 0x12ca80: 0x7a020100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x12ca84: 0x7ea20000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), GPR_VEC(ctx, 2));
label_12ca88:
    // 0x12ca88: 0x12c00047
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        entry_12cba8(rdram, ctx, runtime); return;
    }
    // 0x12ca90: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x12ca94: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12ca98: 0x10000043
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12cba8(rdram, ctx, runtime); return;
    }
label_12caa0:
    // 0x12caa0: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x12caa4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12caa8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12caac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12cab0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12cab4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12cab8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12cabc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12cac4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12cac4
// Address: 0x12cac4 - 0x12cb28

void entry_12cac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12cac4) {
        switch (ctx->pc) {
            case 0x12cb00: ctx->pc = 0; goto label_12cb00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12cac4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x12cac8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12cacc: 0x4600b5c6
    ctx->f[23] = FPU_MOV_S(ctx->f[22]);
    // 0x12cad0: 0xda420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12cad4: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12cad8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12cadc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12cae0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12cae4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12cae8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12caec: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12caf0: 0x4482b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 2);
    // 0x12caf4: 0x45000022
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12CB80; return;
    }
    // 0x12cafc: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_12cb00:
    // 0x12cb00: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12cb04: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12cb08: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12cb0c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x12cb10: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12cb14: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12cb18: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12cb1c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12cb20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12cb28);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12cb28
// Address: 0x12cb28 - 0x12cba8

void entry_12cb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12cb28) {
        switch (ctx->pc) {
            case 0x12cb68: ctx->pc = 0; goto label_12cb68;
            case 0x12cb80: ctx->pc = 0; goto label_12cb80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12cb28: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12cb2c: 0xda420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12cb30: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12cb34: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12cb38: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12cb3c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12cb40: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12cb44: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12cb48: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x12cb4c: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12cb50: 0x0
    // NOP
    // 0x12cb54: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
        goto label_12cb68;
    }
    // 0x12cb5c: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x12cb60: 0x4600a5c6
    ctx->f[23] = FPU_MOV_S(ctx->f[20]);
    // 0x12cb64: 0x4618a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
label_12cb68:
    // 0x12cb68: 0x4600ad29
    ctx->f[20] = std::min(ctx->f[21], ctx->f[0]);
    // 0x12cb6c: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12cb70: 0x0
    // NOP
    // 0x12cb74: 0x4503ffe2
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x12CB00; return;
    }
    // 0x12cb7c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_12cb80:
    // 0x12cb80: 0xc66c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 52)); ctx->f[12] = *(float*)&val; }
    // 0x12cb84: 0xc44d9b10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294941456)); ctx->f[13] = *(float*)&val; }
    // 0x12cb88: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12cb8c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12cb90: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12cb94: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x12cb98: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x12cb9c: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x12cba0: 0xc04bc84
    SET_GPR_U32(ctx, 31, 0x12cba8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    FindChnClosestPointLocal__FP3CHNP3ALOP6VECTORfffPfT2T2(rdram, ctx, runtime); return;
}


// Function: entry_12cba8
// Address: 0x12cba8 - 0x12cbe8

void entry_12cba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12cba8: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12cbac: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12cbb0: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12cbb4: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12cbb8: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12cbbc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12cbc0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12cbc4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12cbc8: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x12cbcc: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x12cbd0: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x12cbd4: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x12cbd8: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x12cbdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12cbe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12cbe8; return;
}


// Function: PeaFindAsegLabel__FP4ASEG3OID
// Address: 0x12cbe8 - 0x12ccc0

void entry_12ccd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ccd0) {
        switch (ctx->pc) {
            case 0x12ccdc: ctx->pc = 0; goto label_12ccdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ccd0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12ccd4: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
        goto label_12ccdc;
    }
label_12ccdc:
    // 0x12ccdc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12cce0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PchnFindAseg__FP4ASEGP3ALO
// Address: 0x12cce8 - 0x12cd34

void entry_12cd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12cd34) {
        switch (ctx->pc) {
            case 0x12cd50: ctx->pc = 0; goto label_12cd50;
            case 0x12cd54: ctx->pc = 0; goto label_12cd54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12cd34: 0x14400007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12cd54;
    }
    // 0x12cd3c: 0x8e420038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 56)));
    // 0x12cd40: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x12cd44: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x12cd48: 0x1440fff5
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 28));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12CD20; return;
    }
label_12cd50:
    // 0x12cd50: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_12cd54:
    // 0x12cd54: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12cd58: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12cd5c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12cd60: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12cd64: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12cd68: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12cd6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12cd74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12cd78; return;
}


// Function: PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6
// Address: 0x12cd78 - 0x12cf20

void entry_12cf20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12cf20) {
        switch (ctx->pc) {
            case 0x12cf34: ctx->pc = 0; goto label_12cf34;
            case 0x12cf38: ctx->pc = 0; goto label_12cf38;
            case 0x12cf48: ctx->pc = 0; goto label_12cf48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12cf20: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12cf34;
    }
    // 0x12cf28: 0x8c510008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12cf2c: 0x10000002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12cf38;
    }
label_12cf34:
    // 0x12cf34: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_12cf38:
    // 0x12cf38: 0x16a00003
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        goto label_12cf48;
    }
    // 0x12cf40: 0x12600011
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12CF88; return;
    }
label_12cf48:
    // 0x12cf48: 0x1080000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12CF78; return;
    }
    // 0x12cf50: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12cf54: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x12cf58: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x12cf5c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12cf60: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12cf64: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x12cf68: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12cf70);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12cf70
// Address: 0x12cf70 - 0x12cfb4

void entry_12cf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12cf70) {
        switch (ctx->pc) {
            case 0x12cf78: ctx->pc = 0; goto label_12cf78;
            case 0x12cf88: ctx->pc = 0; goto label_12cf88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12cf70: 0x10000005
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12cf88;
    }
label_12cf78:
    // 0x12cf78: 0x7a020100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x12cf7c: 0x7fa200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 2));
    // 0x12cf80: 0x7a030150
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x12cf84: 0x7fa300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 3));
label_12cf88:
    // 0x12cf88: 0x1220000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12CFBC; return;
    }
    // 0x12cf90: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12cf94: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12cf98: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x12cf9c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12cfa0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x12cfa4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12cfa8: 0x27a700d0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 208));
    // 0x12cfac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12cfb4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12cfb4
// Address: 0x12cfb4 - 0x12d1b0

void entry_12cfb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12cfb4) {
        switch (ctx->pc) {
            case 0x12cfbc: ctx->pc = 0; goto label_12cfbc;
            case 0x12cfdc: ctx->pc = 0; goto label_12cfdc;
            case 0x12cfec: ctx->pc = 0; goto label_12cfec;
            case 0x12d054: ctx->pc = 0; goto label_12d054;
            case 0x12d064: ctx->pc = 0; goto label_12d064;
            case 0x12d090: ctx->pc = 0; goto label_12d090;
            case 0x12d110: ctx->pc = 0; goto label_12d110;
            case 0x12d138: ctx->pc = 0; goto label_12d138;
            case 0x12d144: ctx->pc = 0; goto label_12d144;
            case 0x12d154: ctx->pc = 0; goto label_12d154;
            case 0x12d17c: ctx->pc = 0; goto label_12d17c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12cfb4: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12cfdc;
    }
label_12cfbc:
    // 0x12cfbc: 0x7a0200d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x12cfc0: 0x7fa200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 2));
    // 0x12cfc4: 0x7a0300e0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 224)));
    // 0x12cfc8: 0x7fa300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 3));
    // 0x12cfcc: 0x7a0200f0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 240)));
    // 0x12cfd0: 0x7fa200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 2));
    // 0x12cfd4: 0x7a030160
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x12cfd8: 0x7fa300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 3));
label_12cfdc:
    // 0x12cfdc: 0x16a00003
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        goto label_12cfec;
    }
    // 0x12cfe4: 0x1260001b
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_12d054;
    }
label_12cfec:
    // 0x12cfec: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12cff0: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12cff4: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12cff8: 0x4bc231bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x12cffc: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12d000: 0x4bc2190a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12d004: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12d008: 0x4be40868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12d00c: 0xfba40130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12d010: 0x12600010
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_12d054;
    }
    // 0x12d018: 0xdba100b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x12d01c: 0x4bc131bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x12d020: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12d024: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12d028: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d02c: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12d030: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12d034: 0x4bc41afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[4] = READ32(addr); }
    // 0x12d038: 0x4bc320ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12d03c: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x12d040: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x12d044: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12d048: 0xfba10140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12d04c: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x12d050: 0xfba30150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[3]));
label_12d054:
    // 0x12d054: 0x16c00003
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        goto label_12d064;
    }
    // 0x12d05c: 0x5260000c
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
        goto label_12d090;
    }
label_12d064:
    // 0x12d064: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12d068: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12d06c: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12d070: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x12d074: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x12d078: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12d07c: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12d080: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12d084: 0xfba30130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12d088: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x12d08c: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_12d090:
    // 0x12d090: 0x254102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 20)));
    // 0x12d094: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12d098: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12d09c: 0xdba500d0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x12d0a0: 0xdba600e0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x12d0a4: 0x4bc519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x12d0a8: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x12d0ac: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12d0b0: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x12d0b4: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x12d0b8: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12d0bc: 0xdba200f0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x12d0c0: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x12d0c4: 0x4bc220bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12d0c8: 0x4bc208ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12d0cc: 0xfba50070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x12d0d0: 0xfba60080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x12d0d4: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12d0d8: 0xfba50160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x12d0dc: 0xfba50130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x12d0e0: 0xfba60170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x12d0e4: 0xfba60140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x12d0e8: 0xfba30180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12d0ec: 0xfba30150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12d0f0: 0xfba50100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x12d0f4: 0xfba60110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x12d0f8: 0x10400016
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12d154;
    }
    // 0x12d100: 0x12a00003
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_12d110;
    }
    // 0x12d108: 0x8fa30198
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 408)));
    // 0x12d10c: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
label_12d110:
    // 0x12d110: 0x12e00009
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_12d138;
    }
    // 0x12d118: 0x7ba50070
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12d11c: 0x2431018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12d120: 0x7ba40080
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12d124: 0x571821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x12d128: 0x7ba20090
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12d12c: 0x7c650000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 5));
    // 0x12d130: 0x7c620020
    WRITE128(ADD32(GPR_U32(ctx, 3), 32), GPR_VEC(ctx, 2));
    // 0x12d134: 0x7c640010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 4));
label_12d138:
    // 0x12d138: 0x12600002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_12d144;
    }
    // 0x12d140: 0x7fc20000
    WRITE128(ADD32(GPR_U32(ctx, 30), 0), GPR_VEC(ctx, 2));
label_12d144:
    // 0x12d144: 0x12c00003
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_12d154;
    }
    // 0x12d14c: 0x8fa30194
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 404)));
    // 0x12d150: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
label_12d154:
    // 0x12d154: 0x8fa80194
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 404)));
    // 0x12d158: 0x27defff0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 4294967280));
    // 0x12d15c: 0x8fa20198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 408)));
    // 0x12d160: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x12d164: 0x2508fff0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967280));
    // 0x12d168: 0x2442fff0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967280));
    // 0x12d16c: 0xafa80194
    WRITE32(ADD32(GPR_U32(ctx, 29), 404), GPR_U32(ctx, 8));
    // 0x12d170: 0x641ff65
    WRITE32(ADD32(GPR_U32(ctx, 29), 408), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x12CF08; return;
    }
    // 0x12d178: 0x7bbf0230
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 560)));
label_12d17c:
    // 0x12d17c: 0x7bbe0220
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x12d180: 0x7bb70210
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x12d184: 0x7bb60200
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x12d188: 0x7bb501f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x12d18c: 0x7bb401e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x12d190: 0x7bb301d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x12d194: 0x7bb201c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x12d198: 0x7bb101b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x12d19c: 0x7bb001a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x12d1a0: 0xc7b50248
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 584)); ctx->f[21] = *(float*)&val; }
    // 0x12d1a4: 0xc7b40240
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 576)); ctx->f[20] = *(float*)&val; }
    // 0x12d1a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 592));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT
// Address: 0x12d1b0 - 0x12d224

void entry_12d224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d224) {
        switch (ctx->pc) {
            case 0x12d240: ctx->pc = 0; goto label_12d240;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d224: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12d228: 0xae230000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
    // 0x12d22c: 0x8e42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x12d230: 0x18400014
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x12D284; return;
    }
    // 0x12d238: 0x24130029
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 41));
    // 0x12d23c: 0x8e420060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 96)));
label_12d240:
    // 0x12d240: 0x101900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 4));
    // 0x12d244: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12d248: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x12d24c: 0x54930009
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
        ctx->pc = 0x12D274; return;
    }
    // 0x12d254: 0x8c460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12d258: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12d25c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x12d260: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12d268);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12d268
// Address: 0x12d268 - 0x12d2a8

void entry_12d268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d268) {
        switch (ctx->pc) {
            case 0x12d274: ctx->pc = 0; goto label_12d274;
            case 0x12d284: ctx->pc = 0; goto label_12d284;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d268: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x12d26c: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x12d270: 0x8e42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
label_12d274:
    // 0x12d274: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x12d278: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12d27c: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 96)));
        ctx->pc = 0x12D240; return;
    }
label_12d284:
    // 0x12d284: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d288: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12d28c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12d290: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12d294: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12d298: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12d29c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12d2a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12d2a8; return;
}


// Function: StripAsegChn__FP4ASEGP3CHN
// Address: 0x12d2a8 - 0x12d338

void entry_12d338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d338: 0x8e020038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x12d33c: 0x2403001c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 28));
    // 0x12d340: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x12d344: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12d348: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12d34c: 0x822821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x12d350: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x12d354: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x12d358: 0x6ba3000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12d35c: 0x6fa30008
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x12d360: 0x6ba40017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12d364: 0x6fa40010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x12d368: 0x8fa60018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x12d36c: 0xb0a20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12d370: 0xb4a20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12d374: 0xb0a3000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12d378: 0xb4a30008
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12d37c: 0xb0a40017
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12d380: 0xb4a40010
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x12d384: 0xaca60018
    WRITE32(ADD32(GPR_U32(ctx, 5), 24), GPR_U32(ctx, 6));
    // 0x12d388: 0xae05009c
    WRITE32(ADD32(GPR_U32(ctx, 16), 156), GPR_U32(ctx, 5));
    // 0x12d38c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12d390: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StripAsegAlo__FP4ASEGP3ALO
// Address: 0x12d398 - 0x12d3bc

void entry_12d3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d3bc: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12d3cc(rdram, ctx, runtime); return;
    }
    // 0x12d3c4: 0xc04b4aa
    SET_GPR_U32(ctx, 31, 0x12d3cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    StripAsegChn__FP4ASEGP3CHN(rdram, ctx, runtime); return;
}


// Function: entry_12d3cc
// Address: 0x12d3cc - 0x12d3e0

void entry_12d3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d3cc) {
        switch (ctx->pc) {
            case 0x12d3d0: ctx->pc = 0; goto label_12d3d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d3cc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12d3d0:
    // 0x12d3d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12d3d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12d3dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12d3e0; return;
}


// Function: LoadAsegblFromBrx__FP6ASEGBLP18CBinaryInputStream
// Address: 0x12d3e0 - 0x12d3e8

void entry_12d40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d40c: 0x3c030022
    SET_GPR_U32(ctx, 3, ((uint32_t)34 << 16));
    // 0x12d410: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12d414: 0x246397b8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294940600));
    // 0x12d418: 0x26040044
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 68));
    // 0x12d41c: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x12d420: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x12d428);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_12d428
// Address: 0x12d428 - 0x12d448

void entry_12d428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d428: 0x26030064
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 100));
    // 0x12d42c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12d430: 0xae030060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 3));
    // 0x12d434: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12d438: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12d43c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12d444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12d448; return;
}


// Function: SetAsegaHandsOff__FP5ASEGAi
// Address: 0x12d448 - 0x12d47c

void entry_12d47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d47c) {
        switch (ctx->pc) {
            case 0x12d484: ctx->pc = 0; goto label_12d484;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d47c: 0x10000004
    WRITE8(ADD32(GPR_U32(ctx, 17), 36), (uint8_t)GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12D490; return;
    }
label_12d484:
    // 0x12d484: 0xc077694
    SET_GPR_U32(ctx, 31, 0x12d48c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    DecrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_12d48c
// Address: 0x12d48c - 0x12d4a8

void entry_12d48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d48c) {
        switch (ctx->pc) {
            case 0x12d490: ctx->pc = 0; goto label_12d490;
            case 0x12d494: ctx->pc = 0; goto label_12d494;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d48c: 0xa2300024
    WRITE8(ADD32(GPR_U32(ctx, 17), 36), (uint8_t)GPR_U32(ctx, 16));
label_12d490:
    // 0x12d490: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_12d494:
    // 0x12d494: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12d498: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12d49c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12d4a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12d4a8; return;
}


// Function: UpdateAsegaIeaCur__FP5ASEGA
// Address: 0x12d4a8 - 0x12d570

void entry_12d598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d598) {
        switch (ctx->pc) {
            case 0x12d5ac: ctx->pc = 0; goto label_12d5ac;
            case 0x12d5b0: ctx->pc = 0; goto label_12d5b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d598: 0x14400005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12d5b0;
    }
    // 0x12d5a0: 0x8e100020
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x12d5a4: 0x5600fffa
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x12D590; return;
    }
label_12d5ac:
    // 0x12d5ac: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_12d5b0:
    // 0x12d5b0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12d5b4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12d5b8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12d5bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12d5c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12d5c8; return;
}


// Function: junk_0012D5C8
// Address: 0x12d5c8 - 0x12d5d0

void entry_12d66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d66c) {
        switch (ctx->pc) {
            case 0x12d694: ctx->pc = 0; goto label_12d694;
            case 0x12d6a4: ctx->pc = 0; goto label_12d6a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d66c: 0x10400395
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d674: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12d678: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x12d67c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12d680: 0x0
    // NOP
    // 0x12d684: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12d694;
    }
    // 0x12d68c: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12d6a4;
    }
label_12d694:
    // 0x12d694: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12d698: 0x0
    // NOP
    // 0x12d69c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[1]);
        goto label_12d6a4;
    }
label_12d6a4:
    // 0x12d6a4: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d6a8: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12d6ac: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x12d6b0: 0xe4400014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 20), *(uint32_t*)&val); }
    // 0x12d6b4: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x12d6b8: 0xac430020
    WRITE32(ADD32(GPR_U32(ctx, 2), 32), GPR_U32(ctx, 3));
    // 0x12d6bc: 0x10000380
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12d6c4: 0xc06f9ca
    SET_GPR_U32(ctx, 31, 0x12d6cc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    PreloadVag1(rdram, ctx, runtime); return;
}


// Function: entry_12d6cc
// Address: 0x12d6cc - 0x12d6dc

void entry_12d6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d6cc: 0x1000037d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d6d4: 0xc06fa66
    SET_GPR_U32(ctx, 31, 0x12d6dc);
    StopVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_12d6dc
// Address: 0x12d6dc - 0x12d704

void entry_12d6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d6dc: 0x10000379
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d6e4: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12d6e8: 0x84450000
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12d6ec: 0x28a30002
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 5), 2));
    // 0x12d6f0: 0x14600010
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12D734; return;
    }
    // 0x12d6f8: 0x24a5fffe
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967294));
    // 0x12d6fc: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x12d704);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_12d704
// Address: 0x12d704 - 0x12d754

void entry_12d704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d704) {
        switch (ctx->pc) {
            case 0x12d720: ctx->pc = 0; goto label_12d720;
            case 0x12d734: ctx->pc = 0; goto label_12d734;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d704: 0x8e250008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12d708: 0x84a3000e
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 14)));
    // 0x12d70c: 0x84a40000
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x12d710: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12d714: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x12d718: 0x50800001
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_12d720;
    }
label_12d720:
    // 0x12d720: 0x64001a
    { int32_t divisor = GPR_S32(ctx, 4); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 3) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 4) % divisor); } else { ctx->lo = (GPR_S32(ctx,3) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,4); } }
    // 0x12d724: 0x1010
    SET_GPR_U32(ctx, 2, ctx->hi);
    // 0x12d728: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12d72c: 0xa4a3000e
    WRITE16(ADD32(GPR_U32(ctx, 5), 14), (uint16_t)GPR_U32(ctx, 3));
    // 0x12d730: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_12d734:
    // 0x12d734: 0x31840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 1));
    // 0x12d738: 0x2410ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12d73c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12d740: 0x84520002
    SET_GPR_S32(ctx, 18, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 2)));
    // 0x12d744: 0x1250035f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d74c: 0xc06f95a
    SET_GPR_U32(ctx, 31, 0x12d754);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FContinuousSound__F5SFXID(rdram, ctx, runtime); return;
}


// Function: entry_12d754
// Address: 0x12d754 - 0x12d798

void entry_12d754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d754) {
        switch (ctx->pc) {
            case 0x12d774: ctx->pc = 0; goto label_12d774;
            case 0x12d78c: ctx->pc = 0; goto label_12d78c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d754: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d758: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12d75c: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x12d760: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        goto label_12d774;
    }
    // 0x12d768: 0x16800356
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d770: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_12d774:
    // 0x12d774: 0x84460010
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x12d778: 0x50d00008
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 12)));
        ctx->pc = 0x12D79C; return;
    }
    // 0x12d780: 0x8c67000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x12d784: 0x50e00001
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 8)));
        goto label_12d78c;
    }
label_12d78c:
    // 0x12d78c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12d790: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12d798);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12d798
// Address: 0x12d798 - 0x12d7f0

void entry_12d798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d798) {
        switch (ctx->pc) {
            case 0x12d79c: ctx->pc = 0; goto label_12d79c;
            case 0x12d7b4: ctx->pc = 0; goto label_12d7b4;
            case 0x12d7b8: ctx->pc = 0; goto label_12d7b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d798: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_12d79c:
    // 0x12d79c: 0x1200001f
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12D81C; return;
    }
    // 0x12d7a4: 0x12800003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_12d7b4;
    }
    // 0x12d7ac: 0x10000002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 80));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12d7b8;
    }
label_12d7b4:
    // 0x12d7b4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_12d7b8:
    // 0x12d7b8: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12d7bc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12d7c0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12d7c4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12d7c8: 0xc44c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[12] = *(float*)&val; }
    // 0x12d7cc: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x12d7d0: 0xc4500020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[16] = *(float*)&val; }
    // 0x12d7d4: 0xc44d0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[13] = *(float*)&val; }
    // 0x12d7d8: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x12d7dc: 0xc44e0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 36)); ctx->f[14] = *(float*)&val; }
    // 0x12d7e0: 0xc44f001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 28)); ctx->f[15] = *(float*)&val; }
    // 0x12d7e4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12d7e8: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x12d7f0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_12d7f0
// Address: 0x12d7f0 - 0x12d814

void entry_12d7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d7f0: 0x12800333
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12d7f8: 0x8c460050
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x12d7fc: 0x10c00330
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12d804: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12d808: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x12d80c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12d814);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12d814
// Address: 0x12d814 - 0x12d86c

void entry_12d814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d814) {
        switch (ctx->pc) {
            case 0x12d81c: ctx->pc = 0; goto label_12d81c;
            case 0x12d82c: ctx->pc = 0; goto label_12d82c;
            case 0x12d830: ctx->pc = 0; goto label_12d830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d814: 0x1000032b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
label_12d81c:
    // 0x12d81c: 0x12800003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_12d82c;
    }
    // 0x12d824: 0x10000002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 80));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12d830;
    }
label_12d82c:
    // 0x12d82c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_12d830:
    // 0x12d830: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x12d834: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12d838: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x12d83c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x12d840: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x12d844: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12d848: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x12d84c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12d850: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12d854: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12d858: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x12d85c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x12d860: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12d864: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x12d86c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_12d86c
// Address: 0x12d86c - 0x12d88c

void entry_12d86c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d86c: 0x10000315
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d874: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d878: 0x8c440050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x12d87c: 0x10800311
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d884: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x12d88c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_12d88c
// Address: 0x12d88c - 0x12d89c

void entry_12d88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d88c: 0x1000030d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d894: 0xc06fb48
    SET_GPR_U32(ctx, 31, 0x12d89c);
    ContinueMusic__Fv(rdram, ctx, runtime); return;
}


// Function: entry_12d89c
// Address: 0x12d89c - 0x12d8ac

void entry_12d89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d89c: 0x10000309
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d8a4: 0xc06fb3e
    SET_GPR_U32(ctx, 31, 0x12d8ac);
    PauseMusic__Fv(rdram, ctx, runtime); return;
}


// Function: entry_12d8ac
// Address: 0x12d8ac - 0x12d90c

void entry_12d8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d8ac) {
        switch (ctx->pc) {
            case 0x12d8d4: ctx->pc = 0; goto label_12d8d4;
            case 0x12d8e4: ctx->pc = 0; goto label_12d8e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d8ac: 0x10000305
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d8b4: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12d8b8: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x12d8bc: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12d8c0: 0x0
    // NOP
    // 0x12d8c4: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12d8d4;
    }
    // 0x12d8cc: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12d8e4;
    }
label_12d8d4:
    // 0x12d8d4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12d8d8: 0x0
    // NOP
    // 0x12d8dc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[1]);
        goto label_12d8e4;
    }
label_12d8e4:
    // 0x12d8e4: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d8e8: 0xe4400014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 20), *(uint32_t*)&val); }
    // 0x12d8ec: 0x100002f4
    WRITE32(ADD32(GPR_U32(ctx, 2), 24), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12d8f4: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d8f8: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x12d8fc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12d900: 0xe4400014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 20), *(uint32_t*)&val); }
    // 0x12d904: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x12d90c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[12] = *(float*)&val; }
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_12d90c
// Address: 0x12d90c - 0x12d914

void entry_12d90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d90c: 0xc04b52a
    SET_GPR_U32(ctx, 31, 0x12d914);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12d914
// Address: 0x12d914 - 0x12d91c

void entry_12d914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d914: 0xc04bc76
    SET_GPR_U32(ctx, 31, 0x12d91c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    AdaptAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12d91c
// Address: 0x12d91c - 0x12d930

void entry_12d91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d91c: 0x100002e9
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d924: 0xc62c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    // 0x12d928: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x12d930);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_12d930
// Address: 0x12d930 - 0x12d954

void entry_12d930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d930: 0x100002e4
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d938: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d93c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12d940: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12d944: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12d948: 0x8c47000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12d94c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12d954);
    if (GPR_U32(ctx, 7) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 18));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12d954
// Address: 0x12d954 - 0x12d964

void entry_12d954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d954: 0x104002db
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d95c: 0xc05462e
    SET_GPR_U32(ctx, 31, 0x12d964);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    TriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_12d964
// Address: 0x12d964 - 0x12d974

void entry_12d964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d964: 0x100002d7
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d96c: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x12d974);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12d974
// Address: 0x12d974 - 0x12d9a8

void entry_12d974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d974: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12d978: 0x100002d1
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12d980: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12d984: 0x38a30009
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 5), 9));
    // 0x12d988: 0x2c700001
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x12d98c: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12d990: 0x8c47000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12d994: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12d998: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12d99c: 0x2148026
    SET_GPR_U32(ctx, 16, XOR32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    // 0x12d9a0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12d9a8);
    if (GPR_U32(ctx, 7) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 18));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12d9a8
// Address: 0x12d9a8 - 0x12d9d4

void entry_12d9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12d9a8: 0x104002c6
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12d9b0: 0xc62c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[12] = *(float*)&val; }
    // 0x12d9b4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12d9b8: 0x46006032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12d9bc: 0x4501000b
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12D9EC; return;
    }
    // 0x12d9c4: 0x12000005
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12D9DC; return;
    }
    // 0x12d9cc: 0xc049b2e
    SET_GPR_U32(ctx, 31, 0x12d9d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FadeAloIn__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_12d9d4
// Address: 0x12d9d4 - 0x12d9e4

void entry_12d9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d9d4) {
        switch (ctx->pc) {
            case 0x12d9dc: ctx->pc = 0; goto label_12d9dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d9d4: 0x100002bb
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
label_12d9dc:
    // 0x12d9dc: 0xc049b58
    SET_GPR_U32(ctx, 31, 0x12d9e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FadeAloOut__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_12d9e4
// Address: 0x12d9e4 - 0x12da04

void entry_12d9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12d9e4) {
        switch (ctx->pc) {
            case 0x12d9ec: ctx->pc = 0; goto label_12d9ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12d9e4: 0x100002b7
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
label_12d9ec:
    // 0x12d9ec: 0x12000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12DA0C; return;
    }
    // 0x12d9f4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12d9f8: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x12d9fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12da04);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12da04
// Address: 0x12da04 - 0x12da1c

void entry_12da04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12da04) {
        switch (ctx->pc) {
            case 0x12da0c: ctx->pc = 0; goto label_12da0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12da04: 0x100002af
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
label_12da0c:
    // 0x12da0c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12da10: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x12da14: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12da1c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12da1c
// Address: 0x12da1c - 0x12da44

void entry_12da1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12da1c) {
        switch (ctx->pc) {
            case 0x12da34: ctx->pc = 0; goto label_12da34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12da1c: 0x100002a9
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12da24: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12da28: 0x8c47000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12da2c: 0x50e00001
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 8)));
        goto label_12da34;
    }
label_12da34:
    // 0x12da34: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12da38: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12da3c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12da44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12da44
// Address: 0x12da44 - 0x12da74

void entry_12da44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12da44) {
        switch (ctx->pc) {
            case 0x12da58: ctx->pc = 0; goto label_12da58;
            case 0x12da64: ctx->pc = 0; goto label_12da64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12da44: 0x1040029f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12da4c: 0x8625000c
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12da50: 0x4a20001
    if (GPR_S32(ctx, 5) < 0) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 1104)));
        goto label_12da58;
    }
label_12da58:
    // 0x12da58: 0x8627000e
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 14)));
    // 0x12da5c: 0x4e20001
    if (GPR_S32(ctx, 7) < 0) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 1136)));
        goto label_12da64;
    }
label_12da64:
    // 0x12da64: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12da68: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12da6c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x12da74);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_12da74
// Address: 0x12da74 - 0x12daa0

void entry_12da74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12da74: 0x10000293
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12da7c: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12da80: 0x38a2000c
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 5), 12));
    // 0x12da84: 0x2c500001
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x12da88: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12da8c: 0x8c670008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12da90: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12da94: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x12da98: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12daa0);
    SET_GPR_U32(ctx, 16, XOR32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12daa0
// Address: 0x12daa0 - 0x12dab8

void entry_12daa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12daa0: 0x10400288
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12daa8: 0x12000005
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12DAC0; return;
    }
    // 0x12dab0: 0xc07d3b4
    SET_GPR_U32(ctx, 31, 0x12dab8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    EnableCamera__FP6CAMERA(rdram, ctx, runtime); return;
}


// Function: entry_12dab8
// Address: 0x12dab8 - 0x12dac8

void entry_12dab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12dab8) {
        switch (ctx->pc) {
            case 0x12dac0: ctx->pc = 0; goto label_12dac0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12dab8: 0x10000282
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
label_12dac0:
    // 0x12dac0: 0xc07d3c8
    SET_GPR_U32(ctx, 31, 0x12dac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    DisableCamera__FP6CAMERA(rdram, ctx, runtime); return;
}


// Function: entry_12dac8
// Address: 0x12dac8 - 0x12dae4

void entry_12dac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dac8: 0x1000027e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dad0: 0x38a5000e
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 14));
    // 0x12dad4: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dad8: 0x2ca50001
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    // 0x12dadc: 0xc04b512
    SET_GPR_U32(ctx, 31, 0x12dae4);
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), GPR_U32(ctx, 20)));
    SetAsegaHandsOff__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_12dae4
// Address: 0x12dae4 - 0x12db08

void entry_12dae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dae4: 0x10000277
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12daec: 0x38b00013
    SET_GPR_U32(ctx, 16, XOR32(GPR_U32(ctx, 5), 19));
    // 0x12daf0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x12daf4: 0x2e100001
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 16), 1));
    // 0x12daf8: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x12dafc: 0x2148026
    SET_GPR_U32(ctx, 16, XOR32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    // 0x12db00: 0xc05de00
    SET_GPR_U32(ctx, 31, 0x12db08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetJtPuppet__FP2JTP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12db08
// Address: 0x12db08 - 0x12db24

void entry_12db08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12db08: 0x1200026e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12db10: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12db14: 0x1040026b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12db1c: 0xc04bc64
    SET_GPR_U32(ctx, 31, 0x12db24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnapAsega__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_12db24
// Address: 0x12db24 - 0x12db38

void entry_12db24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12db24: 0x10000267
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12db2c: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12db30: 0xc04b55c
    SET_GPR_U32(ctx, 31, 0x12db38);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime); return;
}


// Function: entry_12db38
// Address: 0x12db38 - 0x12db70

void entry_12db38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12db38) {
        switch (ctx->pc) {
            case 0x12db68: ctx->pc = 0; goto label_12db68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12db38: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12db3c: 0x10800260
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 20), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12db44: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12db48: 0x38420011
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 17));
    // 0x12db4c: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x12db50: 0x10430005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_12db68;
    }
    // 0x12db58: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x12db5c: 0xa0820010
    WRITE8(ADD32(GPR_U32(ctx, 4), 16), (uint8_t)GPR_U32(ctx, 2));
    // 0x12db60: 0x10000257
    WRITE8(ADD32(GPR_U32(ctx, 4), 17), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
label_12db68:
    // 0x12db68: 0xc048570
    SET_GPR_U32(ctx, 31, 0x12db70);
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_12db70
// Address: 0x12db70 - 0x12db9c

void entry_12db70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12db70) {
        switch (ctx->pc) {
            case 0x12db8c: ctx->pc = 0; goto label_12db8c;
            case 0x12db94: ctx->pc = 0; goto label_12db94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12db70: 0x10000254
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12db78: 0x24020015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    // 0x12db7c: 0x10a20003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_12db8c;
    }
    // 0x12db84: 0x54a20003
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        goto label_12db94;
    }
label_12db8c:
    // 0x12db8c: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12db90: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_12db94:
    // 0x12db94: 0xc04b55c
    SET_GPR_U32(ctx, 31, 0x12db9c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime); return;
}


// Function: entry_12db9c
// Address: 0x12db9c - 0x12dc48

void entry_12db9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12db9c) {
        switch (ctx->pc) {
            case 0x12dbcc: ctx->pc = 0; goto label_12dbcc;
            case 0x12dbe8: ctx->pc = 0; goto label_12dbe8;
            case 0x12dbf8: ctx->pc = 0; goto label_12dbf8;
            case 0x12dc08: ctx->pc = 0; goto label_12dc08;
            case 0x12dc18: ctx->pc = 0; goto label_12dc18;
            case 0x12dc24: ctx->pc = 0; goto label_12dc24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12db9c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12dba0: 0x10800247
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 22));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12dba8: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12dbac: 0x10620012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 23));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_12dbf8;
    }
    // 0x12dbb4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12dbcc;
    }
    // 0x12dbbc: 0x1062000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_12dbe8;
    }
    // 0x12dbc4: 0x10000240
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C8; return;
    }
label_12dbcc:
    // 0x12dbcc: 0x24020017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    // 0x12dbd0: 0x1062000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_12dc08;
    }
    // 0x12dbd8: 0x1062000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_12dc18;
    }
    // 0x12dbe0: 0x10000239
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C8; return;
    }
label_12dbe8:
    // 0x12dbe8: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dbec: 0xac51002c
    WRITE32(ADD32(GPR_U32(ctx, 2), 44), GPR_U32(ctx, 17));
    // 0x12dbf0: 0x10000233
    WRITE32(ADD32(GPR_U32(ctx, 2), 40), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
label_12dbf8:
    // 0x12dbf8: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dbfc: 0x8c620030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x12dc00: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 3), 44), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12dc24;
    }
label_12dc08:
    // 0x12dc08: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dc0c: 0xac510030
    WRITE32(ADD32(GPR_U32(ctx, 2), 48), GPR_U32(ctx, 17));
    // 0x12dc10: 0x1000022b
    WRITE32(ADD32(GPR_U32(ctx, 2), 40), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
label_12dc18:
    // 0x12dc18: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dc1c: 0x8c62002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 44)));
    // 0x12dc20: 0xac600030
    WRITE32(ADD32(GPR_U32(ctx, 3), 48), GPR_U32(ctx, 0));
label_12dc24:
    // 0x12dc24: 0x50400226
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 40), GPR_U32(ctx, 0));
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12dc2c: 0x10000225
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dc34: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x12dc38: 0x86260008
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12dc3c: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12dc40: 0xc07bfe8
    SET_GPR_U32(ctx, 31, 0x12dc48);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    ActivateWipe__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_12dc48
// Address: 0x12dc48 - 0x12dc64

void entry_12dc48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dc48: 0x1000021e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dc50: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x12dc54: 0x86260008
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12dc58: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12dc5c: 0xc07c030
    SET_GPR_U32(ctx, 31, 0x12dc64);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    SetWipeButtonTrans__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_12dc64
// Address: 0x12dc64 - 0x12dcbc

void entry_12dc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12dc64) {
        switch (ctx->pc) {
            case 0x12dcb0: ctx->pc = 0; goto label_12dcb0;
            case 0x12dcb4: ctx->pc = 0; goto label_12dcb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12dc64: 0x10000217
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dc6c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x12dc70: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x12dc74: 0x1080000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_12dcb0;
    }
    // 0x12dc7c: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x12dc80: 0x5462000c
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        goto label_12dcb4;
    }
    // 0x12dc88: 0x8c832228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8744)));
    // 0x12dc8c: 0x2402001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 28));
    // 0x12dc90: 0x54620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        goto label_12dcb4;
    }
    // 0x12dc98: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x12dc9c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x12dca0: 0x8c6523c8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x12dca4: 0x8c8223c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 9156)));
    // 0x12dca8: 0x10a20206
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12E4C4; return;
    }
label_12dcb0:
    // 0x12dcb0: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_12dcb4:
    // 0x12dcb4: 0xc07d102
    SET_GPR_U32(ctx, 31, 0x12dcbc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    TriggerDefaultExit__Fi5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_12dcbc
// Address: 0x12dcbc - 0x12dcd8

void entry_12dcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dcbc: 0x10000201
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dcc4: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x12dcc8: 0xc62c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    // 0x12dccc: 0x2610e760
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294960992));
    // 0x12dcd0: 0xc06ae24
    SET_GPR_U32(ctx, 31, 0x12dcd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTimer__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_12dcd8
// Address: 0x12dcd8 - 0x12dce0

void entry_12dcd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dcd8: 0xc06ae4e
    SET_GPR_U32(ctx, 31, 0x12dce0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StartTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_12dce0
// Address: 0x12dce0 - 0x12dcf4

void entry_12dce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dce0: 0x100001f8
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dce8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x12dcec: 0xc06ae56
    SET_GPR_U32(ctx, 31, 0x12dcf4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960992));
    StopTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_12dcf4
// Address: 0x12dcf4 - 0x12dd10

void entry_12dcf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dcf4: 0x100001f3
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dcfc: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12dd00: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12dd04: 0x8e460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x12dd08: 0xc056912
    SET_GPR_U32(ctx, 31, 0x12dd10);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12dd10
// Address: 0x12dd10 - 0x12dd34

void entry_12dd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dd10: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12dd14: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12dd18: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12dd1c: 0x8c450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x12dd20: 0x50a30005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x12DD38; return;
    }
    // 0x12dd28: 0x8e460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x12dd2c: 0xc056912
    SET_GPR_U32(ctx, 31, 0x12dd34);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12dd34
// Address: 0x12dd34 - 0x12dd58

void entry_12dd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12dd34) {
        switch (ctx->pc) {
            case 0x12dd38: ctx->pc = 0; goto label_12dd38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12dd34: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_12dd38:
    // 0x12dd38: 0x120001e1
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12dd40: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12dd44: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12dd48: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12dd4c: 0xc44d000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[13] = *(float*)&val; }
    // 0x12dd50: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x12dd58);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12dd58
// Address: 0x12dd58 - 0x12dd6c

void entry_12dd58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dd58: 0x100001da
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dd60: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dd64: 0xc04b55c
    SET_GPR_U32(ctx, 31, 0x12dd6c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime); return;
}


// Function: entry_12dd6c
// Address: 0x12dd6c - 0x12de54

void entry_12dd6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12dd6c) {
        switch (ctx->pc) {
            case 0x12ddb4: ctx->pc = 0; goto label_12ddb4;
            case 0x12ddd0: ctx->pc = 0; goto label_12ddd0;
            case 0x12dde4: ctx->pc = 0; goto label_12dde4;
            case 0x12ddfc: ctx->pc = 0; goto label_12ddfc;
            case 0x12de10: ctx->pc = 0; goto label_12de10;
            case 0x12de20: ctx->pc = 0; goto label_12de20;
            case 0x12de30: ctx->pc = 0; goto label_12de30;
            case 0x12de38: ctx->pc = 0; goto label_12de38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12dd6c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12dd70: 0x10c00031
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
    // 0x12dd78: 0x8cc20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 40)));
    // 0x12dd7c: 0x2403001c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 28));
    // 0x12dd80: 0x8e44003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x12dd84: 0x2405001e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 30));
    // 0x12dd88: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12dd8c: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12dd90: 0x10650014
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 5)) {
        goto label_12dde4;
    }
    // 0x12dd98: 0x2862001f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 31));
    // 0x12dd9c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 29));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12ddb4;
    }
    // 0x12dda4: 0x5062000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
        goto label_12ddd0;
    }
    // 0x12ddac: 0x10000022
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
label_12ddb4:
    // 0x12ddb4: 0x2402001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    // 0x12ddb8: 0x10620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_12ddfc;
    }
    // 0x12ddc0: 0x50620017
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
        goto label_12de20;
    }
    // 0x12ddc8: 0x1000001b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
label_12ddd0:
    // 0x12ddd0: 0x10400019
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
    // 0x12ddd8: 0x90c20012
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 18)));
    // 0x12dddc: 0x1000000c
    WRITE8(ADD32(GPR_U32(ctx, 6), 18), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12de10;
    }
label_12dde4:
    // 0x12dde4: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x12dde8: 0x10400013
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
    // 0x12ddf0: 0x80c20012
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 18)));
    // 0x12ddf4: 0x1000000e
    WRITE8(ADD32(GPR_U32(ctx, 6), 18), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12de30;
    }
label_12ddfc:
    // 0x12ddfc: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x12de00: 0x1040000d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
    // 0x12de08: 0x90c20013
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 19)));
    // 0x12de0c: 0xa0c30013
    WRITE8(ADD32(GPR_U32(ctx, 6), 19), (uint8_t)GPR_U32(ctx, 3));
label_12de10:
    // 0x12de10: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x12de14: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x12de18: 0x10000007
    SET_GPR_U32(ctx, 7, SLTU32(GPR_U32(ctx, 2), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
label_12de20:
    // 0x12de20: 0x10400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12de38;
    }
    // 0x12de28: 0x80c20013
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 19)));
    // 0x12de2c: 0xa0c30013
    WRITE8(ADD32(GPR_U32(ctx, 6), 19), (uint8_t)GPR_U32(ctx, 3));
label_12de30:
    // 0x12de30: 0x21027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x12de34: 0x2382b
    SET_GPR_U32(ctx, 7, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_12de38:
    // 0x12de38: 0x10e001a2
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12de40: 0x8cc40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x12de44: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12de48: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x12de4c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12de54);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12de54
// Address: 0x12de54 - 0x12de68

void entry_12de54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12de54: 0x1000019b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12de5c: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12de60: 0xc04b55c
    SET_GPR_U32(ctx, 31, 0x12de68);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime); return;
}


// Function: entry_12de68
// Address: 0x12de68 - 0x12dec4

void entry_12de68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12de68: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12de6c: 0x10e00194
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 28));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12de74: 0x8ce20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 40)));
    // 0x12de78: 0x8e45003c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x12de7c: 0x24060023
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 35));
    // 0x12de80: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12de84: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12de88: 0x8cf20004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x12de8c: 0x14860019
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 6)) {
        ctx->pc = 0x12DEF4; return;
    }
    // 0x12de94: 0x8ca40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x12de98: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x12de9c: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dea0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12dea4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12dea8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12deac: 0xc44d0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[13] = *(float*)&val; }
    // 0x12deb0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12deb4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12deb8: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12debc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12dec4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12dec4
// Address: 0x12dec4 - 0x12ded8

void entry_12dec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dec4: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12dec8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12decc: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x12ded0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12ded8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12ded8
// Address: 0x12ded8 - 0x12deec

void entry_12ded8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ded8: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12dedc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12dee0: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x12dee4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12deec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12deec
// Address: 0x12deec - 0x12df24

void entry_12deec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12deec) {
        switch (ctx->pc) {
            case 0x12def4: ctx->pc = 0; goto label_12def4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12deec: 0x10000175
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
label_12def4:
    // 0x12def4: 0x8ca40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x12def8: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x12defc: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12df00: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12df04: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12df08: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12df0c: 0xc44d0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[13] = *(float*)&val; }
    // 0x12df10: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12df14: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12df18: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12df1c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12df24);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12df24
// Address: 0x12df24 - 0x12df38

void entry_12df24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12df24: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12df28: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12df2c: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x12df30: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12df38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12df38
// Address: 0x12df38 - 0x12df4c

void entry_12df38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12df38: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12df3c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12df40: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x12df44: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12df4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12df4c
// Address: 0x12df4c - 0x12df80

void entry_12df4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12df4c: 0x1000015d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12df54: 0x86220008
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12df58: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x12df5c: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x12df60: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x12df64: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x12df68: 0x24842c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    // 0x12df6c: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x12df70: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x12df74: 0x8625000a
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 10)));
    // 0x12df78: 0xc05bb0e
    SET_GPR_U32(ctx, 31, 0x12df80);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    TriggerJoyRumbleRumk__FP3JOY4RUMKf(rdram, ctx, runtime); return;
}


// Function: entry_12df80
// Address: 0x12df80 - 0x12dfac

void entry_12df80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12df80) {
        switch (ctx->pc) {
            case 0x12dfa0: ctx->pc = 0; goto label_12dfa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12df80: 0x10000150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12df88: 0x8e250008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12df8c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12df90: 0x14a20003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_12dfa0;
    }
    // 0x12df98: 0x10000005
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12DFB0; return;
    }
label_12dfa0:
    // 0x12dfa0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12dfa4: 0xc056912
    SET_GPR_U32(ctx, 31, 0x12dfac);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12dfac
// Address: 0x12dfac - 0x12dfdc

void entry_12dfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12dfac) {
        switch (ctx->pc) {
            case 0x12dfb0: ctx->pc = 0; goto label_12dfb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12dfac: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_12dfb0:
    // 0x12dfb0: 0x10e00143
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12dfb8: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12dfbc: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dfc0: 0x24050012
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    // 0x12dfc4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x12dfc8: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x12dfcc: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x12dfd0: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x12dfd4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12dfdc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12dfdc
// Address: 0x12dfdc - 0x12e030

void entry_12dfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12dfdc: 0x10000139
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12dfe4: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12dfe8: 0x24050013
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 19));
    // 0x12dfec: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12dff0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12dff4: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12dff8: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x12dffc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e000: 0x1000001d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E078; return;
    }
    // 0x12e008: 0x26220008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 8));
    // 0x12e00c: 0x27a30050
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 80));
    // 0x12e010: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x12e014: 0x2405000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    // 0x12e018: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x12e01c: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x12e020: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e024: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12e028: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x12e030);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_12e030
// Address: 0x12e030 - 0x12e054

void entry_12e030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e030: 0x10000124
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e038: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e03c: 0x8c47000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12e040: 0x10e0011f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12e048: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e04c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e054);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e054
// Address: 0x12e054 - 0x12e080

void entry_12e054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e054) {
        switch (ctx->pc) {
            case 0x12e078: ctx->pc = 0; goto label_12e078;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e054: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e058: 0x10600119
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12e060: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12e064: 0x24050015
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 21));
    // 0x12e068: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12e06c: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x12e070: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x12e074: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_12e078:
    // 0x12e078: 0xc04bdd8
    SET_GPR_U32(ctx, 31, 0x12e080);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    SendAsegaMessage__FP5ASEGA5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_12e080
// Address: 0x12e080 - 0x12e0a0

void entry_12e080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e080: 0x10000110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e088: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e08c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12e090: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e094: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12e098: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e0a0);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e0a0
// Address: 0x12e0a0 - 0x12e0b4

void entry_12e0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e0a0: 0x10400108
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e0a8: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12e0ac: 0xc04acbe
    SET_GPR_U32(ctx, 31, 0x12e0b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetAloPoseCombo__FP3ALO3OID(rdram, ctx, runtime); return;
}


// Function: entry_12e0b4
// Address: 0x12e0b4 - 0x12e0e0

void entry_12e0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e0b4) {
        switch (ctx->pc) {
            case 0x12e0cc: ctx->pc = 0; goto label_12e0cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e0b4: 0x10000103
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e0bc: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e0c0: 0x8c50000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12e0c4: 0x52000001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
        goto label_12e0cc;
    }
label_12e0cc:
    // 0x12e0cc: 0x86260008
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e0d0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12e0d4: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12e0d8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e0e0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e0e0
// Address: 0x12e0e0 - 0x12e0fc

void entry_12e0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e0e0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e0e4: 0x124000f6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12e0ec: 0x8626000a
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 10)));
    // 0x12e0f0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e0f4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e0fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e0fc
// Address: 0x12e0fc - 0x12e10c

void entry_12e0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e0fc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e100: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12e104: 0xc06d8e2
    SET_GPR_U32(ctx, 31, 0x12e10c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PsmaFindSm__FP2SMP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12e10c
// Address: 0x12e10c - 0x12e128

void entry_12e10c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e10c: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x12E12C; return;
    }
    // 0x12e114: 0x8626000c
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12e118: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12e11c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e120: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x12e128);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_12e128
// Address: 0x12e128 - 0x12e134

void entry_12e128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e128) {
        switch (ctx->pc) {
            case 0x12e12c: ctx->pc = 0; goto label_12e12c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e128: 0x8625000c
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 12)));
label_12e12c:
    // 0x12e12c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x12e134);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_12e134
// Address: 0x12e134 - 0x12e160

void entry_12e134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e134) {
        switch (ctx->pc) {
            case 0x12e150: ctx->pc = 0; goto label_12e150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e134: 0x100000e3
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e13c: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e140: 0x8c50000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12e144: 0x16000002
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_12e150;
    }
    // 0x12e14c: 0x8c500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
label_12e150:
    // 0x12e150: 0x8e250008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e154: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12e158: 0xc056912
    SET_GPR_U32(ctx, 31, 0x12e160);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e160
// Address: 0x12e160 - 0x12e178

void entry_12e160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e160: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e164: 0x12400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E188; return;
    }
    // 0x12e16c: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12e170: 0xc056912
    SET_GPR_U32(ctx, 31, 0x12e178);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e178
// Address: 0x12e178 - 0x12e184

void entry_12e178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e178: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12e17c: 0xc06d8e2
    SET_GPR_U32(ctx, 31, 0x12e184);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PsmaFindSm__FP2SMP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12e184
// Address: 0x12e184 - 0x12e198

void entry_12e184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e184) {
        switch (ctx->pc) {
            case 0x12e188: ctx->pc = 0; goto label_12e188;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e184: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_12e188:
    // 0x12e188: 0x128000ce
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e190: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x12e198);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_12e198
// Address: 0x12e198 - 0x12e1c4

void entry_12e198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e198: 0x100000ca
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e1a0: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e1a4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12e1a8: 0x8e340008
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e1ac: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12e1b0: 0x8c51000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12e1b4: 0x8e860000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x12e1b8: 0x251880a
    if (GPR_U32(ctx, 17) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 18));
    // 0x12e1bc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e1c4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e1c4
// Address: 0x12e1c4 - 0x12e1ec

void entry_12e1c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e1c4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e1c8: 0x124000bd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12e1d0: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x12e1d4: 0x8e860004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x12e1d8: 0x10c20025
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        entry_12e270(rdram, ctx, runtime); return;
    }
    // 0x12e1e0: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x12e1e4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e1ec);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e1ec
// Address: 0x12e1ec - 0x12e200

void entry_12e1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e1ec: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e1f0: 0x1200001f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_12e270(rdram, ctx, runtime); return;
    }
    // 0x12e1f8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x12e200);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_12e200
// Address: 0x12e200 - 0x12e224

void entry_12e200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e200) {
        switch (ctx->pc) {
            case 0x12e218: ctx->pc = 0; goto label_12e218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e200: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12e218;
    }
    // 0x12e208: 0xafb00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 16));
    // 0x12e20c: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x12e210: 0x10000017
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e270(rdram, ctx, runtime); return;
    }
label_12e218:
    // 0x12e218: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e21c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x12e224);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_12e224
// Address: 0x12e224 - 0x12e240

void entry_12e224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e224: 0x10400008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E248; return;
    }
    // 0x12e22c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e230: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x12e234: 0x34420004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    // 0x12e238: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x12e240);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12e240
// Address: 0x12e240 - 0x12e254

void entry_12e240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e240) {
        switch (ctx->pc) {
            case 0x12e248: ctx->pc = 0; goto label_12e248;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e240: 0x1000000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E274; return;
    }
label_12e248:
    // 0x12e248: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e24c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x12e254);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 115));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_12e254
// Address: 0x12e254 - 0x12e270

void entry_12e254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e254: 0x10400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12e270(rdram, ctx, runtime); return;
    }
    // 0x12e25c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e260: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x12e264: 0x34420004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    // 0x12e268: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x12e270);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12e270
// Address: 0x12e270 - 0x12e290

void entry_12e270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e270) {
        switch (ctx->pc) {
            case 0x12e274: ctx->pc = 0; goto label_12e274;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e270: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_12e274:
    // 0x12e274: 0x54400013
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 8)));
        ctx->pc = 0x12E2C4; return;
    }
    // 0x12e27c: 0x8e440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x12e280: 0x1080000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E2AC; return;
    }
    // 0x12e288: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x12e290);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e290
// Address: 0x12e290 - 0x12e2c0

void entry_12e290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e290) {
        switch (ctx->pc) {
            case 0x12e2ac: ctx->pc = 0; goto label_12e2ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e290: 0x10400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12e2ac;
    }
    // 0x12e298: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x12e29c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x12e2a0: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x12e2a4: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12e2c0(rdram, ctx, runtime); return;
    }
label_12e2ac:
    // 0x12e2ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12e2b0: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x12e2b4: 0x34420004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    // 0x12e2b8: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x12e2c0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_12e2c0
// Address: 0x12e2c0 - 0x12e2dc

void entry_12e2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e2c0) {
        switch (ctx->pc) {
            case 0x12e2c4: ctx->pc = 0; goto label_12e2c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e2c0: 0x8e860008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 8)));
label_12e2c4:
    // 0x12e2c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12e2c8: 0x10c2000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12E2F4; return;
    }
    // 0x12e2d0: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12e2d4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e2dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e2dc
// Address: 0x12e2dc - 0x12e338

void entry_12e2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e2dc) {
        switch (ctx->pc) {
            case 0x12e2f4: ctx->pc = 0; goto label_12e2f4;
            case 0x12e328: ctx->pc = 0; goto label_12e328;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e2dc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e2e0: 0x10600004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_12e2f4;
    }
    // 0x12e2e8: 0xafa30038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 3));
    // 0x12e2ec: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x12e2f0: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
label_12e2f4:
    // 0x12e2f4: 0xc681000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 12)); ctx->f[1] = *(float*)&val; }
    // 0x12e2f8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12e2fc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x12e300: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12e304: 0x0
    // NOP
    // 0x12e308: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_12e328;
    }
    // 0x12e310: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12e314: 0x34420018
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 24));
    // 0x12e318: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x12e31c: 0xc680000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 12)); ctx->f[0] = *(float*)&val; }
    // 0x12e320: 0xe7a00030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x12e324: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_12e328:
    // 0x12e328: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12e32c: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x12e330: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12e338);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12e338
// Address: 0x12e338 - 0x12e348

void entry_12e338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e338: 0x10000062
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e340: 0xc0776d6
    SET_GPR_U32(ctx, 31, 0x12e348);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FUN_001ddb58(rdram, ctx, runtime); return;
}


// Function: entry_12e348
// Address: 0x12e348 - 0x12e358

void entry_12e348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e348: 0x1000005e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e350: 0xc0776ee
    SET_GPR_U32(ctx, 31, 0x12e358);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FUN_001ddbb8(rdram, ctx, runtime); return;
}


// Function: entry_12e358
// Address: 0x12e358 - 0x12e370

void entry_12e358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e358: 0x1000005a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e360: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x12e364: 0x8e250008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e368: 0xc063c3a
    SET_GPR_U32(ctx, 31, 0x12e370);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941184));
    FUN_0018f0e8(rdram, ctx, runtime); return;
}


// Function: entry_12e370
// Address: 0x12e370 - 0x12e398

void entry_12e370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e370: 0x10000054
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e378: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x12e37c: 0x8fa50050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e380: 0x8e032e08
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 11784)));
    // 0x12e384: 0x26102e08
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 11784));
    // 0x12e388: 0x24a50014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 20));
    // 0x12e38c: 0x8c620044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 68)));
    // 0x12e390: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12e398);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12e398
// Address: 0x12e398 - 0x12e3bc

void entry_12e398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e398: 0x86230008
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e39c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e3a0: 0x8622000a
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 10)));
    // 0x12e3a4: 0x44836000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 3);
    // 0x12e3a8: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x12e3ac: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x12e3b0: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x12e3b4: 0xc052ba8
    SET_GPR_U32(ctx, 31, 0x12e3bc);
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 12)));
    PlaceCredit__FP6CREDITffi(rdram, ctx, runtime); return;
}


// Function: entry_12e3bc
// Address: 0x12e3bc - 0x12e3e0

void entry_12e3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e3bc: 0x10000041
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e3c4: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x12e3c8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12e3cc: 0x8e032e08
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 11784)));
    // 0x12e3d0: 0x26102e08
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 11784));
    // 0x12e3d4: 0x8c620044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 68)));
    // 0x12e3d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12e3e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12e3e0
// Address: 0x12e3e0 - 0x12e3e8

void entry_12e3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e3e0: 0xc052bc4
    SET_GPR_U32(ctx, 31, 0x12e3e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    VacateCredit__FP6CREDIT(rdram, ctx, runtime); return;
}


// Function: entry_12e3e8
// Address: 0x12e3e8 - 0x12e41c

void entry_12e3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e3e8: 0x10000036
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e3f0: 0x8622000a
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 10)));
    // 0x12e3f4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x12e3f8: 0x3c013b80
    SET_GPR_U32(ctx, 1, ((uint32_t)15232 << 16));
    // 0x12e3fc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x12e400: 0x24842e08
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11784));
    // 0x12e404: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x12e408: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x12e40c: 0x8e26000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x12e410: 0x86250008
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e414: 0xc052bce
    SET_GPR_U32(ctx, 31, 0x12e41c);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    SetCreditLine__FP6CREDITiPcf(rdram, ctx, runtime); return;
}


// Function: entry_12e41c
// Address: 0x12e41c - 0x12e440

void entry_12e41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e41c: 0x10000029
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e424: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x12e428: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12e42c: 0x24425bc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23488));
    // 0x12e430: 0xa8400033
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x12e434: 0xb8400030
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x12e438: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x12e440);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_12e440
// Address: 0x12e440 - 0x12e460

void entry_12e440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e440: 0x10000020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e448: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x12e44c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12e450: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x12e454: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12e458: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x12e460);
    WRITE32(ADD32(GPR_U32(ctx, 4), 48), GPR_U32(ctx, 2));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_12e460
// Address: 0x12e460 - 0x12e474

void entry_12e460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e460: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e468: 0xc62c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    // 0x12e46c: 0xc0776ae
    SET_GPR_U32(ctx, 31, 0x12e474);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSwDarken__FP2SWf(rdram, ctx, runtime); return;
}


// Function: entry_12e474
// Address: 0x12e474 - 0x12e488

void entry_12e474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e474: 0x10000013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e47c: 0xc62c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    // 0x12e480: 0xc0776b2
    SET_GPR_U32(ctx, 31, 0x12e488);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSwDarkenSmooth__FP2SWf(rdram, ctx, runtime); return;
}


// Function: entry_12e488
// Address: 0x12e488 - 0x12e4ac

void entry_12e488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e488: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E4C4; return;
    }
    // 0x12e490: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e494: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12e498: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x12e49c: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x12e4a0: 0x8c47000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x12e4a4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x12e4ac);
    if (GPR_U32(ctx, 7) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 18));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12e4ac
// Address: 0x12e4ac - 0x12e4c0

void entry_12e4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e4ac: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e4b0: 0x10800003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_12e4c0(rdram, ctx, runtime); return;
    }
    // 0x12e4b8: 0xc05f388
    SET_GPR_U32(ctx, 31, 0x12e4c0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    ApplyJsg__FP3JSGP2JT(rdram, ctx, runtime); return;
}


// Function: entry_12e4c0
// Address: 0x12e4c0 - 0x12e4e0

void entry_12e4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e4c0) {
        switch (ctx->pc) {
            case 0x12e4c4: ctx->pc = 0; goto label_12e4c4;
            case 0x12e4c8: ctx->pc = 0; goto label_12e4c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e4c0: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_12e4c4:
    // 0x12e4c4: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_12e4c8:
    // 0x12e4c8: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12e4cc: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12e4d0: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12e4d4: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12e4d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleAsegaEventsFF__FP5ASEGAP4ASEGPi
// Address: 0x12e4e0 - 0x12e584

void entry_12e584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e584) {
        switch (ctx->pc) {
            case 0x12e58c: ctx->pc = 0; goto label_12e58c;
            case 0x12e5b4: ctx->pc = 0; goto label_12e5b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e584: 0x8e040020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x12e588: 0x8e22005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 92)));
label_12e58c:
    // 0x12e58c: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x12e590: 0x10400008
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12e5b4;
    }
    // 0x12e598: 0x8e250060
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 96)));
    // 0x12e59c: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x12e5a0: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12e5a4: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12e5a8: 0x0
    // NOP
    // 0x12e5ac: 0x4501ffde
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 1));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12E528; return;
    }
label_12e5b4:
    // 0x12e5b4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12e5b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12e5bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12e5c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12e5c4: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x12e5c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleAsegaEvents__FP5ASEGAP4ASEGPi
// Address: 0x12e5d0 - 0x12e66c

void entry_12e66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e66c) {
        switch (ctx->pc) {
            case 0x12e680: ctx->pc = 0; goto label_12e680;
            case 0x12e6cc: ctx->pc = 0; goto label_12e6cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e66c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12e670: 0x14400021
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E6F8; return;
    }
    // 0x12e678: 0x1000ffe3
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E608; return;
    }
label_12e680:
    // 0x12e680: 0x1880001c
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x12E6F4; return;
    }
    // 0x12e688: 0x8e230060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 96)));
    // 0x12e68c: 0xc6010014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[1] = *(float*)&val; }
    // 0x12e690: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12e694: 0xc440fff0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967280)); ctx->f[0] = *(float*)&val; }
    // 0x12e698: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12e69c: 0x0
    // NOP
    // 0x12e6a0: 0x4503000a
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294967295));
        goto label_12e6cc;
    }
    // 0x12e6a8: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12e6ac: 0x0
    // NOP
    // 0x12e6b0: 0x45000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12E6F8; return;
    }
    // 0x12e6b8: 0xc6000018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[0] = *(float*)&val; }
    // 0x12e6bc: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12e6c0: 0x0
    // NOP
    // 0x12e6c4: 0x4500000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12E6F8; return;
    }
label_12e6cc:
    // 0x12e6cc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12e6d0: 0xae020020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    // 0x12e6d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12e6d8: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x12e6dc: 0x8e250060
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 96)));
    // 0x12e6e0: 0xc04b574
    SET_GPR_U32(ctx, 31, 0x12e6e8);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    HandleAsegaEvent__FP5ASEGAP2EAPi(rdram, ctx, runtime); return;
}


// Function: entry_12e6e8
// Address: 0x12e6e8 - 0x12e710

void entry_12e6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e6e8) {
        switch (ctx->pc) {
            case 0x12e6f4: ctx->pc = 0; goto label_12e6f4;
            case 0x12e6f8: ctx->pc = 0; goto label_12e6f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e6e8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12e6ec: 0x5040ffc6
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 32)));
        ctx->pc = 0x12E608; return;
    }
label_12e6f4:
    // 0x12e6f4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_12e6f8:
    // 0x12e6f8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12e6fc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12e700: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12e704: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x12e708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveAsega__FP5ASEGA
// Address: 0x12e710 - 0x12e738

void entry_12e738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e738: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x12e73c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12e740: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x12e748);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7000));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_12e748
// Address: 0x12e748 - 0x12e760

void entry_12e748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e748: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12e74c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12e750: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12e754: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12e75c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12e760; return;
}


// Function: RetractAsega__FP5ASEGA
// Address: 0x12e760 - 0x12e7c0

void entry_12e7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e7c0) {
        switch (ctx->pc) {
            case 0x12e7d4: ctx->pc = 0; goto label_12e7d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e7c0: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x12e7c4: 0x8e420064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 100)));
    // 0x12e7c8: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12e7cc: 0x5440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 104)));
        ctx->pc = 0x12E7A8; return;
    }
label_12e7d4:
    // 0x12e7d4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12e7d8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12e7dc: 0xc04bdd8
    SET_GPR_U32(ctx, 31, 0x12e7e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SendAsegaMessage__FP5ASEGA5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_12e7e4
// Address: 0x12e7e4 - 0x12e7f0

void entry_12e7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e7e4: 0x8e2500e4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 228)));
    // 0x12e7e8: 0xc076f06
    SET_GPR_U32(ctx, 31, 0x12e7f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FreeSwMqList__FP2SWP2MQ(rdram, ctx, runtime); return;
}


// Function: entry_12e7f0
// Address: 0x12e7f0 - 0x12e800

void entry_12e7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e7f0: 0xae2000e4
    WRITE32(ADD32(GPR_U32(ctx, 17), 228), GPR_U32(ctx, 0));
    // 0x12e7f4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12e7f8: 0xc057e68
    SET_GPR_U32(ctx, 31, 0x12e800);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 84));
    RemoveSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime); return;
}


// Function: entry_12e800
// Address: 0x12e800 - 0x12e80c

void entry_12e800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e800: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12e804: 0xc04b512
    SET_GPR_U32(ctx, 31, 0x12e80c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetAsegaHandsOff__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_12e80c
// Address: 0x12e80c - 0x12e828

void entry_12e80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e80c: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12e810: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12e814: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12e818: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x12e81c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12e820: 0xc076f50
    SET_GPR_U32(ctx, 31, 0x12e828);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime); return;
}


// Function: entry_12e828
// Address: 0x12e828 - 0x12e834

void entry_12e828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e828: 0x2644006c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 108));
    // 0x12e82c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x12e834);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12e834
// Address: 0x12e834 - 0x12e848

void entry_12e834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e834: 0x8e420050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x12e838: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 7024));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E850; return;
    }
    // 0x12e840: 0xc054980
    SET_GPR_U32(ctx, 31, 0x12e848);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12e848
// Address: 0x12e848 - 0x12e85c

void entry_12e848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e848) {
        switch (ctx->pc) {
            case 0x12e850: ctx->pc = 0; goto label_12e850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e848: 0x10000005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 7036));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E860; return;
    }
label_12e850:
    // 0x12e850: 0x26641b64
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 7012));
    // 0x12e854: 0xc054980
    SET_GPR_U32(ctx, 31, 0x12e85c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12e85c
// Address: 0x12e85c - 0x12e868

void entry_12e85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e85c) {
        switch (ctx->pc) {
            case 0x12e860: ctx->pc = 0; goto label_12e860;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e85c: 0x26641b7c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 7036));
label_12e860:
    // 0x12e860: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x12e868);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_12e868
// Address: 0x12e868 - 0x12e8b0

void entry_12e868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e868) {
        switch (ctx->pc) {
            case 0x12e8a0: ctx->pc = 0; goto label_12e8a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e868: 0x2630000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 12));
    // 0x12e86c: 0x26220044
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 68));
    // 0x12e870: 0x8e84b314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 4294947604)));
    // 0x12e874: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x12e878: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x12e87c: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12e880: 0xafa4000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 4));
    // 0x12e884: 0xae9db314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 29));
    // 0x12e888: 0x8e220044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 68)));
    // 0x12e88c: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x12e890: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12e894: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12e898: 0x1080000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E8CC; return;
    }
label_12e8a0:
    // 0x12e8a0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12e8a4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12e8a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12e8b0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12e8b0
// Address: 0x12e8b0 - 0x12e8e0

void entry_12e8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e8b0) {
        switch (ctx->pc) {
            case 0x12e8cc: ctx->pc = 0; goto label_12e8cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e8b0: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x12e8b4: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x12e8b8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12e8bc: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12e8c0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x12e8c4: 0x1480fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12E8A0; return;
    }
label_12e8cc:
    // 0x12e8cc: 0x8e220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x12e8d0: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 16));
        ctx->pc = 0x12E8E4; return;
    }
    // 0x12e8d8: 0xc06fdc6
    SET_GPR_U32(ctx, 31, 0x12e8e0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 80));
    DropPamb__FPP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_12e8e0
// Address: 0x12e8e0 - 0x12e8f8

void entry_12e8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12e8e0) {
        switch (ctx->pc) {
            case 0x12e8e4: ctx->pc = 0; goto label_12e8e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12e8e0: 0xafb00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 16));
label_12e8e4:
    // 0x12e8e4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12e8e8: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x12e8ec: 0x2405000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    // 0x12e8f0: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x12e8f8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_12e8f8
// Address: 0x12e8f8 - 0x12e928

void entry_12e8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e8f8: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x12e8fc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12e900: 0xae82b314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    // 0x12e904: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12e908: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x12e90c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12e910: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12e914: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12e918: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12e91c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12e924: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12e928; return;
}


// Function: FUN_0012e928
// Address: 0x12e928 - 0x12e93c

void FUN_0012e928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e928: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x12e92c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x12e930: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x12e934: 0xc04b55c
    SET_GPR_U32(ctx, 31, 0x12e93c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime); return;
}


// Function: entry_12e93c
// Address: 0x12e93c - 0x12e954

void entry_12e93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e93c: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12e954(rdram, ctx, runtime); return;
    }
    // 0x12e944: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12e948: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12e94c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12e954);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12e954
// Address: 0x12e954 - 0x12e968

void entry_12e954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12e954: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12e958: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12e95c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12e964: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12e968; return;
}


// Function: UFromEaErrorFunc__FP2EAf
// Address: 0x12e968 - 0x12e9e0

void entry_12ea7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ea7c) {
        switch (ctx->pc) {
            case 0x12ea84: ctx->pc = 0; goto label_12ea84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ea7c: 0x1000004c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBB0; return;
    }
label_12ea84:
    // 0x12ea84: 0x460d6d00
    ctx->f[20] = FPU_ADD_S(ctx->f[13], ctx->f[13]);
    // 0x12ea88: 0x460ca036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12ea8c: 0x0
    // NOP
    // 0x12ea90: 0x4500000c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12EAC4; return;
    }
    // 0x12ea98: 0xc081628
    SET_GPR_U32(ctx, 31, 0x12eaa0);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    fmodf(rdram, ctx, runtime); return;
}


// Function: entry_12eaa0
// Address: 0x12eaa0 - 0x12eb44

void entry_12eaa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12eaa0) {
        switch (ctx->pc) {
            case 0x12eab8: ctx->pc = 0; goto label_12eab8;
            case 0x12eac4: ctx->pc = 0; goto label_12eac4;
            case 0x12eae8: ctx->pc = 0; goto label_12eae8;
            case 0x12eb24: ctx->pc = 0; goto label_12eb24;
            case 0x12eb34: ctx->pc = 0; goto label_12eb34;
            case 0x12eb3c: ctx->pc = 0; goto label_12eb3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12eaa0: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x12eaa4: 0xc6410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[1] = *(float*)&val; }
    // 0x12eaa8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12eaac: 0x0
    // NOP
    // 0x12eab0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_12eab8;
    }
label_12eab8:
    // 0x12eab8: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12eabc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x12eac0: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_12eac4:
    // 0x12eac4: 0x1260003b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBB4; return;
    }
    // 0x12eacc: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12ead0: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x12ead4: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x12ead8: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x12eadc: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x12eae0: 0x10000034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBB4; return;
    }
label_12eae8:
    // 0x12eae8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12eaec: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12eaf0: 0x0
    // NOP
    // 0x12eaf4: 0x45000030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12EBB8; return;
    }
    // 0x12eafc: 0x8e430044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 68)));
    // 0x12eb00: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12eb04: 0x1062000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_12eb3c;
    }
    // 0x12eb0c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_12eb24;
    }
    // 0x12eb14: 0x10600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_12eb34;
    }
    // 0x12eb1c: 0x10000027
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBBC; return;
    }
label_12eb24:
    // 0x12eb24: 0x10620009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12EB4C; return;
    }
    // 0x12eb2c: 0x10000022
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBB8; return;
    }
label_12eb34:
    // 0x12eb34: 0x1000001d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBAC; return;
    }
label_12eb3c:
    // 0x12eb3c: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x12eb44);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_12eb44
// Address: 0x12eb44 - 0x12eb80

void entry_12eb44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12eb44) {
        switch (ctx->pc) {
            case 0x12eb4c: ctx->pc = 0; goto label_12eb4c;
            case 0x12eb68: ctx->pc = 0; goto label_12eb68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12eb44: 0x1000001a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBB0; return;
    }
label_12eb4c:
    // 0x12eb4c: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    // 0x12eb50: 0x460d6036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12eb54: 0x0
    // NOP
    // 0x12eb58: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
        goto label_12eb68;
    }
    // 0x12eb60: 0x10000010
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EBA4; return;
    }
label_12eb68:
    // 0x12eb68: 0x460d6d00
    ctx->f[20] = FPU_ADD_S(ctx->f[13], ctx->f[13]);
    // 0x12eb6c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x12eb70: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x12eb74: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x12eb78: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x12eb80);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_12eb80
// Address: 0x12eb80 - 0x12ebd8

void entry_12eb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12eb80) {
        switch (ctx->pc) {
            case 0x12eba4: ctx->pc = 0; goto label_12eba4;
            case 0x12ebac: ctx->pc = 0; goto label_12ebac;
            case 0x12ebb0: ctx->pc = 0; goto label_12ebb0;
            case 0x12ebb4: ctx->pc = 0; goto label_12ebb4;
            case 0x12ebb8: ctx->pc = 0; goto label_12ebb8;
            case 0x12ebbc: ctx->pc = 0; goto label_12ebbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12eb80: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x12eb84: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x12eb88: 0xc6400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[0] = *(float*)&val; }
    // 0x12eb8c: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12eb90: 0x0
    // NOP
    // 0x12eb94: 0x45000007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12ebb4;
    }
    // 0x12eb9c: 0x4601a041
    ctx->f[1] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x12eba0: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_12eba4:
    // 0x12eba4: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x12eba8: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
label_12ebac:
    // 0x12ebac: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_12ebb0:
    // 0x12ebb0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_12ebb4:
    // 0x12ebb4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_12ebb8:
    // 0x12ebb8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_12ebbc:
    // 0x12ebbc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12ebc0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ebc4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12ebc8: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x12ebcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12ebd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12ebd8; return;
}


// Function: UpdateAsega__FP5ASEGAf
// Address: 0x12ebd8 - 0x12ecbc

void entry_12ecbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ecbc) {
        switch (ctx->pc) {
            case 0x12ece0: ctx->pc = 0; goto label_12ece0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ecbc: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12ecc0: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x12ecc4: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ecc8: 0xd8610100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 256)));
    // 0x12eccc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12ecd0: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12ecd4: 0x82020010
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x12ecd8: 0x50440001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
        goto label_12ece0;
    }
label_12ece0:
    // 0x12ece0: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12ece4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12ece8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12ecec: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12ecf0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12ecf4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12ecf8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12ecfc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x12ed00: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x12ed04: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12ed08: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x12ed0c: 0xc04ba5a
    SET_GPR_U32(ctx, 31, 0x12ed14);
    UFromEaErrorFunc__FP2EAf(rdram, ctx, runtime); return;
}


// Function: entry_12ed14
// Address: 0x12ed14 - 0x12ed50

void entry_12ed14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ed14) {
        switch (ctx->pc) {
            case 0x12ed24: ctx->pc = 0; goto label_12ed24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ed14: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12ed18: 0x0
    // NOP
    // 0x12ed1c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_MOV_S(ctx->f[0]);
        goto label_12ed24;
    }
label_12ed24:
    // 0x12ed24: 0x8e530030
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 48)));
    // 0x12ed28: 0x1260001a
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12ED94; return;
    }
    // 0x12ed30: 0x8e500028
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 40)));
    // 0x12ed34: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x12ed38: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12ed3c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12ed40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12ed44: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x12ed48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12ed50);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12ed50
// Address: 0x12ed50 - 0x12ed68

void entry_12ed50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ed50: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12ed54: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12ed58: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x12ed5c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12ed60: 0xc062454
    SET_GPR_U32(ctx, 31, 0x12ed68);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 208));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_12ed68
// Address: 0x12ed68 - 0x12ed70

void entry_12ed68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ed68: 0xc062338
    SET_GPR_U32(ctx, 31, 0x12ed70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CosRotateMatrixMagnitude__FP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_12ed70
// Address: 0x12ed70 - 0x12ed78

void entry_12ed70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ed70: 0xc08155e
    SET_GPR_U32(ctx, 31, 0x12ed78);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    acosf(rdram, ctx, runtime); return;
}


// Function: entry_12ed78
// Address: 0x12ed78 - 0x12ed84

void entry_12ed78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ed78: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x12ed7c: 0xc04ba5a
    SET_GPR_U32(ctx, 31, 0x12ed84);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    UFromEaErrorFunc__FP2EAf(rdram, ctx, runtime); return;
}


// Function: entry_12ed84
// Address: 0x12ed84 - 0x12ee54

void entry_12ed84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ed84) {
        switch (ctx->pc) {
            case 0x12ed94: ctx->pc = 0; goto label_12ed94;
            case 0x12edb4: ctx->pc = 0; goto label_12edb4;
            case 0x12edc4: ctx->pc = 0; goto label_12edc4;
            case 0x12ede4: ctx->pc = 0; goto label_12ede4;
            case 0x12ee18: ctx->pc = 0; goto label_12ee18;
            case 0x12ee1c: ctx->pc = 0; goto label_12ee1c;
            case 0x12ee20: ctx->pc = 0; goto label_12ee20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ed84: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12ed88: 0x0
    // NOP
    // 0x12ed8c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_MOV_S(ctx->f[0]);
        goto label_12ed94;
    }
label_12ed94:
    // 0x12ed94: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12ed98: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12ed9c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12eda0: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12eda4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12edb4;
    }
    // 0x12edac: 0x10000005
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12edc4;
    }
label_12edb4:
    // 0x12edb4: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12edb8: 0x0
    // NOP
    // 0x12edbc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_MOV_S(ctx->f[1]);
        goto label_12edc4;
    }
label_12edc4:
    // 0x12edc4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x12edc8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x12edcc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x12edd0: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12edd4: 0x0
    // NOP
    // 0x12edd8: 0x450100a2
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12F064; return;
    }
    // 0x12ede0: 0xc6400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[0] = *(float*)&val; }
label_12ede4:
    // 0x12ede4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x12ede8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12edec: 0x0
    // NOP
    // 0x12edf0: 0x4502000b
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[0] = *(float*)&val; }
        goto label_12ee20;
    }
    // 0x12edf8: 0x46150001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x12edfc: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12ee00: 0x0
    // NOP
    // 0x12ee04: 0x45000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12ee18;
    }
    // 0x12ee0c: 0x46000547
    ctx->f[21] = FPU_NEG_S(ctx->f[0]);
    // 0x12ee10: 0x10000002
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12ee1c;
    }
label_12ee18:
    // 0x12ee18: 0x46000d46
    ctx->f[21] = FPU_MOV_S(ctx->f[1]);
label_12ee1c:
    // 0x12ee1c: 0xc6400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[0] = *(float*)&val; }
label_12ee20:
    // 0x12ee20: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x12ee24: 0xc6410014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[1] = *(float*)&val; }
    // 0x12ee28: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x12ee2c: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x12ee30: 0xafa00090
    WRITE32(ADD32(GPR_U32(ctx, 29), 144), GPR_U32(ctx, 0));
    // 0x12ee34: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12ee38: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x12ee3c: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12ee40: 0xf02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12ee44: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x12ee48: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x12ee4c: 0xc04b974
    SET_GPR_U32(ctx, 31, 0x12ee54);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 20), *(uint32_t*)&val); }
    HandleAsegaEvents__FP5ASEGAP4ASEGPi(rdram, ctx, runtime); return;
}


// Function: entry_12ee54
// Address: 0x12ee54 - 0x12ee70

void entry_12ee54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ee54: 0x8fa20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12ee58: 0x14400082
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F064; return;
    }
    // 0x12ee60: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12ee64: 0x26450014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 20));
    // 0x12ee68: 0xc04ba78
    SET_GPR_U32(ctx, 31, 0x12ee70);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 24));
    FWrapAsegaTime__FP5ASEGAPfT1(rdram, ctx, runtime); return;
}


// Function: entry_12ee70
// Address: 0x12ee70 - 0x12eea4

void entry_12ee70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ee70) {
        switch (ctx->pc) {
            case 0x12ee94: ctx->pc = 0; goto label_12ee94;
            case 0x12ee9c: ctx->pc = 0; goto label_12ee9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ee70: 0x50400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x12EED4; return;
    }
    // 0x12ee78: 0x8ec30044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 68)));
    // 0x12ee7c: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_12ee94;
    }
    // 0x12ee84: 0x10620009
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12EEAC; return;
    }
    // 0x12ee8c: 0x10000012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EED8; return;
    }
label_12ee94:
    // 0x12ee94: 0x1000000e
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12EED0; return;
    }
label_12ee9c:
    // 0x12ee9c: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x12eea4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_12eea4
// Address: 0x12eea4 - 0x12eee0

void entry_12eea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12eea4) {
        switch (ctx->pc) {
            case 0x12eeac: ctx->pc = 0; goto label_12eeac;
            case 0x12eecc: ctx->pc = 0; goto label_12eecc;
            case 0x12eed0: ctx->pc = 0; goto label_12eed0;
            case 0x12eed4: ctx->pc = 0; goto label_12eed4;
            case 0x12eed8: ctx->pc = 0; goto label_12eed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12eea4: 0x1000006f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F064; return;
    }
label_12eeac:
    // 0x12eeac: 0xc6410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[1] = *(float*)&val; }
    // 0x12eeb0: 0x24170001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12eeb4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12eeb8: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12eebc: 0x0
    // NOP
    // 0x12eec0: 0x45000002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12eecc;
    }
    // 0x12eec8: 0x8ec2005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 92)));
label_12eecc:
    // 0x12eecc: 0xae420020
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 2));
label_12eed0:
    // 0x12eed0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_12eed4:
    // 0x12eed4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_12eed8:
    // 0x12eed8: 0xc04b974
    SET_GPR_U32(ctx, 31, 0x12eee0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    HandleAsegaEvents__FP5ASEGAP4ASEGPi(rdram, ctx, runtime); return;
}


// Function: entry_12eee0
// Address: 0x12eee0 - 0x12ef14

void entry_12eee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12eee0) {
        switch (ctx->pc) {
            case 0x12ef00: ctx->pc = 0; goto label_12ef00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12eee0: 0x8fa20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12eee4: 0x1440005f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F064; return;
    }
    // 0x12eeec: 0x8e42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x12eef0: 0x1840000c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x12EF24; return;
    }
    // 0x12eef8: 0x8e430060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 96)));
    // 0x12eefc: 0x0
    // NOP
label_12ef00:
    // 0x12ef00: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x12ef04: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x12ef08: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x12ef0c: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x12ef14);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_12ef14
// Address: 0x12ef14 - 0x12ef9c

void entry_12ef14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ef14) {
        switch (ctx->pc) {
            case 0x12ef24: ctx->pc = 0; goto label_12ef24;
            case 0x12ef48: ctx->pc = 0; goto label_12ef48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ef14: 0x8e42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x12ef18: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x12ef1c: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 96)));
        ctx->pc = 0x12EF00; return;
    }
label_12ef24:
    // 0x12ef24: 0x12e00045
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F03C; return;
    }
    // 0x12ef2c: 0x8e500044
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 68)));
    // 0x12ef30: 0x12000042
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F03C; return;
    }
    // 0x12ef38: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x12ef3c: 0x27b50020
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 32));
    // 0x12ef40: 0x27b40040
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 64));
    // 0x12ef44: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
label_12ef48:
    // 0x12ef48: 0x2404001c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 28));
    // 0x12ef4c: 0x8ec3003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 60)));
    // 0x12ef50: 0x441018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x12ef54: 0x629821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x12ef58: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x12ef5c: 0x5040001a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
        ctx->pc = 0x12EFC8; return;
    }
    // 0x12ef64: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12ef68: 0x54400017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
        ctx->pc = 0x12EFC8; return;
    }
    // 0x12ef70: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12ef74: 0x8c4301ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 492)));
    // 0x12ef78: 0x56030013
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
        ctx->pc = 0x12EFC8; return;
    }
    // 0x12ef80: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12ef84: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12ef88: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x12ef8c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12ef90: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x12ef94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12ef9c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12ef9c
// Address: 0x12ef9c - 0x12efb0

void entry_12ef9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ef9c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12efa0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12efa4: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x12efa8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12efb0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12efb0
// Address: 0x12efb0 - 0x12efc4

void entry_12efb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12efb0: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12efb4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12efb8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x12efbc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12efc4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12efc4
// Address: 0x12efc4 - 0x12f008

void entry_12efc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12efc4) {
        switch (ctx->pc) {
            case 0x12efc8: ctx->pc = 0; goto label_12efc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12efc4: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
label_12efc8:
    // 0x12efc8: 0x5060001a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
        ctx->pc = 0x12F034; return;
    }
    // 0x12efd0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x12efd4: 0x54400017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
        ctx->pc = 0x12F034; return;
    }
    // 0x12efdc: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12efe0: 0x8c4301f0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 496)));
    // 0x12efe4: 0x56030013
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
        ctx->pc = 0x12F034; return;
    }
    // 0x12efec: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12eff0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12eff4: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x12eff8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12effc: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x12f000: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12f008);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12f008
// Address: 0x12f008 - 0x12f01c

void entry_12f008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f008: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12f00c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12f010: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x12f014: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12f01c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12f01c
// Address: 0x12f01c - 0x12f030

void entry_12f01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f01c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12f020: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12f024: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x12f028: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12f030);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12f030
// Address: 0x12f030 - 0x12f060

void entry_12f030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f030) {
        switch (ctx->pc) {
            case 0x12f034: ctx->pc = 0; goto label_12f034;
            case 0x12f03c: ctx->pc = 0; goto label_12f03c;
            case 0x12f04c: ctx->pc = 0; goto label_12f04c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f030: 0x8e100020
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
label_12f034:
    // 0x12f034: 0x5600ffc4
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
        ctx->pc = 0x12EF48; return;
    }
label_12f03c:
    // 0x12f03c: 0x17c00003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_12f04c;
    }
    // 0x12f044: 0x12e00007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F064; return;
    }
label_12f04c:
    // 0x12f04c: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x12f050: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x12f054: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x12f058: 0xc04bdd8
    SET_GPR_U32(ctx, 31, 0x12f060);
    if (GPR_U32(ctx, 30) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    SendAsegaMessage__FP5ASEGA5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_12f060
// Address: 0x12f060 - 0x12f0a0

void entry_12f060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f060) {
        switch (ctx->pc) {
            case 0x12f064: ctx->pc = 0; goto label_12f064;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f060: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
label_12f064:
    // 0x12f064: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x12f068: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x12f06c: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x12f070: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x12f074: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x12f078: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x12f07c: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x12f080: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x12f084: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12f088: 0xc7b60150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[22] = *(float*)&val; }
    // 0x12f08c: 0xc7b50148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[21] = *(float*)&val; }
    // 0x12f090: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x12f094: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12f09c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12f0a0; return;
}


// Function: SeekAsega__FP5ASEGA4SEEKff
// Address: 0x12f0a0 - 0x12f110

void entry_12f110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f110: 0xc6000014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[0] = *(float*)&val; }
    // 0x12f114: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f118: 0x0
    // NOP
    // 0x12f11c: 0x45010017
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12F17C; return;
    }
    // 0x12f124: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x12f128: 0x16220007
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x12F148; return;
    }
    // 0x12f130: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12f134: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12f138: 0xc04b938
    SET_GPR_U32(ctx, 31, 0x12f140);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    HandleAsegaEventsFF__FP5ASEGAP4ASEGPi(rdram, ctx, runtime); return;
}


// Function: entry_12f140
// Address: 0x12f140 - 0x12f150

void entry_12f140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f140) {
        switch (ctx->pc) {
            case 0x12f148: ctx->pc = 0; goto label_12f148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f140: 0x10000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F154; return;
    }
label_12f148:
    // 0x12f148: 0xc04b52a
    SET_GPR_U32(ctx, 31, 0x12f150);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12f150
// Address: 0x12f150 - 0x12f15c

void entry_12f150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f150) {
        switch (ctx->pc) {
            case 0x12f154: ctx->pc = 0; goto label_12f154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f150: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_12f154:
    // 0x12f154: 0xc04bc64
    SET_GPR_U32(ctx, 31, 0x12f15c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SnapAsega__FP5ASEGAi(rdram, ctx, runtime); return;
}


// Function: entry_12f15c
// Address: 0x12f15c - 0x12f164

void entry_12f15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f15c: 0xc04bc76
    SET_GPR_U32(ctx, 31, 0x12f164);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AdaptAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12f164
// Address: 0x12f164 - 0x12f178

void entry_12f164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f164: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f168: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F17C; return;
    }
    // 0x12f170: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x12f178);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_12f178
// Address: 0x12f178 - 0x12f190

void entry_12f178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f178) {
        switch (ctx->pc) {
            case 0x12f17c: ctx->pc = 0; goto label_12f17c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f178: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_12f17c:
    // 0x12f17c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12f180: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f184: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x12f188: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SnapAsega__FP5ASEGAi
// Address: 0x12f190 - 0x12f1b8

void entry_12f1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f1b8) {
        switch (ctx->pc) {
            case 0x12f1c4: ctx->pc = 0; goto label_12f1c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f1b8: 0x8e100020
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x12f1bc: 0x1600fffc
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F1B0; return;
    }
label_12f1c4:
    // 0x12f1c4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12f1c8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12f1cc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f1d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdaptAsega__FP5ASEGA
// Address: 0x12f1d8 - 0x12f1f8

void entry_12f1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f1f8) {
        switch (ctx->pc) {
            case 0x12f204: ctx->pc = 0; goto label_12f204;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f1f8: 0x8e100020
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x12f1fc: 0x1600fffc
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F1F0; return;
    }
label_12f204:
    // 0x12f204: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FindChnClosestPointLocal__FP3CHNP3ALOP6VECTORfffPfT2T2
// Address: 0x12f210 - 0x12f2ac

void entry_12f2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f2ac) {
        switch (ctx->pc) {
            case 0x12f2ec: ctx->pc = 0; goto label_12f2ec;
            case 0x12f35c: ctx->pc = 0; goto label_12f35c;
            case 0x12f37c: ctx->pc = 0; goto label_12f37c;
            case 0x12f3a8: ctx->pc = 0; goto label_12f3a8;
            case 0x12f3c0: ctx->pc = 0; goto label_12f3c0;
            case 0x12f3e8: ctx->pc = 0; goto label_12f3e8;
            case 0x12f3f8: ctx->pc = 0; goto label_12f3f8;
            case 0x12f410: ctx->pc = 0; goto label_12f410;
            case 0x12f424: ctx->pc = 0; goto label_12f424;
            case 0x12f428: ctx->pc = 0; goto label_12f428;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f2ac: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12f2b0: 0x4614a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x12f2b4: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f2b8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12f2bc: 0x4be4086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f2c0: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f2c4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12f2c8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x12f2cc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12f2d0: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12f2d4: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x12f2d8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x12f2dc: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f2e0: 0x0
    // NOP
    // 0x12f2e4: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_12f2ec;
    }
label_12f2ec:
    // 0x12f2ec: 0x144000d3
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F63C; return;
    }
    // 0x12f2f4: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f2f8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12f2fc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f300: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12f304: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x12f308: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x12f30c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12f310: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12f314: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x12f318: 0x46001005
    ctx->f[0] = FPU_ABS_S(ctx->f[2]);
    // 0x12f31c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f320: 0x450100c6
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12F63C; return;
    }
    // 0x12f328: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12f32c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f330: 0x0
    // NOP
    // 0x12f334: 0x45000009
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12f35c;
    }
    // 0x12f33c: 0x460016c6
    ctx->f[27] = FPU_MOV_S(ctx->f[2]);
    // 0x12f340: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12f344: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12f348: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x12f34c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x12f350: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x12f354: 0x10000009
    ctx->f[23] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12f37c;
    }
label_12f35c:
    // 0x12f35c: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12f360: 0x46001646
    ctx->f[25] = FPU_MOV_S(ctx->f[2]);
    // 0x12f364: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12f368: 0x4600ae06
    ctx->f[24] = FPU_MOV_S(ctx->f[21]);
    // 0x12f36c: 0x3c01be4c
    SET_GPR_U32(ctx, 1, ((uint32_t)48716 << 16));
    // 0x12f370: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x12f374: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x12f378: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
label_12f37c:
    // 0x12f37c: 0x461aa800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[26]);
    // 0x12f380: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x12f384: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f388: 0x0
    // NOP
    // 0x12f38c: 0x45010006
    ctx->f[12] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_12f3a8;
    }
    // 0x12f394: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f398: 0x0
    // NOP
    // 0x12f39c: 0x45000002
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12f3a8;
    }
    // 0x12f3a4: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
label_12f3a8:
    // 0x12f3a8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x12f3ac: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x12f3b0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x12f3b4: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x12f3b8: 0x1000001b
    ctx->f[21] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12f428;
    }
label_12f3c0:
    // 0x12f3c0: 0x46141034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f3c4: 0x0
    // NOP
    // 0x12f3c8: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[24] = FPU_MOV_S(ctx->f[21]);
        goto label_12f3e8;
    }
    // 0x12f3d0: 0x461cb001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[28]);
    // 0x12f3d4: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f3d8: 0x0
    // NOP
    // 0x12f3dc: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[26]);
        goto label_12f3f8;
    }
    // 0x12f3e4: 0x4600ae06
    ctx->f[24] = FPU_MOV_S(ctx->f[21]);
label_12f3e8:
    // 0x12f3e8: 0x46001646
    ctx->f[25] = FPU_MOV_S(ctx->f[2]);
    // 0x12f3ec: 0xfba50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x12f3f0: 0x10000032
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F4BC; return;
    }
label_12f3f8:
    // 0x12f3f8: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f3fc: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12f410;
    }
    // 0x12f404: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x12f408: 0x10000007
    ctx->f[21] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12f428;
    }
label_12f410:
    // 0x12f410: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f414: 0x0
    // NOP
    // 0x12f418: 0x45000002
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12f424;
    }
    // 0x12f420: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
label_12f424:
    // 0x12f424: 0x46006546
    ctx->f[21] = FPU_MOV_S(ctx->f[12]);
label_12f428:
    // 0x12f428: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12f42c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12f430: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12f434: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12f438: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x12f43c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12f440: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12f444: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12f448: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12f44c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12f454);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12f454
// Address: 0x12f454 - 0x12f520

void entry_12f454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f454) {
        switch (ctx->pc) {
            case 0x12f4b0: ctx->pc = 0; goto label_12f4b0;
            case 0x12f4bc: ctx->pc = 0; goto label_12f4bc;
            case 0x12f4f0: ctx->pc = 0; goto label_12f4f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f454: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12f458: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f45c: 0x4be5086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f460: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f464: 0x4bc408ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f468: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12f46c: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x12f470: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12f474: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12f478: 0x48231800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12f47c: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x12f480: 0x1260ffcf
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F3C0; return;
    }
    // 0x12f488: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x12f48c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f490: 0x0
    // NOP
    // 0x12f494: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
        goto label_12f4b0;
    }
    // 0x12f49c: 0x4600a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f4a0: 0x0
    // NOP
    // 0x12f4a4: 0x4502ffd4
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[26]);
        ctx->pc = 0x12F3F8; return;
    }
    // 0x12f4ac: 0xfba50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
label_12f4b0:
    // 0x12f4b0: 0x4600adc6
    ctx->f[23] = FPU_MOV_S(ctx->f[21]);
    // 0x12f4b4: 0xfba40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12f4b8: 0x460016c6
    ctx->f[27] = FPU_MOV_S(ctx->f[2]);
label_12f4bc:
    // 0x12f4bc: 0x4617c001
    ctx->f[0] = FPU_SUB_S(ctx->f[24], ctx->f[23]);
    // 0x12f4c0: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x12f4c4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x12f4c8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12f4cc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f4d0: 0x0
    // NOP
    // 0x12f4d4: 0x4502002f
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_SUB_S(ctx->f[25], ctx->f[27]);
        ctx->pc = 0x12F594; return;
    }
    // 0x12f4dc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x12f4e0: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x12f4e4: 0x46000d86
    ctx->f[22] = FPU_MOV_S(ctx->f[1]);
    // 0x12f4e8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x12f4ec: 0x4617c000
    ctx->f[0] = FPU_ADD_S(ctx->f[24], ctx->f[23]);
label_12f4f0:
    // 0x12f4f0: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12f4f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12f4f8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12f4fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12f500: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12f504: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12f508: 0x461a0542
    ctx->f[21] = FPU_MUL_S(ctx->f[0], ctx->f[26]);
    // 0x12f50c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12f510: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12f514: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x12f518: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12f520);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12f520
// Address: 0x12f520 - 0x12f624

void entry_12f520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f520) {
        switch (ctx->pc) {
            case 0x12f570: ctx->pc = 0; goto label_12f570;
            case 0x12f57c: ctx->pc = 0; goto label_12f57c;
            case 0x12f594: ctx->pc = 0; goto label_12f594;
            case 0x12f5d8: ctx->pc = 0; goto label_12f5d8;
            case 0x12f5e8: ctx->pc = 0; goto label_12f5e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f520: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x12f524: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f528: 0x4be5086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f52c: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f530: 0x4bc408ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12f534: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12f538: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x12f53c: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12f540: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12f544: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x12f548: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x12f54c: 0x4602a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f550: 0x0
    // NOP
    // 0x12f554: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
        goto label_12f570;
    }
    // 0x12f55c: 0x4600adc6
    ctx->f[23] = FPU_MOV_S(ctx->f[21]);
    // 0x12f560: 0x460016c6
    ctx->f[27] = FPU_MOV_S(ctx->f[2]);
    // 0x12f564: 0xfba50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x12f568: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12f57c;
    }
label_12f570:
    // 0x12f570: 0x4600ae06
    ctx->f[24] = FPU_MOV_S(ctx->f[21]);
    // 0x12f574: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x12f578: 0x46001646
    ctx->f[25] = FPU_MOV_S(ctx->f[2]);
label_12f57c:
    // 0x12f57c: 0x4617c001
    ctx->f[0] = FPU_SUB_S(ctx->f[24], ctx->f[23]);
    // 0x12f580: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f584: 0x0
    // NOP
    // 0x12f588: 0x4503ffd9
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[24], ctx->f[23]);
        ctx->pc = 0x12F4F0; return;
    }
    // 0x12f590: 0x461bc881
    ctx->f[2] = FPU_SUB_S(ctx->f[25], ctx->f[27]);
label_12f594:
    // 0x12f594: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x12f598: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x12f59c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x12f5a0: 0x46001005
    ctx->f[0] = FPU_ABS_S(ctx->f[2]);
    // 0x12f5a4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f5a8: 0x0
    // NOP
    // 0x12f5ac: 0x4500001f
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x12F62C; return;
    }
    // 0x12f5b4: 0x4602c803
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[25] * 0.0f); } else ctx->f[0] = ctx->f[25] / ctx->f[2];
    // 0x12f5b8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x12f5bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12f5c0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x12f5c4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f5c8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_12f5d8;
    }
    // 0x12f5d0: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12f5e8;
    }
label_12f5d8:
    // 0x12f5d8: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12f5dc: 0x0
    // NOP
    // 0x12f5e0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[2]);
        goto label_12f5e8;
    }
label_12f5e8:
    // 0x12f5e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x12f5ec: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x12f5f0: 0x4600b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x12f5f4: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x12f5f8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12f5fc: 0x46006801
    ctx->f[0] = FPU_SUB_S(ctx->f[13], ctx->f[0]);
    // 0x12f600: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x12f604: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12f608: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12f60c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12f610: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x12f614: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x12f618: 0x46000d40
    ctx->f[21] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x12f61c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12f624);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12f624
// Address: 0x12f624 - 0x12f6b0

void entry_12f624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f624) {
        switch (ctx->pc) {
            case 0x12f62c: ctx->pc = 0; goto label_12f62c;
            case 0x12f63c: ctx->pc = 0; goto label_12f63c;
            case 0x12f644: ctx->pc = 0; goto label_12f644;
            case 0x12f650: ctx->pc = 0; goto label_12f650;
            case 0x12f65c: ctx->pc = 0; goto label_12f65c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f624: 0x10000005
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12f63c;
    }
label_12f62c:
    // 0x12f62c: 0x4600bd46
    ctx->f[21] = FPU_MOV_S(ctx->f[23]);
    // 0x12f630: 0x7ba20050
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x12f634: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x12f638: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
label_12f63c:
    // 0x12f63c: 0x56a00001
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 21), 0), *(uint32_t*)&val); }
        goto label_12f644;
    }
label_12f644:
    // 0x12f644: 0x12e00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_12f650;
    }
    // 0x12f64c: 0x7ee20000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), GPR_VEC(ctx, 2));
label_12f650:
    // 0x12f650: 0x12c00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_12f65c;
    }
    // 0x12f658: 0x7ec20000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
label_12f65c:
    // 0x12f65c: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x12f660: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x12f664: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x12f668: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x12f66c: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x12f670: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x12f674: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x12f678: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x12f67c: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x12f680: 0xc7bc0140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[28] = *(float*)&val; }
    // 0x12f684: 0xc7bb0138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[27] = *(float*)&val; }
    // 0x12f688: 0xc7ba0130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[26] = *(float*)&val; }
    // 0x12f68c: 0xc7b90128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[25] = *(float*)&val; }
    // 0x12f690: 0xc7b80120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[24] = *(float*)&val; }
    // 0x12f694: 0xc7b70118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[23] = *(float*)&val; }
    // 0x12f698: 0xc7b60110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[22] = *(float*)&val; }
    // 0x12f69c: 0xc7b50108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[21] = *(float*)&val; }
    // 0x12f6a0: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x12f6a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12f6ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12f6b0; return;
}


// Function: SetAsegaSpeed__FP5ASEGAf
// Address: 0x12f6b0 - 0x12f6d0

void entry_12f70c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f70c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f710: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetAsegaPriority__FP5ASEGAi
// Address: 0x12f718 - 0x12f740

void entry_12f740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f740) {
        switch (ctx->pc) {
            case 0x12f74c: ctx->pc = 0; goto label_12f74c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f740: 0x8e100020
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x12f744: 0x5600fffc
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 17));
        ctx->pc = 0x12F738; return;
    }
label_12f74c:
    // 0x12f74c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12f750: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12f754: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f758: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SendAsegaMessage__FP5ASEGA5MSGIDPv
// Address: 0x12f760 - 0x12f798

void entry_12f798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f798) {
        switch (ctx->pc) {
            case 0x12f7a8: ctx->pc = 0; goto label_12f7a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f798: 0x8e1000e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 228)));
    // 0x12f79c: 0x1200000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F7C8; return;
    }
    // 0x12f7a4: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_12f7a8:
    // 0x12f7a8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x12f7ac: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12f7b0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12f7b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12f7bc);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12f7bc
// Address: 0x12f7bc - 0x12f7e0

void entry_12f7bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f7bc) {
        switch (ctx->pc) {
            case 0x12f7c8: ctx->pc = 0; goto label_12f7c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f7bc: 0x5600fffa
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x12F7A8; return;
    }
    // 0x12f7c4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_12f7c8:
    // 0x12f7c8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12f7cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f7d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f7d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12f7dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12f7e0; return;
}


// Function: SubscribeAsegaStruct__FP5ASEGAPFPv5MSGIDPv_vPv
// Address: 0x12f7e0 - 0x12f804

void entry_12f804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f804: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f808: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SubscribeAsegaObject__FP5ASEGAP2LO
// Address: 0x12f810 - 0x12f834

void entry_12f834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f834: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f838: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitBarrier__FP7BARRIER
// Address: 0x12f840 - 0x12f854

void entry_12f854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f854: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12f858: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x12f85c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12f860: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x12f864: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x12f86c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_12f86c
// Address: 0x12f86c - 0x12f888

void entry_12f86c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f86c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12f870: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f874: 0xae020590
    WRITE32(ADD32(GPR_U32(ctx, 16), 1424), GPR_U32(ctx, 2));
    // 0x12f878: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f87c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12f884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12f888; return;
}


// Function: CloneBarrier__FP7BARRIERT0
// Address: 0x12f888 - 0x12f89c

void entry_12f89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f89c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x12f8a0: 0x14400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F8B8; return;
    }
    // 0x12f8a8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x12f8ac: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x12f8b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_12f8b4
// Address: 0x12f8b4 - 0x12f8c8

void entry_12f8b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f8b4) {
        switch (ctx->pc) {
            case 0x12f8b8: ctx->pc = 0; goto label_12f8b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f8b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12f8b8:
    // 0x12f8b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12f8bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12f8c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12f8c8; return;
}


// Function: PostBarrierLoad__FP7BARRIER
// Address: 0x12f8c8 - 0x12f8e4

void entry_12f8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f8e4: 0x8e050590
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1424)));
    // 0x12f8e8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12f8ec: 0x10a20008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12F910; return;
    }
    // 0x12f8f4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x12f8f8: 0xc056912
    SET_GPR_U32(ctx, 31, 0x12f900);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_12f900
// Address: 0x12f900 - 0x12f94c

void entry_12f900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f900) {
        switch (ctx->pc) {
            case 0x12f910: ctx->pc = 0; goto label_12f910;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f900: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x12f904: 0xae020590
    WRITE32(ADD32(GPR_U32(ctx, 16), 1424), GPR_U32(ctx, 2));
    // 0x12f908: 0x10000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12F99C; return;
    }
label_12f910:
    // 0x12f910: 0x3c120028
    SET_GPR_U32(ctx, 18, ((uint32_t)40 << 16));
    // 0x12f914: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x12f918: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x12f91c: 0x8e44b314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4294947604)));
    // 0x12f920: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x12f924: 0xae5db314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 29));
    // 0x12f928: 0xafa4000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 4));
    // 0x12f92c: 0x8e110034
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x12f930: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x12f934: 0x2231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x12f938: 0x12200016
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_12f994(rdram, ctx, runtime); return;
    }
    // 0x12f940: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x12f944: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x12f94c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_12f94c
// Address: 0x12f94c - 0x12f97c

void entry_12f94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f94c: 0x10400011
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_12f994(rdram, ctx, runtime); return;
    }
    // 0x12f954: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x12f958: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12f95c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x12f960: 0x1480000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        entry_12f994(rdram, ctx, runtime); return;
    }
    // 0x12f968: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12f96c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12f970: 0x26260040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 64));
    // 0x12f974: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x12f97c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1424));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_12f97c
// Address: 0x12f97c - 0x12f994

void entry_12f97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f97c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12f980: 0xae030580
    WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 3));
    // 0x12f984: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x12f988: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x12f98c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x12f994);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_12f994
// Address: 0x12f994 - 0x12f9b8

void entry_12f994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12f994) {
        switch (ctx->pc) {
            case 0x12f99c: ctx->pc = 0; goto label_12f99c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12f994: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x12f998: 0xae42b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 2));
label_12f99c:
    // 0x12f99c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12f9a0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12f9a4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12f9a8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12f9ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12f9b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12f9b8; return;
}


// Function: UpdateBarrier__FP7BARRIERf
// Address: 0x12f9b8 - 0x12f9d0

void entry_12f9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f9d0: 0x8e2405a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
    // 0x12f9d4: 0x10800027
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FA74; return;
    }
    // 0x12f9dc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12f9e0: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x12f9e4: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x12f9e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12f9f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12f9f0
// Address: 0x12f9f0 - 0x12fa04

void entry_12f9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12f9f0: 0x8e2405a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
    // 0x12f9f4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12f9f8: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x12f9fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12fa04);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12fa04
// Address: 0x12fa04 - 0x12fa38

void entry_12fa04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fa04) {
        switch (ctx->pc) {
            case 0x12fa24: ctx->pc = 0; goto label_12fa24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fa04: 0x8e230580
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1408)));
    // 0x12fa08: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12fa0c: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_12fa24;
    }
    // 0x12fa14: 0x5062000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1424)));
        ctx->pc = 0x12FA40; return;
    }
    // 0x12fa1c: 0x10000013
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FA6C; return;
    }
label_12fa24:
    // 0x12fa24: 0x8e2405a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
    // 0x12fa28: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12fa2c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x12fa30: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12fa38);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1424));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12fa38
// Address: 0x12fa38 - 0x12fa54

void entry_12fa38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fa38) {
        switch (ctx->pc) {
            case 0x12fa40: ctx->pc = 0; goto label_12fa40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fa38: 0x1000000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FA6C; return;
    }
label_12fa40:
    // 0x12fa40: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12fa44: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12fa48: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x12fa4c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x12fa54);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 64));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_12fa54
// Address: 0x12fa54 - 0x12fa68

void entry_12fa54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12fa54: 0x8e2405a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
    // 0x12fa58: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x12fa5c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x12fa60: 0x40f809
    SET_GPR_U32(ctx, 31, 0x12fa68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_12fa68
// Address: 0x12fa68 - 0x12fa88

void entry_12fa68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fa68) {
        switch (ctx->pc) {
            case 0x12fa6c: ctx->pc = 0; goto label_12fa6c;
            case 0x12fa74: ctx->pc = 0; goto label_12fa74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fa68: 0x8e2205a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
label_12fa6c:
    // 0x12fa6c: 0xae2005a0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1440), GPR_U32(ctx, 0));
    // 0x12fa70: 0xae2205a4
    WRITE32(ADD32(GPR_U32(ctx, 17), 1444), GPR_U32(ctx, 2));
label_12fa74:
    // 0x12fa74: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12fa78: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12fa7c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12fa80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIgnoreBarrierIntersection__FP7BARRIERP2SO
// Address: 0x12fa88 - 0x12faac

void entry_12faac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12faac) {
        switch (ctx->pc) {
            case 0x12fac0: ctx->pc = 0; goto label_12fac0;
            case 0x12fac4: ctx->pc = 0; goto label_12fac4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12faac: 0x14400026
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FB48; return;
    }
    // 0x12fab4: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12fab8: 0x10000002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1368));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12fac4;
    }
label_12fac0:
    // 0x12fac0: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_12fac4:
    // 0x12fac4: 0x8e220554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    // 0x12fac8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x12facc: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x12FB00; return;
    }
    // 0x12fad4: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12fad8: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x12fae0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_12fae0
// Address: 0x12fae0 - 0x12fb28

void entry_12fae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fae0) {
        switch (ctx->pc) {
            case 0x12fb00: ctx->pc = 0; goto label_12fb00;
            case 0x12fb08: ctx->pc = 0; goto label_12fb08;
            case 0x12fb0c: ctx->pc = 0; goto label_12fb0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fae0: 0x5040fff7
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
        ctx->pc = 0x12FAC0; return;
    }
    // 0x12fae8: 0x8e220554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    // 0x12faec: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x12faf0: 0x14400011
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FB38; return;
    }
    // 0x12faf8: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12fafc: 0x0
    // NOP
label_12fb00:
    // 0x12fb00: 0x10000002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1388));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_12fb0c;
    }
label_12fb08:
    // 0x12fb08: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_12fb0c:
    // 0x12fb0c: 0x8e220568
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1384)));
    // 0x12fb10: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x12fb14: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1384)));
        ctx->pc = 0x12FB34; return;
    }
    // 0x12fb1c: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12fb20: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x12fb28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_12fb28
// Address: 0x12fb28 - 0x12fb68

void entry_12fb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fb28) {
        switch (ctx->pc) {
            case 0x12fb34: ctx->pc = 0; goto label_12fb34;
            case 0x12fb38: ctx->pc = 0; goto label_12fb38;
            case 0x12fb48: ctx->pc = 0; goto label_12fb48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fb28: 0x1040fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FB08; return;
    }
    // 0x12fb30: 0x8e220568
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1384)));
label_12fb34:
    // 0x12fb34: 0x242182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
label_12fb38:
    // 0x12fb38: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x12fb3c: 0x14400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_12fb48;
    }
    // 0x12fb44: 0x38620001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 1));
label_12fb48:
    // 0x12fb48: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12fb4c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12fb50: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12fb54: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12fb58: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12fb5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12fb64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12fb68; return;
}


// Function: NotifyBarrierImpact__FP7BARRIERP2XPi
// Address: 0x12fb68 - 0x12fb9c

void entry_12fb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12fb9c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12fba0: 0x2321023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 18)));
    // 0x12fba4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x12fba8: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x12fbac: 0x2405001d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 29));
    // 0x12fbb0: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x12fbb4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12fbb8: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x12fbbc: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x12fbc0: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x12fbc8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_12fbc8
// Address: 0x12fbc8 - 0x12fc24

void entry_12fbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fbc8) {
        switch (ctx->pc) {
            case 0x12fc04: ctx->pc = 0; goto label_12fc04;
            case 0x12fc10: ctx->pc = 0; goto label_12fc10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fbc8: 0x8e030580
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1408)));
    // 0x12fbcc: 0x10600032
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FC98; return;
    }
    // 0x12fbd4: 0x8e0205a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1440)));
    // 0x12fbd8: 0x54400030
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
        ctx->pc = 0x12FC9C; return;
    }
    // 0x12fbe0: 0x8e0205a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1444)));
    // 0x12fbe4: 0x10400026
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FC80; return;
    }
    // 0x12fbec: 0x10710005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 17)) {
        goto label_12fc04;
    }
    // 0x12fbf4: 0x50620006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1424)));
        goto label_12fc10;
    }
    // 0x12fbfc: 0x1000000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1444)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FC28; return;
    }
label_12fc04:
    // 0x12fc04: 0x7a020590
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 1424)));
    // 0x12fc08: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_12fc24(rdram, ctx, runtime); return;
    }
label_12fc10:
    // 0x12fc10: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12fc14: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x12fc18: 0x8cc40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x12fc1c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x12fc24);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_12fc24
// Address: 0x12fc24 - 0x12fcb0

void entry_12fc24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fc24) {
        switch (ctx->pc) {
            case 0x12fc28: ctx->pc = 0; goto label_12fc28;
            case 0x12fc74: ctx->pc = 0; goto label_12fc74;
            case 0x12fc80: ctx->pc = 0; goto label_12fc80;
            case 0x12fc98: ctx->pc = 0; goto label_12fc98;
            case 0x12fc9c: ctx->pc = 0; goto label_12fc9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fc24: 0x8e0205a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1444)));
label_12fc28:
    // 0x12fc28: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12fc2c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12fc30: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x12fc34: 0xc44103d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 976)); ctx->f[1] = *(float*)&val; }
    // 0x12fc38: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12fc3c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12fc40: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x12fc44: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12fc48: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x12fc4c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x12fc50: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x12fc54: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x12fc58: 0x46010840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
    // 0x12fc5c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x12fc60: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x12fc64: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x12fc68: 0x0
    // NOP
    // 0x12fc6c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_12fc74;
    }
label_12fc74:
    // 0x12fc74: 0x14600008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_12fc98;
    }
    // 0x12fc7c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_12fc80:
    // 0x12fc80: 0x521023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x12fc84: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x12fc88: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x12fc8c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x12fc90: 0xae0305a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1440), GPR_U32(ctx, 3));
    // 0x12fc94: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_12fc98:
    // 0x12fc98: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_12fc9c:
    // 0x12fc9c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12fca0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12fca4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12fca8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddBarrierObject__FP7BARRIER3OID
// Address: 0x12fcb0 - 0x12fcd0

void entry_12fd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12fd4c: 0x32100001
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 1));
    // 0x12fd50: 0x12000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FD64; return;
    }
    // 0x12fd58: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x12fd60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_12fd60
// Address: 0x12fd60 - 0x12fd78

void entry_12fd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fd60) {
        switch (ctx->pc) {
            case 0x12fd64: ctx->pc = 0; goto label_12fd64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fd60: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_12fd64:
    // 0x12fd64: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12fd68: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12fd6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12fd74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12fd78; return;
}


// Function: FOpenFile__18CBinaryAsyncStreamP13CFileLocation
// Address: 0x12fd78 - 0x12fd8c

void entry_12fd8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12fd8c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12fd90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0012FD98
// Address: 0x12fd98 - 0x12fda0

void entry_12fdd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12fdd4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12fdd8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12fddc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x12fde4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x12fde8; return;
}


// Function: Close__18CBinaryAsyncStream
// Address: 0x12fde8 - 0x12fe28

void entry_12fe28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fe28) {
        switch (ctx->pc) {
            case 0x12fe2c: ctx->pc = 0; goto label_12fe2c;
            case 0x12fe34: ctx->pc = 0; goto label_12fe34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fe28: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_12fe2c:
    // 0x12fe2c: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FE58; return;
    }
label_12fe34:
    // 0x12fe34: 0xc04bfc4
    SET_GPR_U32(ctx, 31, 0x12fe3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FSpooling__18CBinaryAsyncStream(rdram, ctx, runtime); return;
}


// Function: entry_12fe3c
// Address: 0x12fe3c - 0x12fe4c

void entry_12fe3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12fe3c: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
        ctx->pc = 0x12FE58; return;
    }
    // 0x12fe44: 0xc080cb2
    SET_GPR_U32(ctx, 31, 0x12fe4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceCdSync(rdram, ctx, runtime); return;
}


// Function: entry_12fe4c
// Address: 0x12fe4c - 0x12fe54

void entry_12fe4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12fe4c: 0xc04bffa
    SET_GPR_U32(ctx, 31, 0x12fe54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FinishSpooling__18CBinaryAsyncStream(rdram, ctx, runtime); return;
}


// Function: entry_12fe54
// Address: 0x12fe54 - 0x12fe70

void entry_12fe54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fe54) {
        switch (ctx->pc) {
            case 0x12fe58: ctx->pc = 0; goto label_12fe58;
            case 0x12fe60: ctx->pc = 0; goto label_12fe60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fe54: 0xae000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
label_12fe58:
    // 0x12fe58: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x12fe5c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12fe60:
    // 0x12fe60: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x12fe64: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12fe68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartSpooling__18CBinaryAsyncStream
// Address: 0x12fe70 - 0x12fe84

void entry_12fe84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fe84) {
        switch (ctx->pc) {
            case 0x12fedc: ctx->pc = 0; goto label_12fedc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fe84: 0x1440001f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FF04; return;
    }
    // 0x12fe8c: 0x8e050024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x12fe90: 0x10a0001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16383));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FF04; return;
    }
    // 0x12fe98: 0x8e060014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x12fe9c: 0x8e03001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x12fea0: 0x45102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x12fea4: 0x24c44000
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 16384));
    // 0x12fea8: 0x24074000
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 16384));
    // 0x12feac: 0x661826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x12feb0: 0xa2380a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 5));
    // 0x12feb4: 0x83300a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 4));
    // 0x12feb8: 0xae07000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 7));
    // 0x12febc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12fec0: 0x10600006
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_12fedc;
    }
    // 0x12fec8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12fecc: 0x10620009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 7), 2047));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12FEF4; return;
    }
    // 0x12fed4: 0x1000000c
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FF08; return;
    }
label_12fedc:
    // 0x12fedc: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x12fee0: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12fee4: 0xc07e36e
    SET_GPR_U32(ctx, 31, 0x12feec);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    sceRead(rdram, ctx, runtime); return;
}


// Function: entry_12feec
// Address: 0x12feec - 0x12ff00

void entry_12feec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12feec) {
        switch (ctx->pc) {
            case 0x12fef4: ctx->pc = 0; goto label_12fef4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12feec: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FF04; return;
    }
label_12fef4:
    // 0x12fef4: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x12fef8: 0xc050332
    SET_GPR_U32(ctx, 31, 0x12ff00);
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 5), 11));
    ReadCdDirect__FUiUiPv(rdram, ctx, runtime); return;
}


// Function: entry_12ff00
// Address: 0x12ff00 - 0x12ff10

void entry_12ff00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ff00) {
        switch (ctx->pc) {
            case 0x12ff04: ctx->pc = 0; goto label_12ff04;
            case 0x12ff08: ctx->pc = 0; goto label_12ff08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ff00: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_12ff04:
    // 0x12ff04: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_12ff08:
    // 0x12ff08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FSpooling__18CBinaryAsyncStream
// Address: 0x12ff10 - 0x12ff20

void entry_12ff54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ff54) {
        switch (ctx->pc) {
            case 0x12ff78: ctx->pc = 0; goto label_12ff78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ff54: 0x10400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FFB8; return;
    }
    // 0x12ff5c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x12ff60: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_12ff78;
    }
    // 0x12ff68: 0x1062000b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x12FF98; return;
    }
    // 0x12ff70: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FFB8; return;
    }
label_12ff78:
    // 0x12ff78: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x12ff7c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x12ff80: 0xc07e4ba
    SET_GPR_U32(ctx, 31, 0x12ff88);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    sceIoctl(rdram, ctx, runtime); return;
}


// Function: entry_12ff88
// Address: 0x12ff88 - 0x12ffa0

void entry_12ff88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ff88) {
        switch (ctx->pc) {
            case 0x12ff98: ctx->pc = 0; goto label_12ff98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ff88: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x12ff8c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x12ff90: 0x10000009
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FFB8; return;
    }
label_12ff98:
    // 0x12ff98: 0xc080cb2
    SET_GPR_U32(ctx, 31, 0x12ffa0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    sceCdSync(rdram, ctx, runtime); return;
}


// Function: entry_12ffa0
// Address: 0x12ffa0 - 0x12ffb4

void entry_12ffa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x12ffa0: 0x2c510001
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x12ffa4: 0x12200004
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x12FFB8; return;
    }
    // 0x12ffac: 0xc080f64
    SET_GPR_U32(ctx, 31, 0x12ffb4);
    sceCdGetError(rdram, ctx, runtime); return;
}


// Function: entry_12ffb4
// Address: 0x12ffb4 - 0x12ffe8

void entry_12ffb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12ffb4) {
        switch (ctx->pc) {
            case 0x12ffb8: ctx->pc = 0; goto label_12ffb8;
            case 0x12ffd0: ctx->pc = 0; goto label_12ffd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12ffb4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_12ffb8:
    // 0x12ffb8: 0x12400005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_12ffd0;
    }
    // 0x12ffc0: 0xae000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 0));
    // 0x12ffc4: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x12ffc8: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x12ffcc: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_12ffd0:
    // 0x12ffd0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x12ffd4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x12ffd8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x12ffdc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x12ffe0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FinishSpooling__18CBinaryAsyncStream
// Address: 0x12ffe8 - 0x12fffc

void entry_12fffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x12fffc) {
        switch (ctx->pc) {
            case 0x130038: ctx->pc = 0; goto label_130038;
            case 0x13005c: ctx->pc = 0; goto label_13005c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x12fffc: 0x10400017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_13005c;
    }
    // 0x130004: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x130008: 0x5462000b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_130038;
    }
    // 0x130010: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x130014: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x130018: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x13001c: 0x64182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x130020: 0x248207ff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 2047));
    // 0x130024: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x130028: 0x212c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 11));
    // 0x13002c: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x130030: 0xae050008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 5));
    // 0x130034: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_130038:
    // 0x130038: 0x8e030024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x13003c: 0x8e040010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x130040: 0x621823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x130044: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x130048: 0xae030024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 3));
    // 0x13004c: 0xae04001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 4));
    // 0x130050: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x130054: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x130058: 0xae000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 0));
label_13005c:
    // 0x13005c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x130060: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x130064: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x13006c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x130070; return;
}


// Function: Spool__18CBinaryAsyncStream
// Address: 0x130070 - 0x1300a4

void entry_1200e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1200e8 inside entry_1200c0 (0x1200c0 - 0x1200f4)
    ctx->pc = 0x1200e8;
    entry_1200c0(rdram, ctx, runtime);
}

void entry_1200ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1200ec inside entry_1200c0 (0x1200c0 - 0x1200f4)
    ctx->pc = 0x1200ec;
    entry_1200c0(rdram, ctx, runtime);
}

void entry_120230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120230 inside entry_120218 (0x120218 - 0x12023c)
    ctx->pc = 0x120230;
    entry_120218(rdram, ctx, runtime);
}

void entry_1202a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1202a4 inside entry_120280 (0x120280 - 0x1202c0)
    ctx->pc = 0x1202a4;
    entry_120280(rdram, ctx, runtime);
}

void entry_12034c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12034c inside entry_120334 (0x120334 - 0x120360)
    ctx->pc = 0x12034c;
    entry_120334(rdram, ctx, runtime);
}

void entry_120404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120404 inside entry_1203ec (0x1203ec - 0x120418)
    ctx->pc = 0x120404;
    entry_1203ec(rdram, ctx, runtime);
}

void entry_1204c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1204c8 inside EvaluateAcpbl__FP5ACPBLP3ALOffiP6VECTORT5 (0x120470 - 0x120504)
    ctx->pc = 0x1204c8;
    EvaluateAcpbl__FP5ACPBLP3ALOffiP6VECTORT5(rdram, ctx, runtime);
}

void entry_1204dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1204dc inside EvaluateAcpbl__FP5ACPBLP3ALOffiP6VECTORT5 (0x120470 - 0x120504)
    ctx->pc = 0x1204dc;
    EvaluateAcpbl__FP5ACPBLP3ALOffiP6VECTORT5(rdram, ctx, runtime);
}

void entry_1204f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1204f0 inside EvaluateAcpbl__FP5ACPBLP3ALOffiP6VECTORT5 (0x120470 - 0x120504)
    ctx->pc = 0x1204f0;
    EvaluateAcpbl__FP5ACPBLP3ALOffiP6VECTORT5(rdram, ctx, runtime);
}

void entry_120520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120520 inside entry_120504 (0x120504 - 0x120640)
    ctx->pc = 0x120520;
    entry_120504(rdram, ctx, runtime);
}

void entry_120540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120540 inside entry_120504 (0x120504 - 0x120640)
    ctx->pc = 0x120540;
    entry_120504(rdram, ctx, runtime);
}

void entry_1205a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1205a4 inside entry_120504 (0x120504 - 0x120640)
    ctx->pc = 0x1205a4;
    entry_120504(rdram, ctx, runtime);
}

void entry_1205b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1205b8 inside entry_120504 (0x120504 - 0x120640)
    ctx->pc = 0x1205b8;
    entry_120504(rdram, ctx, runtime);
}

void entry_1205d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1205d8 inside entry_120504 (0x120504 - 0x120640)
    ctx->pc = 0x1205d8;
    entry_120504(rdram, ctx, runtime);
}

void entry_12060c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12060c inside entry_120504 (0x120504 - 0x120640)
    ctx->pc = 0x12060c;
    entry_120504(rdram, ctx, runtime);
}

void entry_12061c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12061c inside entry_120504 (0x120504 - 0x120640)
    ctx->pc = 0x12061c;
    entry_120504(rdram, ctx, runtime);
}

void entry_120668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120668 inside entry_120640 (0x120640 - 0x1206c8)
    ctx->pc = 0x120668;
    entry_120640(rdram, ctx, runtime);
}

void entry_120690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120690 inside entry_120640 (0x120640 - 0x1206c8)
    ctx->pc = 0x120690;
    entry_120640(rdram, ctx, runtime);
}

void entry_120694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120694 inside entry_120640 (0x120640 - 0x1206c8)
    ctx->pc = 0x120694;
    entry_120640(rdram, ctx, runtime);
}

void entry_1206a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1206a4 inside entry_120640 (0x120640 - 0x1206c8)
    ctx->pc = 0x1206a4;
    entry_120640(rdram, ctx, runtime);
}

void entry_1206cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1206cc inside entry_1206c8 (0x1206c8 - 0x120700)
    ctx->pc = 0x1206cc;
    entry_1206c8(rdram, ctx, runtime);
}

void entry_120760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120760 inside EvaluateAcrbl__FP5ACRBLP3ALOffiP7MATRIX3P6VECTOR (0x120700 - 0x12079c)
    ctx->pc = 0x120760;
    EvaluateAcrbl__FP5ACRBLP3ALOffiP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_120774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120774 inside EvaluateAcrbl__FP5ACRBLP3ALOffiP7MATRIX3P6VECTOR (0x120700 - 0x12079c)
    ctx->pc = 0x120774;
    EvaluateAcrbl__FP5ACRBLP3ALOffiP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_120788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120788 inside EvaluateAcrbl__FP5ACRBLP3ALOffiP7MATRIX3P6VECTOR (0x120700 - 0x12079c)
    ctx->pc = 0x120788;
    EvaluateAcrbl__FP5ACRBLP3ALOffiP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_1207b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1207b8 inside entry_12079c (0x12079c - 0x1208d8)
    ctx->pc = 0x1207b8;
    entry_12079c(rdram, ctx, runtime);
}

void entry_1207f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1207f0 inside entry_12079c (0x12079c - 0x1208d8)
    ctx->pc = 0x1207f0;
    entry_12079c(rdram, ctx, runtime);
}

void entry_120840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120840 inside entry_12079c (0x12079c - 0x1208d8)
    ctx->pc = 0x120840;
    entry_12079c(rdram, ctx, runtime);
}

void entry_12084c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12084c inside entry_12079c (0x12079c - 0x1208d8)
    ctx->pc = 0x12084c;
    entry_12079c(rdram, ctx, runtime);
}

void entry_12086c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12086c inside entry_12079c (0x12079c - 0x1208d8)
    ctx->pc = 0x12086c;
    entry_12079c(rdram, ctx, runtime);
}

void entry_1208a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1208a4 inside entry_12079c (0x12079c - 0x1208d8)
    ctx->pc = 0x1208a4;
    entry_12079c(rdram, ctx, runtime);
}

void entry_1208b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1208b4 inside entry_12079c (0x12079c - 0x1208d8)
    ctx->pc = 0x1208b4;
    entry_12079c(rdram, ctx, runtime);
}

void entry_120900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120900 inside entry_1208d8 (0x1208d8 - 0x12092c)
    ctx->pc = 0x120900;
    entry_1208d8(rdram, ctx, runtime);
}

void entry_120934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120934 inside entry_12092c (0x12092c - 0x120940)
    ctx->pc = 0x120934;
    entry_12092c(rdram, ctx, runtime);
}

void entry_1209e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1209e4 inside entry_120980 (0x120980 - 0x120a38)
    ctx->pc = 0x1209e4;
    entry_120980(rdram, ctx, runtime);
}

void entry_1209ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1209ec inside entry_120980 (0x120980 - 0x120a38)
    ctx->pc = 0x1209ec;
    entry_120980(rdram, ctx, runtime);
}

void entry_120a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120a08 inside entry_120980 (0x120980 - 0x120a38)
    ctx->pc = 0x120a08;
    entry_120980(rdram, ctx, runtime);
}

void entry_120a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120a0c inside entry_120980 (0x120980 - 0x120a38)
    ctx->pc = 0x120a0c;
    entry_120980(rdram, ctx, runtime);
}

void entry_120a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120a1c inside entry_120980 (0x120980 - 0x120a38)
    ctx->pc = 0x120a1c;
    entry_120980(rdram, ctx, runtime);
}

void entry_120b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120b18 inside EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5 (0x120aa8 - 0x120b64)
    ctx->pc = 0x120b18;
    EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120b20 inside EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5 (0x120aa8 - 0x120b64)
    ctx->pc = 0x120b20;
    EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120b34 inside EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5 (0x120aa8 - 0x120b64)
    ctx->pc = 0x120b34;
    EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120b50 inside EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5 (0x120aa8 - 0x120b64)
    ctx->pc = 0x120b50;
    EvaluateAcgblt__FP6ACGBLTP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120b80 inside entry_120b64 (0x120b64 - 0x120be8)
    ctx->pc = 0x120b80;
    entry_120b64(rdram, ctx, runtime);
}

void entry_120b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120b98 inside entry_120b64 (0x120b64 - 0x120be8)
    ctx->pc = 0x120b98;
    entry_120b64(rdram, ctx, runtime);
}

void entry_120c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120c00 inside entry_120be8 (0x120be8 - 0x120c84)
    ctx->pc = 0x120c00;
    entry_120be8(rdram, ctx, runtime);
}

void entry_120c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120c20 inside entry_120be8 (0x120be8 - 0x120c84)
    ctx->pc = 0x120c20;
    entry_120be8(rdram, ctx, runtime);
}

void entry_120c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120c54 inside entry_120be8 (0x120be8 - 0x120c84)
    ctx->pc = 0x120c54;
    entry_120be8(rdram, ctx, runtime);
}

void entry_120c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120c64 inside entry_120be8 (0x120be8 - 0x120c84)
    ctx->pc = 0x120c64;
    entry_120be8(rdram, ctx, runtime);
}

void entry_120c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120c98 inside entry_120c84 (0x120c84 - 0x120ca0)
    ctx->pc = 0x120c98;
    entry_120c84(rdram, ctx, runtime);
}

void entry_120cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120cbc inside entry_120ca8 (0x120ca8 - 0x120cdc)
    ctx->pc = 0x120cbc;
    entry_120ca8(rdram, ctx, runtime);
}

void entry_120ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120ccc inside entry_120ca8 (0x120ca8 - 0x120cdc)
    ctx->pc = 0x120ccc;
    entry_120ca8(rdram, ctx, runtime);
}

void entry_120cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120cd4 inside entry_120ca8 (0x120ca8 - 0x120cdc)
    ctx->pc = 0x120cd4;
    entry_120ca8(rdram, ctx, runtime);
}

void entry_120ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120ce4 inside entry_120cdc (0x120cdc - 0x120d58)
    ctx->pc = 0x120ce4;
    entry_120cdc(rdram, ctx, runtime);
}

void entry_120cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120cf4 inside entry_120cdc (0x120cdc - 0x120d58)
    ctx->pc = 0x120cf4;
    entry_120cdc(rdram, ctx, runtime);
}

void entry_120d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120d00 inside entry_120cdc (0x120cdc - 0x120d58)
    ctx->pc = 0x120d00;
    entry_120cdc(rdram, ctx, runtime);
}

void entry_120d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120d0c inside entry_120cdc (0x120cdc - 0x120d58)
    ctx->pc = 0x120d0c;
    entry_120cdc(rdram, ctx, runtime);
}

void entry_120dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120dc4 inside EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5 (0x120d58 - 0x120e0c)
    ctx->pc = 0x120dc4;
    EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120dcc inside EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5 (0x120d58 - 0x120e0c)
    ctx->pc = 0x120dcc;
    EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120de0 inside EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5 (0x120d58 - 0x120e0c)
    ctx->pc = 0x120de0;
    EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120df8 inside EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5 (0x120d58 - 0x120e0c)
    ctx->pc = 0x120df8;
    EvaluateAcgblp__FP6ACGBLPP3ALOffiPfT5(rdram, ctx, runtime);
}

void entry_120e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120e28 inside entry_120e0c (0x120e0c - 0x120f24)
    ctx->pc = 0x120e28;
    entry_120e0c(rdram, ctx, runtime);
}

void entry_120e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120e40 inside entry_120e0c (0x120e0c - 0x120f24)
    ctx->pc = 0x120e40;
    entry_120e0c(rdram, ctx, runtime);
}

void entry_120ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120ea0 inside entry_120e0c (0x120e0c - 0x120f24)
    ctx->pc = 0x120ea0;
    entry_120e0c(rdram, ctx, runtime);
}

void entry_120ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120ec0 inside entry_120e0c (0x120e0c - 0x120f24)
    ctx->pc = 0x120ec0;
    entry_120e0c(rdram, ctx, runtime);
}

void entry_120ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120ef4 inside entry_120e0c (0x120e0c - 0x120f24)
    ctx->pc = 0x120ef4;
    entry_120e0c(rdram, ctx, runtime);
}

void entry_120f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120f04 inside entry_120e0c (0x120e0c - 0x120f24)
    ctx->pc = 0x120f04;
    entry_120e0c(rdram, ctx, runtime);
}

void entry_120f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120f40 inside entry_120f24 (0x120f24 - 0x120fb0)
    ctx->pc = 0x120f40;
    entry_120f24(rdram, ctx, runtime);
}

void entry_120f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120f44 inside entry_120f24 (0x120f24 - 0x120fb0)
    ctx->pc = 0x120f44;
    entry_120f24(rdram, ctx, runtime);
}

void entry_120f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120f54 inside entry_120f24 (0x120f24 - 0x120fb0)
    ctx->pc = 0x120f54;
    entry_120f24(rdram, ctx, runtime);
}

void entry_120f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120f60 inside entry_120f24 (0x120f24 - 0x120fb0)
    ctx->pc = 0x120f60;
    entry_120f24(rdram, ctx, runtime);
}

void entry_120f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120f6c inside entry_120f24 (0x120f24 - 0x120fb0)
    ctx->pc = 0x120f6c;
    entry_120f24(rdram, ctx, runtime);
}

void entry_120fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120fe4 inside PacpNew__F4ACVK (0x120fb0 - 0x120ffc)
    ctx->pc = 0x120fe4;
    PacpNew__F4ACVK(rdram, ctx, runtime);
}

void entry_120ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x120ff4 inside PacpNew__F4ACVK (0x120fb0 - 0x120ffc)
    ctx->pc = 0x120ff4;
    PacpNew__F4ACVK(rdram, ctx, runtime);
}

void entry_12100c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12100c inside entry_120ffc (0x120ffc - 0x121014)
    ctx->pc = 0x12100c;
    entry_120ffc(rdram, ctx, runtime);
}

void entry_121024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121024 inside entry_121014 (0x121014 - 0x12102c)
    ctx->pc = 0x121024;
    entry_121014(rdram, ctx, runtime);
}

void entry_121038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121038 inside entry_12102c (0x12102c - 0x121050)
    ctx->pc = 0x121038;
    entry_12102c(rdram, ctx, runtime);
}

void entry_121040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121040 inside entry_12102c (0x12102c - 0x121050)
    ctx->pc = 0x121040;
    entry_12102c(rdram, ctx, runtime);
}

void entry_121084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121084 inside PacrNew__F4ACVK (0x121050 - 0x12109c)
    ctx->pc = 0x121084;
    PacrNew__F4ACVK(rdram, ctx, runtime);
}

void entry_121094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121094 inside PacrNew__F4ACVK (0x121050 - 0x12109c)
    ctx->pc = 0x121094;
    PacrNew__F4ACVK(rdram, ctx, runtime);
}

void entry_1210ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1210ac inside entry_12109c (0x12109c - 0x1210b4)
    ctx->pc = 0x1210ac;
    entry_12109c(rdram, ctx, runtime);
}

void entry_1210c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1210c4 inside entry_1210b4 (0x1210b4 - 0x1210cc)
    ctx->pc = 0x1210c4;
    entry_1210b4(rdram, ctx, runtime);
}

void entry_1210d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1210d8 inside entry_1210cc (0x1210cc - 0x1210f0)
    ctx->pc = 0x1210d8;
    entry_1210cc(rdram, ctx, runtime);
}

void entry_1210e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1210e0 inside entry_1210cc (0x1210cc - 0x1210f0)
    ctx->pc = 0x1210e0;
    entry_1210cc(rdram, ctx, runtime);
}

void entry_121118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121118 inside PacsNew__F4ACVK (0x1210f0 - 0x121120)
    ctx->pc = 0x121118;
    PacsNew__F4ACVK(rdram, ctx, runtime);
}

void entry_121130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121130 inside entry_121120 (0x121120 - 0x121138)
    ctx->pc = 0x121130;
    entry_121120(rdram, ctx, runtime);
}

void entry_121144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121144 inside entry_121138 (0x121138 - 0x121160)
    ctx->pc = 0x121144;
    entry_121138(rdram, ctx, runtime);
}

void entry_12114c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12114c inside entry_121138 (0x121138 - 0x121160)
    ctx->pc = 0x12114c;
    entry_121138(rdram, ctx, runtime);
}

void entry_12120c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12120c inside entry_1211fc (0x1211fc - 0x121228)
    ctx->pc = 0x12120c;
    entry_1211fc(rdram, ctx, runtime);
}

void entry_121210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121210 inside entry_1211fc (0x1211fc - 0x121228)
    ctx->pc = 0x121210;
    entry_1211fc(rdram, ctx, runtime);
}

void entry_121218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121218 inside entry_1211fc (0x1211fc - 0x121228)
    ctx->pc = 0x121218;
    entry_1211fc(rdram, ctx, runtime);
}

void entry_121404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121404 inside entry_1213fc (0x1213fc - 0x121410)
    ctx->pc = 0x121404;
    entry_1213fc(rdram, ctx, runtime);
}

void entry_121474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121474 inside entry_12146c (0x12146c - 0x121484)
    ctx->pc = 0x121474;
    entry_12146c(rdram, ctx, runtime);
}

void entry_121488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121488 inside entry_121484 (0x121484 - 0x121494)
    ctx->pc = 0x121488;
    entry_121484(rdram, ctx, runtime);
}

void entry_121500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121500 inside entry_1214fc (0x1214fc - 0x121508)
    ctx->pc = 0x121500;
    entry_1214fc(rdram, ctx, runtime);
}

void entry_1215f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1215f0 inside CalculateActDefaultAck__FP3ACT (0x1215c0 - 0x121648)
    ctx->pc = 0x1215f0;
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime);
}

void entry_121604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121604 inside CalculateActDefaultAck__FP3ACT (0x1215c0 - 0x121648)
    ctx->pc = 0x121604;
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime);
}

void entry_12160c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12160c inside CalculateActDefaultAck__FP3ACT (0x1215c0 - 0x121648)
    ctx->pc = 0x12160c;
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime);
}

void entry_12161c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12161c inside CalculateActDefaultAck__FP3ACT (0x1215c0 - 0x121648)
    ctx->pc = 0x12161c;
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime);
}

void entry_121624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121624 inside CalculateActDefaultAck__FP3ACT (0x1215c0 - 0x121648)
    ctx->pc = 0x121624;
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime);
}

void entry_121638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121638 inside CalculateActDefaultAck__FP3ACT (0x1215c0 - 0x121648)
    ctx->pc = 0x121638;
    CalculateActDefaultAck__FP3ACT(rdram, ctx, runtime);
}

void entry_121690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121690 inside SnapAct__FP3ACTi (0x121648 - 0x1216ac)
    ctx->pc = 0x121690;
    SnapAct__FP3ACTi(rdram, ctx, runtime);
}

void entry_1216d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1216d8 inside entry_1216d4 (0x1216d4 - 0x121718)
    ctx->pc = 0x1216d8;
    entry_1216d4(rdram, ctx, runtime);
}

void entry_1216fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1216fc inside entry_1216d4 (0x1216d4 - 0x121718)
    ctx->pc = 0x1216fc;
    entry_1216d4(rdram, ctx, runtime);
}

void entry_121744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121744 inside entry_121740 (0x121740 - 0x121760)
    ctx->pc = 0x121744;
    entry_121740(rdram, ctx, runtime);
}

void entry_121748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121748 inside entry_121740 (0x121740 - 0x121760)
    ctx->pc = 0x121748;
    entry_121740(rdram, ctx, runtime);
}

void entry_1217fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1217fc inside CalculateAloPositionSpring__FP3ALOfP6VECTORN22 (0x121760 - 0x1218c0)
    ctx->pc = 0x1217fc;
    CalculateAloPositionSpring__FP3ALOfP6VECTORN22(rdram, ctx, runtime);
}

void entry_121800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121800 inside CalculateAloPositionSpring__FP3ALOfP6VECTORN22 (0x121760 - 0x1218c0)
    ctx->pc = 0x121800;
    CalculateAloPositionSpring__FP3ALOfP6VECTORN22(rdram, ctx, runtime);
}

void entry_121890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121890 inside CalculateAloPositionSpring__FP3ALOfP6VECTORN22 (0x121760 - 0x1218c0)
    ctx->pc = 0x121890;
    CalculateAloPositionSpring__FP3ALOfP6VECTORN22(rdram, ctx, runtime);
}

void entry_1218b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1218b0 inside CalculateAloPositionSpring__FP3ALOfP6VECTORN22 (0x121760 - 0x1218c0)
    ctx->pc = 0x1218b0;
    CalculateAloPositionSpring__FP3ALOfP6VECTORN22(rdram, ctx, runtime);
}

void entry_121904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121904 inside ProjectActPosition__FP3ACT (0x1218c0 - 0x121948)
    ctx->pc = 0x121904;
    ProjectActPosition__FP3ACT(rdram, ctx, runtime);
}

void entry_121910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121910 inside ProjectActPosition__FP3ACT (0x1218c0 - 0x121948)
    ctx->pc = 0x121910;
    ProjectActPosition__FP3ACT(rdram, ctx, runtime);
}

void entry_121924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121924 inside ProjectActPosition__FP3ACT (0x1218c0 - 0x121948)
    ctx->pc = 0x121924;
    ProjectActPosition__FP3ACT(rdram, ctx, runtime);
}

void entry_121928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121928 inside ProjectActPosition__FP3ACT (0x1218c0 - 0x121948)
    ctx->pc = 0x121928;
    ProjectActPosition__FP3ACT(rdram, ctx, runtime);
}

void entry_121a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121a74 inside entry_1219a4 (0x1219a4 - 0x121a98)
    ctx->pc = 0x121a74;
    entry_1219a4(rdram, ctx, runtime);
}

void entry_121a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121a80 inside entry_1219a4 (0x1219a4 - 0x121a98)
    ctx->pc = 0x121a80;
    entry_1219a4(rdram, ctx, runtime);
}

void entry_121b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121b10 inside entry_121adc (0x121adc - 0x121c14)
    ctx->pc = 0x121b10;
    entry_121adc(rdram, ctx, runtime);
}

void entry_121b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121b28 inside entry_121adc (0x121adc - 0x121c14)
    ctx->pc = 0x121b28;
    entry_121adc(rdram, ctx, runtime);
}

void entry_121b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121b5c inside entry_121adc (0x121adc - 0x121c14)
    ctx->pc = 0x121b5c;
    entry_121adc(rdram, ctx, runtime);
}

void entry_121be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121be8 inside entry_121adc (0x121adc - 0x121c14)
    ctx->pc = 0x121be8;
    entry_121adc(rdram, ctx, runtime);
}

void entry_121c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121c20 inside entry_121c14 (0x121c14 - 0x121c48)
    ctx->pc = 0x121c20;
    entry_121c14(rdram, ctx, runtime);
}

void entry_121c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121c24 inside entry_121c14 (0x121c14 - 0x121c48)
    ctx->pc = 0x121c24;
    entry_121c14(rdram, ctx, runtime);
}

void entry_121d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121d04 inside entry_121cac (0x121cac - 0x121de0)
    ctx->pc = 0x121d04;
    entry_121cac(rdram, ctx, runtime);
}

void entry_121d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121d98 inside entry_121cac (0x121cac - 0x121de0)
    ctx->pc = 0x121d98;
    entry_121cac(rdram, ctx, runtime);
}

void entry_121db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121db8 inside entry_121cac (0x121cac - 0x121de0)
    ctx->pc = 0x121db8;
    entry_121cac(rdram, ctx, runtime);
}

void entry_121e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121e38 inside ProjectActRotation__FP3ACT (0x121de0 - 0x121e7c)
    ctx->pc = 0x121e38;
    ProjectActRotation__FP3ACT(rdram, ctx, runtime);
}

void entry_121e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121e44 inside ProjectActRotation__FP3ACT (0x121de0 - 0x121e7c)
    ctx->pc = 0x121e44;
    ProjectActRotation__FP3ACT(rdram, ctx, runtime);
}

void entry_121e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121e58 inside ProjectActRotation__FP3ACT (0x121de0 - 0x121e7c)
    ctx->pc = 0x121e58;
    ProjectActRotation__FP3ACT(rdram, ctx, runtime);
}

void entry_121e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121e5c inside ProjectActRotation__FP3ACT (0x121de0 - 0x121e7c)
    ctx->pc = 0x121e5c;
    ProjectActRotation__FP3ACT(rdram, ctx, runtime);
}

void entry_121eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121eb8 inside entry_121eb0 (0x121eb0 - 0x121f4c)
    ctx->pc = 0x121eb8;
    entry_121eb0(rdram, ctx, runtime);
}

void entry_121ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x121ebc inside entry_121eb0 (0x121eb0 - 0x121f4c)
    ctx->pc = 0x121ebc;
    entry_121eb0(rdram, ctx, runtime);
}

void entry_122124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122124 inside entry_1220e8 (0x1220e8 - 0x122188)
    ctx->pc = 0x122124;
    entry_1220e8(rdram, ctx, runtime);
}

void entry_122140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122140 inside entry_1220e8 (0x1220e8 - 0x122188)
    ctx->pc = 0x122140;
    entry_1220e8(rdram, ctx, runtime);
}

void entry_122144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122144 inside entry_1220e8 (0x1220e8 - 0x122188)
    ctx->pc = 0x122144;
    entry_1220e8(rdram, ctx, runtime);
}

void entry_122180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122180 inside entry_1220e8 (0x1220e8 - 0x122188)
    ctx->pc = 0x122180;
    entry_1220e8(rdram, ctx, runtime);
}

void entry_122218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122218 inside entry_1221f8 (0x1221f8 - 0x122238)
    ctx->pc = 0x122218;
    entry_1221f8(rdram, ctx, runtime);
}

void entry_12225c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12225c inside entry_122238 (0x122238 - 0x122338)
    ctx->pc = 0x12225c;
    entry_122238(rdram, ctx, runtime);
}

void entry_1222e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1222e0 inside entry_122238 (0x122238 - 0x122338)
    ctx->pc = 0x1222e0;
    entry_122238(rdram, ctx, runtime);
}

void entry_12230c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12230c inside entry_122238 (0x122238 - 0x122338)
    ctx->pc = 0x12230c;
    entry_122238(rdram, ctx, runtime);
}

void entry_1223a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1223a4 inside entry_122338 (0x122338 - 0x1223f8)
    ctx->pc = 0x1223a4;
    entry_122338(rdram, ctx, runtime);
}

void entry_1223c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1223c4 inside entry_122338 (0x122338 - 0x1223f8)
    ctx->pc = 0x1223c4;
    entry_122338(rdram, ctx, runtime);
}

void entry_1224cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1224cc inside entry_1224ac (0x1224ac - 0x12252c)
    ctx->pc = 0x1224cc;
    entry_1224ac(rdram, ctx, runtime);
}

void entry_1224e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1224e4 inside entry_1224ac (0x1224ac - 0x12252c)
    ctx->pc = 0x1224e4;
    entry_1224ac(rdram, ctx, runtime);
}

void entry_122510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122510 inside entry_1224ac (0x1224ac - 0x12252c)
    ctx->pc = 0x122510;
    entry_1224ac(rdram, ctx, runtime);
}

void entry_122518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122518 inside entry_1224ac (0x1224ac - 0x12252c)
    ctx->pc = 0x122518;
    entry_1224ac(rdram, ctx, runtime);
}

void entry_12253c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12253c inside entry_12252c (0x12252c - 0x122550)
    ctx->pc = 0x12253c;
    entry_12252c(rdram, ctx, runtime);
}

void entry_122544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122544 inside entry_12252c (0x12252c - 0x122550)
    ctx->pc = 0x122544;
    entry_12252c(rdram, ctx, runtime);
}

void entry_122584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122584 inside PredictAloPosition__FP3ALOfP6VECTORT2 (0x122550 - 0x12259c)
    ctx->pc = 0x122584;
    PredictAloPosition__FP3ALOfP6VECTORT2(rdram, ctx, runtime);
}

void entry_1225a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1225a4 inside entry_12259c (0x12259c - 0x1225d0)
    ctx->pc = 0x1225a4;
    entry_12259c(rdram, ctx, runtime);
}

void entry_1225c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1225c4 inside entry_12259c (0x12259c - 0x1225d0)
    ctx->pc = 0x1225c4;
    entry_12259c(rdram, ctx, runtime);
}

void entry_1225c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1225c8 inside entry_12259c (0x12259c - 0x1225d0)
    ctx->pc = 0x1225c8;
    entry_12259c(rdram, ctx, runtime);
}

void entry_12261c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12261c inside PredictAloRotation__FP3ALOfP7MATRIX3P6VECTOR (0x1225d0 - 0x122634)
    ctx->pc = 0x12261c;
    PredictAloRotation__FP3ALOfP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_12263c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12263c inside entry_122634 (0x122634 - 0x122660)
    ctx->pc = 0x12263c;
    entry_122634(rdram, ctx, runtime);
}

void entry_1226c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1226c4 inside entry_122660 (0x122660 - 0x1226d8)
    ctx->pc = 0x1226c4;
    entry_122660(rdram, ctx, runtime);
}

void entry_1226c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1226c8 inside entry_122660 (0x122660 - 0x1226d8)
    ctx->pc = 0x1226c8;
    entry_122660(rdram, ctx, runtime);
}

void entry_1226f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1226f4 inside AdaptAct__FP3ACT (0x1226d8 - 0x122708)
    ctx->pc = 0x1226f4;
    AdaptAct__FP3ACT(rdram, ctx, runtime);
}

void entry_122700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122700 inside AdaptAct__FP3ACT (0x1226d8 - 0x122708)
    ctx->pc = 0x122700;
    AdaptAct__FP3ACT(rdram, ctx, runtime);
}

void entry_12276c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12276c inside entry_122724 (0x122724 - 0x1227b0)
    ctx->pc = 0x12276c;
    entry_122724(rdram, ctx, runtime);
}

void entry_122770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122770 inside entry_122724 (0x122724 - 0x1227b0)
    ctx->pc = 0x122770;
    entry_122724(rdram, ctx, runtime);
}

void entry_1227e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1227e8 inside entry_1227e4 (0x1227e4 - 0x1227f0)
    ctx->pc = 0x1227e8;
    entry_1227e4(rdram, ctx, runtime);
}

void entry_122900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122900 inside entry_1228ac (0x1228ac - 0x122920)
    ctx->pc = 0x122900;
    entry_1228ac(rdram, ctx, runtime);
}

void entry_122904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122904 inside entry_1228ac (0x1228ac - 0x122920)
    ctx->pc = 0x122904;
    entry_1228ac(rdram, ctx, runtime);
}

void entry_122960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122960 inside entry_12295c (0x12295c - 0x122968)
    ctx->pc = 0x122960;
    entry_12295c(rdram, ctx, runtime);
}

void entry_122aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122aa8 inside GetActadjPositionGoal__FP6ACTADJfP6VECTORT2 (0x122a80 - 0x122adc)
    ctx->pc = 0x122aa8;
    GetActadjPositionGoal__FP6ACTADJfP6VECTORT2(rdram, ctx, runtime);
}

void entry_122ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122ac4 inside GetActadjPositionGoal__FP6ACTADJfP6VECTORT2 (0x122a80 - 0x122adc)
    ctx->pc = 0x122ac4;
    GetActadjPositionGoal__FP6ACTADJfP6VECTORT2(rdram, ctx, runtime);
}

void entry_122ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122ae4 inside entry_122adc (0x122adc - 0x122af4)
    ctx->pc = 0x122ae4;
    entry_122adc(rdram, ctx, runtime);
}

void entry_122ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122ae8 inside entry_122adc (0x122adc - 0x122af4)
    ctx->pc = 0x122ae8;
    entry_122adc(rdram, ctx, runtime);
}

void entry_122af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122af8 inside entry_122af4 (0x122af4 - 0x122b30)
    ctx->pc = 0x122af8;
    entry_122af4(rdram, ctx, runtime);
}

void entry_122b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122b58 inside GetActadjRotationGoal__FP6ACTADJfP7MATRIX3P6VECTOR (0x122b30 - 0x122b8c)
    ctx->pc = 0x122b58;
    GetActadjRotationGoal__FP6ACTADJfP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_122b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122b74 inside GetActadjRotationGoal__FP6ACTADJfP7MATRIX3P6VECTOR (0x122b30 - 0x122b8c)
    ctx->pc = 0x122b74;
    GetActadjRotationGoal__FP6ACTADJfP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_122b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122b94 inside entry_122b8c (0x122b8c - 0x122ba4)
    ctx->pc = 0x122b94;
    entry_122b8c(rdram, ctx, runtime);
}

void entry_122b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122b98 inside entry_122b8c (0x122b8c - 0x122ba4)
    ctx->pc = 0x122b98;
    entry_122b8c(rdram, ctx, runtime);
}

void entry_122ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122ba8 inside entry_122ba4 (0x122ba4 - 0x122c48)
    ctx->pc = 0x122ba8;
    entry_122ba4(rdram, ctx, runtime);
}

void entry_122c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122c60 inside GetActadjTwistGoal__FP6ACTADJPfT1 (0x122c48 - 0x122c94)
    ctx->pc = 0x122c60;
    GetActadjTwistGoal__FP6ACTADJPfT1(rdram, ctx, runtime);
}

void entry_122c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122c7c inside GetActadjTwistGoal__FP6ACTADJPfT1 (0x122c48 - 0x122c94)
    ctx->pc = 0x122c7c;
    GetActadjTwistGoal__FP6ACTADJPfT1(rdram, ctx, runtime);
}

void entry_122c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122c9c inside entry_122c94 (0x122c94 - 0x122ca4)
    ctx->pc = 0x122c9c;
    entry_122c94(rdram, ctx, runtime);
}

void entry_122ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122ca8 inside entry_122ca4 (0x122ca4 - 0x122cb0)
    ctx->pc = 0x122ca8;
    entry_122ca4(rdram, ctx, runtime);
}

void entry_122cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122cd0 inside GetActadjScale__FP6ACTADJP7MATRIX3 (0x122cb0 - 0x122d04)
    ctx->pc = 0x122cd0;
    GetActadjScale__FP6ACTADJP7MATRIX3(rdram, ctx, runtime);
}

void entry_122cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122cec inside GetActadjScale__FP6ACTADJP7MATRIX3 (0x122cb0 - 0x122d04)
    ctx->pc = 0x122cec;
    GetActadjScale__FP6ACTADJP7MATRIX3(rdram, ctx, runtime);
}

void entry_122d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122d0c inside entry_122d04 (0x122d04 - 0x122d14)
    ctx->pc = 0x122d0c;
    entry_122d04(rdram, ctx, runtime);
}

void entry_122d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122d18 inside entry_122d14 (0x122d14 - 0x122d90)
    ctx->pc = 0x122d18;
    entry_122d14(rdram, ctx, runtime);
}

void entry_122e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122e40 inside GetActbankRotationGoal__FP7ACTBANKfP7MATRIX3P6VECTOR (0x122de0 - 0x122ea8)
    ctx->pc = 0x122e40;
    GetActbankRotationGoal__FP7ACTBANKfP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_122e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122e60 inside GetActbankRotationGoal__FP7ACTBANKfP7MATRIX3P6VECTOR (0x122de0 - 0x122ea8)
    ctx->pc = 0x122e60;
    GetActbankRotationGoal__FP7ACTBANKfP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_122ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122ee8 inside entry_122ea8 (0x122ea8 - 0x122ef8)
    ctx->pc = 0x122ee8;
    entry_122ea8(rdram, ctx, runtime);
}

void entry_122eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122eec inside entry_122ea8 (0x122ea8 - 0x122ef8)
    ctx->pc = 0x122eec;
    entry_122ea8(rdram, ctx, runtime);
}

void entry_122f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x122f60 inside entry_122f54 (0x122f54 - 0x122f6c)
    ctx->pc = 0x122f60;
    entry_122f54(rdram, ctx, runtime);
}

void entry_123070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123070 inside entry_123068 (0x123068 - 0x1230e8)
    ctx->pc = 0x123070;
    entry_123068(rdram, ctx, runtime);
}

void entry_123078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123078 inside entry_123068 (0x123068 - 0x1230e8)
    ctx->pc = 0x123078;
    entry_123068(rdram, ctx, runtime);
}

void entry_1230c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1230c0 inside entry_123068 (0x123068 - 0x1230e8)
    ctx->pc = 0x1230c0;
    entry_123068(rdram, ctx, runtime);
}

void entry_1230c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1230c4 inside entry_123068 (0x123068 - 0x1230e8)
    ctx->pc = 0x1230c4;
    entry_123068(rdram, ctx, runtime);
}

void entry_1230f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1230f0 inside entry_1230e8 (0x1230e8 - 0x123100)
    ctx->pc = 0x1230f0;
    entry_1230e8(rdram, ctx, runtime);
}

void entry_123104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123104 inside entry_123100 (0x123100 - 0x123120)
    ctx->pc = 0x123104;
    entry_123100(rdram, ctx, runtime);
}

void entry_1231b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1231b8 inside entry_1231b0 (0x1231b0 - 0x123230)
    ctx->pc = 0x1231b8;
    entry_1231b0(rdram, ctx, runtime);
}

void entry_1231c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1231c0 inside entry_1231b0 (0x1231b0 - 0x123230)
    ctx->pc = 0x1231c0;
    entry_1231b0(rdram, ctx, runtime);
}

void entry_123208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123208 inside entry_1231b0 (0x1231b0 - 0x123230)
    ctx->pc = 0x123208;
    entry_1231b0(rdram, ctx, runtime);
}

void entry_12320c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12320c inside entry_1231b0 (0x1231b0 - 0x123230)
    ctx->pc = 0x12320c;
    entry_1231b0(rdram, ctx, runtime);
}

void entry_123238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123238 inside entry_123230 (0x123230 - 0x123248)
    ctx->pc = 0x123238;
    entry_123230(rdram, ctx, runtime);
}

void entry_12324c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12324c inside entry_123248 (0x123248 - 0x123270)
    ctx->pc = 0x12324c;
    entry_123248(rdram, ctx, runtime);
}

void entry_1232d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1232d0 inside entry_1232c8 (0x1232c8 - 0x1232dc)
    ctx->pc = 0x1232d0;
    entry_1232c8(rdram, ctx, runtime);
}

void entry_1232e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1232e0 inside entry_1232dc (0x1232dc - 0x1232e8)
    ctx->pc = 0x1232e0;
    entry_1232dc(rdram, ctx, runtime);
}

void entry_12333c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12333c inside entry_123334 (0x123334 - 0x123348)
    ctx->pc = 0x12333c;
    entry_123334(rdram, ctx, runtime);
}

void entry_12334c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12334c inside entry_123348 (0x123348 - 0x123358)
    ctx->pc = 0x12334c;
    entry_123348(rdram, ctx, runtime);
}

void entry_1234c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1234c0 inside entry_123484 (0x123484 - 0x1234cc)
    ctx->pc = 0x1234c0;
    entry_123484(rdram, ctx, runtime);
}

void entry_1234e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1234e0 inside entry_1234cc (0x1234cc - 0x123514)
    ctx->pc = 0x1234e0;
    entry_1234cc(rdram, ctx, runtime);
}

void entry_1234e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1234e4 inside entry_1234cc (0x1234cc - 0x123514)
    ctx->pc = 0x1234e4;
    entry_1234cc(rdram, ctx, runtime);
}

void entry_1234fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1234fc inside entry_1234cc (0x1234cc - 0x123514)
    ctx->pc = 0x1234fc;
    entry_1234cc(rdram, ctx, runtime);
}

void entry_1235f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1235f0 inside entry_1235e8 (0x1235e8 - 0x123614)
    ctx->pc = 0x1235f0;
    entry_1235e8(rdram, ctx, runtime);
}

void entry_1235f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1235f4 inside entry_1235e8 (0x1235e8 - 0x123614)
    ctx->pc = 0x1235f4;
    entry_1235e8(rdram, ctx, runtime);
}

void entry_12361c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12361c inside entry_123614 (0x123614 - 0x123664)
    ctx->pc = 0x12361c;
    entry_123614(rdram, ctx, runtime);
}

void entry_123650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123650 inside entry_123614 (0x123614 - 0x123664)
    ctx->pc = 0x123650;
    entry_123614(rdram, ctx, runtime);
}

void entry_123698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123698 inside entry_123694 (0x123694 - 0x1236c8)
    ctx->pc = 0x123698;
    entry_123694(rdram, ctx, runtime);
}

void entry_1236ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1236ac inside entry_123694 (0x123694 - 0x1236c8)
    ctx->pc = 0x1236ac;
    entry_123694(rdram, ctx, runtime);
}

void entry_1236b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1236b0 inside entry_123694 (0x123694 - 0x1236c8)
    ctx->pc = 0x1236b0;
    entry_123694(rdram, ctx, runtime);
}

void entry_123700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123700 inside PostAlarmLoadCallbackHookup__FP5ALARM5MSGIDPv (0x1236c8 - 0x123714)
    ctx->pc = 0x123700;
    PostAlarmLoadCallbackHookup__FP5ALARM5MSGIDPv(rdram, ctx, runtime);
}

void entry_12373c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12373c inside entry_123738 (0x123738 - 0x12377c)
    ctx->pc = 0x12373c;
    entry_123738(rdram, ctx, runtime);
}

void entry_123750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123750 inside entry_123738 (0x123738 - 0x12377c)
    ctx->pc = 0x123750;
    entry_123738(rdram, ctx, runtime);
}

void entry_123768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123768 inside entry_123738 (0x123738 - 0x12377c)
    ctx->pc = 0x123768;
    entry_123738(rdram, ctx, runtime);
}

void entry_1237d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1237d4 inside entry_1237c0 (0x1237c0 - 0x1237fc)
    ctx->pc = 0x1237d4;
    entry_1237c0(rdram, ctx, runtime);
}

void entry_1237e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1237e8 inside entry_1237c0 (0x1237c0 - 0x1237fc)
    ctx->pc = 0x1237e8;
    entry_1237c0(rdram, ctx, runtime);
}

void entry_123834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123834 inside entry_123820 (0x123820 - 0x123844)
    ctx->pc = 0x123834;
    entry_123820(rdram, ctx, runtime);
}

void entry_12385c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12385c inside entry_123854 (0x123854 - 0x123864)
    ctx->pc = 0x12385c;
    entry_123854(rdram, ctx, runtime);
}

void entry_123868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123868 inside entry_123864 (0x123864 - 0x123888)
    ctx->pc = 0x123868;
    entry_123864(rdram, ctx, runtime);
}

void entry_123914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123914 inside entry_123910 (0x123910 - 0x123968)
    ctx->pc = 0x123914;
    entry_123910(rdram, ctx, runtime);
}

void entry_123944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123944 inside entry_123910 (0x123910 - 0x123968)
    ctx->pc = 0x123944;
    entry_123910(rdram, ctx, runtime);
}

void entry_123954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123954 inside entry_123910 (0x123910 - 0x123968)
    ctx->pc = 0x123954;
    entry_123910(rdram, ctx, runtime);
}

void entry_123978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123978 inside entry_123970 (0x123970 - 0x12398c)
    ctx->pc = 0x123978;
    entry_123970(rdram, ctx, runtime);
}

void entry_123990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123990 inside entry_12398c (0x12398c - 0x123998)
    ctx->pc = 0x123990;
    entry_12398c(rdram, ctx, runtime);
}

void entry_1239c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1239c8 inside entry_1239c0 (0x1239c0 - 0x1239dc)
    ctx->pc = 0x1239c8;
    entry_1239c0(rdram, ctx, runtime);
}

void entry_1239e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1239e0 inside entry_1239dc (0x1239dc - 0x1239e8)
    ctx->pc = 0x1239e0;
    entry_1239dc(rdram, ctx, runtime);
}

void entry_1239f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1239f0 inside entry_1239e8 (0x1239e8 - 0x123a04)
    ctx->pc = 0x1239f0;
    entry_1239e8(rdram, ctx, runtime);
}

void entry_123a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123a08 inside entry_123a04 (0x123a04 - 0x123a4c)
    ctx->pc = 0x123a08;
    entry_123a04(rdram, ctx, runtime);
}

void entry_123a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123a9c inside entry_123a98 (0x123a98 - 0x123ab0)
    ctx->pc = 0x123a9c;
    entry_123a98(rdram, ctx, runtime);
}

void entry_123aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123aa0 inside entry_123a98 (0x123a98 - 0x123ab0)
    ctx->pc = 0x123aa0;
    entry_123a98(rdram, ctx, runtime);
}

void entry_123adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123adc inside TriggerAlarm__FP5ALARM4ALTK (0x123ab0 - 0x123b08)
    ctx->pc = 0x123adc;
    TriggerAlarm__FP5ALARM4ALTK(rdram, ctx, runtime);
}

void entry_123aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123aec inside TriggerAlarm__FP5ALARM4ALTK (0x123ab0 - 0x123b08)
    ctx->pc = 0x123aec;
    TriggerAlarm__FP5ALARM4ALTK(rdram, ctx, runtime);
}

void entry_123af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123af4 inside TriggerAlarm__FP5ALARM4ALTK (0x123ab0 - 0x123b08)
    ctx->pc = 0x123af4;
    TriggerAlarm__FP5ALARM4ALTK(rdram, ctx, runtime);
}

void entry_123afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123afc inside TriggerAlarm__FP5ALARM4ALTK (0x123ab0 - 0x123b08)
    ctx->pc = 0x123afc;
    TriggerAlarm__FP5ALARM4ALTK(rdram, ctx, runtime);
}

void entry_123b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123b00 inside TriggerAlarm__FP5ALARM4ALTK (0x123ab0 - 0x123b08)
    ctx->pc = 0x123b00;
    TriggerAlarm__FP5ALARM4ALTK(rdram, ctx, runtime);
}

void entry_123b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123b0c inside entry_123b08 (0x123b08 - 0x123b18)
    ctx->pc = 0x123b0c;
    entry_123b08(rdram, ctx, runtime);
}

void entry_123b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123b58 inside EnableAlarmSensors__FP5ALARM (0x123b28 - 0x123b80)
    ctx->pc = 0x123b58;
    EnableAlarmSensors__FP5ALARM(rdram, ctx, runtime);
}

void entry_123b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123b84 inside entry_123b80 (0x123b80 - 0x123bb0)
    ctx->pc = 0x123b84;
    entry_123b80(rdram, ctx, runtime);
}

void entry_123b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123b94 inside entry_123b80 (0x123b80 - 0x123bb0)
    ctx->pc = 0x123b94;
    entry_123b80(rdram, ctx, runtime);
}

void entry_123bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123bd8 inside DisableAlarmSensors__FP5ALARM (0x123bb0 - 0x123bf4)
    ctx->pc = 0x123bd8;
    DisableAlarmSensors__FP5ALARM(rdram, ctx, runtime);
}

void entry_123bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123bf8 inside entry_123bf4 (0x123bf4 - 0x123c20)
    ctx->pc = 0x123bf8;
    entry_123bf4(rdram, ctx, runtime);
}

void entry_123c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123c08 inside entry_123bf4 (0x123bf4 - 0x123c20)
    ctx->pc = 0x123c08;
    entry_123bf4(rdram, ctx, runtime);
}

void entry_123c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123c48 inside NotifyAlarmSensorsOnTrigger__FP5ALARM (0x123c20 - 0x123c64)
    ctx->pc = 0x123c48;
    NotifyAlarmSensorsOnTrigger__FP5ALARM(rdram, ctx, runtime);
}

void entry_123c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123c68 inside entry_123c64 (0x123c64 - 0x123c90)
    ctx->pc = 0x123c68;
    entry_123c64(rdram, ctx, runtime);
}

void entry_123c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123c78 inside entry_123c64 (0x123c64 - 0x123c90)
    ctx->pc = 0x123c78;
    entry_123c64(rdram, ctx, runtime);
}

void entry_123cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123cb0 inside AddAlarmAlbrk__FP5ALARM3OID (0x123c90 - 0x123cb8)
    ctx->pc = 0x123cb0;
    AddAlarmAlbrk__FP5ALARM3OID(rdram, ctx, runtime);
}

void entry_123cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123cd8 inside AddAlarmSensor__FP5ALARM3OID (0x123cb8 - 0x123ce0)
    ctx->pc = 0x123cd8;
    AddAlarmSensor__FP5ALARM3OID(rdram, ctx, runtime);
}

void entry_123d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123d00 inside AddAlarmStepguard__FP5ALARM3OID (0x123ce0 - 0x123d08)
    ctx->pc = 0x123d00;
    AddAlarmStepguard__FP5ALARM3OID(rdram, ctx, runtime);
}

void entry_123d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123d70 inside FGetAlarmSensorList__FP5ALARMPv (0x123d40 - 0x123d7c)
    ctx->pc = 0x123d70;
    FGetAlarmSensorList__FP5ALARMPv(rdram, ctx, runtime);
}

void entry_123d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123d8c inside entry_123d7c (0x123d7c - 0x123dc0)
    ctx->pc = 0x123d8c;
    entry_123d7c(rdram, ctx, runtime);
}

void entry_123d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123d9c inside entry_123d7c (0x123d7c - 0x123dc0)
    ctx->pc = 0x123d9c;
    entry_123d7c(rdram, ctx, runtime);
}

void entry_123da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123da0 inside entry_123d7c (0x123d7c - 0x123dc0)
    ctx->pc = 0x123da0;
    entry_123d7c(rdram, ctx, runtime);
}

void entry_123df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123df8 inside FIsZeroV__FP6VECTOR (0x123dc0 - 0x123e00)
    ctx->pc = 0x123df8;
    FIsZeroV__FP6VECTOR(rdram, ctx, runtime);
}

void entry_123e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123e3c inside FIsZeroW__FP6VECTOR (0x123e00 - 0x123e48)
    ctx->pc = 0x123e3c;
    FIsZeroW__FP6VECTOR(rdram, ctx, runtime);
}

void entry_123e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123e80 inside FIsZeroDv__FP6VECTOR (0x123e48 - 0x123e88)
    ctx->pc = 0x123e80;
    FIsZeroDv__FP6VECTOR(rdram, ctx, runtime);
}

void entry_123ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123ec4 inside FIsZeroDw__FP6VECTOR (0x123e88 - 0x123ed0)
    ctx->pc = 0x123ec4;
    FIsZeroDw__FP6VECTOR(rdram, ctx, runtime);
}

void entry_123f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123f28 inside entry_123ef8 (0x123ef8 - 0x123f5c)
    ctx->pc = 0x123f28;
    entry_123ef8(rdram, ctx, runtime);
}

void entry_123f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x123f50 inside entry_123ef8 (0x123ef8 - 0x123f5c)
    ctx->pc = 0x123f50;
    entry_123ef8(rdram, ctx, runtime);
}

void entry_124098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124098 inside AddAloHierarchy__FP3ALO (0x124050 - 0x1240a8)
    ctx->pc = 0x124098;
    AddAloHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_1240a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1240a0 inside AddAloHierarchy__FP3ALO (0x124050 - 0x1240a8)
    ctx->pc = 0x1240a0;
    AddAloHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_124144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124144 inside entry_12413c (0x12413c - 0x124150)
    ctx->pc = 0x124144;
    entry_12413c(rdram, ctx, runtime);
}

void entry_1241b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1241b8 inside entry_12418c (0x12418c - 0x1241c8)
    ctx->pc = 0x1241b8;
    entry_12418c(rdram, ctx, runtime);
}

void entry_1241d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1241d8 inside entry_1241c8 (0x1241c8 - 0x124210)
    ctx->pc = 0x1241d8;
    entry_1241c8(rdram, ctx, runtime);
}

void entry_124214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124214 inside entry_124210 (0x124210 - 0x124234)
    ctx->pc = 0x124214;
    entry_124210(rdram, ctx, runtime);
}

void entry_1242e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1242e8 inside entry_1242e4 (0x1242e4 - 0x1242fc)
    ctx->pc = 0x1242e8;
    entry_1242e4(rdram, ctx, runtime);
}

void entry_124300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124300 inside entry_1242fc (0x1242fc - 0x124310)
    ctx->pc = 0x124300;
    entry_1242fc(rdram, ctx, runtime);
}

void entry_124380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124380 inside RemoveAloHierarchy__FP3ALO (0x124338 - 0x124390)
    ctx->pc = 0x124380;
    RemoveAloHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_124388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124388 inside RemoveAloHierarchy__FP3ALO (0x124338 - 0x124390)
    ctx->pc = 0x124388;
    RemoveAloHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_124420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124420 inside entry_124418 (0x124418 - 0x12442c)
    ctx->pc = 0x124420;
    entry_124418(rdram, ctx, runtime);
}

void entry_1244a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1244a0 inside entry_12449c (0x12449c - 0x1244c0)
    ctx->pc = 0x1244a0;
    entry_12449c(rdram, ctx, runtime);
}

void entry_1244dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1244dc inside entry_1244d8 (0x1244d8 - 0x124508)
    ctx->pc = 0x1244dc;
    entry_1244d8(rdram, ctx, runtime);
}

void entry_124630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124630 inside entry_124628 (0x124628 - 0x124658)
    ctx->pc = 0x124630;
    entry_124628(rdram, ctx, runtime);
}

void entry_124648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124648 inside entry_124628 (0x124628 - 0x124658)
    ctx->pc = 0x124648;
    entry_124628(rdram, ctx, runtime);
}

void entry_1246c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1246c4 inside entry_1246a4 (0x1246a4 - 0x1246dc)
    ctx->pc = 0x1246c4;
    entry_1246a4(rdram, ctx, runtime);
}

void entry_124778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124778 inside entry_12471c (0x12471c - 0x124830)
    ctx->pc = 0x124778;
    entry_12471c(rdram, ctx, runtime);
}

void entry_1247a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1247a4 inside entry_12471c (0x12471c - 0x124830)
    ctx->pc = 0x1247a4;
    entry_12471c(rdram, ctx, runtime);
}

void entry_1247dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1247dc inside entry_12471c (0x12471c - 0x124830)
    ctx->pc = 0x1247dc;
    entry_12471c(rdram, ctx, runtime);
}

void entry_124818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124818 inside entry_12471c (0x12471c - 0x124830)
    ctx->pc = 0x124818;
    entry_12471c(rdram, ctx, runtime);
}

void entry_124824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124824 inside entry_12471c (0x12471c - 0x124830)
    ctx->pc = 0x124824;
    entry_12471c(rdram, ctx, runtime);
}

void entry_124828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124828 inside entry_12471c (0x12471c - 0x124830)
    ctx->pc = 0x124828;
    entry_12471c(rdram, ctx, runtime);
}

void entry_124848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124848 inside entry_124844 (0x124844 - 0x124868)
    ctx->pc = 0x124848;
    entry_124844(rdram, ctx, runtime);
}

void entry_1249fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1249fc inside entry_1249f8 (0x1249f8 - 0x124a04)
    ctx->pc = 0x1249fc;
    entry_1249f8(rdram, ctx, runtime);
}

void entry_124a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124a18 inside entry_124a04 (0x124a04 - 0x124a2c)
    ctx->pc = 0x124a18;
    entry_124a04(rdram, ctx, runtime);
}

void entry_124a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124a30 inside entry_124a2c (0x124a2c - 0x124a48)
    ctx->pc = 0x124a30;
    entry_124a2c(rdram, ctx, runtime);
}

void entry_124a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124a3c inside entry_124a2c (0x124a2c - 0x124a48)
    ctx->pc = 0x124a3c;
    entry_124a2c(rdram, ctx, runtime);
}

void entry_124ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124ab8 inside entry_124a90 (0x124a90 - 0x124ad0)
    ctx->pc = 0x124ab8;
    entry_124a90(rdram, ctx, runtime);
}

void entry_124ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124ad4 inside entry_124ad0 (0x124ad0 - 0x124adc)
    ctx->pc = 0x124ad4;
    entry_124ad0(rdram, ctx, runtime);
}

void entry_124b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124b20 inside entry_124b1c (0x124b1c - 0x124b3c)
    ctx->pc = 0x124b20;
    entry_124b1c(rdram, ctx, runtime);
}

void entry_124b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124b68 inside entry_124b64 (0x124b64 - 0x124bb4)
    ctx->pc = 0x124b68;
    entry_124b64(rdram, ctx, runtime);
}

void entry_124b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124b7c inside entry_124b64 (0x124b64 - 0x124bb4)
    ctx->pc = 0x124b7c;
    entry_124b64(rdram, ctx, runtime);
}

void entry_124bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124bd0 inside entry_124bc8 (0x124bc8 - 0x124be8)
    ctx->pc = 0x124bd0;
    entry_124bc8(rdram, ctx, runtime);
}

void entry_124be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124be0 inside entry_124bc8 (0x124bc8 - 0x124be8)
    ctx->pc = 0x124be0;
    entry_124bc8(rdram, ctx, runtime);
}

void entry_124c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124c10 inside entry_124c04 (0x124c04 - 0x124c18)
    ctx->pc = 0x124c10;
    entry_124c04(rdram, ctx, runtime);
}

void entry_124c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124c38 inside entry_124c34 (0x124c34 - 0x124c44)
    ctx->pc = 0x124c38;
    entry_124c34(rdram, ctx, runtime);
}

void entry_124c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124c48 inside entry_124c44 (0x124c44 - 0x124c80)
    ctx->pc = 0x124c48;
    entry_124c44(rdram, ctx, runtime);
}

void entry_124c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124c54 inside entry_124c44 (0x124c44 - 0x124c80)
    ctx->pc = 0x124c54;
    entry_124c44(rdram, ctx, runtime);
}

void entry_124c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124c70 inside entry_124c44 (0x124c44 - 0x124c80)
    ctx->pc = 0x124c70;
    entry_124c44(rdram, ctx, runtime);
}

void entry_124c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124c9c inside entry_124c80 (0x124c80 - 0x124cc0)
    ctx->pc = 0x124c9c;
    entry_124c80(rdram, ctx, runtime);
}

void entry_124d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124d00 inside entry_124cfc (0x124cfc - 0x124dac)
    ctx->pc = 0x124d00;
    entry_124cfc(rdram, ctx, runtime);
}

void entry_124d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124d2c inside entry_124cfc (0x124cfc - 0x124dac)
    ctx->pc = 0x124d2c;
    entry_124cfc(rdram, ctx, runtime);
}

void entry_124d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124d3c inside entry_124cfc (0x124cfc - 0x124dac)
    ctx->pc = 0x124d3c;
    entry_124cfc(rdram, ctx, runtime);
}

void entry_124d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124d48 inside entry_124cfc (0x124cfc - 0x124dac)
    ctx->pc = 0x124d48;
    entry_124cfc(rdram, ctx, runtime);
}

void entry_124d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124d7c inside entry_124cfc (0x124cfc - 0x124dac)
    ctx->pc = 0x124d7c;
    entry_124cfc(rdram, ctx, runtime);
}

void entry_124d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124d80 inside entry_124cfc (0x124cfc - 0x124dac)
    ctx->pc = 0x124d80;
    entry_124cfc(rdram, ctx, runtime);
}

void entry_124d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124d8c inside entry_124cfc (0x124cfc - 0x124dac)
    ctx->pc = 0x124d8c;
    entry_124cfc(rdram, ctx, runtime);
}

void entry_124de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124de4 inside entry_124ddc (0x124ddc - 0x124df8)
    ctx->pc = 0x124de4;
    entry_124ddc(rdram, ctx, runtime);
}

void entry_124e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124e30 inside SnipAloObjects__FP3ALOiP4SNIP (0x124df8 - 0x124e5c)
    ctx->pc = 0x124e30;
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime);
}

void entry_124e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124e88 inside entry_124e5c (0x124e5c - 0x124e9c)
    ctx->pc = 0x124e88;
    entry_124e5c(rdram, ctx, runtime);
}

void entry_124ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124ea0 inside entry_124e9c (0x124e9c - 0x124eb4)
    ctx->pc = 0x124ea0;
    entry_124e9c(rdram, ctx, runtime);
}

void entry_124eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124eb8 inside entry_124eb4 (0x124eb4 - 0x124ee8)
    ctx->pc = 0x124eb8;
    entry_124eb4(rdram, ctx, runtime);
}

void entry_124ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124ec0 inside entry_124eb4 (0x124eb4 - 0x124ee8)
    ctx->pc = 0x124ec0;
    entry_124eb4(rdram, ctx, runtime);
}

void entry_124f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124f68 inside entry_124f20 (0x124f20 - 0x124f84)
    ctx->pc = 0x124f68;
    entry_124f20(rdram, ctx, runtime);
}

void entry_124f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124f88 inside entry_124f84 (0x124f84 - 0x124fc0)
    ctx->pc = 0x124f88;
    entry_124f84(rdram, ctx, runtime);
}

void entry_124f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124f9c inside entry_124f84 (0x124f84 - 0x124fc0)
    ctx->pc = 0x124f9c;
    entry_124f84(rdram, ctx, runtime);
}

void entry_124fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x124fa8 inside entry_124f84 (0x124f84 - 0x124fc0)
    ctx->pc = 0x124fa8;
    entry_124f84(rdram, ctx, runtime);
}

void entry_125004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125004 inside entry_125000 (0x125000 - 0x125014)
    ctx->pc = 0x125004;
    entry_125000(rdram, ctx, runtime);
}

void entry_125058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125058 inside entry_125014 (0x125014 - 0x125070)
    ctx->pc = 0x125058;
    entry_125014(rdram, ctx, runtime);
}

void entry_125074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125074 inside entry_125070 (0x125070 - 0x1250a8)
    ctx->pc = 0x125074;
    entry_125070(rdram, ctx, runtime);
}

void entry_125088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125088 inside entry_125070 (0x125070 - 0x1250a8)
    ctx->pc = 0x125088;
    entry_125070(rdram, ctx, runtime);
}

void entry_1250e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1250e0 inside InvalidateAloLighting__FP3ALO (0x1250c8 - 0x125108)
    ctx->pc = 0x1250e0;
    InvalidateAloLighting__FP3ALO(rdram, ctx, runtime);
}

void entry_125100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125100 inside InvalidateAloLighting__FP3ALO (0x1250c8 - 0x125108)
    ctx->pc = 0x125100;
    InvalidateAloLighting__FP3ALO(rdram, ctx, runtime);
}

void entry_12512c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12512c inside entry_125128 (0x125128 - 0x125138)
    ctx->pc = 0x12512c;
    entry_125128(rdram, ctx, runtime);
}

void entry_125174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125174 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x125174;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_1251a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1251a8 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x1251a8;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_1251b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1251b0 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x1251b0;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_1251c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1251c8 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x1251c8;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_125228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125228 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x125228;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_125244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125244 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x125244;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_125248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125248 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x125248;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_1252cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1252cc inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x1252cc;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_1252e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1252e0 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x1252e0;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_125300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125300 inside UpdateAloXfWorldHierarchy__FP3ALO (0x125138 - 0x125338)
    ctx->pc = 0x125300;
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime);
}

void entry_125340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125340 inside entry_125338 (0x125338 - 0x125360)
    ctx->pc = 0x125340;
    entry_125338(rdram, ctx, runtime);
}

void entry_125350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125350 inside entry_125338 (0x125338 - 0x125360)
    ctx->pc = 0x125350;
    entry_125338(rdram, ctx, runtime);
}

void entry_1253b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1253b8 inside entry_1253b4 (0x1253b4 - 0x1253dc)
    ctx->pc = 0x1253b8;
    entry_1253b4(rdram, ctx, runtime);
}

void entry_1253c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1253c8 inside entry_1253b4 (0x1253b4 - 0x1253dc)
    ctx->pc = 0x1253c8;
    entry_1253b4(rdram, ctx, runtime);
}

void entry_1253e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1253e0 inside entry_1253dc (0x1253dc - 0x125438)
    ctx->pc = 0x1253e0;
    entry_1253dc(rdram, ctx, runtime);
}

void entry_1253ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1253ec inside entry_1253dc (0x1253dc - 0x125438)
    ctx->pc = 0x1253ec;
    entry_1253dc(rdram, ctx, runtime);
}

void entry_125420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125420 inside entry_1253dc (0x1253dc - 0x125438)
    ctx->pc = 0x125420;
    entry_1253dc(rdram, ctx, runtime);
}

void entry_125424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125424 inside entry_1253dc (0x1253dc - 0x125438)
    ctx->pc = 0x125424;
    entry_1253dc(rdram, ctx, runtime);
}

void entry_1254a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1254a0 inside ProjectAloTransform__FP3ALOfi (0x125440 - 0x1254c4)
    ctx->pc = 0x1254a0;
    ProjectAloTransform__FP3ALOfi(rdram, ctx, runtime);
}

void entry_1254e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1254e8 inside entry_1254e0 (0x1254e0 - 0x1254f0)
    ctx->pc = 0x1254e8;
    entry_1254e0(rdram, ctx, runtime);
}

void entry_125508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125508 inside entry_125500 (0x125500 - 0x12558c)
    ctx->pc = 0x125508;
    entry_125500(rdram, ctx, runtime);
}

void entry_125570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125570 inside entry_125500 (0x125500 - 0x12558c)
    ctx->pc = 0x125570;
    entry_125500(rdram, ctx, runtime);
}

void entry_125594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125594 inside entry_12558c (0x12558c - 0x12559c)
    ctx->pc = 0x125594;
    entry_12558c(rdram, ctx, runtime);
}

void entry_1255b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1255b8 inside entry_1255ac (0x1255ac - 0x125618)
    ctx->pc = 0x1255b8;
    entry_1255ac(rdram, ctx, runtime);
}

void entry_125688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125688 inside entry_125684 (0x125684 - 0x1256e0)
    ctx->pc = 0x125688;
    entry_125684(rdram, ctx, runtime);
}

void entry_1256c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1256c0 inside entry_125684 (0x125684 - 0x1256e0)
    ctx->pc = 0x1256c0;
    entry_125684(rdram, ctx, runtime);
}

void entry_1256f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1256f8 inside entry_1256e0 (0x1256e0 - 0x125720)
    ctx->pc = 0x1256f8;
    entry_1256e0(rdram, ctx, runtime);
}

void entry_125724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125724 inside entry_125720 (0x125720 - 0x125750)
    ctx->pc = 0x125724;
    entry_125720(rdram, ctx, runtime);
}

void entry_125728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125728 inside entry_125720 (0x125720 - 0x125750)
    ctx->pc = 0x125728;
    entry_125720(rdram, ctx, runtime);
}

void entry_1257a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1257a0 inside PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x125750 - 0x12584c)
    ctx->pc = 0x1257a0;
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_1257c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1257c8 inside PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x125750 - 0x12584c)
    ctx->pc = 0x1257c8;
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_1257cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1257cc inside PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x125750 - 0x12584c)
    ctx->pc = 0x1257cc;
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_1257d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1257d4 inside PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x125750 - 0x12584c)
    ctx->pc = 0x1257d4;
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_125820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125820 inside PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x125750 - 0x12584c)
    ctx->pc = 0x125820;
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_125830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125830 inside PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x125750 - 0x12584c)
    ctx->pc = 0x125830;
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_1258ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1258ac inside entry_12584c (0x12584c - 0x1258c8)
    ctx->pc = 0x1258ac;
    entry_12584c(rdram, ctx, runtime);
}

void entry_1258b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1258b0 inside entry_12584c (0x12584c - 0x1258c8)
    ctx->pc = 0x1258b0;
    entry_12584c(rdram, ctx, runtime);
}

void entry_1258d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1258d8 inside entry_1258c8 (0x1258c8 - 0x1259d8)
    ctx->pc = 0x1258d8;
    entry_1258c8(rdram, ctx, runtime);
}

void entry_125900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125900 inside entry_1258c8 (0x1258c8 - 0x1259d8)
    ctx->pc = 0x125900;
    entry_1258c8(rdram, ctx, runtime);
}

void entry_125968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125968 inside entry_1258c8 (0x1258c8 - 0x1259d8)
    ctx->pc = 0x125968;
    entry_1258c8(rdram, ctx, runtime);
}

void entry_125974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125974 inside entry_1258c8 (0x1258c8 - 0x1259d8)
    ctx->pc = 0x125974;
    entry_1258c8(rdram, ctx, runtime);
}

void entry_125990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125990 inside entry_1258c8 (0x1258c8 - 0x1259d8)
    ctx->pc = 0x125990;
    entry_1258c8(rdram, ctx, runtime);
}

void entry_12599c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12599c inside entry_1258c8 (0x1258c8 - 0x1259d8)
    ctx->pc = 0x12599c;
    entry_1258c8(rdram, ctx, runtime);
}

void entry_1259a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1259a8 inside entry_1258c8 (0x1258c8 - 0x1259d8)
    ctx->pc = 0x1259a8;
    entry_1258c8(rdram, ctx, runtime);
}

void entry_125a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125a0c inside PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x1259d8 - 0x125a34)
    ctx->pc = 0x125a0c;
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_125a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125a10 inside PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x1259d8 - 0x125a34)
    ctx->pc = 0x125a10;
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_125a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125a28 inside PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x1259d8 - 0x125a34)
    ctx->pc = 0x125a28;
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_125a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125a2c inside PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3 (0x1259d8 - 0x125a34)
    ctx->pc = 0x125a2c;
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_125a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125a4c inside entry_125a34 (0x125a34 - 0x125b70)
    ctx->pc = 0x125a4c;
    entry_125a34(rdram, ctx, runtime);
}

void entry_125a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125a78 inside entry_125a34 (0x125a34 - 0x125b70)
    ctx->pc = 0x125a78;
    entry_125a34(rdram, ctx, runtime);
}

void entry_125a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125a80 inside entry_125a34 (0x125a34 - 0x125b70)
    ctx->pc = 0x125a80;
    entry_125a34(rdram, ctx, runtime);
}

void entry_125ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125ac4 inside entry_125a34 (0x125a34 - 0x125b70)
    ctx->pc = 0x125ac4;
    entry_125a34(rdram, ctx, runtime);
}

void entry_125af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125af0 inside entry_125a34 (0x125a34 - 0x125b70)
    ctx->pc = 0x125af0;
    entry_125a34(rdram, ctx, runtime);
}

void entry_125b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125b54 inside entry_125a34 (0x125a34 - 0x125b70)
    ctx->pc = 0x125b54;
    entry_125a34(rdram, ctx, runtime);
}

void entry_125b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125b8c inside DupAloRo__FP3ALOP2ROT1 (0x125b70 - 0x125bcc)
    ctx->pc = 0x125b8c;
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime);
}

void entry_125bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125bb4 inside DupAloRo__FP3ALOP2ROT1 (0x125b70 - 0x125bcc)
    ctx->pc = 0x125bb4;
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime);
}

void entry_125bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125bdc inside entry_125bcc (0x125bcc - 0x125bf0)
    ctx->pc = 0x125bdc;
    entry_125bcc(rdram, ctx, runtime);
}

void entry_125d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125d08 inside RenderAloAll__FP3ALOP2CMP2RO (0x125c90 - 0x125d9c)
    ctx->pc = 0x125d08;
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime);
}

void entry_125de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125de4 inside entry_125dcc (0x125dcc - 0x125e08)
    ctx->pc = 0x125de4;
    entry_125dcc(rdram, ctx, runtime);
}

void entry_125e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125e10 inside entry_125e08 (0x125e08 - 0x125e34)
    ctx->pc = 0x125e10;
    entry_125e08(rdram, ctx, runtime);
}

void entry_125e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125e48 inside entry_125e34 (0x125e34 - 0x125e60)
    ctx->pc = 0x125e48;
    entry_125e34(rdram, ctx, runtime);
}

void entry_125e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125e4c inside entry_125e34 (0x125e34 - 0x125e60)
    ctx->pc = 0x125e4c;
    entry_125e34(rdram, ctx, runtime);
}

void entry_125e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125e78 inside entry_125e60 (0x125e60 - 0x125eec)
    ctx->pc = 0x125e78;
    entry_125e60(rdram, ctx, runtime);
}

void entry_125fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x125fa0 inside entry_125f98 (0x125f98 - 0x125fb8)
    ctx->pc = 0x125fa0;
    entry_125f98(rdram, ctx, runtime);
}

void entry_126014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126014 inside entry_125ff0 (0x125ff0 - 0x12602c)
    ctx->pc = 0x126014;
    entry_125ff0(rdram, ctx, runtime);
}

void entry_126040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126040 inside entry_12602c (0x12602c - 0x126060)
    ctx->pc = 0x126040;
    entry_12602c(rdram, ctx, runtime);
}

void entry_126074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126074 inside entry_126060 (0x126060 - 0x1260c8)
    ctx->pc = 0x126074;
    entry_126060(rdram, ctx, runtime);
}

void entry_126090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126090 inside entry_126060 (0x126060 - 0x1260c8)
    ctx->pc = 0x126090;
    entry_126060(rdram, ctx, runtime);
}

void entry_1260f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1260f4 inside entry_1260e8 (0x1260e8 - 0x126104)
    ctx->pc = 0x1260f4;
    entry_1260e8(rdram, ctx, runtime);
}

void entry_1260f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1260f8 inside entry_1260e8 (0x1260e8 - 0x126104)
    ctx->pc = 0x1260f8;
    entry_1260e8(rdram, ctx, runtime);
}

void entry_12610c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12610c inside entry_126104 (0x126104 - 0x126114)
    ctx->pc = 0x12610c;
    entry_126104(rdram, ctx, runtime);
}

void entry_126160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126160 inside entry_12615c (0x12615c - 0x12618c)
    ctx->pc = 0x126160;
    entry_12615c(rdram, ctx, runtime);
}

void entry_126168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126168 inside entry_12615c (0x12615c - 0x12618c)
    ctx->pc = 0x126168;
    entry_12615c(rdram, ctx, runtime);
}

void entry_12616c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12616c inside entry_12615c (0x12615c - 0x12618c)
    ctx->pc = 0x12616c;
    entry_12615c(rdram, ctx, runtime);
}

void entry_126190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126190 inside entry_12618c (0x12618c - 0x1261c0)
    ctx->pc = 0x126190;
    entry_12618c(rdram, ctx, runtime);
}

void entry_12623c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12623c inside entry_1261ec (0x1261ec - 0x126258)
    ctx->pc = 0x12623c;
    entry_1261ec(rdram, ctx, runtime);
}

void entry_126240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126240 inside entry_1261ec (0x1261ec - 0x126258)
    ctx->pc = 0x126240;
    entry_1261ec(rdram, ctx, runtime);
}

void entry_126244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126244 inside entry_1261ec (0x1261ec - 0x126258)
    ctx->pc = 0x126244;
    entry_1261ec(rdram, ctx, runtime);
}

void entry_126310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126310 inside entry_1262e0 (0x1262e0 - 0x12639c)
    ctx->pc = 0x126310;
    entry_1262e0(rdram, ctx, runtime);
}

void entry_126364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126364 inside entry_1262e0 (0x1262e0 - 0x12639c)
    ctx->pc = 0x126364;
    entry_1262e0(rdram, ctx, runtime);
}

void entry_126388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126388 inside entry_1262e0 (0x1262e0 - 0x12639c)
    ctx->pc = 0x126388;
    entry_1262e0(rdram, ctx, runtime);
}

void entry_12647c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12647c inside entry_12646c (0x12646c - 0x1265d0)
    ctx->pc = 0x12647c;
    entry_12646c(rdram, ctx, runtime);
}

void entry_12648c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12648c inside entry_12646c (0x12646c - 0x1265d0)
    ctx->pc = 0x12648c;
    entry_12646c(rdram, ctx, runtime);
}

void entry_1264e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1264e0 inside entry_12646c (0x12646c - 0x1265d0)
    ctx->pc = 0x1264e0;
    entry_12646c(rdram, ctx, runtime);
}

void entry_1264e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1264e4 inside entry_12646c (0x12646c - 0x1265d0)
    ctx->pc = 0x1264e4;
    entry_12646c(rdram, ctx, runtime);
}

void entry_1264e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1264e8 inside entry_12646c (0x12646c - 0x1265d0)
    ctx->pc = 0x1264e8;
    entry_12646c(rdram, ctx, runtime);
}

void entry_126558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126558 inside entry_12646c (0x12646c - 0x1265d0)
    ctx->pc = 0x126558;
    entry_12646c(rdram, ctx, runtime);
}

void entry_126564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126564 inside entry_12646c (0x12646c - 0x1265d0)
    ctx->pc = 0x126564;
    entry_12646c(rdram, ctx, runtime);
}

void entry_1265e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1265e0 inside entry_1265d0 (0x1265d0 - 0x12663c)
    ctx->pc = 0x1265e0;
    entry_1265d0(rdram, ctx, runtime);
}

void entry_126614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126614 inside entry_1265d0 (0x1265d0 - 0x12663c)
    ctx->pc = 0x126614;
    entry_1265d0(rdram, ctx, runtime);
}

void entry_126648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126648 inside entry_12663c (0x12663c - 0x126730)
    ctx->pc = 0x126648;
    entry_12663c(rdram, ctx, runtime);
}

void entry_126654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126654 inside entry_12663c (0x12663c - 0x126730)
    ctx->pc = 0x126654;
    entry_12663c(rdram, ctx, runtime);
}

void entry_126690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126690 inside entry_12663c (0x12663c - 0x126730)
    ctx->pc = 0x126690;
    entry_12663c(rdram, ctx, runtime);
}

void entry_1266ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1266ac inside entry_12663c (0x12663c - 0x126730)
    ctx->pc = 0x1266ac;
    entry_12663c(rdram, ctx, runtime);
}

void entry_126708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126708 inside entry_12663c (0x12663c - 0x126730)
    ctx->pc = 0x126708;
    entry_12663c(rdram, ctx, runtime);
}

void entry_12670c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12670c inside entry_12663c (0x12663c - 0x126730)
    ctx->pc = 0x12670c;
    entry_12663c(rdram, ctx, runtime);
}

void entry_126734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126734 inside entry_126730 (0x126730 - 0x126778)
    ctx->pc = 0x126734;
    entry_126730(rdram, ctx, runtime);
}

void entry_126748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126748 inside entry_126730 (0x126730 - 0x126778)
    ctx->pc = 0x126748;
    entry_126730(rdram, ctx, runtime);
}

void entry_126798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126798 inside entry_126778 (0x126778 - 0x1267b4)
    ctx->pc = 0x126798;
    entry_126778(rdram, ctx, runtime);
}

void entry_1267e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1267e0 inside entry_1267bc (0x1267bc - 0x1267e8)
    ctx->pc = 0x1267e0;
    entry_1267bc(rdram, ctx, runtime);
}

void entry_1267ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1267ec inside entry_1267e8 (0x1267e8 - 0x126814)
    ctx->pc = 0x1267ec;
    entry_1267e8(rdram, ctx, runtime);
}

void entry_1267fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1267fc inside entry_1267e8 (0x1267e8 - 0x126814)
    ctx->pc = 0x1267fc;
    entry_1267e8(rdram, ctx, runtime);
}

void entry_126830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126830 inside entry_126814 (0x126814 - 0x12684c)
    ctx->pc = 0x126830;
    entry_126814(rdram, ctx, runtime);
}

void entry_126854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126854 inside entry_12684c (0x12684c - 0x1268b8)
    ctx->pc = 0x126854;
    entry_12684c(rdram, ctx, runtime);
}

void entry_12686c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12686c inside entry_12684c (0x12684c - 0x1268b8)
    ctx->pc = 0x12686c;
    entry_12684c(rdram, ctx, runtime);
}

void entry_12687c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12687c inside entry_12684c (0x12684c - 0x1268b8)
    ctx->pc = 0x12687c;
    entry_12684c(rdram, ctx, runtime);
}

void entry_126880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126880 inside entry_12684c (0x12684c - 0x1268b8)
    ctx->pc = 0x126880;
    entry_12684c(rdram, ctx, runtime);
}

void entry_126958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126958 inside RenderAloLine__FP3ALOP2CMP6VECTORT2ff (0x1268b8 - 0x126a08)
    ctx->pc = 0x126958;
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime);
}

void entry_126968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126968 inside RenderAloLine__FP3ALOP2CMP6VECTORT2ff (0x1268b8 - 0x126a08)
    ctx->pc = 0x126968;
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime);
}

void entry_126a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126a78 inside SetAloOverrideCel__FP3ALOG4RGBA (0x126a48 - 0x126a90)
    ctx->pc = 0x126a78;
    SetAloOverrideCel__FP3ALOG4RGBA(rdram, ctx, runtime);
}

void entry_126a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126a9c inside entry_126a90 (0x126a90 - 0x126ab0)
    ctx->pc = 0x126a9c;
    entry_126a90(rdram, ctx, runtime);
}

void entry_126be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126be8 inside SetAloBlotContext__FP3ALOP4BLOT (0x126bc0 - 0x126c38)
    ctx->pc = 0x126be8;
    SetAloBlotContext__FP3ALOP4BLOT(rdram, ctx, runtime);
}

void entry_126c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126c0c inside SetAloBlotContext__FP3ALOP4BLOT (0x126bc0 - 0x126c38)
    ctx->pc = 0x126c0c;
    SetAloBlotContext__FP3ALOP4BLOT(rdram, ctx, runtime);
}

void entry_126c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126c20 inside SetAloBlotContext__FP3ALOP4BLOT (0x126bc0 - 0x126c38)
    ctx->pc = 0x126c20;
    SetAloBlotContext__FP3ALOP4BLOT(rdram, ctx, runtime);
}

void entry_126c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126c48 inside entry_126c38 (0x126c38 - 0x126c58)
    ctx->pc = 0x126c48;
    entry_126c38(rdram, ctx, runtime);
}

void entry_126ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126ca0 inside entry_126c88 (0x126c88 - 0x126cb8)
    ctx->pc = 0x126ca0;
    entry_126c88(rdram, ctx, runtime);
}

void entry_126ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126ca4 inside entry_126c88 (0x126c88 - 0x126cb8)
    ctx->pc = 0x126ca4;
    entry_126c88(rdram, ctx, runtime);
}

void entry_126ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126ca8 inside entry_126c88 (0x126c88 - 0x126cb8)
    ctx->pc = 0x126ca8;
    entry_126c88(rdram, ctx, runtime);
}

void entry_126ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126ce8 inside entry_126cd4 (0x126cd4 - 0x126cf0)
    ctx->pc = 0x126ce8;
    entry_126cd4(rdram, ctx, runtime);
}

void entry_126d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126d3c inside entry_126d00 (0x126d00 - 0x126d60)
    ctx->pc = 0x126d3c;
    entry_126d00(rdram, ctx, runtime);
}

void entry_126d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126d48 inside entry_126d00 (0x126d00 - 0x126d60)
    ctx->pc = 0x126d48;
    entry_126d00(rdram, ctx, runtime);
}

void entry_126d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126d50 inside entry_126d00 (0x126d00 - 0x126d60)
    ctx->pc = 0x126d50;
    entry_126d00(rdram, ctx, runtime);
}

void entry_126dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126dc0 inside entry_126d8c (0x126d8c - 0x126de8)
    ctx->pc = 0x126dc0;
    entry_126d8c(rdram, ctx, runtime);
}

void entry_126dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126dcc inside entry_126d8c (0x126d8c - 0x126de8)
    ctx->pc = 0x126dcc;
    entry_126d8c(rdram, ctx, runtime);
}

void entry_126dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126dd4 inside entry_126d8c (0x126d8c - 0x126de8)
    ctx->pc = 0x126dd4;
    entry_126d8c(rdram, ctx, runtime);
}

void entry_126fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x126fd8 inside entry_126fc0 (0x126fc0 - 0x126fe8)
    ctx->pc = 0x126fd8;
    entry_126fc0(rdram, ctx, runtime);
}

void entry_127004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127004 inside entry_126fe8 (0x126fe8 - 0x12702c)
    ctx->pc = 0x127004;
    entry_126fe8(rdram, ctx, runtime);
}

void entry_127030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127030 inside entry_12702c (0x12702c - 0x127048)
    ctx->pc = 0x127030;
    entry_12702c(rdram, ctx, runtime);
}

void entry_12710c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12710c inside entry_127108 (0x127108 - 0x127114)
    ctx->pc = 0x12710c;
    entry_127108(rdram, ctx, runtime);
}

void entry_1271e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1271e0 inside entry_1271dc (0x1271dc - 0x1271f4)
    ctx->pc = 0x1271e0;
    entry_1271dc(rdram, ctx, runtime);
}

void entry_127208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127208 inside entry_127204 (0x127204 - 0x12721c)
    ctx->pc = 0x127208;
    entry_127204(rdram, ctx, runtime);
}

void entry_127230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127230 inside entry_12722c (0x12722c - 0x127244)
    ctx->pc = 0x127230;
    entry_12722c(rdram, ctx, runtime);
}

void entry_127278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127278 inside entry_127274 (0x127274 - 0x127288)
    ctx->pc = 0x127278;
    entry_127274(rdram, ctx, runtime);
}

void entry_127290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127290 inside entry_127288 (0x127288 - 0x1272a0)
    ctx->pc = 0x127290;
    entry_127288(rdram, ctx, runtime);
}

void entry_1272a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1272a8 inside entry_1272a0 (0x1272a0 - 0x1272c4)
    ctx->pc = 0x1272a8;
    entry_1272a0(rdram, ctx, runtime);
}

void entry_1272dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1272dc inside entry_1272d8 (0x1272d8 - 0x1272f4)
    ctx->pc = 0x1272dc;
    entry_1272d8(rdram, ctx, runtime);
}

void entry_1272fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1272fc inside entry_1272f4 (0x1272f4 - 0x127314)
    ctx->pc = 0x1272fc;
    entry_1272f4(rdram, ctx, runtime);
}

void entry_12731c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12731c inside entry_127314 (0x127314 - 0x127334)
    ctx->pc = 0x12731c;
    entry_127314(rdram, ctx, runtime);
}

void entry_12733c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12733c inside entry_127334 (0x127334 - 0x127354)
    ctx->pc = 0x12733c;
    entry_127334(rdram, ctx, runtime);
}

void entry_12735c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12735c inside entry_127354 (0x127354 - 0x127378)
    ctx->pc = 0x12735c;
    entry_127354(rdram, ctx, runtime);
}

void entry_1273e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1273e8 inside entry_1273e4 (0x1273e4 - 0x1273f0)
    ctx->pc = 0x1273e8;
    entry_1273e4(rdram, ctx, runtime);
}

void entry_127430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127430 inside entry_12742c (0x12742c - 0x127440)
    ctx->pc = 0x127430;
    entry_12742c(rdram, ctx, runtime);
}

void entry_127444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127444 inside entry_127440 (0x127440 - 0x127458)
    ctx->pc = 0x127444;
    entry_127440(rdram, ctx, runtime);
}

void entry_1274bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1274bc inside entry_1274b8 (0x1274b8 - 0x1274cc)
    ctx->pc = 0x1274bc;
    entry_1274b8(rdram, ctx, runtime);
}

void entry_1274d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1274d0 inside entry_1274cc (0x1274cc - 0x1274e4)
    ctx->pc = 0x1274d0;
    entry_1274cc(rdram, ctx, runtime);
}

void entry_127544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127544 inside entry_127540 (0x127540 - 0x127558)
    ctx->pc = 0x127544;
    entry_127540(rdram, ctx, runtime);
}

void entry_1275dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1275dc inside entry_1275d8 (0x1275d8 - 0x1275f0)
    ctx->pc = 0x1275dc;
    entry_1275d8(rdram, ctx, runtime);
}

void entry_1277f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1277f4 inside entry_1277a0 (0x1277a0 - 0x127828)
    ctx->pc = 0x1277f4;
    entry_1277a0(rdram, ctx, runtime);
}

void entry_127800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127800 inside entry_1277a0 (0x1277a0 - 0x127828)
    ctx->pc = 0x127800;
    entry_1277a0(rdram, ctx, runtime);
}

void entry_12786c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12786c inside entry_127828 (0x127828 - 0x127878)
    ctx->pc = 0x12786c;
    entry_127828(rdram, ctx, runtime);
}

void entry_12787c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12787c inside entry_127878 (0x127878 - 0x1278a8)
    ctx->pc = 0x12787c;
    entry_127878(rdram, ctx, runtime);
}

void entry_127888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127888 inside entry_127878 (0x127878 - 0x1278a8)
    ctx->pc = 0x127888;
    entry_127878(rdram, ctx, runtime);
}

void entry_1278f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1278f8 inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x1278f8;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_127900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127900 inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x127900;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_127918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127918 inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x127918;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_12793c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12793c inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x12793c;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_127940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127940 inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x127940;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_127948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127948 inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x127948;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_127960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127960 inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x127960;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_127978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127978 inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x127978;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_12797c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12797c inside CalculateAloMovement__FP3ALOT0P6VECTORN42 (0x1278a8 - 0x12798c)
    ctx->pc = 0x12797c;
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime);
}

void entry_12799c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12799c inside entry_12798c (0x12798c - 0x1279bc)
    ctx->pc = 0x12799c;
    entry_12798c(rdram, ctx, runtime);
}

void entry_1279ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1279ac inside entry_12798c (0x12798c - 0x1279bc)
    ctx->pc = 0x1279ac;
    entry_12798c(rdram, ctx, runtime);
}

void entry_1279cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1279cc inside entry_1279bc (0x1279bc - 0x127a10)
    ctx->pc = 0x1279cc;
    entry_1279bc(rdram, ctx, runtime);
}

void entry_1279dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1279dc inside entry_1279bc (0x1279bc - 0x127a10)
    ctx->pc = 0x1279dc;
    entry_1279bc(rdram, ctx, runtime);
}

void entry_1279ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1279ec inside entry_1279bc (0x1279bc - 0x127a10)
    ctx->pc = 0x1279ec;
    entry_1279bc(rdram, ctx, runtime);
}

void entry_127a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127a5c inside entry_127a4c (0x127a4c - 0x127ab8)
    ctx->pc = 0x127a5c;
    entry_127a4c(rdram, ctx, runtime);
}

void entry_127ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127ac8 inside entry_127ab8 (0x127ab8 - 0x127b20)
    ctx->pc = 0x127ac8;
    entry_127ab8(rdram, ctx, runtime);
}

void entry_127acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127acc inside entry_127ab8 (0x127ab8 - 0x127b20)
    ctx->pc = 0x127acc;
    entry_127ab8(rdram, ctx, runtime);
}

void entry_127ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127ad8 inside entry_127ab8 (0x127ab8 - 0x127b20)
    ctx->pc = 0x127ad8;
    entry_127ab8(rdram, ctx, runtime);
}

void entry_127ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127ae4 inside entry_127ab8 (0x127ab8 - 0x127b20)
    ctx->pc = 0x127ae4;
    entry_127ab8(rdram, ctx, runtime);
}

void entry_127af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127af0 inside entry_127ab8 (0x127ab8 - 0x127b20)
    ctx->pc = 0x127af0;
    entry_127ab8(rdram, ctx, runtime);
}

void entry_127b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127b70 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127b70;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127b98 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127b98;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127b9c inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127b9c;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127ba4 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127ba4;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c20 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c20;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c38 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c38;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c4c inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c4c;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c54 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c54;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c5c inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c5c;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c68 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c68;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c88 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c88;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127c98 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127c98;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127d04 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127d04;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127d18 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127d18;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127d44 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127d44;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127dc4 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127dc4;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127dec inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127dec;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127df8 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127df8;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127e04 inside CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3 (0x127b20 - 0x127e10)
    ctx->pc = 0x127e04;
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime);
}

void entry_127e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127e2c inside entry_127e10 (0x127e10 - 0x127e60)
    ctx->pc = 0x127e2c;
    entry_127e10(rdram, ctx, runtime);
}

void entry_127e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127e94 inside CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2 (0x127e60 - 0x127ec0)
    ctx->pc = 0x127e94;
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime);
}

void entry_127e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127e98 inside CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2 (0x127e60 - 0x127ec0)
    ctx->pc = 0x127e98;
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime);
}

void entry_127eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127eb0 inside CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2 (0x127e60 - 0x127ec0)
    ctx->pc = 0x127eb0;
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime);
}

void entry_127eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127eb4 inside CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2 (0x127e60 - 0x127ec0)
    ctx->pc = 0x127eb4;
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime);
}

void entry_127ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127ed8 inside entry_127ec0 (0x127ec0 - 0x128018)
    ctx->pc = 0x127ed8;
    entry_127ec0(rdram, ctx, runtime);
}

void entry_127f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127f04 inside entry_127ec0 (0x127ec0 - 0x128018)
    ctx->pc = 0x127f04;
    entry_127ec0(rdram, ctx, runtime);
}

void entry_127f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127f0c inside entry_127ec0 (0x127ec0 - 0x128018)
    ctx->pc = 0x127f0c;
    entry_127ec0(rdram, ctx, runtime);
}

void entry_127f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127f5c inside entry_127ec0 (0x127ec0 - 0x128018)
    ctx->pc = 0x127f5c;
    entry_127ec0(rdram, ctx, runtime);
}

void entry_127f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127f8c inside entry_127ec0 (0x127ec0 - 0x128018)
    ctx->pc = 0x127f8c;
    entry_127ec0(rdram, ctx, runtime);
}

void entry_127ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x127ffc inside entry_127ec0 (0x127ec0 - 0x128018)
    ctx->pc = 0x127ffc;
    entry_127ec0(rdram, ctx, runtime);
}

void entry_128058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128058 inside ConvertAloPos__FP3ALOT0P6VECTORT2 (0x128018 - 0x1280c0)
    ctx->pc = 0x128058;
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime);
}

void entry_1280ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1280ac inside ConvertAloPos__FP3ALOT0P6VECTORT2 (0x128018 - 0x1280c0)
    ctx->pc = 0x1280ac;
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime);
}

void entry_1280b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1280b4 inside ConvertAloPos__FP3ALOT0P6VECTORT2 (0x128018 - 0x1280c0)
    ctx->pc = 0x1280b4;
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime);
}

void entry_1280f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1280f4 inside ConvertAloVec__FP3ALOT0P6VECTORT2 (0x1280c0 - 0x128150)
    ctx->pc = 0x1280f4;
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime);
}

void entry_128140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128140 inside ConvertAloVec__FP3ALOT0P6VECTORT2 (0x1280c0 - 0x128150)
    ctx->pc = 0x128140;
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime);
}

void entry_128148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128148 inside ConvertAloVec__FP3ALOT0P6VECTORT2 (0x1280c0 - 0x128150)
    ctx->pc = 0x128148;
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime);
}

void entry_1281d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1281d0 inside ConvertAloMat__FP3ALOT0P7MATRIX3T2 (0x128150 - 0x1281e0)
    ctx->pc = 0x1281d0;
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime);
}

void entry_128208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128208 inside entry_1281e0 (0x1281e0 - 0x128230)
    ctx->pc = 0x128208;
    entry_1281e0(rdram, ctx, runtime);
}

void entry_128220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128220 inside entry_1281e0 (0x1281e0 - 0x128230)
    ctx->pc = 0x128220;
    entry_1281e0(rdram, ctx, runtime);
}

void entry_128254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128254 inside FDrivenAlo__FP3ALO (0x128230 - 0x128278)
    ctx->pc = 0x128254;
    FDrivenAlo__FP3ALO(rdram, ctx, runtime);
}

void entry_128268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128268 inside FDrivenAlo__FP3ALO (0x128230 - 0x128278)
    ctx->pc = 0x128268;
    FDrivenAlo__FP3ALO(rdram, ctx, runtime);
}

void entry_12826c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12826c inside FDrivenAlo__FP3ALO (0x128230 - 0x128278)
    ctx->pc = 0x12826c;
    FDrivenAlo__FP3ALO(rdram, ctx, runtime);
}

void entry_1282b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1282b0 inside RetractAloDrive__FP3ALO (0x128278 - 0x1282bc)
    ctx->pc = 0x1282b0;
    RetractAloDrive__FP3ALO(rdram, ctx, runtime);
}

void entry_1282d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1282d4 inside entry_1282bc (0x1282bc - 0x128304)
    ctx->pc = 0x1282d4;
    entry_1282bc(rdram, ctx, runtime);
}

void entry_1282d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1282d8 inside entry_1282bc (0x1282bc - 0x128304)
    ctx->pc = 0x1282d8;
    entry_1282bc(rdram, ctx, runtime);
}

void entry_1282f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1282f8 inside entry_1282bc (0x1282bc - 0x128304)
    ctx->pc = 0x1282f8;
    entry_1282bc(rdram, ctx, runtime);
}

void entry_12831c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12831c inside entry_128304 (0x128304 - 0x128330)
    ctx->pc = 0x12831c;
    entry_128304(rdram, ctx, runtime);
}

void entry_128320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128320 inside entry_128304 (0x128304 - 0x128330)
    ctx->pc = 0x128320;
    entry_128304(rdram, ctx, runtime);
}

void entry_128430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128430 inside entry_12841c (0x12841c - 0x1284a8)
    ctx->pc = 0x128430;
    entry_12841c(rdram, ctx, runtime);
}

void entry_128444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128444 inside entry_12841c (0x12841c - 0x1284a8)
    ctx->pc = 0x128444;
    entry_12841c(rdram, ctx, runtime);
}

void entry_128458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128458 inside entry_12841c (0x12841c - 0x1284a8)
    ctx->pc = 0x128458;
    entry_12841c(rdram, ctx, runtime);
}

void entry_12846c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12846c inside entry_12841c (0x12841c - 0x1284a8)
    ctx->pc = 0x12846c;
    entry_12841c(rdram, ctx, runtime);
}

void entry_1284bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1284bc inside entry_1284a8 (0x1284a8 - 0x128518)
    ctx->pc = 0x1284bc;
    entry_1284a8(rdram, ctx, runtime);
}

void entry_1284d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1284d0 inside entry_1284a8 (0x1284a8 - 0x128518)
    ctx->pc = 0x1284d0;
    entry_1284a8(rdram, ctx, runtime);
}

void entry_1284e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1284e8 inside entry_1284a8 (0x1284a8 - 0x128518)
    ctx->pc = 0x1284e8;
    entry_1284a8(rdram, ctx, runtime);
}

void entry_128500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128500 inside entry_1284a8 (0x1284a8 - 0x128518)
    ctx->pc = 0x128500;
    entry_1284a8(rdram, ctx, runtime);
}

void entry_1285e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1285e8 inside CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25 (0x128598 - 0x128618)
    ctx->pc = 0x1285e8;
    CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25(rdram, ctx, runtime);
}

void entry_1285f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1285f8 inside CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25 (0x128598 - 0x128618)
    ctx->pc = 0x1285f8;
    CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25(rdram, ctx, runtime);
}

void entry_128620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128620 inside entry_128618 (0x128618 - 0x128658)
    ctx->pc = 0x128620;
    entry_128618(rdram, ctx, runtime);
}

void entry_128638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128638 inside entry_128618 (0x128618 - 0x128658)
    ctx->pc = 0x128638;
    entry_128618(rdram, ctx, runtime);
}

void entry_128660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128660 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128660;
    entry_128658(rdram, ctx, runtime);
}

void entry_12868c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12868c inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x12868c;
    entry_128658(rdram, ctx, runtime);
}

void entry_1286a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1286a0 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x1286a0;
    entry_128658(rdram, ctx, runtime);
}

void entry_128718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128718 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128718;
    entry_128658(rdram, ctx, runtime);
}

void entry_128768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128768 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128768;
    entry_128658(rdram, ctx, runtime);
}

void entry_128794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128794 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128794;
    entry_128658(rdram, ctx, runtime);
}

void entry_1287ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1287ac inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x1287ac;
    entry_128658(rdram, ctx, runtime);
}

void entry_1287b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1287b0 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x1287b0;
    entry_128658(rdram, ctx, runtime);
}

void entry_1287b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1287b4 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x1287b4;
    entry_128658(rdram, ctx, runtime);
}

void entry_1287d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1287d8 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x1287d8;
    entry_128658(rdram, ctx, runtime);
}

void entry_128828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128828 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128828;
    entry_128658(rdram, ctx, runtime);
}

void entry_128838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128838 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128838;
    entry_128658(rdram, ctx, runtime);
}

void entry_128854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128854 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128854;
    entry_128658(rdram, ctx, runtime);
}

void entry_128858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128858 inside entry_128658 (0x128658 - 0x128884)
    ctx->pc = 0x128858;
    entry_128658(rdram, ctx, runtime);
}

void entry_12888c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12888c inside entry_128884 (0x128884 - 0x1288a8)
    ctx->pc = 0x12888c;
    entry_128884(rdram, ctx, runtime);
}

void entry_1288b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1288b0 inside entry_1288a8 (0x1288a8 - 0x1288f0)
    ctx->pc = 0x1288b0;
    entry_1288a8(rdram, ctx, runtime);
}

void entry_1288bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1288bc inside entry_1288a8 (0x1288a8 - 0x1288f0)
    ctx->pc = 0x1288bc;
    entry_1288a8(rdram, ctx, runtime);
}

void entry_1288c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1288c0 inside entry_1288a8 (0x1288a8 - 0x1288f0)
    ctx->pc = 0x1288c0;
    entry_1288a8(rdram, ctx, runtime);
}

void entry_1288c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1288c4 inside entry_1288a8 (0x1288a8 - 0x1288f0)
    ctx->pc = 0x1288c4;
    entry_1288a8(rdram, ctx, runtime);
}

void entry_1288c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1288c8 inside entry_1288a8 (0x1288a8 - 0x1288f0)
    ctx->pc = 0x1288c8;
    entry_1288a8(rdram, ctx, runtime);
}

void entry_128940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128940 inside FGetAloChildrenList__FP3ALOPv (0x1288f0 - 0x12894c)
    ctx->pc = 0x128940;
    FGetAloChildrenList__FP3ALOPv(rdram, ctx, runtime);
}

void entry_128960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128960 inside entry_12894c (0x12894c - 0x128998)
    ctx->pc = 0x128960;
    entry_12894c(rdram, ctx, runtime);
}

void entry_128978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128978 inside entry_12894c (0x12894c - 0x128998)
    ctx->pc = 0x128978;
    entry_12894c(rdram, ctx, runtime);
}

void entry_128980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128980 inside entry_12894c (0x12894c - 0x128998)
    ctx->pc = 0x128980;
    entry_12894c(rdram, ctx, runtime);
}

void entry_128ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128ad8 inside entry_128aac (0x128aac - 0x128b08)
    ctx->pc = 0x128ad8;
    entry_128aac(rdram, ctx, runtime);
}

void entry_128b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128b00 inside entry_128aac (0x128aac - 0x128b08)
    ctx->pc = 0x128b00;
    entry_128aac(rdram, ctx, runtime);
}

void entry_128b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128b40 inside entry_128b3c (0x128b3c - 0x128b48)
    ctx->pc = 0x128b40;
    entry_128b3c(rdram, ctx, runtime);
}

void entry_128b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128b68 inside entry_128b54 (0x128b54 - 0x128b80)
    ctx->pc = 0x128b68;
    entry_128b54(rdram, ctx, runtime);
}

void entry_128ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128ba0 inside entry_128b90 (0x128b90 - 0x128ba8)
    ctx->pc = 0x128ba0;
    entry_128b90(rdram, ctx, runtime);
}

void entry_128bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128bd0 inside entry_128ba8 (0x128ba8 - 0x128bf0)
    ctx->pc = 0x128bd0;
    entry_128ba8(rdram, ctx, runtime);
}

void entry_128be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128be0 inside entry_128ba8 (0x128ba8 - 0x128bf0)
    ctx->pc = 0x128be0;
    entry_128ba8(rdram, ctx, runtime);
}

void entry_128cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128cf4 inside entry_128cf0 (0x128cf0 - 0x128d08)
    ctx->pc = 0x128cf4;
    entry_128cf0(rdram, ctx, runtime);
}

void entry_128cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128cf8 inside entry_128cf0 (0x128cf0 - 0x128d08)
    ctx->pc = 0x128cf8;
    entry_128cf0(rdram, ctx, runtime);
}

void entry_128d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128d10 inside entry_128d08 (0x128d08 - 0x128d20)
    ctx->pc = 0x128d10;
    entry_128d08(rdram, ctx, runtime);
}

void entry_128d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128d5c inside entry_128d4c (0x128d4c - 0x128d6c)
    ctx->pc = 0x128d5c;
    entry_128d4c(rdram, ctx, runtime);
}

void entry_128d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128d80 inside entry_128d78 (0x128d78 - 0x128d90)
    ctx->pc = 0x128d80;
    entry_128d78(rdram, ctx, runtime);
}

void entry_128d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128d98 inside entry_128d90 (0x128d90 - 0x128db8)
    ctx->pc = 0x128d98;
    entry_128d90(rdram, ctx, runtime);
}

void entry_128e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128e08 inside entry_128dfc (0x128dfc - 0x128e24)
    ctx->pc = 0x128e08;
    entry_128dfc(rdram, ctx, runtime);
}

void entry_128e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128e40 inside entry_128e3c (0x128e3c - 0x128e5c)
    ctx->pc = 0x128e40;
    entry_128e3c(rdram, ctx, runtime);
}

void entry_128e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128e74 inside entry_128e70 (0x128e70 - 0x128e88)
    ctx->pc = 0x128e74;
    entry_128e70(rdram, ctx, runtime);
}

void entry_128e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128e78 inside entry_128e70 (0x128e70 - 0x128e88)
    ctx->pc = 0x128e78;
    entry_128e70(rdram, ctx, runtime);
}

void entry_128f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128f1c inside AdjustAloRotation__FP3ALOP7MATRIX3P6VECTOR (0x128e88 - 0x128fd0)
    ctx->pc = 0x128f1c;
    AdjustAloRotation__FP3ALOP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_128f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128f9c inside AdjustAloRotation__FP3ALOP7MATRIX3P6VECTOR (0x128e88 - 0x128fd0)
    ctx->pc = 0x128f9c;
    AdjustAloRotation__FP3ALOP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_128fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x128fc8 inside AdjustAloRotation__FP3ALOP7MATRIX3P6VECTOR (0x128e88 - 0x128fd0)
    ctx->pc = 0x128fc8;
    AdjustAloRotation__FP3ALOP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_129068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129068 inside UnadjustAloRotation__FP3ALOP7MATRIX3 (0x128fd0 - 0x129080)
    ctx->pc = 0x129068;
    UnadjustAloRotation__FP3ALOP7MATRIX3(rdram, ctx, runtime);
}

void entry_1290a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1290a4 inside entry_129080 (0x129080 - 0x1290b8)
    ctx->pc = 0x1290a4;
    entry_129080(rdram, ctx, runtime);
}

void entry_129160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129160 inside entry_12912c (0x12912c - 0x129170)
    ctx->pc = 0x129160;
    entry_12912c(rdram, ctx, runtime);
}

void entry_12921c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12921c inside entry_129214 (0x129214 - 0x129228)
    ctx->pc = 0x12921c;
    entry_129214(rdram, ctx, runtime);
}

void entry_12924c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12924c inside entry_129244 (0x129244 - 0x129264)
    ctx->pc = 0x12924c;
    entry_129244(rdram, ctx, runtime);
}

void entry_12927c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12927c inside entry_129274 (0x129274 - 0x129288)
    ctx->pc = 0x12927c;
    entry_129274(rdram, ctx, runtime);
}

void entry_129430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129430 inside entry_129428 (0x129428 - 0x129440)
    ctx->pc = 0x129430;
    entry_129428(rdram, ctx, runtime);
}

void entry_129474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129474 inside GetAloShadowShader__FP3ALOP3OID (0x129450 - 0x129480)
    ctx->pc = 0x129474;
    GetAloShadowShader__FP3ALOP3OID(rdram, ctx, runtime);
}

void entry_129620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129620 inside entry_129610 (0x129610 - 0x129648)
    ctx->pc = 0x129620;
    entry_129610(rdram, ctx, runtime);
}

void entry_129678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129678 inside SetAloEuler__FP3ALOP6VECTOR (0x129648 - 0x1296a0)
    ctx->pc = 0x129678;
    SetAloEuler__FP3ALOP6VECTOR(rdram, ctx, runtime);
}

void entry_129724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129724 inside entry_129720 (0x129720 - 0x129730)
    ctx->pc = 0x129724;
    entry_129720(rdram, ctx, runtime);
}

void entry_129774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129774 inside entry_129770 (0x129770 - 0x129780)
    ctx->pc = 0x129774;
    entry_129770(rdram, ctx, runtime);
}

void entry_1297e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1297e0 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1297e0;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1297f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1297f8 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1297f8;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129810 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129810;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_12982c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12982c inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x12982c;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129868 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129868;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129894 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129894;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129898 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129898;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1298b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1298b0 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1298b0;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1298b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1298b8 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1298b8;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1298d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1298d0 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1298d0;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1298e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1298e4 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1298e4;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1298e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1298e8 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1298e8;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1298f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1298f0 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x1298f0;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129900 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129900;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129910 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129910;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129920 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129920;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129938 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129938;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129958 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129958;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_12995c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12995c inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x12995c;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_12996c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12996c inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x12996c;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129970 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129970;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_129984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129984 inside entry_1297c0 (0x1297c0 - 0x12998c)
    ctx->pc = 0x129984;
    entry_1297c0(rdram, ctx, runtime);
}

void entry_1299ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1299ac inside entry_1299a8 (0x1299a8 - 0x1299c4)
    ctx->pc = 0x1299ac;
    entry_1299a8(rdram, ctx, runtime);
}

void entry_1299c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1299c8 inside entry_1299c4 (0x1299c4 - 0x1299e0)
    ctx->pc = 0x1299c8;
    entry_1299c4(rdram, ctx, runtime);
}

void entry_129a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129a18 inside InsertAloAct__FP3ALOP3ACT (0x1299e0 - 0x129a38)
    ctx->pc = 0x129a18;
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime);
}

void entry_129a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129a30 inside InsertAloAct__FP3ALOP3ACT (0x1299e0 - 0x129a38)
    ctx->pc = 0x129a30;
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime);
}

void entry_129ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129ac0 inside ResortAloActList__FP3ALO (0x129a58 - 0x129ad4)
    ctx->pc = 0x129ac0;
    ResortAloActList__FP3ALO(rdram, ctx, runtime);
}

void entry_129af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129af4 inside entry_129ad4 (0x129ad4 - 0x129b58)
    ctx->pc = 0x129af4;
    entry_129ad4(rdram, ctx, runtime);
}

void entry_129b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129b08 inside entry_129ad4 (0x129ad4 - 0x129b58)
    ctx->pc = 0x129b08;
    entry_129ad4(rdram, ctx, runtime);
}

void entry_129b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129b38 inside entry_129ad4 (0x129ad4 - 0x129b58)
    ctx->pc = 0x129b38;
    entry_129ad4(rdram, ctx, runtime);
}

void entry_129b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129b50 inside entry_129ad4 (0x129ad4 - 0x129b58)
    ctx->pc = 0x129b50;
    entry_129ad4(rdram, ctx, runtime);
}

void entry_129b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129b60 inside entry_129b58 (0x129b58 - 0x129b70)
    ctx->pc = 0x129b60;
    entry_129b58(rdram, ctx, runtime);
}

void entry_129bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129bd0 inside PasegaFindAlo__FP3ALO3OID (0x129b98 - 0x129bec)
    ctx->pc = 0x129bd0;
    PasegaFindAlo__FP3ALO3OID(rdram, ctx, runtime);
}

void entry_129bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129bf8 inside entry_129bec (0x129bec - 0x129c20)
    ctx->pc = 0x129bf8;
    entry_129bec(rdram, ctx, runtime);
}

void entry_129c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129c00 inside entry_129bec (0x129bec - 0x129c20)
    ctx->pc = 0x129c00;
    entry_129bec(rdram, ctx, runtime);
}

void entry_129c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129c04 inside entry_129bec (0x129bec - 0x129c20)
    ctx->pc = 0x129c04;
    entry_129bec(rdram, ctx, runtime);
}

void entry_129c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129c58 inside PsmaFindAlo__FP3ALO3OID (0x129c20 - 0x129c74)
    ctx->pc = 0x129c58;
    PsmaFindAlo__FP3ALO3OID(rdram, ctx, runtime);
}

void entry_129c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129c80 inside entry_129c74 (0x129c74 - 0x129ca8)
    ctx->pc = 0x129c80;
    entry_129c74(rdram, ctx, runtime);
}

void entry_129c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129c88 inside entry_129c74 (0x129c74 - 0x129ca8)
    ctx->pc = 0x129c88;
    entry_129c74(rdram, ctx, runtime);
}

void entry_129c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129c8c inside entry_129c74 (0x129c74 - 0x129ca8)
    ctx->pc = 0x129c8c;
    entry_129c74(rdram, ctx, runtime);
}

void entry_129cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129cb8 inside PasegaFindAloNearest__FP3ALO (0x129ca8 - 0x129d00)
    ctx->pc = 0x129cb8;
    PasegaFindAloNearest__FP3ALO(rdram, ctx, runtime);
}

void entry_129ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129ccc inside PasegaFindAloNearest__FP3ALO (0x129ca8 - 0x129d00)
    ctx->pc = 0x129ccc;
    PasegaFindAloNearest__FP3ALO(rdram, ctx, runtime);
}

void entry_129cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129cd4 inside PasegaFindAloNearest__FP3ALO (0x129ca8 - 0x129d00)
    ctx->pc = 0x129cd4;
    PasegaFindAloNearest__FP3ALO(rdram, ctx, runtime);
}

void entry_129cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129cec inside PasegaFindAloNearest__FP3ALO (0x129ca8 - 0x129d00)
    ctx->pc = 0x129cec;
    PasegaFindAloNearest__FP3ALO(rdram, ctx, runtime);
}

void entry_129cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129cf4 inside PasegaFindAloNearest__FP3ALO (0x129ca8 - 0x129d00)
    ctx->pc = 0x129cf4;
    PasegaFindAloNearest__FP3ALO(rdram, ctx, runtime);
}

void entry_129d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129d54 inside entry_129d50 (0x129d50 - 0x129d70)
    ctx->pc = 0x129d54;
    entry_129d50(rdram, ctx, runtime);
}

void entry_129da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129da8 inside entry_129d98 (0x129d98 - 0x129dd0)
    ctx->pc = 0x129da8;
    entry_129d98(rdram, ctx, runtime);
}

void entry_129db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129db8 inside entry_129d98 (0x129d98 - 0x129dd0)
    ctx->pc = 0x129db8;
    entry_129d98(rdram, ctx, runtime);
}

void entry_129ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129ddc inside entry_129dd0 (0x129dd0 - 0x129df8)
    ctx->pc = 0x129ddc;
    entry_129dd0(rdram, ctx, runtime);
}

void entry_129de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129de8 inside entry_129dd0 (0x129dd0 - 0x129df8)
    ctx->pc = 0x129de8;
    entry_129dd0(rdram, ctx, runtime);
}

void entry_129e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129e04 inside ResolveAlo__FP3ALO (0x129df8 - 0x129e10)
    ctx->pc = 0x129e04;
    ResolveAlo__FP3ALO(rdram, ctx, runtime);
}

void entry_129ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129ec0 inside entry_129eb8 (0x129eb8 - 0x129ee0)
    ctx->pc = 0x129ec0;
    entry_129eb8(rdram, ctx, runtime);
}

void entry_129f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x129f90 inside entry_129f88 (0x129f88 - 0x129fb0)
    ctx->pc = 0x129f90;
    entry_129f88(rdram, ctx, runtime);
}

void entry_12a060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a060 inside entry_12a058 (0x12a058 - 0x12a080)
    ctx->pc = 0x12a060;
    entry_12a058(rdram, ctx, runtime);
}

void entry_12a130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a130 inside entry_12a128 (0x12a128 - 0x12a150)
    ctx->pc = 0x12a130;
    entry_12a128(rdram, ctx, runtime);
}

void entry_12a234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a234 inside entry_12a230 (0x12a230 - 0x12a270)
    ctx->pc = 0x12a234;
    entry_12a230(rdram, ctx, runtime);
}

void entry_12a354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a354 inside entry_12a350 (0x12a350 - 0x12a390)
    ctx->pc = 0x12a354;
    entry_12a350(rdram, ctx, runtime);
}

void entry_12a5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a5c8 inside GetAloLookAtIgnore__FP3ALOPf (0x12a5b8 - 0x12a5d0)
    ctx->pc = 0x12a5c8;
    GetAloLookAtIgnore__FP3ALOPf(rdram, ctx, runtime);
}

void entry_12a624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a624 inside GetAloLookAtPanFunction__FP3ALOP3CLQ (0x12a610 - 0x12a630)
    ctx->pc = 0x12a624;
    GetAloLookAtPanFunction__FP3ALOP3CLQ(rdram, ctx, runtime);
}

void entry_12a68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a68c inside GetAloLookAtPanLimits__FP3ALOP2LM (0x12a678 - 0x12a6a0)
    ctx->pc = 0x12a68c;
    GetAloLookAtPanLimits__FP3ALOP2LM(rdram, ctx, runtime);
}

void entry_12a6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a6f4 inside GetAloLookAtTiltFunction__FP3ALOP3CLQ (0x12a6e0 - 0x12a700)
    ctx->pc = 0x12a6f4;
    GetAloLookAtTiltFunction__FP3ALOP3CLQ(rdram, ctx, runtime);
}

void entry_12a75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a75c inside GetAloLookAtTiltLimits__FP3ALOP2LM (0x12a748 - 0x12a770)
    ctx->pc = 0x12a75c;
    GetAloLookAtTiltLimits__FP3ALOP2LM(rdram, ctx, runtime);
}

void entry_12a7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a7b8 inside GetAloLookAtEnabledPriority__FP3ALOPi (0x12a7a8 - 0x12a7c0)
    ctx->pc = 0x12a7b8;
    GetAloLookAtEnabledPriority__FP3ALOPi(rdram, ctx, runtime);
}

void entry_12a808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a808 inside GetAloLookAtDisabledPriority__FP3ALOPi (0x12a7f8 - 0x12a810)
    ctx->pc = 0x12a808;
    GetAloLookAtDisabledPriority__FP3ALOPi(rdram, ctx, runtime);
}

void entry_12a858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a858 inside FUN_0012a848 (0x12a848 - 0x12a860)
    ctx->pc = 0x12a858;
    FUN_0012a848(rdram, ctx, runtime);
}

void entry_12a9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a9b8 inside entry_12a9b4 (0x12a9b4 - 0x12a9c8)
    ctx->pc = 0x12a9b8;
    entry_12a9b4(rdram, ctx, runtime);
}

void entry_12a9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12a9ec inside entry_12a9dc (0x12a9dc - 0x12aa00)
    ctx->pc = 0x12a9ec;
    entry_12a9dc(rdram, ctx, runtime);
}

void entry_12aa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12aa90 inside SetAloScrollingMasterSpeeds__FP3ALOff (0x12aa50 - 0x12aab4)
    ctx->pc = 0x12aa90;
    SetAloScrollingMasterSpeeds__FP3ALOff(rdram, ctx, runtime);
}

void entry_12aab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12aab8 inside entry_12aab4 (0x12aab4 - 0x12aae8)
    ctx->pc = 0x12aab8;
    entry_12aab4(rdram, ctx, runtime);
}

void entry_12aac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12aac8 inside entry_12aab4 (0x12aab4 - 0x12aae8)
    ctx->pc = 0x12aac8;
    entry_12aab4(rdram, ctx, runtime);
}

void entry_12ab20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ab20 inside SetAloEyesClosed__FP3ALOf (0x12aae8 - 0x12ab40)
    ctx->pc = 0x12ab20;
    SetAloEyesClosed__FP3ALOf(rdram, ctx, runtime);
}

void entry_12ab44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ab44 inside entry_12ab40 (0x12ab40 - 0x12ab80)
    ctx->pc = 0x12ab44;
    entry_12ab40(rdram, ctx, runtime);
}

void entry_12ab54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ab54 inside entry_12ab40 (0x12ab40 - 0x12ab80)
    ctx->pc = 0x12ab54;
    entry_12ab40(rdram, ctx, runtime);
}

void entry_12ab68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ab68 inside entry_12ab40 (0x12ab40 - 0x12ab80)
    ctx->pc = 0x12ab68;
    entry_12ab40(rdram, ctx, runtime);
}

void entry_12ab90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ab90 inside entry_12ab80 (0x12ab80 - 0x12aba8)
    ctx->pc = 0x12ab90;
    entry_12ab80(rdram, ctx, runtime);
}

void entry_12abc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12abc8 inside entry_12abc4 (0x12abc4 - 0x12abd0)
    ctx->pc = 0x12abc8;
    entry_12abc4(rdram, ctx, runtime);
}

void entry_12ac98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ac98 inside GetAloSfxid__FP3ALOP5SFXID (0x12ac88 - 0x12aca0)
    ctx->pc = 0x12ac98;
    GetAloSfxid__FP3ALOP5SFXID(rdram, ctx, runtime);
}

void entry_12acf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12acf0 inside GetAloSStart__FP3ALOPf (0x12acd8 - 0x12acf8)
    ctx->pc = 0x12acf0;
    GetAloSStart__FP3ALOPf(rdram, ctx, runtime);
}

void entry_12ad8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ad8c inside GetAloSFull__FP3ALOPf (0x12ad78 - 0x12ad98)
    ctx->pc = 0x12ad8c;
    GetAloSFull__FP3ALOPf(rdram, ctx, runtime);
}

void entry_12ae18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ae18 inside GetAloUDoppler__FP3ALOPf (0x12ae08 - 0x12ae20)
    ctx->pc = 0x12ae18;
    GetAloUDoppler__FP3ALOPf(rdram, ctx, runtime);
}

void entry_12ae4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ae4c inside entry_12ae48 (0x12ae48 - 0x12ae58)
    ctx->pc = 0x12ae4c;
    entry_12ae48(rdram, ctx, runtime);
}

void entry_12ae6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ae6c inside GetAloUVolume__FP3ALOPf (0x12ae58 - 0x12ae78)
    ctx->pc = 0x12ae6c;
    GetAloUVolume__FP3ALOPf(rdram, ctx, runtime);
}

void entry_12aedc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12aedc inside entry_12aed8 (0x12aed8 - 0x12aee8)
    ctx->pc = 0x12aedc;
    entry_12aed8(rdram, ctx, runtime);
}

void entry_12aef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12aef8 inside GetAloUPitch__FP3ALOPf (0x12aee8 - 0x12af00)
    ctx->pc = 0x12aef8;
    GetAloUPitch__FP3ALOPf(rdram, ctx, runtime);
}

void entry_12af24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12af24 inside GetAloSndRepeat__FP3ALOP2LM (0x12af00 - 0x12af38)
    ctx->pc = 0x12af24;
    GetAloSndRepeat__FP3ALOP2LM(rdram, ctx, runtime);
}

void entry_12b034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b034 inside entry_12b030 (0x12b030 - 0x12b040)
    ctx->pc = 0x12b034;
    entry_12b030(rdram, ctx, runtime);
}

void entry_12b0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b0a0 inside entry_12b064 (0x12b064 - 0x12b0b0)
    ctx->pc = 0x12b0a0;
    entry_12b064(rdram, ctx, runtime);
}

void entry_12b114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b114 inside entry_12b0cc (0x12b0cc - 0x12b128)
    ctx->pc = 0x12b114;
    entry_12b0cc(rdram, ctx, runtime);
}

void entry_12b138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b138 inside GetAloThrobKind__FP3ALOP6THROBK (0x12b128 - 0x12b140)
    ctx->pc = 0x12b138;
    GetAloThrobKind__FP3ALOP6THROBK(rdram, ctx, runtime);
}

void entry_12b194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b194 inside GetAloThrobInColor__FP3ALOP6VECTOR (0x12b180 - 0x12b1a0)
    ctx->pc = 0x12b194;
    GetAloThrobInColor__FP3ALOP6VECTOR(rdram, ctx, runtime);
}

void entry_12b1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b1f4 inside GetAloThrobOutColor__FP3ALOP6VECTOR (0x12b1e0 - 0x12b200)
    ctx->pc = 0x12b1f4;
    GetAloThrobOutColor__FP3ALOP6VECTOR(rdram, ctx, runtime);
}

void entry_12b248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b248 inside GetAloThrobDtInOut__FP3ALOPf (0x12b238 - 0x12b250)
    ctx->pc = 0x12b248;
    GetAloThrobDtInOut__FP3ALOPf(rdram, ctx, runtime);
}

void entry_12b338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b338 inside SetAloPoseCombo__FP3ALO3OID (0x12b2f8 - 0x12b3a4)
    ctx->pc = 0x12b338;
    SetAloPoseCombo__FP3ALO3OID(rdram, ctx, runtime);
}

void entry_12b360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b360 inside SetAloPoseCombo__FP3ALO3OID (0x12b2f8 - 0x12b3a4)
    ctx->pc = 0x12b360;
    SetAloPoseCombo__FP3ALO3OID(rdram, ctx, runtime);
}

void entry_12b37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b37c inside SetAloPoseCombo__FP3ALO3OID (0x12b2f8 - 0x12b3a4)
    ctx->pc = 0x12b37c;
    SetAloPoseCombo__FP3ALO3OID(rdram, ctx, runtime);
}

void entry_12b3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b3b8 inside entry_12b3b4 (0x12b3b4 - 0x12b408)
    ctx->pc = 0x12b3b8;
    entry_12b3b4(rdram, ctx, runtime);
}

void entry_12b3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b3f0 inside entry_12b3b4 (0x12b3b4 - 0x12b408)
    ctx->pc = 0x12b3f0;
    entry_12b3b4(rdram, ctx, runtime);
}

void entry_12b40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b40c inside entry_12b408 (0x12b408 - 0x12b420)
    ctx->pc = 0x12b40c;
    entry_12b408(rdram, ctx, runtime);
}

void entry_12b4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b4a8 inside entry_12b4a0 (0x12b4a0 - 0x12b4b4)
    ctx->pc = 0x12b4a8;
    entry_12b4a0(rdram, ctx, runtime);
}

void entry_12b4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b4b8 inside entry_12b4b4 (0x12b4b4 - 0x12b4c8)
    ctx->pc = 0x12b4b8;
    entry_12b4b4(rdram, ctx, runtime);
}

void entry_12b53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b53c inside entry_12b534 (0x12b534 - 0x12b550)
    ctx->pc = 0x12b53c;
    entry_12b534(rdram, ctx, runtime);
}

void entry_12b540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b540 inside entry_12b534 (0x12b534 - 0x12b550)
    ctx->pc = 0x12b540;
    entry_12b534(rdram, ctx, runtime);
}

void entry_12b56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b56c inside FUN_0012b550 (0x12b550 - 0x12b590)
    ctx->pc = 0x12b56c;
    FUN_0012b550(rdram, ctx, runtime);
}

void entry_12b5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b5b0 inside FUN_0012b590 (0x12b590 - 0x12b5b8)
    ctx->pc = 0x12b5b0;
    FUN_0012b590(rdram, ctx, runtime);
}

void entry_12b5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b5f0 inside FUN_0012b5b8 (0x12b5b8 - 0x12b614)
    ctx->pc = 0x12b5f0;
    FUN_0012b5b8(rdram, ctx, runtime);
}

void entry_12b604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b604 inside FUN_0012b5b8 (0x12b5b8 - 0x12b614)
    ctx->pc = 0x12b604;
    FUN_0012b5b8(rdram, ctx, runtime);
}

void entry_12b61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b61c inside entry_12b614 (0x12b614 - 0x12b674)
    ctx->pc = 0x12b61c;
    entry_12b614(rdram, ctx, runtime);
}

void entry_12b634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b634 inside entry_12b614 (0x12b614 - 0x12b674)
    ctx->pc = 0x12b634;
    entry_12b614(rdram, ctx, runtime);
}

void entry_12b63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b63c inside entry_12b614 (0x12b614 - 0x12b674)
    ctx->pc = 0x12b63c;
    entry_12b614(rdram, ctx, runtime);
}

void entry_12b658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b658 inside entry_12b614 (0x12b614 - 0x12b674)
    ctx->pc = 0x12b658;
    entry_12b614(rdram, ctx, runtime);
}

void entry_12b65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b65c inside entry_12b614 (0x12b614 - 0x12b674)
    ctx->pc = 0x12b65c;
    entry_12b614(rdram, ctx, runtime);
}

void entry_12b68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b68c inside entry_12b688 (0x12b688 - 0x12b6a0)
    ctx->pc = 0x12b68c;
    entry_12b688(rdram, ctx, runtime);
}

void entry_12b700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b700 inside entry_12b6cc (0x12b6cc - 0x12b760)
    ctx->pc = 0x12b700;
    entry_12b6cc(rdram, ctx, runtime);
}

void entry_12b718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b718 inside entry_12b6cc (0x12b6cc - 0x12b760)
    ctx->pc = 0x12b718;
    entry_12b6cc(rdram, ctx, runtime);
}

void entry_12b72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b72c inside entry_12b6cc (0x12b6cc - 0x12b760)
    ctx->pc = 0x12b72c;
    entry_12b6cc(rdram, ctx, runtime);
}

void entry_12b730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b730 inside entry_12b6cc (0x12b6cc - 0x12b760)
    ctx->pc = 0x12b730;
    entry_12b6cc(rdram, ctx, runtime);
}

void entry_12b790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b790 inside anticrack_itm_firewall (0x12b760 - 0x12b85c)
    ctx->pc = 0x12b790;
    anticrack_itm_firewall(rdram, ctx, runtime);
}

void entry_12b828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b828 inside anticrack_itm_firewall (0x12b760 - 0x12b85c)
    ctx->pc = 0x12b828;
    anticrack_itm_firewall(rdram, ctx, runtime);
}

void entry_12b958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b958 inside entry_12b948 (0x12b948 - 0x12b960)
    ctx->pc = 0x12b958;
    entry_12b948(rdram, ctx, runtime);
}

void entry_12b984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b984 inside entry_12b960 (0x12b960 - 0x12b990)
    ctx->pc = 0x12b984;
    entry_12b960(rdram, ctx, runtime);
}

void entry_12b9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12b9d8 inside entry_12b9cc (0x12b9cc - 0x12b9f0)
    ctx->pc = 0x12b9d8;
    entry_12b9cc(rdram, ctx, runtime);
}

void entry_12ba40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ba40 inside entry_12ba3c (0x12ba3c - 0x12ba50)
    ctx->pc = 0x12ba40;
    entry_12ba3c(rdram, ctx, runtime);
}

void entry_12ba7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ba7c inside entry_12ba78 (0x12ba78 - 0x12ba8c)
    ctx->pc = 0x12ba7c;
    entry_12ba78(rdram, ctx, runtime);
}

void entry_12bab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bab8 inside entry_12bab4 (0x12bab4 - 0x12bac8)
    ctx->pc = 0x12bab8;
    entry_12bab4(rdram, ctx, runtime);
}

void entry_12baf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12baf4 inside entry_12baf0 (0x12baf0 - 0x12bb0c)
    ctx->pc = 0x12baf4;
    entry_12baf0(rdram, ctx, runtime);
}

void entry_12bb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bb28 inside entry_12bb18 (0x12bb18 - 0x12bb30)
    ctx->pc = 0x12bb28;
    entry_12bb18(rdram, ctx, runtime);
}

void entry_12bb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bb78 inside entry_12bb74 (0x12bb74 - 0x12bbb0)
    ctx->pc = 0x12bb78;
    entry_12bb74(rdram, ctx, runtime);
}

void entry_12bb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bb88 inside entry_12bb74 (0x12bb74 - 0x12bbb0)
    ctx->pc = 0x12bb88;
    entry_12bb74(rdram, ctx, runtime);
}

void entry_12bb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bb9c inside entry_12bb74 (0x12bb74 - 0x12bbb0)
    ctx->pc = 0x12bb9c;
    entry_12bb74(rdram, ctx, runtime);
}

void entry_12bbb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bbb4 inside entry_12bbb0 (0x12bbb0 - 0x12bbc8)
    ctx->pc = 0x12bbb4;
    entry_12bbb0(rdram, ctx, runtime);
}

void entry_12bc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bc98 inside entry_12bc84 (0x12bc84 - 0x12bca8)
    ctx->pc = 0x12bc98;
    entry_12bc84(rdram, ctx, runtime);
}

void entry_12bcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bcd4 inside entry_12bcb8 (0x12bcb8 - 0x12bd08)
    ctx->pc = 0x12bcd4;
    entry_12bcb8(rdram, ctx, runtime);
}

void entry_12bd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bd80 inside entry_12bd64 (0x12bd64 - 0x12be08)
    ctx->pc = 0x12bd80;
    entry_12bd64(rdram, ctx, runtime);
}

void entry_12bd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bd9c inside entry_12bd64 (0x12bd64 - 0x12be08)
    ctx->pc = 0x12bd9c;
    entry_12bd64(rdram, ctx, runtime);
}

void entry_12bdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12bdf8 inside entry_12bd64 (0x12bd64 - 0x12be08)
    ctx->pc = 0x12bdf8;
    entry_12bd64(rdram, ctx, runtime);
}

void entry_12c01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c01c inside entry_12c018 (0x12c018 - 0x12c024)
    ctx->pc = 0x12c01c;
    entry_12c018(rdram, ctx, runtime);
}

void entry_12c06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c06c inside entry_12c060 (0x12c060 - 0x12c074)
    ctx->pc = 0x12c06c;
    entry_12c060(rdram, ctx, runtime);
}

void entry_12c090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c090 inside entry_12c088 (0x12c088 - 0x12c098)
    ctx->pc = 0x12c090;
    entry_12c088(rdram, ctx, runtime);
}

void entry_12c100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c100 inside entry_12c0fc (0x12c0fc - 0x12c140)
    ctx->pc = 0x12c100;
    entry_12c0fc(rdram, ctx, runtime);
}

void entry_12c104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c104 inside entry_12c0fc (0x12c0fc - 0x12c140)
    ctx->pc = 0x12c104;
    entry_12c0fc(rdram, ctx, runtime);
}

void entry_12c118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c118 inside entry_12c0fc (0x12c0fc - 0x12c140)
    ctx->pc = 0x12c118;
    entry_12c0fc(rdram, ctx, runtime);
}

void entry_12c1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c1bc inside entry_12c174 (0x12c174 - 0x12c1f4)
    ctx->pc = 0x12c1bc;
    entry_12c174(rdram, ctx, runtime);
}

void entry_12c1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c1cc inside entry_12c174 (0x12c174 - 0x12c1f4)
    ctx->pc = 0x12c1cc;
    entry_12c174(rdram, ctx, runtime);
}

void entry_12c254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c254 inside entry_12c24c (0x12c24c - 0x12c278)
    ctx->pc = 0x12c254;
    entry_12c24c(rdram, ctx, runtime);
}

void entry_12c258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c258 inside entry_12c24c (0x12c24c - 0x12c278)
    ctx->pc = 0x12c258;
    entry_12c24c(rdram, ctx, runtime);
}

void entry_12c2f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c2f4 inside entry_12c2e8 (0x12c2e8 - 0x12c318)
    ctx->pc = 0x12c2f4;
    entry_12c2e8(rdram, ctx, runtime);
}

void entry_12c340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c340 inside entry_12c338 (0x12c338 - 0x12c348)
    ctx->pc = 0x12c340;
    entry_12c338(rdram, ctx, runtime);
}

void entry_12c3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c3a0 inside entry_12c37c (0x12c37c - 0x12c3c4)
    ctx->pc = 0x12c3a0;
    entry_12c37c(rdram, ctx, runtime);
}

void entry_12c3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c3dc inside entry_12c3c4 (0x12c3c4 - 0x12c460)
    ctx->pc = 0x12c3dc;
    entry_12c3c4(rdram, ctx, runtime);
}

void entry_12c3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c3f8 inside entry_12c3c4 (0x12c3c4 - 0x12c460)
    ctx->pc = 0x12c3f8;
    entry_12c3c4(rdram, ctx, runtime);
}

void entry_12c428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c428 inside entry_12c3c4 (0x12c3c4 - 0x12c460)
    ctx->pc = 0x12c428;
    entry_12c3c4(rdram, ctx, runtime);
}

void entry_12c44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c44c inside entry_12c3c4 (0x12c3c4 - 0x12c460)
    ctx->pc = 0x12c44c;
    entry_12c3c4(rdram, ctx, runtime);
}

void entry_12c478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c478 inside entry_12c460 (0x12c460 - 0x12c49c)
    ctx->pc = 0x12c478;
    entry_12c460(rdram, ctx, runtime);
}

void entry_12c47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c47c inside entry_12c460 (0x12c460 - 0x12c49c)
    ctx->pc = 0x12c47c;
    entry_12c460(rdram, ctx, runtime);
}

void entry_12c4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c4a8 inside entry_12c49c (0x12c49c - 0x12c4c0)
    ctx->pc = 0x12c4a8;
    entry_12c49c(rdram, ctx, runtime);
}

void entry_12c4cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c4cc inside entry_12c4c0 (0x12c4c0 - 0x12c4d4)
    ctx->pc = 0x12c4cc;
    entry_12c4c0(rdram, ctx, runtime);
}

void entry_12c52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c52c inside entry_12c524 (0x12c524 - 0x12c558)
    ctx->pc = 0x12c52c;
    entry_12c524(rdram, ctx, runtime);
}

void entry_12c534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c534 inside entry_12c524 (0x12c524 - 0x12c558)
    ctx->pc = 0x12c534;
    entry_12c524(rdram, ctx, runtime);
}

void entry_12c550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c550 inside entry_12c524 (0x12c524 - 0x12c558)
    ctx->pc = 0x12c550;
    entry_12c524(rdram, ctx, runtime);
}

void entry_12c570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c570 inside entry_12c558 (0x12c558 - 0x12c5bc)
    ctx->pc = 0x12c570;
    entry_12c558(rdram, ctx, runtime);
}

void entry_12c590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c590 inside entry_12c558 (0x12c558 - 0x12c5bc)
    ctx->pc = 0x12c590;
    entry_12c558(rdram, ctx, runtime);
}

void entry_12c598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c598 inside entry_12c558 (0x12c558 - 0x12c5bc)
    ctx->pc = 0x12c598;
    entry_12c558(rdram, ctx, runtime);
}

void entry_12c59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c59c inside entry_12c558 (0x12c558 - 0x12c5bc)
    ctx->pc = 0x12c59c;
    entry_12c558(rdram, ctx, runtime);
}

void entry_12c5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c5ac inside entry_12c558 (0x12c558 - 0x12c5bc)
    ctx->pc = 0x12c5ac;
    entry_12c558(rdram, ctx, runtime);
}

void entry_12c5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c5e8 inside entry_12c5c8 (0x12c5c8 - 0x12c66c)
    ctx->pc = 0x12c5e8;
    entry_12c5c8(rdram, ctx, runtime);
}

void entry_12c608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c608 inside entry_12c5c8 (0x12c5c8 - 0x12c66c)
    ctx->pc = 0x12c608;
    entry_12c5c8(rdram, ctx, runtime);
}

void entry_12c654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c654 inside entry_12c5c8 (0x12c5c8 - 0x12c66c)
    ctx->pc = 0x12c654;
    entry_12c5c8(rdram, ctx, runtime);
}

void entry_12c664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c664 inside entry_12c5c8 (0x12c5c8 - 0x12c66c)
    ctx->pc = 0x12c664;
    entry_12c5c8(rdram, ctx, runtime);
}

void entry_12c698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c698 inside entry_12c66c (0x12c66c - 0x12c6d8)
    ctx->pc = 0x12c698;
    entry_12c66c(rdram, ctx, runtime);
}

void entry_12c6c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c6c8 inside entry_12c66c (0x12c66c - 0x12c6d8)
    ctx->pc = 0x12c6c8;
    entry_12c66c(rdram, ctx, runtime);
}

void entry_12c700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c700 inside entry_12c6ec (0x12c6ec - 0x12c718)
    ctx->pc = 0x12c700;
    entry_12c6ec(rdram, ctx, runtime);
}

void entry_12c728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c728 inside entry_12c718 (0x12c718 - 0x12c734)
    ctx->pc = 0x12c728;
    entry_12c718(rdram, ctx, runtime);
}

void entry_12c754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c754 inside entry_12c74c (0x12c74c - 0x12c75c)
    ctx->pc = 0x12c754;
    entry_12c74c(rdram, ctx, runtime);
}

void entry_12c760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c760 inside entry_12c75c (0x12c75c - 0x12c778)
    ctx->pc = 0x12c760;
    entry_12c75c(rdram, ctx, runtime);
}

void entry_12c818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c818 inside PasegaFindAseg__FP4ASEGP3ALO (0x12c808 - 0x12c840)
    ctx->pc = 0x12c818;
    PasegaFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime);
}

void entry_12c828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c828 inside PasegaFindAseg__FP4ASEGP3ALO (0x12c808 - 0x12c840)
    ctx->pc = 0x12c828;
    PasegaFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime);
}

void entry_12c830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c830 inside PasegaFindAseg__FP4ASEGP3ALO (0x12c808 - 0x12c840)
    ctx->pc = 0x12c830;
    PasegaFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime);
}

void entry_12c834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c834 inside PasegaFindAseg__FP4ASEGP3ALO (0x12c808 - 0x12c840)
    ctx->pc = 0x12c834;
    PasegaFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime);
}

void entry_12c898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c898 inside entry_12c888 (0x12c888 - 0x12c8b8)
    ctx->pc = 0x12c898;
    entry_12c888(rdram, ctx, runtime);
}

void entry_12c964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c964 inside entry_12c960 (0x12c960 - 0x12c984)
    ctx->pc = 0x12c964;
    entry_12c960(rdram, ctx, runtime);
}

void entry_12c9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c9c0 inside FWipingAseg__FP4ASEG (0x12c9a8 - 0x12c9e8)
    ctx->pc = 0x12c9c0;
    FWipingAseg__FP4ASEG(rdram, ctx, runtime);
}

void entry_12c9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c9d4 inside FWipingAseg__FP4ASEG (0x12c9a8 - 0x12c9e8)
    ctx->pc = 0x12c9d4;
    FWipingAseg__FP4ASEG(rdram, ctx, runtime);
}

void entry_12c9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12c9e0 inside FWipingAseg__FP4ASEG (0x12c9a8 - 0x12c9e8)
    ctx->pc = 0x12c9e0;
    FWipingAseg__FP4ASEG(rdram, ctx, runtime);
}

void entry_12ca78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ca78 inside entry_12ca60 (0x12ca60 - 0x12cac4)
    ctx->pc = 0x12ca78;
    entry_12ca60(rdram, ctx, runtime);
}

void entry_12ca88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ca88 inside entry_12ca60 (0x12ca60 - 0x12cac4)
    ctx->pc = 0x12ca88;
    entry_12ca60(rdram, ctx, runtime);
}

void entry_12caa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12caa0 inside entry_12ca60 (0x12ca60 - 0x12cac4)
    ctx->pc = 0x12caa0;
    entry_12ca60(rdram, ctx, runtime);
}

void entry_12cb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cb00 inside entry_12cac4 (0x12cac4 - 0x12cb28)
    ctx->pc = 0x12cb00;
    entry_12cac4(rdram, ctx, runtime);
}

void entry_12cb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cb68 inside entry_12cb28 (0x12cb28 - 0x12cba8)
    ctx->pc = 0x12cb68;
    entry_12cb28(rdram, ctx, runtime);
}

void entry_12cb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cb80 inside entry_12cb28 (0x12cb28 - 0x12cba8)
    ctx->pc = 0x12cb80;
    entry_12cb28(rdram, ctx, runtime);
}

void entry_12cc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc00 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc00;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc1c inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc1c;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc24 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc24;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc28 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc28;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc30 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc30;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc48 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc48;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc64 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc64;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc70 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc70;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cc88 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cc88;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12cca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cca8 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12cca8;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12ccac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ccac inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12ccac;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12ccb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ccb4 inside PeaFindAsegLabel__FP4ASEG3OID (0x12cbe8 - 0x12ccc0)
    ctx->pc = 0x12ccb4;
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime);
}

void entry_12ccdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ccdc inside entry_12ccd0 (0x12ccd0 - 0x12cce8)
    ctx->pc = 0x12ccdc;
    entry_12ccd0(rdram, ctx, runtime);
}

void entry_12cd20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cd20 inside PchnFindAseg__FP4ASEGP3ALO (0x12cce8 - 0x12cd34)
    ctx->pc = 0x12cd20;
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime);
}

void entry_12cd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cd50 inside entry_12cd34 (0x12cd34 - 0x12cd78)
    ctx->pc = 0x12cd50;
    entry_12cd34(rdram, ctx, runtime);
}

void entry_12cd54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cd54 inside entry_12cd34 (0x12cd34 - 0x12cd78)
    ctx->pc = 0x12cd54;
    entry_12cd34(rdram, ctx, runtime);
}

void entry_12cdf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cdf0 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12cdf0;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12ce0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ce0c inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12ce0c;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12ce18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ce18 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12ce18;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12ce20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ce20 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12ce20;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12ce98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ce98 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12ce98;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12ceb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ceb0 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12ceb0;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12cec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cec4 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12cec4;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12cecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cecc inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12cecc;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12ced4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ced4 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12ced4;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12cee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cee0 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12cee0;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12cf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cf08 inside PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6 (0x12cd78 - 0x12cf20)
    ctx->pc = 0x12cf08;
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime);
}

void entry_12cf34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cf34 inside entry_12cf20 (0x12cf20 - 0x12cf70)
    ctx->pc = 0x12cf34;
    entry_12cf20(rdram, ctx, runtime);
}

void entry_12cf38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cf38 inside entry_12cf20 (0x12cf20 - 0x12cf70)
    ctx->pc = 0x12cf38;
    entry_12cf20(rdram, ctx, runtime);
}

void entry_12cf48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cf48 inside entry_12cf20 (0x12cf20 - 0x12cf70)
    ctx->pc = 0x12cf48;
    entry_12cf20(rdram, ctx, runtime);
}

void entry_12cf78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cf78 inside entry_12cf70 (0x12cf70 - 0x12cfb4)
    ctx->pc = 0x12cf78;
    entry_12cf70(rdram, ctx, runtime);
}

void entry_12cf88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cf88 inside entry_12cf70 (0x12cf70 - 0x12cfb4)
    ctx->pc = 0x12cf88;
    entry_12cf70(rdram, ctx, runtime);
}

void entry_12cfbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cfbc inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12cfbc;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12cfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cfdc inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12cfdc;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12cfec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12cfec inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12cfec;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d054 inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d054;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d064 inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d064;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d090 inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d090;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d110 inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d110;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d138 inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d138;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d144 inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d144;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d154 inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d154;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d17c inside entry_12cfb4 (0x12cfb4 - 0x12d1b0)
    ctx->pc = 0x12d17c;
    entry_12cfb4(rdram, ctx, runtime);
}

void entry_12d1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d1f0 inside GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT (0x12d1b0 - 0x12d224)
    ctx->pc = 0x12d1f0;
    GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT(rdram, ctx, runtime);
}

void entry_12d20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d20c inside GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT (0x12d1b0 - 0x12d224)
    ctx->pc = 0x12d20c;
    GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT(rdram, ctx, runtime);
}

void entry_12d214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d214 inside GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT (0x12d1b0 - 0x12d224)
    ctx->pc = 0x12d214;
    GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT(rdram, ctx, runtime);
}

void entry_12d240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d240 inside entry_12d224 (0x12d224 - 0x12d268)
    ctx->pc = 0x12d240;
    entry_12d224(rdram, ctx, runtime);
}

void entry_12d274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d274 inside entry_12d268 (0x12d268 - 0x12d2a8)
    ctx->pc = 0x12d274;
    entry_12d268(rdram, ctx, runtime);
}

void entry_12d284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d284 inside entry_12d268 (0x12d268 - 0x12d2a8)
    ctx->pc = 0x12d284;
    entry_12d268(rdram, ctx, runtime);
}

void entry_12d3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d3d0 inside entry_12d3cc (0x12d3cc - 0x12d3e0)
    ctx->pc = 0x12d3d0;
    entry_12d3cc(rdram, ctx, runtime);
}

void entry_12d484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d484 inside entry_12d47c (0x12d47c - 0x12d48c)
    ctx->pc = 0x12d484;
    entry_12d47c(rdram, ctx, runtime);
}

void entry_12d490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d490 inside entry_12d48c (0x12d48c - 0x12d4a8)
    ctx->pc = 0x12d490;
    entry_12d48c(rdram, ctx, runtime);
}

void entry_12d494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d494 inside entry_12d48c (0x12d48c - 0x12d4a8)
    ctx->pc = 0x12d494;
    entry_12d48c(rdram, ctx, runtime);
}

void entry_12d500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d500 inside UpdateAsegaIeaCur__FP5ASEGA (0x12d4a8 - 0x12d570)
    ctx->pc = 0x12d500;
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12d520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d520 inside UpdateAsegaIeaCur__FP5ASEGA (0x12d4a8 - 0x12d570)
    ctx->pc = 0x12d520;
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12d528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d528 inside UpdateAsegaIeaCur__FP5ASEGA (0x12d4a8 - 0x12d570)
    ctx->pc = 0x12d528;
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12d540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d540 inside UpdateAsegaIeaCur__FP5ASEGA (0x12d4a8 - 0x12d570)
    ctx->pc = 0x12d540;
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12d548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d548 inside UpdateAsegaIeaCur__FP5ASEGA (0x12d4a8 - 0x12d570)
    ctx->pc = 0x12d548;
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12d55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d55c inside UpdateAsegaIeaCur__FP5ASEGA (0x12d4a8 - 0x12d570)
    ctx->pc = 0x12d55c;
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12d564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d564 inside UpdateAsegaIeaCur__FP5ASEGA (0x12d4a8 - 0x12d570)
    ctx->pc = 0x12d564;
    UpdateAsegaIeaCur__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12d590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d590 inside PactsegFindAsega__FP5ASEGA3OID (0x12d570 - 0x12d598)
    ctx->pc = 0x12d590;
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime);
}

void entry_12d5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d5ac inside entry_12d598 (0x12d598 - 0x12d5c8)
    ctx->pc = 0x12d5ac;
    entry_12d598(rdram, ctx, runtime);
}

void entry_12d5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d5b0 inside entry_12d598 (0x12d598 - 0x12d5c8)
    ctx->pc = 0x12d5b0;
    entry_12d598(rdram, ctx, runtime);
}

void entry_12d638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d638 inside HandleAsegaEvent__FP5ASEGAP2EAPi (0x12d5d0 - 0x12d66c)
    ctx->pc = 0x12d638;
    HandleAsegaEvent__FP5ASEGAP2EAPi(rdram, ctx, runtime);
}

void entry_12d63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d63c inside HandleAsegaEvent__FP5ASEGAP2EAPi (0x12d5d0 - 0x12d66c)
    ctx->pc = 0x12d63c;
    HandleAsegaEvent__FP5ASEGAP2EAPi(rdram, ctx, runtime);
}

void entry_12d694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d694 inside entry_12d66c (0x12d66c - 0x12d6cc)
    ctx->pc = 0x12d694;
    entry_12d66c(rdram, ctx, runtime);
}

void entry_12d6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d6a4 inside entry_12d66c (0x12d66c - 0x12d6cc)
    ctx->pc = 0x12d6a4;
    entry_12d66c(rdram, ctx, runtime);
}

void entry_12d720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d720 inside entry_12d704 (0x12d704 - 0x12d754)
    ctx->pc = 0x12d720;
    entry_12d704(rdram, ctx, runtime);
}

void entry_12d734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d734 inside entry_12d704 (0x12d704 - 0x12d754)
    ctx->pc = 0x12d734;
    entry_12d704(rdram, ctx, runtime);
}

void entry_12d774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d774 inside entry_12d754 (0x12d754 - 0x12d798)
    ctx->pc = 0x12d774;
    entry_12d754(rdram, ctx, runtime);
}

void entry_12d78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d78c inside entry_12d754 (0x12d754 - 0x12d798)
    ctx->pc = 0x12d78c;
    entry_12d754(rdram, ctx, runtime);
}

void entry_12d79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d79c inside entry_12d798 (0x12d798 - 0x12d7f0)
    ctx->pc = 0x12d79c;
    entry_12d798(rdram, ctx, runtime);
}

void entry_12d7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d7b4 inside entry_12d798 (0x12d798 - 0x12d7f0)
    ctx->pc = 0x12d7b4;
    entry_12d798(rdram, ctx, runtime);
}

void entry_12d7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d7b8 inside entry_12d798 (0x12d798 - 0x12d7f0)
    ctx->pc = 0x12d7b8;
    entry_12d798(rdram, ctx, runtime);
}

void entry_12d81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d81c inside entry_12d814 (0x12d814 - 0x12d86c)
    ctx->pc = 0x12d81c;
    entry_12d814(rdram, ctx, runtime);
}

void entry_12d82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d82c inside entry_12d814 (0x12d814 - 0x12d86c)
    ctx->pc = 0x12d82c;
    entry_12d814(rdram, ctx, runtime);
}

void entry_12d830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d830 inside entry_12d814 (0x12d814 - 0x12d86c)
    ctx->pc = 0x12d830;
    entry_12d814(rdram, ctx, runtime);
}

void entry_12d8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d8d4 inside entry_12d8ac (0x12d8ac - 0x12d90c)
    ctx->pc = 0x12d8d4;
    entry_12d8ac(rdram, ctx, runtime);
}

void entry_12d8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d8e4 inside entry_12d8ac (0x12d8ac - 0x12d90c)
    ctx->pc = 0x12d8e4;
    entry_12d8ac(rdram, ctx, runtime);
}

void entry_12d9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d9dc inside entry_12d9d4 (0x12d9d4 - 0x12d9e4)
    ctx->pc = 0x12d9dc;
    entry_12d9d4(rdram, ctx, runtime);
}

void entry_12d9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12d9ec inside entry_12d9e4 (0x12d9e4 - 0x12da04)
    ctx->pc = 0x12d9ec;
    entry_12d9e4(rdram, ctx, runtime);
}

void entry_12da0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12da0c inside entry_12da04 (0x12da04 - 0x12da1c)
    ctx->pc = 0x12da0c;
    entry_12da04(rdram, ctx, runtime);
}

void entry_12da34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12da34 inside entry_12da1c (0x12da1c - 0x12da44)
    ctx->pc = 0x12da34;
    entry_12da1c(rdram, ctx, runtime);
}

void entry_12da58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12da58 inside entry_12da44 (0x12da44 - 0x12da74)
    ctx->pc = 0x12da58;
    entry_12da44(rdram, ctx, runtime);
}

void entry_12da64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12da64 inside entry_12da44 (0x12da44 - 0x12da74)
    ctx->pc = 0x12da64;
    entry_12da44(rdram, ctx, runtime);
}

void entry_12dac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dac0 inside entry_12dab8 (0x12dab8 - 0x12dac8)
    ctx->pc = 0x12dac0;
    entry_12dab8(rdram, ctx, runtime);
}

void entry_12db68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12db68 inside entry_12db38 (0x12db38 - 0x12db70)
    ctx->pc = 0x12db68;
    entry_12db38(rdram, ctx, runtime);
}

void entry_12db8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12db8c inside entry_12db70 (0x12db70 - 0x12db9c)
    ctx->pc = 0x12db8c;
    entry_12db70(rdram, ctx, runtime);
}

void entry_12db94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12db94 inside entry_12db70 (0x12db70 - 0x12db9c)
    ctx->pc = 0x12db94;
    entry_12db70(rdram, ctx, runtime);
}

void entry_12dbcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dbcc inside entry_12db9c (0x12db9c - 0x12dc48)
    ctx->pc = 0x12dbcc;
    entry_12db9c(rdram, ctx, runtime);
}

void entry_12dbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dbe8 inside entry_12db9c (0x12db9c - 0x12dc48)
    ctx->pc = 0x12dbe8;
    entry_12db9c(rdram, ctx, runtime);
}

void entry_12dbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dbf8 inside entry_12db9c (0x12db9c - 0x12dc48)
    ctx->pc = 0x12dbf8;
    entry_12db9c(rdram, ctx, runtime);
}

void entry_12dc08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dc08 inside entry_12db9c (0x12db9c - 0x12dc48)
    ctx->pc = 0x12dc08;
    entry_12db9c(rdram, ctx, runtime);
}

void entry_12dc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dc18 inside entry_12db9c (0x12db9c - 0x12dc48)
    ctx->pc = 0x12dc18;
    entry_12db9c(rdram, ctx, runtime);
}

void entry_12dc24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dc24 inside entry_12db9c (0x12db9c - 0x12dc48)
    ctx->pc = 0x12dc24;
    entry_12db9c(rdram, ctx, runtime);
}

void entry_12dcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dcb0 inside entry_12dc64 (0x12dc64 - 0x12dcbc)
    ctx->pc = 0x12dcb0;
    entry_12dc64(rdram, ctx, runtime);
}

void entry_12dcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dcb4 inside entry_12dc64 (0x12dc64 - 0x12dcbc)
    ctx->pc = 0x12dcb4;
    entry_12dc64(rdram, ctx, runtime);
}

void entry_12dd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dd38 inside entry_12dd34 (0x12dd34 - 0x12dd58)
    ctx->pc = 0x12dd38;
    entry_12dd34(rdram, ctx, runtime);
}

void entry_12ddb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ddb4 inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12ddb4;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12ddd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ddd0 inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12ddd0;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12dde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dde4 inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12dde4;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12ddfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ddfc inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12ddfc;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12de10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12de10 inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12de10;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12de20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12de20 inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12de20;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12de30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12de30 inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12de30;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12de38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12de38 inside entry_12dd6c (0x12dd6c - 0x12de54)
    ctx->pc = 0x12de38;
    entry_12dd6c(rdram, ctx, runtime);
}

void entry_12def4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12def4 inside entry_12deec (0x12deec - 0x12df24)
    ctx->pc = 0x12def4;
    entry_12deec(rdram, ctx, runtime);
}

void entry_12dfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dfa0 inside entry_12df80 (0x12df80 - 0x12dfac)
    ctx->pc = 0x12dfa0;
    entry_12df80(rdram, ctx, runtime);
}

void entry_12dfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12dfb0 inside entry_12dfac (0x12dfac - 0x12dfdc)
    ctx->pc = 0x12dfb0;
    entry_12dfac(rdram, ctx, runtime);
}

void entry_12e078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e078 inside entry_12e054 (0x12e054 - 0x12e080)
    ctx->pc = 0x12e078;
    entry_12e054(rdram, ctx, runtime);
}

void entry_12e0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e0cc inside entry_12e0b4 (0x12e0b4 - 0x12e0e0)
    ctx->pc = 0x12e0cc;
    entry_12e0b4(rdram, ctx, runtime);
}

void entry_12e12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e12c inside entry_12e128 (0x12e128 - 0x12e134)
    ctx->pc = 0x12e12c;
    entry_12e128(rdram, ctx, runtime);
}

void entry_12e150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e150 inside entry_12e134 (0x12e134 - 0x12e160)
    ctx->pc = 0x12e150;
    entry_12e134(rdram, ctx, runtime);
}

void entry_12e188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e188 inside entry_12e184 (0x12e184 - 0x12e198)
    ctx->pc = 0x12e188;
    entry_12e184(rdram, ctx, runtime);
}

void entry_12e218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e218 inside entry_12e200 (0x12e200 - 0x12e224)
    ctx->pc = 0x12e218;
    entry_12e200(rdram, ctx, runtime);
}

void entry_12e248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e248 inside entry_12e240 (0x12e240 - 0x12e254)
    ctx->pc = 0x12e248;
    entry_12e240(rdram, ctx, runtime);
}

void entry_12e274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e274 inside entry_12e270 (0x12e270 - 0x12e290)
    ctx->pc = 0x12e274;
    entry_12e270(rdram, ctx, runtime);
}

void entry_12e2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e2ac inside entry_12e290 (0x12e290 - 0x12e2c0)
    ctx->pc = 0x12e2ac;
    entry_12e290(rdram, ctx, runtime);
}

void entry_12e2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e2c4 inside entry_12e2c0 (0x12e2c0 - 0x12e2dc)
    ctx->pc = 0x12e2c4;
    entry_12e2c0(rdram, ctx, runtime);
}

void entry_12e2f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e2f4 inside entry_12e2dc (0x12e2dc - 0x12e338)
    ctx->pc = 0x12e2f4;
    entry_12e2dc(rdram, ctx, runtime);
}

void entry_12e328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e328 inside entry_12e2dc (0x12e2dc - 0x12e338)
    ctx->pc = 0x12e328;
    entry_12e2dc(rdram, ctx, runtime);
}

void entry_12e4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e4c4 inside entry_12e4c0 (0x12e4c0 - 0x12e4e0)
    ctx->pc = 0x12e4c4;
    entry_12e4c0(rdram, ctx, runtime);
}

void entry_12e4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e4c8 inside entry_12e4c0 (0x12e4c0 - 0x12e4e0)
    ctx->pc = 0x12e4c8;
    entry_12e4c0(rdram, ctx, runtime);
}

void entry_12e528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e528 inside HandleAsegaEventsFF__FP5ASEGAP4ASEGPi (0x12e4e0 - 0x12e584)
    ctx->pc = 0x12e528;
    HandleAsegaEventsFF__FP5ASEGAP4ASEGPi(rdram, ctx, runtime);
}

void entry_12e58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e58c inside entry_12e584 (0x12e584 - 0x12e5d0)
    ctx->pc = 0x12e58c;
    entry_12e584(rdram, ctx, runtime);
}

void entry_12e5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e5b4 inside entry_12e584 (0x12e584 - 0x12e5d0)
    ctx->pc = 0x12e5b4;
    entry_12e584(rdram, ctx, runtime);
}

void entry_12e608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e608 inside HandleAsegaEvents__FP5ASEGAP4ASEGPi (0x12e5d0 - 0x12e66c)
    ctx->pc = 0x12e608;
    HandleAsegaEvents__FP5ASEGAP4ASEGPi(rdram, ctx, runtime);
}

void entry_12e65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e65c inside HandleAsegaEvents__FP5ASEGAP4ASEGPi (0x12e5d0 - 0x12e66c)
    ctx->pc = 0x12e65c;
    HandleAsegaEvents__FP5ASEGAP4ASEGPi(rdram, ctx, runtime);
}

void entry_12e680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e680 inside entry_12e66c (0x12e66c - 0x12e6e8)
    ctx->pc = 0x12e680;
    entry_12e66c(rdram, ctx, runtime);
}

void entry_12e6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e6cc inside entry_12e66c (0x12e66c - 0x12e6e8)
    ctx->pc = 0x12e6cc;
    entry_12e66c(rdram, ctx, runtime);
}

void entry_12e6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e6f4 inside entry_12e6e8 (0x12e6e8 - 0x12e710)
    ctx->pc = 0x12e6f4;
    entry_12e6e8(rdram, ctx, runtime);
}

void entry_12e6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e6f8 inside entry_12e6e8 (0x12e6e8 - 0x12e710)
    ctx->pc = 0x12e6f8;
    entry_12e6e8(rdram, ctx, runtime);
}

void entry_12e7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e7a8 inside RetractAsega__FP5ASEGA (0x12e760 - 0x12e7c0)
    ctx->pc = 0x12e7a8;
    RetractAsega__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12e7d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e7d4 inside entry_12e7c0 (0x12e7c0 - 0x12e7e4)
    ctx->pc = 0x12e7d4;
    entry_12e7c0(rdram, ctx, runtime);
}

void entry_12e850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e850 inside entry_12e848 (0x12e848 - 0x12e85c)
    ctx->pc = 0x12e850;
    entry_12e848(rdram, ctx, runtime);
}

void entry_12e860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e860 inside entry_12e85c (0x12e85c - 0x12e868)
    ctx->pc = 0x12e860;
    entry_12e85c(rdram, ctx, runtime);
}

void entry_12e8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e8a0 inside entry_12e868 (0x12e868 - 0x12e8b0)
    ctx->pc = 0x12e8a0;
    entry_12e868(rdram, ctx, runtime);
}

void entry_12e8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e8cc inside entry_12e8b0 (0x12e8b0 - 0x12e8e0)
    ctx->pc = 0x12e8cc;
    entry_12e8b0(rdram, ctx, runtime);
}

void entry_12e8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e8e4 inside entry_12e8e0 (0x12e8e0 - 0x12e8f8)
    ctx->pc = 0x12e8e4;
    entry_12e8e0(rdram, ctx, runtime);
}

void entry_12e9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e9ac inside UFromEaErrorFunc__FP2EAf (0x12e968 - 0x12e9e0)
    ctx->pc = 0x12e9ac;
    UFromEaErrorFunc__FP2EAf(rdram, ctx, runtime);
}

void entry_12e9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12e9d8 inside UFromEaErrorFunc__FP2EAf (0x12e968 - 0x12e9e0)
    ctx->pc = 0x12e9d8;
    UFromEaErrorFunc__FP2EAf(rdram, ctx, runtime);
}

void entry_12ea48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ea48 inside FWrapAsegaTime__FP5ASEGAPfT1 (0x12e9e0 - 0x12ea7c)
    ctx->pc = 0x12ea48;
    FWrapAsegaTime__FP5ASEGAPfT1(rdram, ctx, runtime);
}

void entry_12ea58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ea58 inside FWrapAsegaTime__FP5ASEGAPfT1 (0x12e9e0 - 0x12ea7c)
    ctx->pc = 0x12ea58;
    FWrapAsegaTime__FP5ASEGAPfT1(rdram, ctx, runtime);
}

void entry_12ea74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ea74 inside FWrapAsegaTime__FP5ASEGAPfT1 (0x12e9e0 - 0x12ea7c)
    ctx->pc = 0x12ea74;
    FWrapAsegaTime__FP5ASEGAPfT1(rdram, ctx, runtime);
}

void entry_12ea84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ea84 inside entry_12ea7c (0x12ea7c - 0x12eaa0)
    ctx->pc = 0x12ea84;
    entry_12ea7c(rdram, ctx, runtime);
}

void entry_12eab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eab8 inside entry_12eaa0 (0x12eaa0 - 0x12eb44)
    ctx->pc = 0x12eab8;
    entry_12eaa0(rdram, ctx, runtime);
}

void entry_12eac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eac4 inside entry_12eaa0 (0x12eaa0 - 0x12eb44)
    ctx->pc = 0x12eac4;
    entry_12eaa0(rdram, ctx, runtime);
}

void entry_12eae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eae8 inside entry_12eaa0 (0x12eaa0 - 0x12eb44)
    ctx->pc = 0x12eae8;
    entry_12eaa0(rdram, ctx, runtime);
}

void entry_12eb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eb24 inside entry_12eaa0 (0x12eaa0 - 0x12eb44)
    ctx->pc = 0x12eb24;
    entry_12eaa0(rdram, ctx, runtime);
}

void entry_12eb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eb34 inside entry_12eaa0 (0x12eaa0 - 0x12eb44)
    ctx->pc = 0x12eb34;
    entry_12eaa0(rdram, ctx, runtime);
}

void entry_12eb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eb3c inside entry_12eaa0 (0x12eaa0 - 0x12eb44)
    ctx->pc = 0x12eb3c;
    entry_12eaa0(rdram, ctx, runtime);
}

void entry_12eb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eb4c inside entry_12eb44 (0x12eb44 - 0x12eb80)
    ctx->pc = 0x12eb4c;
    entry_12eb44(rdram, ctx, runtime);
}

void entry_12eb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eb68 inside entry_12eb44 (0x12eb44 - 0x12eb80)
    ctx->pc = 0x12eb68;
    entry_12eb44(rdram, ctx, runtime);
}

void entry_12eba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eba4 inside entry_12eb80 (0x12eb80 - 0x12ebd8)
    ctx->pc = 0x12eba4;
    entry_12eb80(rdram, ctx, runtime);
}

void entry_12ebac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ebac inside entry_12eb80 (0x12eb80 - 0x12ebd8)
    ctx->pc = 0x12ebac;
    entry_12eb80(rdram, ctx, runtime);
}

void entry_12ebb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ebb0 inside entry_12eb80 (0x12eb80 - 0x12ebd8)
    ctx->pc = 0x12ebb0;
    entry_12eb80(rdram, ctx, runtime);
}

void entry_12ebb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ebb4 inside entry_12eb80 (0x12eb80 - 0x12ebd8)
    ctx->pc = 0x12ebb4;
    entry_12eb80(rdram, ctx, runtime);
}

void entry_12ebb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ebb8 inside entry_12eb80 (0x12eb80 - 0x12ebd8)
    ctx->pc = 0x12ebb8;
    entry_12eb80(rdram, ctx, runtime);
}

void entry_12ebbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ebbc inside entry_12eb80 (0x12eb80 - 0x12ebd8)
    ctx->pc = 0x12ebbc;
    entry_12eb80(rdram, ctx, runtime);
}

void entry_12ec40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ec40 inside UpdateAsega__FP5ASEGAf (0x12ebd8 - 0x12ecbc)
    ctx->pc = 0x12ec40;
    UpdateAsega__FP5ASEGAf(rdram, ctx, runtime);
}

void entry_12ec5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ec5c inside UpdateAsega__FP5ASEGAf (0x12ebd8 - 0x12ecbc)
    ctx->pc = 0x12ec5c;
    UpdateAsega__FP5ASEGAf(rdram, ctx, runtime);
}

void entry_12ec60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ec60 inside UpdateAsega__FP5ASEGAf (0x12ebd8 - 0x12ecbc)
    ctx->pc = 0x12ec60;
    UpdateAsega__FP5ASEGAf(rdram, ctx, runtime);
}

void entry_12ece0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ece0 inside entry_12ecbc (0x12ecbc - 0x12ed14)
    ctx->pc = 0x12ece0;
    entry_12ecbc(rdram, ctx, runtime);
}

void entry_12ed24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ed24 inside entry_12ed14 (0x12ed14 - 0x12ed50)
    ctx->pc = 0x12ed24;
    entry_12ed14(rdram, ctx, runtime);
}

void entry_12ed94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ed94 inside entry_12ed84 (0x12ed84 - 0x12ee54)
    ctx->pc = 0x12ed94;
    entry_12ed84(rdram, ctx, runtime);
}

void entry_12edb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12edb4 inside entry_12ed84 (0x12ed84 - 0x12ee54)
    ctx->pc = 0x12edb4;
    entry_12ed84(rdram, ctx, runtime);
}

void entry_12edc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12edc4 inside entry_12ed84 (0x12ed84 - 0x12ee54)
    ctx->pc = 0x12edc4;
    entry_12ed84(rdram, ctx, runtime);
}

void entry_12ede4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ede4 inside entry_12ed84 (0x12ed84 - 0x12ee54)
    ctx->pc = 0x12ede4;
    entry_12ed84(rdram, ctx, runtime);
}

void entry_12ee18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ee18 inside entry_12ed84 (0x12ed84 - 0x12ee54)
    ctx->pc = 0x12ee18;
    entry_12ed84(rdram, ctx, runtime);
}

void entry_12ee1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ee1c inside entry_12ed84 (0x12ed84 - 0x12ee54)
    ctx->pc = 0x12ee1c;
    entry_12ed84(rdram, ctx, runtime);
}

void entry_12ee20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ee20 inside entry_12ed84 (0x12ed84 - 0x12ee54)
    ctx->pc = 0x12ee20;
    entry_12ed84(rdram, ctx, runtime);
}

void entry_12ee94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ee94 inside entry_12ee70 (0x12ee70 - 0x12eea4)
    ctx->pc = 0x12ee94;
    entry_12ee70(rdram, ctx, runtime);
}

void entry_12ee9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ee9c inside entry_12ee70 (0x12ee70 - 0x12eea4)
    ctx->pc = 0x12ee9c;
    entry_12ee70(rdram, ctx, runtime);
}

void entry_12eeac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eeac inside entry_12eea4 (0x12eea4 - 0x12eee0)
    ctx->pc = 0x12eeac;
    entry_12eea4(rdram, ctx, runtime);
}

void entry_12eecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eecc inside entry_12eea4 (0x12eea4 - 0x12eee0)
    ctx->pc = 0x12eecc;
    entry_12eea4(rdram, ctx, runtime);
}

void entry_12eed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eed0 inside entry_12eea4 (0x12eea4 - 0x12eee0)
    ctx->pc = 0x12eed0;
    entry_12eea4(rdram, ctx, runtime);
}

void entry_12eed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eed4 inside entry_12eea4 (0x12eea4 - 0x12eee0)
    ctx->pc = 0x12eed4;
    entry_12eea4(rdram, ctx, runtime);
}

void entry_12eed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12eed8 inside entry_12eea4 (0x12eea4 - 0x12eee0)
    ctx->pc = 0x12eed8;
    entry_12eea4(rdram, ctx, runtime);
}

void entry_12ef00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ef00 inside entry_12eee0 (0x12eee0 - 0x12ef14)
    ctx->pc = 0x12ef00;
    entry_12eee0(rdram, ctx, runtime);
}

void entry_12ef24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ef24 inside entry_12ef14 (0x12ef14 - 0x12ef9c)
    ctx->pc = 0x12ef24;
    entry_12ef14(rdram, ctx, runtime);
}

void entry_12ef48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ef48 inside entry_12ef14 (0x12ef14 - 0x12ef9c)
    ctx->pc = 0x12ef48;
    entry_12ef14(rdram, ctx, runtime);
}

void entry_12efc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12efc8 inside entry_12efc4 (0x12efc4 - 0x12f008)
    ctx->pc = 0x12efc8;
    entry_12efc4(rdram, ctx, runtime);
}

void entry_12f034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f034 inside entry_12f030 (0x12f030 - 0x12f060)
    ctx->pc = 0x12f034;
    entry_12f030(rdram, ctx, runtime);
}

void entry_12f03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f03c inside entry_12f030 (0x12f030 - 0x12f060)
    ctx->pc = 0x12f03c;
    entry_12f030(rdram, ctx, runtime);
}

void entry_12f04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f04c inside entry_12f030 (0x12f030 - 0x12f060)
    ctx->pc = 0x12f04c;
    entry_12f030(rdram, ctx, runtime);
}

void entry_12f064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f064 inside entry_12f060 (0x12f060 - 0x12f0a0)
    ctx->pc = 0x12f064;
    entry_12f060(rdram, ctx, runtime);
}

void entry_12f0e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f0e4 inside SeekAsega__FP5ASEGA4SEEKff (0x12f0a0 - 0x12f110)
    ctx->pc = 0x12f0e4;
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime);
}

void entry_12f0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f0f4 inside SeekAsega__FP5ASEGA4SEEKff (0x12f0a0 - 0x12f110)
    ctx->pc = 0x12f0f4;
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime);
}

void entry_12f0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f0fc inside SeekAsega__FP5ASEGA4SEEKff (0x12f0a0 - 0x12f110)
    ctx->pc = 0x12f0fc;
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime);
}

void entry_12f100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f100 inside SeekAsega__FP5ASEGA4SEEKff (0x12f0a0 - 0x12f110)
    ctx->pc = 0x12f100;
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime);
}

void entry_12f104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f104 inside SeekAsega__FP5ASEGA4SEEKff (0x12f0a0 - 0x12f110)
    ctx->pc = 0x12f104;
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime);
}

void entry_12f108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f108 inside SeekAsega__FP5ASEGA4SEEKff (0x12f0a0 - 0x12f110)
    ctx->pc = 0x12f108;
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime);
}

void entry_12f148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f148 inside entry_12f140 (0x12f140 - 0x12f150)
    ctx->pc = 0x12f148;
    entry_12f140(rdram, ctx, runtime);
}

void entry_12f154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f154 inside entry_12f150 (0x12f150 - 0x12f15c)
    ctx->pc = 0x12f154;
    entry_12f150(rdram, ctx, runtime);
}

void entry_12f17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f17c inside entry_12f178 (0x12f178 - 0x12f190)
    ctx->pc = 0x12f17c;
    entry_12f178(rdram, ctx, runtime);
}

void entry_12f1b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f1b0 inside SnapAsega__FP5ASEGAi (0x12f190 - 0x12f1b8)
    ctx->pc = 0x12f1b0;
    SnapAsega__FP5ASEGAi(rdram, ctx, runtime);
}

void entry_12f1c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f1c4 inside entry_12f1b8 (0x12f1b8 - 0x12f1d8)
    ctx->pc = 0x12f1c4;
    entry_12f1b8(rdram, ctx, runtime);
}

void entry_12f1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f1f0 inside AdaptAsega__FP5ASEGA (0x12f1d8 - 0x12f1f8)
    ctx->pc = 0x12f1f0;
    AdaptAsega__FP5ASEGA(rdram, ctx, runtime);
}

void entry_12f204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f204 inside entry_12f1f8 (0x12f1f8 - 0x12f210)
    ctx->pc = 0x12f204;
    entry_12f1f8(rdram, ctx, runtime);
}

void entry_12f2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f2ec inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f2ec;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f35c inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f35c;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f37c inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f37c;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f3a8 inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f3a8;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f3c0 inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f3c0;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f3e8 inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f3e8;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f3f8 inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f3f8;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f410 inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f410;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f424 inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f424;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f428 inside entry_12f2ac (0x12f2ac - 0x12f454)
    ctx->pc = 0x12f428;
    entry_12f2ac(rdram, ctx, runtime);
}

void entry_12f4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f4b0 inside entry_12f454 (0x12f454 - 0x12f520)
    ctx->pc = 0x12f4b0;
    entry_12f454(rdram, ctx, runtime);
}

void entry_12f4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f4bc inside entry_12f454 (0x12f454 - 0x12f520)
    ctx->pc = 0x12f4bc;
    entry_12f454(rdram, ctx, runtime);
}

void entry_12f4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f4f0 inside entry_12f454 (0x12f454 - 0x12f520)
    ctx->pc = 0x12f4f0;
    entry_12f454(rdram, ctx, runtime);
}

void entry_12f570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f570 inside entry_12f520 (0x12f520 - 0x12f624)
    ctx->pc = 0x12f570;
    entry_12f520(rdram, ctx, runtime);
}

void entry_12f57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f57c inside entry_12f520 (0x12f520 - 0x12f624)
    ctx->pc = 0x12f57c;
    entry_12f520(rdram, ctx, runtime);
}

void entry_12f594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f594 inside entry_12f520 (0x12f520 - 0x12f624)
    ctx->pc = 0x12f594;
    entry_12f520(rdram, ctx, runtime);
}

void entry_12f5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f5d8 inside entry_12f520 (0x12f520 - 0x12f624)
    ctx->pc = 0x12f5d8;
    entry_12f520(rdram, ctx, runtime);
}

void entry_12f5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f5e8 inside entry_12f520 (0x12f520 - 0x12f624)
    ctx->pc = 0x12f5e8;
    entry_12f520(rdram, ctx, runtime);
}

void entry_12f62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f62c inside entry_12f624 (0x12f624 - 0x12f6b0)
    ctx->pc = 0x12f62c;
    entry_12f624(rdram, ctx, runtime);
}

void entry_12f63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f63c inside entry_12f624 (0x12f624 - 0x12f6b0)
    ctx->pc = 0x12f63c;
    entry_12f624(rdram, ctx, runtime);
}

void entry_12f644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f644 inside entry_12f624 (0x12f624 - 0x12f6b0)
    ctx->pc = 0x12f644;
    entry_12f624(rdram, ctx, runtime);
}

void entry_12f650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f650 inside entry_12f624 (0x12f624 - 0x12f6b0)
    ctx->pc = 0x12f650;
    entry_12f624(rdram, ctx, runtime);
}

void entry_12f65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f65c inside entry_12f624 (0x12f624 - 0x12f6b0)
    ctx->pc = 0x12f65c;
    entry_12f624(rdram, ctx, runtime);
}

void entry_12f704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f704 inside SetAsegaMasterSpeed__FP5ASEGAf (0x12f6d0 - 0x12f70c)
    ctx->pc = 0x12f704;
    SetAsegaMasterSpeed__FP5ASEGAf(rdram, ctx, runtime);
}

void entry_12f738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f738 inside SetAsegaPriority__FP5ASEGAi (0x12f718 - 0x12f740)
    ctx->pc = 0x12f738;
    SetAsegaPriority__FP5ASEGAi(rdram, ctx, runtime);
}

void entry_12f74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f74c inside entry_12f740 (0x12f740 - 0x12f760)
    ctx->pc = 0x12f74c;
    entry_12f740(rdram, ctx, runtime);
}

void entry_12f7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f7a8 inside entry_12f798 (0x12f798 - 0x12f7bc)
    ctx->pc = 0x12f7a8;
    entry_12f798(rdram, ctx, runtime);
}

void entry_12f7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f7c8 inside entry_12f7bc (0x12f7bc - 0x12f7e0)
    ctx->pc = 0x12f7c8;
    entry_12f7bc(rdram, ctx, runtime);
}

void entry_12f8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f8b8 inside entry_12f8b4 (0x12f8b4 - 0x12f8c8)
    ctx->pc = 0x12f8b8;
    entry_12f8b4(rdram, ctx, runtime);
}

void entry_12f910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f910 inside entry_12f900 (0x12f900 - 0x12f94c)
    ctx->pc = 0x12f910;
    entry_12f900(rdram, ctx, runtime);
}

void entry_12f99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12f99c inside entry_12f994 (0x12f994 - 0x12f9b8)
    ctx->pc = 0x12f99c;
    entry_12f994(rdram, ctx, runtime);
}

void entry_12fa24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fa24 inside entry_12fa04 (0x12fa04 - 0x12fa38)
    ctx->pc = 0x12fa24;
    entry_12fa04(rdram, ctx, runtime);
}

void entry_12fa40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fa40 inside entry_12fa38 (0x12fa38 - 0x12fa54)
    ctx->pc = 0x12fa40;
    entry_12fa38(rdram, ctx, runtime);
}

void entry_12fa6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fa6c inside entry_12fa68 (0x12fa68 - 0x12fa88)
    ctx->pc = 0x12fa6c;
    entry_12fa68(rdram, ctx, runtime);
}

void entry_12fa74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fa74 inside entry_12fa68 (0x12fa68 - 0x12fa88)
    ctx->pc = 0x12fa74;
    entry_12fa68(rdram, ctx, runtime);
}

void entry_12fac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fac0 inside entry_12faac (0x12faac - 0x12fae0)
    ctx->pc = 0x12fac0;
    entry_12faac(rdram, ctx, runtime);
}

void entry_12fac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fac4 inside entry_12faac (0x12faac - 0x12fae0)
    ctx->pc = 0x12fac4;
    entry_12faac(rdram, ctx, runtime);
}

void entry_12fb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fb00 inside entry_12fae0 (0x12fae0 - 0x12fb28)
    ctx->pc = 0x12fb00;
    entry_12fae0(rdram, ctx, runtime);
}

void entry_12fb08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fb08 inside entry_12fae0 (0x12fae0 - 0x12fb28)
    ctx->pc = 0x12fb08;
    entry_12fae0(rdram, ctx, runtime);
}

void entry_12fb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fb0c inside entry_12fae0 (0x12fae0 - 0x12fb28)
    ctx->pc = 0x12fb0c;
    entry_12fae0(rdram, ctx, runtime);
}

void entry_12fb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fb34 inside entry_12fb28 (0x12fb28 - 0x12fb68)
    ctx->pc = 0x12fb34;
    entry_12fb28(rdram, ctx, runtime);
}

void entry_12fb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fb38 inside entry_12fb28 (0x12fb28 - 0x12fb68)
    ctx->pc = 0x12fb38;
    entry_12fb28(rdram, ctx, runtime);
}

void entry_12fb48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fb48 inside entry_12fb28 (0x12fb28 - 0x12fb68)
    ctx->pc = 0x12fb48;
    entry_12fb28(rdram, ctx, runtime);
}

void entry_12fc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fc04 inside entry_12fbc8 (0x12fbc8 - 0x12fc24)
    ctx->pc = 0x12fc04;
    entry_12fbc8(rdram, ctx, runtime);
}

void entry_12fc10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fc10 inside entry_12fbc8 (0x12fbc8 - 0x12fc24)
    ctx->pc = 0x12fc10;
    entry_12fbc8(rdram, ctx, runtime);
}

void entry_12fc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fc28 inside entry_12fc24 (0x12fc24 - 0x12fcb0)
    ctx->pc = 0x12fc28;
    entry_12fc24(rdram, ctx, runtime);
}

void entry_12fc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fc74 inside entry_12fc24 (0x12fc24 - 0x12fcb0)
    ctx->pc = 0x12fc74;
    entry_12fc24(rdram, ctx, runtime);
}

void entry_12fc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fc80 inside entry_12fc24 (0x12fc24 - 0x12fcb0)
    ctx->pc = 0x12fc80;
    entry_12fc24(rdram, ctx, runtime);
}

void entry_12fc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fc98 inside entry_12fc24 (0x12fc24 - 0x12fcb0)
    ctx->pc = 0x12fc98;
    entry_12fc24(rdram, ctx, runtime);
}

void entry_12fc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fc9c inside entry_12fc24 (0x12fc24 - 0x12fcb0)
    ctx->pc = 0x12fc9c;
    entry_12fc24(rdram, ctx, runtime);
}

void entry_12fd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fd30 inside __18CBinaryAsyncStreamPv (0x12fcf0 - 0x12fd4c)
    ctx->pc = 0x12fd30;
    fn___18CBinaryAsyncStreamPv(rdram, ctx, runtime);
}

void entry_12fd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fd64 inside entry_12fd60 (0x12fd60 - 0x12fd78)
    ctx->pc = 0x12fd64;
    entry_12fd60(rdram, ctx, runtime);
}

void entry_12fe14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fe14 inside Close__18CBinaryAsyncStream (0x12fde8 - 0x12fe28)
    ctx->pc = 0x12fe14;
    Close__18CBinaryAsyncStream(rdram, ctx, runtime);
}

void entry_12fe2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fe2c inside entry_12fe28 (0x12fe28 - 0x12fe3c)
    ctx->pc = 0x12fe2c;
    entry_12fe28(rdram, ctx, runtime);
}

void entry_12fe34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fe34 inside entry_12fe28 (0x12fe28 - 0x12fe3c)
    ctx->pc = 0x12fe34;
    entry_12fe28(rdram, ctx, runtime);
}

void entry_12fe58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fe58 inside entry_12fe54 (0x12fe54 - 0x12fe70)
    ctx->pc = 0x12fe58;
    entry_12fe54(rdram, ctx, runtime);
}

void entry_12fe60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fe60 inside entry_12fe54 (0x12fe54 - 0x12fe70)
    ctx->pc = 0x12fe60;
    entry_12fe54(rdram, ctx, runtime);
}

void entry_12fedc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fedc inside entry_12fe84 (0x12fe84 - 0x12feec)
    ctx->pc = 0x12fedc;
    entry_12fe84(rdram, ctx, runtime);
}

void entry_12fef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12fef4 inside entry_12feec (0x12feec - 0x12ff00)
    ctx->pc = 0x12fef4;
    entry_12feec(rdram, ctx, runtime);
}

void entry_12ff04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ff04 inside entry_12ff00 (0x12ff00 - 0x12ff10)
    ctx->pc = 0x12ff04;
    entry_12ff00(rdram, ctx, runtime);
}

void entry_12ff08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ff08 inside entry_12ff00 (0x12ff00 - 0x12ff10)
    ctx->pc = 0x12ff08;
    entry_12ff00(rdram, ctx, runtime);
}

void entry_12ff78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ff78 inside entry_12ff54 (0x12ff54 - 0x12ff88)
    ctx->pc = 0x12ff78;
    entry_12ff54(rdram, ctx, runtime);
}

void entry_12ff98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ff98 inside entry_12ff88 (0x12ff88 - 0x12ffa0)
    ctx->pc = 0x12ff98;
    entry_12ff88(rdram, ctx, runtime);
}

void entry_12ffb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ffb8 inside entry_12ffb4 (0x12ffb4 - 0x12ffe8)
    ctx->pc = 0x12ffb8;
    entry_12ffb4(rdram, ctx, runtime);
}

void entry_12ffd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x12ffd0 inside entry_12ffb4 (0x12ffb4 - 0x12ffe8)
    ctx->pc = 0x12ffd0;
    entry_12ffb4(rdram, ctx, runtime);
}

