// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_15004c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15004c) {
        switch (ctx->pc) {
            case 0x15006c: ctx->pc = 0; goto label_15006c;
            case 0x150074: ctx->pc = 0; goto label_150074;
            case 0x150084: ctx->pc = 0; goto label_150084;
            case 0x150088: ctx->pc = 0; goto label_150088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15004c: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15006c;
    }
    // 0x150054: 0x8e2406e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1760)));
    // 0x150058: 0x8c830550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1360)));
    // 0x15005c: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_15006c;
    }
    // 0x150064: 0x14620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_150074;
    }
label_15006c:
    // 0x15006c: 0x10000083
    WRITE32(ADD32(GPR_U32(ctx, 17), 1760), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_15027c(rdram, ctx, runtime); return;
    }
label_150074:
    // 0x150074: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x150078: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x15007c: 0x10000002
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_150088;
    }
label_150084:
    // 0x150084: 0xc63406d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1748)); ctx->f[20] = *(float*)&val; }
label_150088:
    // 0x150088: 0x8e2606c8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1736)));
    // 0x15008c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150090: 0xae2006e0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1760), GPR_U32(ctx, 0));
    // 0x150094: 0xae2006c8
    WRITE32(ADD32(GPR_U32(ctx, 17), 1736), GPR_U32(ctx, 0));
    // 0x150098: 0xafa60090
    WRITE32(ADD32(GPR_U32(ctx, 29), 144), GPR_U32(ctx, 6));
    // 0x15009c: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1500a0: 0x8c430064
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 100)));
    // 0x1500a4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1500ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1500ac
// Address: 0x1500ac - 0x1500c4

void entry_1500ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1500ac: 0x8fa40090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1500b0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1500b4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1500b8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1500bc: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1500c4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1500c4
// Address: 0x1500c4 - 0x1500e4

void entry_1500c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1500c4: 0x8fa20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1500c8: 0x8c4401fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 508)));
    // 0x1500cc: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 320)));
        ctx->pc = 0x1500E8; return;
    }
    // 0x1500d4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1500d8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1500dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1500e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1500e4
// Address: 0x1500e4 - 0x15011c

void entry_1500e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1500e4) {
        switch (ctx->pc) {
            case 0x1500e8: ctx->pc = 0; goto label_1500e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1500e4: 0x7a420140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 320)));
label_1500e8:
    // 0x1500e8: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1500ec: 0x8fa30090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1500f0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1500f4: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1500f8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1500fc: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x150100: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x150104: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x150108: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15010c: 0xd8620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x150110: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x150114: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x15011c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_15011c
// Address: 0x15011c - 0x150130

void entry_15011c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15011c: 0x8fa40090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x150120: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x150124: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x150128: 0x40f809
    SET_GPR_U32(ctx, 31, 0x150130);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_150130
// Address: 0x150130 - 0x15017c

void entry_150130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150130: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x150134: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x150138: 0x8fa20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15013c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x150140: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x150144: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x150148: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15014c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x150150: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x150154: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x150158: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15015c: 0xc4410558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x150160: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x150164: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x150168: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x15016c: 0xe4400580
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 1408), *(uint32_t*)&val); }
    // 0x150170: 0x8e440050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x150174: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x15017c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 336));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_15017c
// Address: 0x15017c - 0x15023c

void entry_15017c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15017c: 0x8fa60090
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x150180: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x150184: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x150188: 0x8cc20580
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 1408)));
    // 0x15018c: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x150190: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x150194: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x150198: 0x4be31098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15019c: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1501a0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1501a4: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1501a8: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1501ac: 0xd8c20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 320)));
    // 0x1501b0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1501b4: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1501b8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1501bc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1501c0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1501c4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1501c8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1501cc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1501d0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1501d4: 0xc4c10558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x1501d8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1501dc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1501e0: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1501e4: 0xe4c00580
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 1408), *(uint32_t*)&val); }
    // 0x1501e8: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1501ec: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1501f0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1501f4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1501f8: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1501fc: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x150200: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x150204: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x150208: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x15020c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x150210: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x150214: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x150218: 0x8cc20558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 1368)));
    // 0x15021c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x150220: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x150224: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x150228: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x15022c: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x150230: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x150234: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15023c);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15023c
// Address: 0x15023c - 0x150248

void entry_15023c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15023c: 0x8fa40090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x150240: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x150248);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_150248
// Address: 0x150248 - 0x150260

void entry_150248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150248: 0x8fa20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15024c: 0xc44c055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1372)); ctx->f[12] = *(float*)&val; }
    // 0x150250: 0x24440140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 320));
    // 0x150254: 0xac52057c
    WRITE32(ADD32(GPR_U32(ctx, 2), 1404), GPR_U32(ctx, 18));
    // 0x150258: 0xc0559b2
    SET_GPR_U32(ctx, 31, 0x150260);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 1412), *(uint32_t*)&val); }
    StandardSmokeCloud__FP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_150260
// Address: 0x150260 - 0x15027c

void entry_150260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150260: 0x27a20090
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 144));
    // 0x150264: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x150268: 0xafa20094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 2));
    // 0x15026c: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x150270: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150274: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x15027c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 148));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_15027c
// Address: 0x15027c - 0x150298

void entry_15027c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15027c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x150280: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x150284: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x150288: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x15028c: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x150290: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AgeDartgunStuckDart__FP7DARTGUN
// Address: 0x150298 - 0x1502e0

void entry_1502e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1502e0) {
        switch (ctx->pc) {
            case 0x150300: ctx->pc = 0; goto label_150300;
            case 0x150308: ctx->pc = 0; goto label_150308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1502e0: 0x10400007
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_150300;
    }
    // 0x1502e8: 0xc4400554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1364)); ctx->f[0] = *(float*)&val; }
    // 0x1502ec: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1502f0: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_150300;
    }
    // 0x1502f8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1502fc: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
label_150300:
    // 0x150300: 0x1600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1502D8; return;
    }
label_150308:
    // 0x150308: 0x12200004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15031C; return;
    }
    // 0x150310: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x150318);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_150318
// Address: 0x150318 - 0x150338

void entry_150318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150318) {
        switch (ctx->pc) {
            case 0x15031c: ctx->pc = 0; goto label_15031c;
            case 0x150320: ctx->pc = 0; goto label_150320;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150318: 0xae5106cc
    WRITE32(ADD32(GPR_U32(ctx, 18), 1740), GPR_U32(ctx, 17));
label_15031c:
    // 0x15031c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_150320:
    // 0x150320: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x150324: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x150328: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15032c: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x150330: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PratGetDartgunRatTarget__FP7DARTGUN
// Address: 0x150338 - 0x150384

void entry_150384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150384) {
        switch (ctx->pc) {
            case 0x1503a4: ctx->pc = 0; goto label_1503a4;
            case 0x1503b4: ctx->pc = 0; goto label_1503b4;
            case 0x1503b8: ctx->pc = 0; goto label_1503b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150384: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1932)));
        goto label_1503a4;
    }
    // 0x15038c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x150390: 0x50550004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1932)));
        goto label_1503a4;
    }
    // 0x150398: 0x14540007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        goto label_1503b8;
    }
    // 0x1503a0: 0x8e62078c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1932)));
label_1503a4:
    // 0x1503a4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1503a8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1503ac: 0x1440fff2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x150378; return;
    }
label_1503b4:
    // 0x1503b4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1503b8:
    // 0x1503b8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1503bc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1503c0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1503c4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1503c8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1503cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1503d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1503d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1503dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1503e0; return;
}


// Function: AddDartgunRatTarget__FP7DARTGUN3OID
// Address: 0x1503e0 - 0x150408

void entry_15043c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15043c) {
        switch (ctx->pc) {
            case 0x15044c: ctx->pc = 0; goto label_15044c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15043c: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15044c;
    }
    // 0x150444: 0x10000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 1968), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1504C8; return;
    }
label_15044c:
    // 0x15044c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x150450: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x150458);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 65));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_150458
// Address: 0x150458 - 0x1504e0

void entry_150458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150458) {
        switch (ctx->pc) {
            case 0x150480: ctx->pc = 0; goto label_150480;
            case 0x1504a0: ctx->pc = 0; goto label_1504a0;
            case 0x1504c8: ctx->pc = 0; goto label_1504c8;
            case 0x1504cc: ctx->pc = 0; goto label_1504cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150458: 0x1040001b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1504c8;
    }
    // 0x150460: 0x8e020768
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1896)));
    // 0x150464: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150468: 0x1840000d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1504a0;
    }
    // 0x150470: 0x8e02076c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1900)));
    // 0x150474: 0x5051000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1504a0;
    }
    // 0x15047c: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_150480:
    // 0x150480: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    // 0x150484: 0x10400006
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1504a0;
    }
    // 0x15048c: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x150490: 0x8c43076c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1900)));
    // 0x150494: 0x5471fffa
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 17)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_150480;
    }
    // 0x15049c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1504a0:
    // 0x1504a0: 0x10a0000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1504cc;
    }
    // 0x1504a8: 0x8e03078c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1932)));
    // 0x1504ac: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1504b0: 0x10400006
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1504cc;
    }
    // 0x1504b8: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1504bc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1504c0: 0xac510790
    WRITE32(ADD32(GPR_U32(ctx, 2), 1936), GPR_U32(ctx, 17));
    // 0x1504c4: 0xae03078c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1932), GPR_U32(ctx, 3));
label_1504c8:
    // 0x1504c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1504cc:
    // 0x1504cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1504d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1504d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1504dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1504e0; return;
}


// Function: InitDialog__FP6DIALOG
// Address: 0x1504e0 - 0x1504f4

void entry_1504f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1504f4: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1504f8: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1504fc: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x150500: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x150504: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x150508: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15050c: 0xae04030c
    WRITE32(ADD32(GPR_U32(ctx, 16), 780), GPR_U32(ctx, 4));
    // 0x150510: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x150514: 0xae040300
    WRITE32(ADD32(GPR_U32(ctx, 16), 768), GPR_U32(ctx, 4));
    // 0x150518: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15051c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x150524: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x150528; return;
}


// Function: LoadDialogFromBrx__FP6DIALOGP18CBinaryInputStream
// Address: 0x150528 - 0x150544

void entry_150544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150544: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x150548: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15054c: 0x248602dc
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 732));
    // 0x150550: 0xc05415c
    SET_GPR_U32(ctx, 31, 0x150558);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 736));
    LoadDialogEventsFromBrx__FP6DIALOGP18CBinaryInputStreamPiPP2DE(rdram, ctx, runtime); return;
}


// Function: entry_150558
// Address: 0x150558 - 0x150570

void entry_150558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150558: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15055c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x150560: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x150564: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15056c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x150570; return;
}


// Function: LoadDialogEventsFromBrx__FP6DIALOGP18CBinaryInputStreamPiPP2DE
// Address: 0x150570 - 0x1505a4

void entry_1505a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1505a4: 0x24040028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1505a8: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x1505ac: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1505b4);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1505b4
// Address: 0x1505b4 - 0x1505dc

void entry_1505b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1505b4) {
        switch (ctx->pc) {
            case 0x1505c8: ctx->pc = 0; goto label_1505c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1505b4: 0xae820000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
    // 0x1505b8: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1505bc: 0x18400044
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1506D0; return;
    }
    // 0x1505c4: 0x24020028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
label_1505c8:
    // 0x1505c8: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1505cc: 0x2421018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1505d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1505d4: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x1505dc);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1505dc
// Address: 0x1505dc - 0x150614

void entry_1505dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1505dc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1505e0: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1505e4: 0x10400034
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1506B8; return;
    }
    // 0x1505ec: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1505f0: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1505f4: 0x2442a020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942752));
    // 0x1505f8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1505fc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x150600: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x150608: 0x26050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4));
    // 0x15060c: 0xc04e154
    SET_GPR_U32(ctx, 31, 0x150614);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Unknown2__18CBinaryInputStreamPPv(rdram, ctx, runtime); return;
}


// Function: entry_150614
// Address: 0x150614 - 0x150624

void entry_150614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150614: 0x10000029
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1506BC; return;
    }
    // 0x15061c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x150624);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150624
// Address: 0x150624 - 0x150630

void entry_150624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150624: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x150628: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x150630);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150630
// Address: 0x150630 - 0x150640

void entry_150630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150630: 0x10000021
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1506B8; return;
    }
    // 0x150638: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x150640);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150640
// Address: 0x150640 - 0x15064c

void entry_150640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150640: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x150644: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x15064c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_15064c
// Address: 0x15064c - 0x150658

void entry_15064c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15064c: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x150650: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x150658);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150658
// Address: 0x150658 - 0x150664

void entry_150658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150658: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15065c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x150664);
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150664
// Address: 0x150664 - 0x150670

void entry_150664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150664: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x150668: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x150670);
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150670
// Address: 0x150670 - 0x15067c

void entry_150670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150670: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x150674: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x15067c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_15067c
// Address: 0x15067c - 0x150688

void entry_15067c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15067c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x150680: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x150688);
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150688
// Address: 0x150688 - 0x150694

void entry_150688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150688: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15068c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x150694);
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_150694
// Address: 0x150694 - 0x1506a4

void entry_150694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150694: 0xae020024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    // 0x150698: 0x26050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 20));
    // 0x15069c: 0xc04e128
    SET_GPR_U32(ctx, 31, 0x1506a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ReadStringSw__18CBinaryInputStreamPPc(rdram, ctx, runtime); return;
}


// Function: entry_1506a4
// Address: 0x1506a4 - 0x1506b4

void entry_1506a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1506a4: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1506BC; return;
    }
    // 0x1506ac: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1506b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1506b4
// Address: 0x1506b4 - 0x1506f0

void entry_1506b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1506b4) {
        switch (ctx->pc) {
            case 0x1506b8: ctx->pc = 0; goto label_1506b8;
            case 0x1506bc: ctx->pc = 0; goto label_1506bc;
            case 0x1506d0: ctx->pc = 0; goto label_1506d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1506b4: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_1506b8:
    // 0x1506b8: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_1506bc:
    // 0x1506bc: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1506c0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1506c4: 0x1440ffc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1505C8; return;
    }
    // 0x1506cc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1506d0:
    // 0x1506d0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1506d4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1506d8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1506dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1506e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1506e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1506ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1506f0; return;
}


// Function: PostDialogLoad__FP6DIALOG
// Address: 0x1506f0 - 0x150704

void entry_150704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150704) {
        switch (ctx->pc) {
            case 0x150720: ctx->pc = 0; goto label_150720;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150704: 0x8e03030c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 780)));
    // 0x150708: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15070c: 0x14620004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_150720;
    }
    // 0x150714: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x150718: 0xae02030c
    WRITE32(ADD32(GPR_U32(ctx, 16), 780), GPR_U32(ctx, 2));
    // 0x15071c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_150720:
    // 0x150720: 0x8e05030c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 780)));
    // 0x150724: 0xc058328
    SET_GPR_U32(ctx, 31, 0x15072c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    PfLookupDialog__FP2LS3OID(rdram, ctx, runtime); return;
}


// Function: entry_15072c
// Address: 0x15072c - 0x150750

void entry_15072c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15072c) {
        switch (ctx->pc) {
            case 0x15073c: ctx->pc = 0; goto label_15073c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15072c: 0x14400003
    WRITE32(ADD32(GPR_U32(ctx, 16), 772), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15073c;
    }
    // 0x150734: 0x26020308
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 776));
    // 0x150738: 0xae020304
    WRITE32(ADD32(GPR_U32(ctx, 16), 772), GPR_U32(ctx, 2));
label_15073c:
    // 0x15073c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x150740: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x150744: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15074c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x150750; return;
}


// Function: SetDialogInstruct__FP6DIALOG
// Address: 0x150750 - 0x150760

void entry_150840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150840: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x150844: 0x24050015
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 21));
    // 0x150848: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15084c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x150854);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_150854
// Address: 0x150854 - 0x15087c

void entry_150854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150854: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x150858: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15085c: 0x1462000b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x15088C; return;
    }
    // 0x150864: 0x2405000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    // 0x150868: 0x24060006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15086c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150870: 0x24870460
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 1120));
    // 0x150874: 0xc05147c
    SET_GPR_U32(ctx, 31, 0x15087c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RevokeCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_15087c
// Address: 0x15087c - 0x150888

void entry_15087c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15087c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x150880: 0xc077694
    SET_GPR_U32(ctx, 31, 0x150888);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    DecrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_150888
// Address: 0x150888 - 0x150894

void entry_150888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150888) {
        switch (ctx->pc) {
            case 0x15088c: ctx->pc = 0; goto label_15088c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150888: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
label_15088c:
    // 0x15088c: 0xc052584
    SET_GPR_U32(ctx, 31, 0x150894);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1120));
    LookkPopCplook__FP6CPLOOK(rdram, ctx, runtime); return;
}


// Function: entry_150894
// Address: 0x150894 - 0x1508b8

void entry_150894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150894: 0x8e2302e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x150898: 0x30630010
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 16));
    // 0x15089c: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x1508BC; return;
    }
    // 0x1508a4: 0x8e2402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x1508a8: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x1508BC; return;
    }
    // 0x1508b0: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1508b8);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1508b8
// Address: 0x1508b8 - 0x1508e8

void entry_1508b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1508b8) {
        switch (ctx->pc) {
            case 0x1508bc: ctx->pc = 0; goto label_1508bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1508b8: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
label_1508bc:
    // 0x1508bc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1508c0: 0x14620017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x150920; return;
    }
    // 0x1508c8: 0x8e220330
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 816)));
    // 0x1508cc: 0x10400013
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15091c(rdram, ctx, runtime); return;
    }
    // 0x1508d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1508d8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1508dc: 0x24040009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1508e0: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1508e8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1508e8
// Address: 0x1508e8 - 0x1508f8

void entry_1508e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1508e8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1508ec: 0x24040009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1508f0: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1508f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1508f8
// Address: 0x1508f8 - 0x15091c

void entry_1508f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1508f8) {
        switch (ctx->pc) {
            case 0x150900: ctx->pc = 0; goto label_150900;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1508f8: 0x10000009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150920; return;
    }
label_150900:
    // 0x150900: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x150904: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150908: 0x244201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 504));
    // 0x15090c: 0xa8400327
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 807); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x150910: 0xb8400324
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 804); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x150914: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x15091c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_15091c
// Address: 0x15091c - 0x150970

void entry_15091c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15091c) {
        switch (ctx->pc) {
            case 0x150920: ctx->pc = 0; goto label_150920;
            case 0x150940: ctx->pc = 0; goto label_150940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15091c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
label_150920:
    // 0x150920: 0x1242001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 4));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x150990; return;
    }
    // 0x150928: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_150940;
    }
    // 0x150930: 0x52420011
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x150978; return;
    }
    // 0x150938: 0x10000060
    WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150ABC; return;
    }
label_150940:
    // 0x150940: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x150944: 0x1242004c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x150A78; return;
    }
    // 0x15094c: 0x5642005b
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 18));
        ctx->pc = 0x150ABC; return;
    }
    // 0x150954: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x150958: 0x2450f5a0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294964640));
    // 0x15095c: 0x8e040260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x150960: 0x50800055
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 17));
        entry_150ab8(rdram, ctx, runtime); return;
    }
    // 0x150968: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x150970);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_150970
// Address: 0x150970 - 0x1509bc

void entry_150970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150970) {
        switch (ctx->pc) {
            case 0x150978: ctx->pc = 0; goto label_150978;
            case 0x150990: ctx->pc = 0; goto label_150990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150970: 0x10000051
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_150ab8(rdram, ctx, runtime); return;
    }
label_150978:
    // 0x150978: 0x1052004f
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        entry_150ab8(rdram, ctx, runtime); return;
    }
    // 0x150980: 0x8c621d38
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 7480)));
    // 0x150984: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x150988: 0x1000004b
    WRITE32(ADD32(GPR_U32(ctx, 3), 7480), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_150ab8(rdram, ctx, runtime); return;
    }
label_150990:
    // 0x150990: 0x2413ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x150994: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x150998: 0xae3302e4
    WRITE32(ADD32(GPR_U32(ctx, 17), 740), GPR_U32(ctx, 19));
    // 0x15099c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1509a0: 0x14620022
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x150A2C; return;
    }
    // 0x1509a8: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1509ac: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1509b0: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1509b4: 0xc05257a
    SET_GPR_U32(ctx, 31, 0x1509bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1120));
    PushCplookLookk__FP6CPLOOK5LOOKK(rdram, ctx, runtime); return;
}


// Function: entry_1509bc
// Address: 0x1509bc - 0x1509d4

void entry_1509bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1509bc: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1509c0: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1509c4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1509c8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1509cc: 0xc051422
    SET_GPR_U32(ctx, 31, 0x1509d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1120));
    SetCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_1509d4
// Address: 0x1509d4 - 0x1509e0

void entry_1509d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1509d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1509d8: 0xc077688
    SET_GPR_U32(ctx, 31, 0x1509e0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    IncrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1509e0
// Address: 0x1509e0 - 0x1509f0

void entry_1509e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1509e0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1509e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1509e8: 0xc04d968
    SET_GPR_U32(ctx, 31, 0x1509f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 504));
    SetBinocLookat__FP5BINOCP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1509f0
// Address: 0x1509f0 - 0x150a14

void entry_1509f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1509f0: 0x8e220330
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 816)));
    // 0x1509f4: 0x10400030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_150ab8(rdram, ctx, runtime); return;
    }
    // 0x1509fc: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x150a00: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x150a04: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x150a08: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150a0c: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x150a14);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_150a14
// Address: 0x150a14 - 0x150a24

void entry_150a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150a14: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x150a18: 0x24040009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 9));
    // 0x150a1c: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x150a24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_150a24
// Address: 0x150a24 - 0x150a40

void entry_150a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150a24) {
        switch (ctx->pc) {
            case 0x150a2c: ctx->pc = 0; goto label_150a2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150a24: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150ABC; return;
    }
label_150a2c:
    // 0x150a2c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x150a30: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x150a34: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x150a38: 0xc05257a
    SET_GPR_U32(ctx, 31, 0x150a40);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1120));
    PushCplookLookk__FP6CPLOOK5LOOKK(rdram, ctx, runtime); return;
}


// Function: entry_150a40
// Address: 0x150a40 - 0x150a64

void entry_150a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150a40: 0x8e2202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x150a44: 0x5440001d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 18));
        ctx->pc = 0x150ABC; return;
    }
    // 0x150a4c: 0x8e250300
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 768)));
    // 0x150a50: 0x10b30007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x150A70; return;
    }
    // 0x150a58: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x150a5c: 0xc056912
    SET_GPR_U32(ctx, 31, 0x150a64);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_150a64
// Address: 0x150a64 - 0x150a8c

void entry_150a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150a64) {
        switch (ctx->pc) {
            case 0x150a70: ctx->pc = 0; goto label_150a70;
            case 0x150a78: ctx->pc = 0; goto label_150a78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150a64: 0x8e031990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x150a68: 0x10000013
    WRITE32(ADD32(GPR_U32(ctx, 3), 1212), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_150ab8(rdram, ctx, runtime); return;
    }
label_150a70:
    // 0x150a70: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 2), 1212), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_150ab8(rdram, ctx, runtime); return;
    }
label_150a78:
    // 0x150a78: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x150a7c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150a80: 0x261008e0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 2272));
    // 0x150a84: 0xc07a1b8
    SET_GPR_U32(ctx, 31, 0x150a8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTvSpeaker__FP2TVP7SPEAKER(rdram, ctx, runtime); return;
}


// Function: entry_150a8c
// Address: 0x150a8c - 0x150a98

void entry_150a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150a8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x150a90: 0xc07a1fc
    SET_GPR_U32(ctx, 31, 0x150a98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTvReplace__FP2TVP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_150a98
// Address: 0x150a98 - 0x150aac

void entry_150a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150a98: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x150a9c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150aa0: 0x26101558
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 5464));
    // 0x150aa4: 0xc07a1b8
    SET_GPR_U32(ctx, 31, 0x150aac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTvSpeaker__FP2TVP7SPEAKER(rdram, ctx, runtime); return;
}


// Function: entry_150aac
// Address: 0x150aac - 0x150ab8

void entry_150aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150aac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x150ab0: 0xc07a1fc
    SET_GPR_U32(ctx, 31, 0x150ab8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTvReplace__FP2TVP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_150ab8
// Address: 0x150ab8 - 0x150ae8

void entry_150ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150ab8) {
        switch (ctx->pc) {
            case 0x150abc: ctx->pc = 0; goto label_150abc;
            case 0x150ac8: ctx->pc = 0; goto label_150ac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150ab8: 0xae3202d4
    WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 18));
label_150abc:
    // 0x150abc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x150ac0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x150ac4: 0xe62002d8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 728), *(uint32_t*)&val); }
label_150ac8:
    // 0x150ac8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x150acc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x150ad0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x150ad4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x150ad8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x150adc: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x150ae0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateDialog__FP6DIALOGf
// Address: 0x150ae8 - 0x150b04

void entry_150b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150b04: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x150b08: 0x2463e9f8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294961656));
    // 0x150b0c: 0x8c620260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 608)));
    // 0x150b10: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x150b14: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 724)));
        ctx->pc = 0x150B50; return;
    }
    // 0x150b1c: 0x8c62026c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 620)));
    // 0x150b20: 0x5440000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 724)));
        ctx->pc = 0x150B50; return;
    }
    // 0x150b28: 0xc06f97a
    SET_GPR_U32(ctx, 31, 0x150b30);
    SetVagUnpaused__FUiUl(rdram, ctx, runtime); return;
}


// Function: entry_150b30
// Address: 0x150b30 - 0x150b80

void entry_150b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150b30) {
        switch (ctx->pc) {
            case 0x150b50: ctx->pc = 0; goto label_150b50;
            case 0x150b78: ctx->pc = 0; goto label_150b78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150b30: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 724)));
        goto label_150b50;
    }
    // 0x150b38: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x150b3c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150b40: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x150b44: 0x14640011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x150B8C; return;
    }
    // 0x150b4c: 0x8e0302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 724)));
label_150b50:
    // 0x150b50: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150b54: 0x10620008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_150b78;
    }
    // 0x150b5c: 0x1860000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 7));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x150B88; return;
    }
    // 0x150b64: 0x10400008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150B88; return;
    }
    // 0x150b6c: 0x14400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x150B8C; return;
    }
    // 0x150b74: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_150b78:
    // 0x150b78: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x150b80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_150b80
// Address: 0x150b80 - 0x150b98

void entry_150b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150b80) {
        switch (ctx->pc) {
            case 0x150b88: ctx->pc = 0; goto label_150b88;
            case 0x150b8c: ctx->pc = 0; goto label_150b8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150b80: 0x10000089
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150DA8; return;
    }
label_150b88:
    // 0x150b88: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_150b8c:
    // 0x150b8c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150b90: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x150b98);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_150b98
// Address: 0x150b98 - 0x150ba0

void entry_150b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150b98: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x150ba0);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_150ba0
// Address: 0x150ba0 - 0x150bb4

void entry_150ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150ba0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x150ba4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x150ba8: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x150bac: 0xc0524e8
    SET_GPR_U32(ctx, 31, 0x150bb4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1108));
    FActiveCplcy(rdram, ctx, runtime); return;
}


// Function: entry_150bb4
// Address: 0x150bb4 - 0x150be4

void entry_150bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150bb4) {
        switch (ctx->pc) {
            case 0x150bc8: ctx->pc = 0; goto label_150bc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150bb4: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_150bc8;
    }
    // 0x150bbc: 0xafa00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    // 0x150bc0: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150BF4; return;
    }
label_150bc8:
    // 0x150bc8: 0x12400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150BEC; return;
    }
    // 0x150bd0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x150bd4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x150bd8: 0x8c620154
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 340)));
    // 0x150bdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x150be4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_150be4
// Address: 0x150be4 - 0x150c4c

void entry_150be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150be4) {
        switch (ctx->pc) {
            case 0x150bec: ctx->pc = 0; goto label_150bec;
            case 0x150bf4: ctx->pc = 0; goto label_150bf4;
            case 0x150bf8: ctx->pc = 0; goto label_150bf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150be4: 0x10000004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_150bf8;
    }
label_150bec:
    // 0x150bec: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150bf0: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
label_150bf4:
    // 0x150bf4: 0x8e1102d4
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 724)));
label_150bf8:
    // 0x150bf8: 0x2e220007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 7));
    // 0x150bfc: 0x1040005a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D68; return;
    }
    // 0x150c04: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x150c08: 0x2442a040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942784));
    // 0x150c0c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x150c10: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x150c14: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x150c1c: 0x8e020324
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 804)));
    // 0x150c20: 0x10400051
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D68; return;
    }
    // 0x150c28: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x150c2c: 0x1460004f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D6C; return;
    }
    // 0x150c34: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x150c38: 0x1040004c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D6C; return;
    }
    // 0x150c40: 0xae000324
    WRITE32(ADD32(GPR_U32(ctx, 16), 804), GPR_U32(ctx, 0));
    // 0x150c44: 0xc05462e
    SET_GPR_U32(ctx, 31, 0x150c4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    TriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_150c4c
// Address: 0x150c4c - 0x150c9c

void entry_150c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150c4c: 0x10000046
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D68; return;
    }
    // 0x150c54: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x150c58: 0x1440001f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x150CD8; return;
    }
    // 0x150c60: 0x10000041
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D68; return;
    }
    // 0x150c68: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x150c6c: 0x1040001a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150CD8; return;
    }
    // 0x150c74: 0x1000003c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D68; return;
    }
    // 0x150c7c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x150c80: 0x10400014
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150CD4; return;
    }
    // 0x150c88: 0x8c44051c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x150c8c: 0x14800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x150CA4; return;
    }
    // 0x150c94: 0xc054618
    SET_GPR_U32(ctx, 31, 0x150c9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00151860(rdram, ctx, runtime); return;
}


// Function: entry_150c9c
// Address: 0x150c9c - 0x150ccc

void entry_150c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150c9c) {
        switch (ctx->pc) {
            case 0x150ca4: ctx->pc = 0; goto label_150ca4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150c9c: 0x10000032
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D68; return;
    }
label_150ca4:
    // 0x150ca4: 0x10900031
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x150D6C; return;
    }
    // 0x150cac: 0x8c820328
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 808)));
    // 0x150cb0: 0x1440002e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D6C; return;
    }
    // 0x150cb8: 0x8c8302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 724)));
    // 0x150cbc: 0x1462002b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x150D6C; return;
    }
    // 0x150cc4: 0xc0545b0
    SET_GPR_U32(ctx, 31, 0x150ccc);
    FUN_001516c0(rdram, ctx, runtime); return;
}


// Function: entry_150ccc
// Address: 0x150ccc - 0x150d44

void entry_150ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150ccc) {
        switch (ctx->pc) {
            case 0x150cd4: ctx->pc = 0; goto label_150cd4;
            case 0x150cd8: ctx->pc = 0; goto label_150cd8;
            case 0x150d38: ctx->pc = 0; goto label_150d38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150ccc: 0x10000027
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D6C; return;
    }
label_150cd4:
    // 0x150cd4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_150cd8:
    // 0x150cd8: 0xc60202d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 728)); ctx->f[2] = *(float*)&val; }
    // 0x150cdc: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x150ce0: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x150ce4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x150ce8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x150cec: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x150cf0: 0x0
    // NOP
    // 0x150cf4: 0x4503001c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x150D68; return;
    }
    // 0x150cfc: 0x1000001b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150D6C; return;
    }
    // 0x150d04: 0x8e0302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x150d08: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x150d0c: 0x10620017
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x150D6C; return;
    }
    // 0x150d14: 0x8e0202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x150d18: 0x8e0302dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 732)));
    // 0x150d1c: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x150d20: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_150d38;
    }
    // 0x150d28: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150d2c: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x150d30: 0x1464000e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x150D6C; return;
    }
label_150d38:
    // 0x150d38: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x150d3c: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x150d44);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_150d44
// Address: 0x150d44 - 0x150d74

void entry_150d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150d44) {
        switch (ctx->pc) {
            case 0x150d68: ctx->pc = 0; goto label_150d68;
            case 0x150d6c: ctx->pc = 0; goto label_150d6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150d44: 0x10000008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_150d68;
    }
    // 0x150d4c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x150d50: 0x8c430b30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 2864)));
    // 0x150d54: 0x14600005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_150d6c;
    }
    // 0x150d5c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x150d60: 0x8c4317a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6056)));
    // 0x150d64: 0x3880a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 0));
label_150d68:
    // 0x150d68: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_150d6c:
    // 0x150d6c: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x150d74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_150d74
// Address: 0x150d74 - 0x150da4

void entry_150d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150d74: 0x8e0302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    // 0x150d78: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x150d7c: 0x10400009
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_150da4(rdram, ctx, runtime); return;
    }
    // 0x150d84: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x150d88: 0x2442a060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942816));
    // 0x150d8c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x150d90: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x150d94: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x150d9c: 0xc0545f0
    SET_GPR_U32(ctx, 31, 0x150da4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    HandleDialogEvents__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_150da4
// Address: 0x150da4 - 0x150dc0

void entry_150da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150da4) {
        switch (ctx->pc) {
            case 0x150da8: ctx->pc = 0; goto label_150da8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150da4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_150da8:
    // 0x150da8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x150dac: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x150db0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x150db4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x150dbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x150dc0; return;
}


// Function: HandleDialogEvent__FP6DIALOGP2DE
// Address: 0x150dc0 - 0x150e18

void entry_150e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150e18: 0x8e2202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x150e1c: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x150e20: 0x10000118
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_151284(rdram, ctx, runtime); return;
    }
    // 0x150e28: 0x8e660004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x150e2c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x150e30: 0x10c20007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x150E50; return;
    }
    // 0x150e38: 0x8e270050
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x150e3c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x150e40: 0xc056906
    SET_GPR_U32(ctx, 31, 0x150e48);
    if (GPR_U32(ctx, 7) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 17));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_150e48
// Address: 0x150e48 - 0x150e74

void entry_150e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150e48) {
        switch (ctx->pc) {
            case 0x150e50: ctx->pc = 0; goto label_150e50;
            case 0x150e54: ctx->pc = 0; goto label_150e54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150e48: 0x10000002
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_150e54;
    }
label_150e50:
    // 0x150e50: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_150e54:
    // 0x150e54: 0x8e660008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x150e58: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x150e5c: 0x10c20007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x150E7C; return;
    }
    // 0x150e64: 0x8e270050
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x150e68: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x150e6c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x150e74);
    if (GPR_U32(ctx, 7) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 17));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_150e74
// Address: 0x150e74 - 0x150e9c

void entry_150e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150e74) {
        switch (ctx->pc) {
            case 0x150e7c: ctx->pc = 0; goto label_150e7c;
            case 0x150e80: ctx->pc = 0; goto label_150e80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150e74: 0x10000002
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_150e80;
    }
label_150e7c:
    // 0x150e7c: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_150e80:
    // 0x150e80: 0x52400007
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x150EA0; return;
    }
    // 0x150e88: 0x8e440334
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 820)));
    // 0x150e8c: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x150EA0; return;
    }
    // 0x150e94: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x150e9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 844));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_150e9c
// Address: 0x150e9c - 0x150ed0

void entry_150e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150e9c) {
        switch (ctx->pc) {
            case 0x150ea0: ctx->pc = 0; goto label_150ea0;
            case 0x150ebc: ctx->pc = 0; goto label_150ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150e9c: 0x8e650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_150ea0:
    // 0x150ea0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150ea4: 0x10a20005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_150ebc;
    }
    // 0x150eac: 0x10a20011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x150EF4; return;
    }
    // 0x150eb4: 0x100000f5
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15128C; return;
    }
label_150ebc:
    // 0x150ebc: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x150ec0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x150ec4: 0x261008e0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 2272));
    // 0x150ec8: 0xc07a1b8
    SET_GPR_U32(ctx, 31, 0x150ed0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTvSpeaker__FP2TVP7SPEAKER(rdram, ctx, runtime); return;
}


// Function: entry_150ed0
// Address: 0x150ed0 - 0x150edc

void entry_150ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150ed0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x150ed4: 0xc07a1fc
    SET_GPR_U32(ctx, 31, 0x150edc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetTvReplace__FP2TVP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_150edc
// Address: 0x150edc - 0x150f08

void entry_150edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150edc) {
        switch (ctx->pc) {
            case 0x150ef4: ctx->pc = 0; goto label_150ef4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150edc: 0x124000e9
    WRITE32(ADD32(GPR_U32(ctx, 17), 752), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_151284(rdram, ctx, runtime); return;
    }
    // 0x150ee4: 0x8e2202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x150ee8: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x150eec: 0x100000e5
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_151284(rdram, ctx, runtime); return;
    }
label_150ef4:
    // 0x150ef4: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x150ef8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x150efc: 0x26101558
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 5464));
    // 0x150f00: 0xc07a1b8
    SET_GPR_U32(ctx, 31, 0x150f08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTvSpeaker__FP2TVP7SPEAKER(rdram, ctx, runtime); return;
}


// Function: entry_150f08
// Address: 0x150f08 - 0x150f14

void entry_150f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150f08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x150f0c: 0xc07a1fc
    SET_GPR_U32(ctx, 31, 0x150f14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetTvReplace__FP2TVP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_150f14
// Address: 0x150f14 - 0x150f40

void entry_150f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150f14: 0x124000db
    WRITE32(ADD32(GPR_U32(ctx, 17), 756), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_151284(rdram, ctx, runtime); return;
    }
    // 0x150f1c: 0x8e2202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x150f20: 0x34420004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    // 0x150f24: 0x100000d7
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_151284(rdram, ctx, runtime); return;
    }
    // 0x150f2c: 0x8e2402f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 752)));
    // 0x150f30: 0x50800010
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 756)));
        ctx->pc = 0x150F74; return;
    }
    // 0x150f38: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x150f40);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_150f40
// Address: 0x150f40 - 0x150f58

void entry_150f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150f40: 0x1040000b
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150F70; return;
    }
    // 0x150f48: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150f4c: 0x248408e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2272));
    // 0x150f50: 0xc079d10
    SET_GPR_U32(ctx, 31, 0x150f58);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 752)));
    SetTvTvs__FP2TV3TVS(rdram, ctx, runtime); return;
}


// Function: entry_150f58
// Address: 0x150f58 - 0x150f68

void entry_150f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150f58: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x150f5c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150f60: 0xc079d10
    SET_GPR_U32(ctx, 31, 0x150f68);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5464));
    SetTvTvs__FP2TV3TVS(rdram, ctx, runtime); return;
}


// Function: entry_150f68
// Address: 0x150f68 - 0x150f84

void entry_150f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150f68) {
        switch (ctx->pc) {
            case 0x150f70: ctx->pc = 0; goto label_150f70;
            case 0x150f74: ctx->pc = 0; goto label_150f74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150f68: 0x10000014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150FBC; return;
    }
label_150f70:
    // 0x150f70: 0x8e2402f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 756)));
label_150f74:
    // 0x150f74: 0x10800010
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150FB8; return;
    }
    // 0x150f7c: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x150f84);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_150f84
// Address: 0x150f84 - 0x150f9c

void entry_150f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150f84: 0x1040000b
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x150FB4; return;
    }
    // 0x150f8c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x150f90: 0x24841558
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5464));
    // 0x150f94: 0xc079d10
    SET_GPR_U32(ctx, 31, 0x150f9c);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 756)));
    SetTvTvs__FP2TV3TVS(rdram, ctx, runtime); return;
}


// Function: entry_150f9c
// Address: 0x150f9c - 0x150fac

void entry_150f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x150f9c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x150fa0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x150fa4: 0xc079d10
    SET_GPR_U32(ctx, 31, 0x150fac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2272));
    SetTvTvs__FP2TV3TVS(rdram, ctx, runtime); return;
}


// Function: entry_150fac
// Address: 0x150fac - 0x150fd8

void entry_150fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150fac) {
        switch (ctx->pc) {
            case 0x150fb4: ctx->pc = 0; goto label_150fb4;
            case 0x150fb8: ctx->pc = 0; goto label_150fb8;
            case 0x150fbc: ctx->pc = 0; goto label_150fbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150fac: 0x10000003
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_150fbc;
    }
label_150fb4:
    // 0x150fb4: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_150fb8:
    // 0x150fb8: 0x8e66001c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 28)));
label_150fbc:
    // 0x150fbc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x150fc0: 0x10c2000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x150FEC; return;
    }
    // 0x150fc8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x150fcc: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x150fd0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x150fd8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_150fd8
// Address: 0x150fd8 - 0x151004

void entry_150fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x150fd8) {
        switch (ctx->pc) {
            case 0x150fec: ctx->pc = 0; goto label_150fec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x150fd8: 0x8e2302e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x150fdc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x150fe0: 0x34630010
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 16));
    // 0x150fe4: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151008; return;
    }
label_150fec:
    // 0x150fec: 0x12400006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151008; return;
    }
    // 0x150ff4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x150ff8: 0x2406054a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1354));
    // 0x150ffc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x151004);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_151004
// Address: 0x151004 - 0x151028

void entry_151004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151004) {
        switch (ctx->pc) {
            case 0x151008: ctx->pc = 0; goto label_151008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151004: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_151008:
    // 0x151008: 0x1080000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_151034(rdram, ctx, runtime); return;
    }
    // 0x151010: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x151014: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x151018: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x15101c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x151020: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x151028);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 760));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_151028
// Address: 0x151028 - 0x151034

void entry_151028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151028: 0x8e2402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x15102c: 0xc04be04
    SET_GPR_U32(ctx, 31, 0x151034);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SubscribeAsegaObject__FP5ASEGAP2LO(rdram, ctx, runtime); return;
}


// Function: entry_151034
// Address: 0x151034 - 0x151060

void entry_151034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151034: 0x8e650014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x151038: 0x50a0003c
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x15112C; return;
    }
    // 0x151040: 0x80a20000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x151044: 0x10400038
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151128; return;
    }
    // 0x15104c: 0x8e0301f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 504)));
    // 0x151050: 0x261401f8
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 504));
    // 0x151054: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x151058: 0x40f809
    SET_GPR_U32(ctx, 31, 0x151060);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_151060
// Address: 0x151060 - 0x1510d4

void entry_151060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151060) {
        switch (ctx->pc) {
            case 0x151080: ctx->pc = 0; goto label_151080;
            case 0x151090: ctx->pc = 0; goto label_151090;
            case 0x1510b0: ctx->pc = 0; goto label_1510b0;
            case 0x1510b4: ctx->pc = 0; goto label_1510b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151060: 0x12400007
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_151080;
    }
    // 0x151068: 0x8a4202d3
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 723); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x15106c: 0x9a4202d0
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 720); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x151070: 0xaa8202f7
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 759); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x151074: 0xba8202f4
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 756); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x151078: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151090;
    }
label_151080:
    // 0x151080: 0x3c028080
    SET_GPR_U32(ctx, 2, ((uint32_t)32896 << 16));
    // 0x151084: 0x34428080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32896));
    // 0x151088: 0xae8202f4
    WRITE32(ADD32(GPR_U32(ctx, 20), 756), GPR_U32(ctx, 2));
    // 0x15108c: 0x8e2402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 760)));
label_151090:
    // 0x151090: 0x10800007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1510b0;
    }
    // 0x151098: 0x8e63001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x15109c: 0x50620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[20] = *(float*)&val; }
        goto label_1510b4;
    }
    // 0x1510a4: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1510a8: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1510b4;
    }
label_1510b0:
    // 0x1510b0: 0xc6740008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[20] = *(float*)&val; }
label_1510b4:
    // 0x1510b4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1510b8: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1510bc: 0x0
    // NOP
    // 0x1510c0: 0x45000013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 504));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x151110; return;
    }
    // 0x1510c8: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x1510cc: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1510d4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 504));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1510d4
// Address: 0x1510d4 - 0x151154

void entry_1510d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1510d4) {
        switch (ctx->pc) {
            case 0x1510f0: ctx->pc = 0; goto label_1510f0;
            case 0x151108: ctx->pc = 0; goto label_151108;
            case 0x151110: ctx->pc = 0; goto label_151110;
            case 0x15111c: ctx->pc = 0; goto label_15111c;
            case 0x151128: ctx->pc = 0; goto label_151128;
            case 0x15112c: ctx->pc = 0; goto label_15112c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1510d4: 0x2442000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 10));
    // 0x1510d8: 0x4400005
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 2), 1));
    if (GPR_S32(ctx, 2) < 0) {
        goto label_1510f0;
    }
    // 0x1510e0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1510e4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1510e8: 0x10000007
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151108;
    }
label_1510f0:
    // 0x1510f0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1510f4: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1510f8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1510fc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x151100: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x151104: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
label_151108:
    // 0x151108: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 752), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15111c;
    }
label_151110:
    // 0x151110: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x151114: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x151118: 0xe44002f0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 752), *(uint32_t*)&val); }
label_15111c:
    // 0x15111c: 0x8e2202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x151120: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x151124: 0xae2202e8
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
label_151128:
    // 0x151128: 0xc6600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[0] = *(float*)&val; }
label_15112c:
    // 0x15112c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x151130: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x151134: 0x0
    // NOP
    // 0x151138: 0x45000009
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x151160; return;
    }
    // 0x151140: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x151144: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x151148: 0x248401f8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 504));
    // 0x15114c: 0xc04d96a
    SET_GPR_U32(ctx, 31, 0x151154);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    SetBinocZoom__FP5BINOCf(rdram, ctx, runtime); return;
}


// Function: entry_151154
// Address: 0x151154 - 0x1511b0

void entry_151154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151154) {
        switch (ctx->pc) {
            case 0x151160: ctx->pc = 0; goto label_151160;
            case 0x151190: ctx->pc = 0; goto label_151190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151154: 0x8e2202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x151158: 0x34420040
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 64));
    // 0x15115c: 0xae2202e8
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
label_151160:
    // 0x151160: 0xc6600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[0] = *(float*)&val; }
    // 0x151164: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x151168: 0x0
    // NOP
    // 0x15116c: 0x45000008
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_151190;
    }
    // 0x151174: 0x8e2202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    // 0x151178: 0x34420080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 128));
    // 0x15117c: 0xae2202e8
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
    // 0x151180: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x151184: 0xc6610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[1] = *(float*)&val; }
    // 0x151188: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15118c: 0xe62002fc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 764), *(uint32_t*)&val); }
label_151190:
    // 0x151190: 0x8e660020
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x151194: 0x2410ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x151198: 0x10d00009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 16)) {
        entry_1511c0(rdram, ctx, runtime); return;
    }
    // 0x1511a0: 0x8e270050
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1511a4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1511a8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1511b0);
    if (GPR_U32(ctx, 7) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 17));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1511b0
// Address: 0x1511b0 - 0x1511c0

void entry_1511b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1511b0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1511b4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1511b8: 0xc04d968
    SET_GPR_U32(ctx, 31, 0x1511c0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 504));
    SetBinocLookat__FP5BINOCP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1511c0
// Address: 0x1511c0 - 0x1511e8

void entry_1511c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1511c0) {
        switch (ctx->pc) {
            case 0x1511d4: ctx->pc = 0; goto label_1511d4;
            case 0x1511e0: ctx->pc = 0; goto label_1511e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1511c0: 0x8e650024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x1511c4: 0x50b00003
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 768)));
        goto label_1511d4;
    }
    // 0x1511cc: 0x10000004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1511e0;
    }
label_1511d4:
    // 0x1511d4: 0x10450008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x1511F8; return;
    }
    // 0x1511dc: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_1511e0:
    // 0x1511e0: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1511e8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1511e8
// Address: 0x1511e8 - 0x15124c

void entry_1511e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1511e8) {
        switch (ctx->pc) {
            case 0x1511f8: ctx->pc = 0; goto label_1511f8;
            case 0x151204: ctx->pc = 0; goto label_151204;
            case 0x151224: ctx->pc = 0; goto label_151224;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1511e8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1511ec: 0x8c641990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    // 0x1511f0: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 4), 1212), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151204;
    }
label_1511f8:
    // 0x1511f8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1511fc: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x151200: 0xac6004bc
    WRITE32(ADD32(GPR_U32(ctx, 3), 1212), GPR_U32(ctx, 0));
label_151204:
    // 0x151204: 0x8e62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x151208: 0x10400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151224;
    }
    // 0x151210: 0x34420100
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 256));
    // 0x151214: 0xae2202e8
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
    // 0x151218: 0x8e630010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x15121c: 0xae2302ec
    WRITE32(ADD32(GPR_U32(ctx, 17), 748), GPR_U32(ctx, 3));
    // 0x151220: 0x8e2202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 744)));
label_151224:
    // 0x151224: 0x34420008
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8));
    // 0x151228: 0x10000016
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_151284(rdram, ctx, runtime); return;
    }
    // 0x151230: 0x26620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 4));
    // 0x151234: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x151238: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x15123c: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x151240: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x151244: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x15124c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_15124c
// Address: 0x15124c - 0x15125c

void entry_15124c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15124c: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151288; return;
    }
    // 0x151254: 0xc0776d6
    SET_GPR_U32(ctx, 31, 0x15125c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    FUN_001ddb58(rdram, ctx, runtime); return;
}


// Function: entry_15125c
// Address: 0x15125c - 0x15126c

void entry_15125c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15125c: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151288; return;
    }
    // 0x151264: 0xc0776ee
    SET_GPR_U32(ctx, 31, 0x15126c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    FUN_001ddbb8(rdram, ctx, runtime); return;
}


// Function: entry_15126c
// Address: 0x15126c - 0x151284

void entry_15126c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15126c: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151288; return;
    }
    // 0x151274: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x151278: 0x8e650004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x15127c: 0xc063c3a
    SET_GPR_U32(ctx, 31, 0x151284);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941184));
    FUN_0018f0e8(rdram, ctx, runtime); return;
}


// Function: entry_151284
// Address: 0x151284 - 0x1512a8

void entry_151284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151284) {
        switch (ctx->pc) {
            case 0x151288: ctx->pc = 0; goto label_151288;
            case 0x15128c: ctx->pc = 0; goto label_15128c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151284: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_151288:
    // 0x151288: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_15128c:
    // 0x15128c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x151290: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x151294: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x151298: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15129c: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1512a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleDialogMessage__FP6DIALOG5MSGIDPv
// Address: 0x1512a8 - 0x1512cc

void entry_1512cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1512cc) {
        switch (ctx->pc) {
            case 0x1512e8: ctx->pc = 0; goto label_1512e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1512cc: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1512d0: 0x16020005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1512e8;
    }
    // 0x1512d8: 0x8e2202f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x1512dc: 0x52420002
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 760), GPR_U32(ctx, 0));
        goto label_1512e8;
    }
    // 0x1512e4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1512e8:
    // 0x1512e8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1512ec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1512f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1512f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1512fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x151300; return;
}


// Function: FPauseDialog__FP6DIALOG
// Address: 0x151300 - 0x151458

void entry_151458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151458) {
        switch (ctx->pc) {
            case 0x151470: ctx->pc = 0; goto label_151470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151458: 0x14400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_151470;
    }
    // 0x151460: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x151464: 0x3442fffe
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65534));
    // 0x151468: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x15146c: 0x32020008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 8));
label_151470:
    // 0x151470: 0x10400009
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151498; return;
    }
    // 0x151478: 0xc06fa60
    SET_GPR_U32(ctx, 31, 0x151480);
    FVagPlaying__Fv(rdram, ctx, runtime); return;
}


// Function: entry_151480
// Address: 0x151480 - 0x1514cc

void entry_151480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151480) {
        switch (ctx->pc) {
            case 0x151498: ctx->pc = 0; goto label_151498;
            case 0x1514bc: ctx->pc = 0; goto label_1514bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151480: 0x14400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_151498;
    }
    // 0x151488: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x15148c: 0x3442fff7
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65527));
    // 0x151490: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x151494: 0x32020010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 16));
label_151498:
    // 0x151498: 0x10400008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1514bc;
    }
    // 0x1514a0: 0x8e2202f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x1514a4: 0x14400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1514bc;
    }
    // 0x1514ac: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1514b0: 0x3442ffef
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65519));
    // 0x1514b4: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1514b8: 0x32020020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 32));
label_1514bc:
    // 0x1514bc: 0x10400008
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1514E0; return;
    }
    // 0x1514c4: 0xc04d94c
    SET_GPR_U32(ctx, 31, 0x1514cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 504));
    FDoneBinocAchz(rdram, ctx, runtime); return;
}


// Function: entry_1514cc
// Address: 0x1514cc - 0x1516c0

void entry_1514cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1514cc) {
        switch (ctx->pc) {
            case 0x1514e0: ctx->pc = 0; goto label_1514e0;
            case 0x1514e4: ctx->pc = 0; goto label_1514e4;
            case 0x151518: ctx->pc = 0; goto label_151518;
            case 0x15151c: ctx->pc = 0; goto label_15151c;
            case 0x151548: ctx->pc = 0; goto label_151548;
            case 0x15154c: ctx->pc = 0; goto label_15154c;
            case 0x151574: ctx->pc = 0; goto label_151574;
            case 0x15157c: ctx->pc = 0; goto label_15157c;
            case 0x1515f0: ctx->pc = 0; goto label_1515f0;
            case 0x151608: ctx->pc = 0; goto label_151608;
            case 0x15165c: ctx->pc = 0; goto label_15165c;
            case 0x15167c: ctx->pc = 0; goto label_15167c;
            case 0x15168c: ctx->pc = 0; goto label_15168c;
            case 0x1516a0: ctx->pc = 0; goto label_1516a0;
            case 0x1516a8: ctx->pc = 0; goto label_1516a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1514cc: 0x10400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1514e4;
    }
    // 0x1514d4: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1514d8: 0x3442ffdf
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65503));
    // 0x1514dc: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_1514e0:
    // 0x1514e0: 0x32020040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 64));
label_1514e4:
    // 0x1514e4: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151518;
    }
    // 0x1514ec: 0x264301f8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 504));
    // 0x1514f0: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1514f4: 0xc4610300
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 768)); ctx->f[1] = *(float*)&val; }
    // 0x1514f8: 0xc4800478
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1144)); ctx->f[0] = *(float*)&val; }
    // 0x1514fc: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x151500: 0x0
    // NOP
    // 0x151504: 0x45000005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 128));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_15151c;
    }
    // 0x15150c: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x151510: 0x3442ffbf
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65471));
    // 0x151514: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_151518:
    // 0x151518: 0x32020080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 128));
label_15151c:
    // 0x15151c: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151548;
    }
    // 0x151524: 0xc62102fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 764)); ctx->f[1] = *(float*)&val; }
    // 0x151528: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x15152c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x151530: 0x0
    // NOP
    // 0x151534: 0x45000005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 504));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_15154c;
    }
    // 0x15153c: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x151540: 0x3442ff7f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65407));
    // 0x151544: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_151548:
    // 0x151548: 0x264201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 504));
label_15154c:
    // 0x15154c: 0x24030100
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 256));
    // 0x151550: 0x16030053
    WRITE8(ADD32(GPR_U32(ctx, 2), 760), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        goto label_1516a0;
    }
    // 0x151558: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15155c: 0x8c622c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11368)));
    // 0x151560: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x151564: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151574;
    }
    // 0x15156c: 0x10000003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15157c;
    }
label_151574:
    // 0x151574: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x151578: 0x24452d38
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11576));
label_15157c:
    // 0x15157c: 0x8e2702ec
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 748)));
    // 0x151580: 0x24e3fff7
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 7), 4294967287));
    // 0x151584: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x151588: 0x10400034
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15165c;
    }
    // 0x151590: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x151594: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x151598: 0x2442a0a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942880));
    // 0x15159c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1515a0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1515a4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1515ac: 0xc4a10048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1515b0: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1515b4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1515b8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1515bc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1515c0: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151608;
    }
    // 0x1515c8: 0xc4a1007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 124)); ctx->f[1] = *(float*)&val; }
    // 0x1515cc: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1515d0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1515d4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1515d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1515dc: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151608;
    }
    // 0x1515e4: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 64)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1515f0;
    }
    // 0x1515ec: 0xc4a00044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 68)); ctx->f[0] = *(float*)&val; }
label_1515f0:
    // 0x1515f0: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1515f4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1515f8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1515fc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x151600: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x151604: 0x0
    // NOP
label_151608:
    // 0x151608: 0x4503001c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
        goto label_15167c;
    }
    // 0x151610: 0x1000001a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15167c;
    }
    // 0x151618: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15161c: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x151620: 0x10800016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_15167c;
    }
    // 0x151628: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x15162c: 0x14620013
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_15167c;
    }
    // 0x151634: 0x8c822228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8744)));
    // 0x151638: 0x38420003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 3));
    // 0x15163c: 0x1000000f
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15167c;
    }
    // 0x151644: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x151648: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x15164c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x151650: 0x30630004
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4));
    // 0x151654: 0x10000009
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15167c;
    }
label_15165c:
    // 0x15165c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x151660: 0x71840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 1));
    // 0x151664: 0x24421d08
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7432));
    // 0x151668: 0x94a400aa
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 170)));
    // 0x15166c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x151670: 0x94650000
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x151674: 0x852024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x151678: 0x4302b
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
label_15167c:
    // 0x15167c: 0x10c00003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_15168c;
    }
    // 0x151684: 0x10000006
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1516a0;
    }
label_15168c:
    // 0x15168c: 0x264401f8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 504));
    // 0x151690: 0x24421d28
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7464));
    // 0x151694: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x151698: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15169c: 0xa08302f8
    WRITE8(ADD32(GPR_U32(ctx, 4), 760), (uint8_t)GPR_U32(ctx, 3));
label_1516a0:
    // 0x1516a0: 0xae3002e8
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 16));
    // 0x1516a4: 0x10102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 16)));
label_1516a8:
    // 0x1516a8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1516ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1516b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1516b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1516b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001516c0
// Address: 0x1516c0 - 0x151758

void FUN_001516c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1516c0) {
        switch (ctx->pc) {
            case 0x151700: ctx->pc = 0; goto label_151700;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1516c0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1516c4: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1516c8: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1516cc: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1516d0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1516d4: 0x8e0202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    // 0x1516d8: 0x10430035
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1517B0; return;
    }
    // 0x1516e0: 0x8e0302e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x1516e4: 0x8e0402dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 732)));
    // 0x1516e8: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1516ec: 0x10400028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151790; return;
    }
    // 0x1516f4: 0x44182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
    // 0x1516f8: 0x10600025
    WRITE32(ADD32(GPR_U32(ctx, 16), 740), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151790; return;
    }
label_151700:
    // 0x151700: 0x8e0202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x151704: 0x24030028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 40));
    // 0x151708: 0x8e0402e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 736)));
    // 0x15170c: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x151710: 0x822821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x151714: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x151718: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x15171c: 0x10400016
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_151778(rdram, ctx, runtime); return;
    }
    // 0x151724: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x151728: 0x2442a0c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942912));
    // 0x15172c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x151730: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x151734: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x15173c: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x151740: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x151744: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x151748: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x15174c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x151750: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x151758);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_151758
// Address: 0x151758 - 0x151768

void entry_151758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151758: 0x10000008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15177C; return;
    }
    // 0x151760: 0xc0776d6
    SET_GPR_U32(ctx, 31, 0x151768);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddb58(rdram, ctx, runtime); return;
}


// Function: entry_151768
// Address: 0x151768 - 0x151778

void entry_151768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151768: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15177C; return;
    }
    // 0x151770: 0xc0776ee
    SET_GPR_U32(ctx, 31, 0x151778);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddbb8(rdram, ctx, runtime); return;
}


// Function: entry_151778
// Address: 0x151778 - 0x1517ac

void entry_151778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151778) {
        switch (ctx->pc) {
            case 0x15177c: ctx->pc = 0; goto label_15177c;
            case 0x151790: ctx->pc = 0; goto label_151790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151778: 0x8e0202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_15177c:
    // 0x15177c: 0x8e0302dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 732)));
    // 0x151780: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x151784: 0x43182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x151788: 0x1460ffdd
    WRITE32(ADD32(GPR_U32(ctx, 16), 740), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x151700; return;
    }
label_151790:
    // 0x151790: 0x8e0302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x151794: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x151798: 0x14620005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1517B0; return;
    }
    // 0x1517a0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1517a4: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x1517ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_1517ac
// Address: 0x1517ac - 0x1517c0

void entry_1517ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1517ac) {
        switch (ctx->pc) {
            case 0x1517b0: ctx->pc = 0; goto label_1517b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1517ac: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1517b0:
    // 0x1517b0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1517b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1517bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1517c0; return;
}


// Function: HandleDialogEvents__FP6DIALOG
// Address: 0x1517c0 - 0x151804

void entry_151804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151804: 0xc0544c0
    SET_GPR_U32(ctx, 31, 0x15180c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_15180c
// Address: 0x15180c - 0x151828

void entry_15180c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15180c: 0x14400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x151850; return;
    }
    // 0x151814: 0x8e0402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 760)));
    // 0x151818: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x151830; return;
    }
    // 0x151820: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x151828);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_151828
// Address: 0x151828 - 0x15184c

void entry_151828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151828) {
        switch (ctx->pc) {
            case 0x151830: ctx->pc = 0; goto label_151830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151828: 0xae0002f8
    WRITE32(ADD32(GPR_U32(ctx, 16), 760), GPR_U32(ctx, 0));
    // 0x15182c: 0x8e0302e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_151830:
    // 0x151830: 0x8e0202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 732)));
    // 0x151834: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x151838: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x15183c: 0x1440ffec
    WRITE32(ADD32(GPR_U32(ctx, 16), 740), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1517F0; return;
    }
    // 0x151844: 0xc0545b0
    SET_GPR_U32(ctx, 31, 0x15184c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001516c0(rdram, ctx, runtime); return;
}


// Function: entry_15184c
// Address: 0x15184c - 0x151860

void entry_15184c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15184c) {
        switch (ctx->pc) {
            case 0x151850: ctx->pc = 0; goto label_151850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15184c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_151850:
    // 0x151850: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x151854: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x151858: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00151860
// Address: 0x151860 - 0x151888

void FUN_00151860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151860: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x151864: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x151868: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x15186c: 0x10800008
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151890; return;
    }
    // 0x151874: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x151878: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15187c: 0x8c620158
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 344)));
    // 0x151880: 0x40f809
    SET_GPR_U32(ctx, 31, 0x151888);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_151888
// Address: 0x151888 - 0x1518a8

void entry_151888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151888) {
        switch (ctx->pc) {
            case 0x151890: ctx->pc = 0; goto label_151890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151888: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1518AC; return;
    }
label_151890:
    // 0x151890: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x151894: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x151898: 0x24a501f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 504));
    // 0x15189c: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x1518a0: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x1518a8);
    WRITE32(ADD32(GPR_U32(ctx, 5), 804), GPR_U32(ctx, 2));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1518a8
// Address: 0x1518a8 - 0x1518b8

void entry_1518a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1518a8) {
        switch (ctx->pc) {
            case 0x1518ac: ctx->pc = 0; goto label_1518ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1518a8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1518ac:
    // 0x1518ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1518b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1518b8; return;
}


// Function: TriggerDialog__FP6DIALOG
// Address: 0x1518b8 - 0x1518f0

void entry_1518f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1518f0) {
        switch (ctx->pc) {
            case 0x151940: ctx->pc = 0; goto label_151940;
            case 0x151968: ctx->pc = 0; goto label_151968;
            case 0x15198c: ctx->pc = 0; goto label_15198c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1518f0: 0x14400029
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x151998; return;
    }
    // 0x1518f8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1518fc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x151900: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x151904: 0x10640024
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x151998; return;
    }
    // 0x15190c: 0x8c43051c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x151910: 0x52030022
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x15199C; return;
    }
    // 0x151918: 0x8e030304
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 772)));
    // 0x15191c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x151920: 0x10400007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151940;
    }
    // 0x151928: 0x8e0302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x15192c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x151930: 0x14620016
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_15198c;
    }
    // 0x151938: 0x10000014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15198c;
    }
label_151940:
    // 0x151940: 0x8e070310
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 784)));
    // 0x151944: 0x18e00011
    if (GPR_S32(ctx, 7) <= 0) {
        goto label_15198c;
    }
    // 0x15194c: 0x18e0000f
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 7) <= 0) {
        goto label_15198c;
    }
    // 0x151954: 0x8e020314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 788)));
    // 0x151958: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15195c: 0x5460000b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
        goto label_15198c;
    }
    // 0x151964: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_151968:
    // 0x151968: 0xc7102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 7)));
    // 0x15196c: 0x10400007
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15198c;
    }
    // 0x151974: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x151978: 0x8c430314
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 788)));
    // 0x15197c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x151980: 0x1080fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_151968;
    }
    // 0x151988: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
label_15198c:
    // 0x15198c: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x151994);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_151994
// Address: 0x151994 - 0x1519a8

void entry_151994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151994) {
        switch (ctx->pc) {
            case 0x151998: ctx->pc = 0; goto label_151998;
            case 0x15199c: ctx->pc = 0; goto label_15199c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151994: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_151998:
    // 0x151998: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_15199c:
    // 0x15199c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1519a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1519a8; return;
}


// Function: UntriggerDialog__FP6DIALOG
// Address: 0x1519a8 - 0x1519d0

void entry_1519d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1519d0) {
        switch (ctx->pc) {
            case 0x1519d4: ctx->pc = 0; goto label_1519d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1519d0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1519d4:
    // 0x1519d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1519dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1519e0; return;
}


// Function: PdifficultyEnsureSw
// Address: 0x1519e0 - 0x151a10

void entry_151a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151a10: 0x1040000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x151A44; return;
    }
    // 0x151a18: 0xc058328
    SET_GPR_U32(ctx, 31, 0x151a20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PfLookupDialog__FP2LS3OID(rdram, ctx, runtime); return;
}


// Function: entry_151a20
// Address: 0x151a20 - 0x151a58

void entry_151a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151a20) {
        switch (ctx->pc) {
            case 0x151a44: ctx->pc = 0; goto label_151a44;
            case 0x151a48: ctx->pc = 0; goto label_151a48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151a20: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x151a24: 0x10800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_151a48;
    }
    // 0x151a2c: 0x8e030310
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 784)));
    // 0x151a30: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x151a34: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x151a38: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x151a3c: 0xac440314
    WRITE32(ADD32(GPR_U32(ctx, 2), 788), GPR_U32(ctx, 4));
    // 0x151a40: 0xae030310
    WRITE32(ADD32(GPR_U32(ctx, 16), 784), GPR_U32(ctx, 3));
label_151a44:
    // 0x151a44: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_151a48:
    // 0x151a48: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x151a4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x151a50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00151A58
// Address: 0x151a58 - 0x151a68

void FUN_00151A58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151a58: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x151a5c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7920));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x151a64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x151a68; return;
}


// Function: OnDifficultyGameLoad__FP10DIFFICULTY
// Address: 0x151a68 - 0x151a7c

void entry_151a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151a7c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x151a80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnDifficultyWorldPreLoad
// Address: 0x151a88 - 0x151b34

void entry_151b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151b34) {
        switch (ctx->pc) {
            case 0x151b54: ctx->pc = 0; goto label_151b54;
            case 0x151b98: ctx->pc = 0; goto label_151b98;
            case 0x151bd8: ctx->pc = 0; goto label_151bd8;
            case 0x151be0: ctx->pc = 0; goto label_151be0;
            case 0x151bf8: ctx->pc = 0; goto label_151bf8;
            case 0x151c3c: ctx->pc = 0; goto label_151c3c;
            case 0x151c7c: ctx->pc = 0; goto label_151c7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151b34: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x151b38: 0x8e2323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    // 0x151b3c: 0x8c450024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x151b40: 0x8c44001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x151b44: 0x14850003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[4] = *(float*)&val; }
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 5)) {
        goto label_151b54;
    }
    // 0x151b4c: 0x10000024
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151be0;
    }
label_151b54:
    // 0x151b54: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x151b58: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151b98;
    }
    // 0x151b60: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x151b64: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x151b68: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x151b6c: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x151b70: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x151b74: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x151b78: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x151b7c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x151b80: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x151b84: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x151b88: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x151b8c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x151b90: 0x10000011
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151bd8;
    }
label_151b98:
    // 0x151b98: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x151b9c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x151ba0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x151ba4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x151ba8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x151bac: 0x44851800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 5);
    // 0x151bb0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x151bb4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x151bb8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x151bbc: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x151bc0: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x151bc4: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x151bc8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x151bcc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x151bd0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x151bd4: 0xa22021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
label_151bd8:
    // 0x151bd8: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x151bdc: 0x8e2323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
label_151be0:
    // 0x151be0: 0x8c460028
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x151be4: 0x8c450020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x151be8: 0x14a60003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[4] = *(float*)&val; }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 6)) {
        goto label_151bf8;
    }
    // 0x151bf0: 0x10000022
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151c7c;
    }
label_151bf8:
    // 0x151bf8: 0xa6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 6)));
    // 0x151bfc: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151c3c;
    }
    // 0x151c04: 0x44860000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 6);
    // 0x151c08: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x151c0c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x151c10: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x151c14: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x151c18: 0x44851000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 5);
    // 0x151c1c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x151c20: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x151c24: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x151c28: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x151c2c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x151c30: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x151c34: 0x10000011
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151c7c;
    }
label_151c3c:
    // 0x151c3c: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x151c40: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x151c44: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x151c48: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x151c4c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x151c50: 0x44861800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 6);
    // 0x151c54: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x151c58: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x151c5c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x151c60: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x151c64: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x151c68: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x151c6c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x151c70: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x151c74: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x151c78: 0xc22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
label_151c7c:
    // 0x151c7c: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x151c84);
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_151c84
// Address: 0x151c84 - 0x151d08

void entry_151c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151c84) {
        switch (ctx->pc) {
            case 0x151cd0: ctx->pc = 0; goto label_151cd0;
            case 0x151cfc: ctx->pc = 0; goto label_151cfc;
            case 0x151d00: ctx->pc = 0; goto label_151d00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151c84: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x151c88: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x151c8c: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x151c90: 0x8c850054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 84)));
    // 0x151c94: 0x18a00019
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_151cfc;
    }
    // 0x151c9c: 0x8e2223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    // 0x151ca0: 0x8c830058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 88)));
    // 0x151ca4: 0xc4410010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[1] = *(float*)&val; }
    // 0x151ca8: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x151cac: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x151cb0: 0x0
    // NOP
    // 0x151cb4: 0x45030012
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 8)));
        goto label_151d00;
    }
    // 0x151cbc: 0x80402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x151cc0: 0xa0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x151cc4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x151cc8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x151ccc: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_151cd0:
    // 0x151cd0: 0xc7102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 7)));
    // 0x151cd4: 0x10400009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 12));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_151cfc;
    }
    // 0x151cdc: 0x8d020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 88)));
    // 0x151ce0: 0xc4a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 16)); ctx->f[1] = *(float*)&val; }
    // 0x151ce4: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x151ce8: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x151cec: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x151cf0: 0x0
    // NOP
    // 0x151cf4: 0x4500fff6
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_151cd0;
    }
label_151cfc:
    // 0x151cfc: 0x8c650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 8)));
label_151d00:
    // 0x151d00: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x151d08);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_151d08
// Address: 0x151d08 - 0x151d28

void entry_151d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151d08: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x151d0c: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x151d10: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x151d14: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x151d18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x151d1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x151d24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x151d28; return;
}


// Function: OnDifficultyWorldPostLoad
// Address: 0x151d28 - 0x151dc8

void entry_151dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151dc8) {
        switch (ctx->pc) {
            case 0x151dd4: ctx->pc = 0; goto label_151dd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151dc8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x151dcc: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_151df8(rdram, ctx, runtime); return;
    }
label_151dd4:
    // 0x151dd4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x151dd8: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x151ddc: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x151de0: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    // 0x151de4: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x151dec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[12] = *(float*)&val; }
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_151dec
// Address: 0x151dec - 0x151df8

void entry_151dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151dec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x151df0: 0xc054904
    SET_GPR_U32(ctx, 31, 0x151df8);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    ChangeSuck__FfP10DIFFICULTY(rdram, ctx, runtime); return;
}


// Function: entry_151df8
// Address: 0x151df8 - 0x151e04

void entry_151df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151df8) {
        switch (ctx->pc) {
            case 0x151dfc: ctx->pc = 0; goto label_151dfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151df8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_151dfc:
    // 0x151dfc: 0xc052338
    SET_GPR_U32(ctx, 31, 0x151e04);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    RemoveSwExtraneousCharms__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_151e04
// Address: 0x151e04 - 0x151e18

void entry_151e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151e04: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x151e08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x151e0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x151e14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x151e18; return;
}


// Function: OnDifficultyInitialTeleport__FP10DIFFICULTY
// Address: 0x151e18 - 0x151e20

void entry_151e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151e64) {
        switch (ctx->pc) {
            case 0x151e84: ctx->pc = 0; goto label_151e84;
            case 0x151e9c: ctx->pc = 0; goto label_151e9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151e64: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x151e68: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x151e6c: 0x8c6319e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 6624)));
    // 0x151e70: 0x4630004
    if (GPR_S32(ctx, 3) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        goto label_151e84;
    }
    // 0x151e78: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x151e7c: 0x10000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_151e9c;
    }
label_151e84:
    // 0x151e84: 0x8c82004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 76)));
    // 0x151e88: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x151e8c: 0x14400003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 60)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_151e9c;
    }
    // 0x151e94: 0xc4800050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 80)); ctx->f[0] = *(float*)&val; }
    // 0x151e98: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
label_151e9c:
    // 0x151e9c: 0x8e2223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    // 0x151ea0: 0x460ca002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    // 0x151ea4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x151ea8: 0xc44c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[12] = *(float*)&val; }
    // 0x151eac: 0x24845c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x151eb0: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x151eb8);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_151eb8
// Address: 0x151eb8 - 0x151ed8

void entry_151eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151eb8: 0x8e2223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    // 0x151ebc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x151ec0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x151ec4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x151ec8: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x151ecc: 0xe4400010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
    // 0x151ed0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT
// Address: 0x151ed8 - 0x151f58

void entry_151f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x151f58) {
        switch (ctx->pc) {
            case 0x151fb0: ctx->pc = 0; goto label_151fb0;
            case 0x151fb4: ctx->pc = 0; goto label_151fb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x151f58: 0x12000015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_151fb0;
    }
    // 0x151f60: 0x8e0405b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1460)));
    // 0x151f64: 0x8e2723c8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    // 0x151f68: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x151f6c: 0x64182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x151f70: 0x24820007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 7));
    // 0x151f74: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x151f78: 0x24e50074
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 7), 116));
    // 0x151f7c: 0x210c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 3));
    // 0x151f80: 0x30840007
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 7));
    // 0x151f84: 0xa24021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x151f88: 0x91030000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x151f8c: 0x862804
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 6), GPR_U32(ctx, 4) & 0x1F));
    // 0x151f90: 0x651024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x151f94: 0x14400007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_151fb4;
    }
    // 0x151f9c: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x151fa0: 0xa1030000
    WRITE8(ADD32(GPR_U32(ctx, 8), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x151fa4: 0x8ce20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 112)));
    // 0x151fa8: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x151fac: 0xace20070
    WRITE32(ADD32(GPR_U32(ctx, 7), 112), GPR_U32(ctx, 2));
label_151fb0:
    // 0x151fb0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_151fb4:
    // 0x151fb4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x151fb8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x151fbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x151fc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x151fc8; return;
}


// Function: OnDifficultyCollectKey__FP10DIFFICULTY
// Address: 0x151fc8 - 0x151fe0

void entry_151fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x151fe0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x151fe4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x151fe8: 0x8c6223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x151fec: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x151ff0: 0xe4540010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
    // 0x151ff4: 0x24440074
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 116));
    // 0x151ff8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x152000);
    WRITE32(ADD32(GPR_U32(ctx, 2), 112), GPR_U32(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_152000
// Address: 0x152000 - 0x152010

void entry_152000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152000: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152004: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x152008: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnDifficultyBreak
// Address: 0x152010 - 0x1520a8

void entry_1520a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1520a8) {
        switch (ctx->pc) {
            case 0x1520bc: ctx->pc = 0; goto label_1520bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1520a8: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1520ac: 0x62202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1520b0: 0x44180a
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 2));
    // 0x1520b4: 0x1000004d
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1521EC; return;
    }
label_1520bc:
    // 0x1520bc: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1520c0: 0x4410032
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x15218C; return;
    }
    // 0x1520c8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1520cc: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1520d0: 0xc4610010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1520d4: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1520d8: 0x0
    // NOP
    // 0x1520dc: 0x4501000a
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x152108; return;
    }
    // 0x1520e4: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1520e8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1520ec: 0x24845c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1520f0: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1520f4: 0xc44c0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[12] = *(float*)&val; }
    // 0x1520f8: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x152100);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_152100
// Address: 0x152100 - 0x152188

void entry_152100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152100) {
        switch (ctx->pc) {
            case 0x152108: ctx->pc = 0; goto label_152108;
            case 0x152150: ctx->pc = 0; goto label_152150;
            case 0x15217c: ctx->pc = 0; goto label_15217c;
            case 0x152180: ctx->pc = 0; goto label_152180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152100: 0x8e8223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 9160)));
    // 0x152104: 0xe4400010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
label_152108:
    // 0x152108: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x15210c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152110: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152114: 0x8c430054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x152118: 0x18600018
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_15217c;
    }
    // 0x152120: 0x8e8223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 9160)));
    // 0x152124: 0x8cc40058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 88)));
    // 0x152128: 0xc4410010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[1] = *(float*)&val; }
    // 0x15212c: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x152130: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x152134: 0x0
    // NOP
    // 0x152138: 0x45030011
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
        goto label_152180;
    }
    // 0x152140: 0x60402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x152144: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152148: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15214c: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
label_152150:
    // 0x152150: 0xe8102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 8)));
    // 0x152154: 0x10400009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 12));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15217c;
    }
    // 0x15215c: 0x8cc20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 88)));
    // 0x152160: 0xc4610010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 16)); ctx->f[1] = *(float*)&val; }
    // 0x152164: 0x452021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x152168: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x15216c: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x152170: 0x0
    // NOP
    // 0x152174: 0x4500fff6
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_152150;
    }
label_15217c:
    // 0x15217c: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
label_152180:
    // 0x152180: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x152188);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_152188
// Address: 0x152188 - 0x152208

void entry_152188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152188) {
        switch (ctx->pc) {
            case 0x15218c: ctx->pc = 0; goto label_15218c;
            case 0x1521c8: ctx->pc = 0; goto label_1521c8;
            case 0x1521ec: ctx->pc = 0; goto label_1521ec;
            case 0x152200: ctx->pc = 0; goto label_152200;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152188: 0xae220018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
label_15218c:
    // 0x15218c: 0x16000017
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1521ec;
    }
    // 0x152194: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x152198: 0x8c430054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x15219c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1521a0: 0x2465ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1521a4: 0x205102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 5)));
    // 0x1521a8: 0x10400010
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1521ec;
    }
    // 0x1521b0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1521b4: 0x8cc40058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 88)));
    // 0x1521b8: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1521bc: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1521c0: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1521c4: 0xc4610010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 16)); ctx->f[1] = *(float*)&val; }
label_1521c8:
    // 0x1521c8: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1521cc: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1521d0: 0x0
    // NOP
    // 0x1521d4: 0x4501ffb1
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x15209C; return;
    }
    // 0x1521dc: 0x24a5000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 12));
    // 0x1521e0: 0xe6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 6)));
    // 0x1521e4: 0x1440fff8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1521c8;
    }
label_1521ec:
    // 0x1521ec: 0x12400008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x152210; return;
    }
    // 0x1521f4: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1521f8: 0x24050057
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 87));
    // 0x1521fc: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
label_152200:
    // 0x152200: 0xc0522b0
    SET_GPR_U32(ctx, 31, 0x152208);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CpdprizeAttractSwDprizes__FP2SW3CIDP6VECTORiPP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_152208
// Address: 0x152208 - 0x15237c

void entry_152208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152208) {
        switch (ctx->pc) {
            case 0x152210: ctx->pc = 0; goto label_152210;
            case 0x152250: ctx->pc = 0; goto label_152250;
            case 0x152294: ctx->pc = 0; goto label_152294;
            case 0x1522d4: ctx->pc = 0; goto label_1522d4;
            case 0x1522f0: ctx->pc = 0; goto label_1522f0;
            case 0x152334: ctx->pc = 0; goto label_152334;
            case 0x152374: ctx->pc = 0; goto label_152374;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152208: 0x1000006a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1523b4(rdram, ctx, runtime); return;
    }
label_152210:
    // 0x152210: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x152214: 0x443005b
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x152384; return;
    }
    // 0x15221c: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x152220: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x152224: 0x8c6423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x152228: 0x60a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x15222c: 0x8c45001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x152230: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x152234: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x152238: 0xc484000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 12)); ctx->f[4] = *(float*)&val; }
    // 0x15223c: 0x8e330004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x152240: 0x14a30003
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 3)) {
        goto label_152250;
    }
    // 0x152248: 0x10000022
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1522d4;
    }
label_152250:
    // 0x152250: 0xa3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 3)));
    // 0x152254: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_152294;
    }
    // 0x15225c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x152260: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x152264: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x152268: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x15226c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x152270: 0x44851000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 5);
    // 0x152274: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x152278: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15227c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x152280: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x152284: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x152288: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x15228c: 0x10000011
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1522d4;
    }
label_152294:
    // 0x152294: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x152298: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15229c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1522a0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1522a4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1522a8: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1522ac: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1522b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1522b4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1522b8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1522bc: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1522c0: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1522c4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1522c8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1522cc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1522d0: 0x622021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1522d4:
    // 0x1522d4: 0x8e8223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 9160)));
    // 0x1522d8: 0x8cc30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 40)));
    // 0x1522dc: 0x8cc50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x1522e0: 0x14a30003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[4] = *(float*)&val; }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 3)) {
        goto label_1522f0;
    }
    // 0x1522e8: 0x10000022
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_152374;
    }
label_1522f0:
    // 0x1522f0: 0xa3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 3)));
    // 0x1522f4: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_152334;
    }
    // 0x1522fc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x152300: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x152304: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x152308: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x15230c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x152310: 0x44851000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 5);
    // 0x152314: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x152318: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15231c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x152320: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x152324: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x152328: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x15232c: 0x10000011
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_152374;
    }
label_152334:
    // 0x152334: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x152338: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15233c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x152340: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x152344: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x152348: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x15234c: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x152350: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x152354: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x152358: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x15235c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x152360: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x152364: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x152368: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x15236c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x152370: 0x622821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_152374:
    // 0x152374: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x15237c);
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_15237c
// Address: 0x15237c - 0x152394

void entry_15237c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15237c) {
        switch (ctx->pc) {
            case 0x152384: ctx->pc = 0; goto label_152384;
            case 0x152388: ctx->pc = 0; goto label_152388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15237c: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_152388;
    }
label_152384:
    // 0x152384: 0x8e320010
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 16)));
label_152388:
    // 0x152388: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15238c: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x152394);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_152394
// Address: 0x152394 - 0x1523b4

void entry_152394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152394: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x152398: 0x10a00006
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1523b4(rdram, ctx, runtime); return;
    }
    // 0x1523a0: 0x8ec45710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    // 0x1523a4: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1523a8: 0x24050058
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 88));
    // 0x1523ac: 0xc0522b0
    SET_GPR_U32(ctx, 31, 0x1523b4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CpdprizeAttractSwDprizes__FP2SW3CIDP6VECTORiPP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_1523b4
// Address: 0x1523b4 - 0x1523e0

void entry_1523b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1523b4: 0x1600000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1523EC; return;
    }
    // 0x1523bc: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1523c0: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1523c4: 0x8e0323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9160)));
    // 0x1523c8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1523cc: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1523d0: 0x24845c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1523d4: 0xc46c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1523d8: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x1523e0);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1523e0
// Address: 0x1523e0 - 0x152410

void entry_1523e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1523e0) {
        switch (ctx->pc) {
            case 0x1523ec: ctx->pc = 0; goto label_1523ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1523e0: 0x8e0223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9160)));
    // 0x1523e4: 0xe4400010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
    // 0x1523e8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1523ec:
    // 0x1523ec: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1523f0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1523f4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1523f8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1523fc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152400: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152404: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152408: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChangeSuck__FfP10DIFFICULTY
// Address: 0x152410 - 0x152420

void entry_152420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152420: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x152424: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152428: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x15242c: 0xe460000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 12), *(uint32_t*)&val); }
    // 0x152430: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitDl__FP2DLi
// Address: 0x152438 - 0x152440

void entry_152490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152490) {
        switch (ctx->pc) {
            case 0x1524a4: ctx->pc = 0; goto label_1524a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152490: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152494: 0x14a00003
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1524a4;
    }
    // 0x15249c: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1524B8; return;
    }
label_1524a4:
    // 0x1524a4: 0xc054918
    SET_GPR_U32(ctx, 31, 0x1524ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1524ac
// Address: 0x1524ac - 0x1524d8

void entry_1524ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1524ac) {
        switch (ctx->pc) {
            case 0x1524b8: ctx->pc = 0; goto label_1524b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1524ac: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1524b0: 0xae430004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 3));
    // 0x1524b4: 0xac510000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 17));
label_1524b8:
    // 0x1524b8: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x1524bc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1524c0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1524c4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1524c8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1524cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1524d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1524d8; return;
}


// Function: PrependDlEntry__FP2DLPv
// Address: 0x1524d8 - 0x1524f8

void entry_1524f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1524f8) {
        switch (ctx->pc) {
            case 0x152510: ctx->pc = 0; goto label_152510;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1524f8: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1524fc: 0x14a00004
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_152510;
    }
    // 0x152504: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x152508: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x152528; return;
    }
label_152510:
    // 0x152510: 0xc054918
    SET_GPR_U32(ctx, 31, 0x152518);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_152518
// Address: 0x152518 - 0x152540

void entry_152518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152518) {
        switch (ctx->pc) {
            case 0x152528: ctx->pc = 0; goto label_152528;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152518: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15251c: 0xae430000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 3));
    // 0x152520: 0xac510004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 17));
    // 0x152524: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
label_152528:
    // 0x152528: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15252c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152530: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152534: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152538: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InsertDlEntryBefore__FP2DLPvT1
// Address: 0x152540 - 0x152574

void entry_152574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152574) {
        switch (ctx->pc) {
            case 0x15257c: ctx->pc = 0; goto label_15257c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152574: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1525D8; return;
    }
label_15257c:
    // 0x15257c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x152580: 0x16620005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x152598; return;
    }
    // 0x152588: 0xc054936
    SET_GPR_U32(ctx, 31, 0x152590);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PrependDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_152590
// Address: 0x152590 - 0x1525a0

void entry_152590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152590) {
        switch (ctx->pc) {
            case 0x152598: ctx->pc = 0; goto label_152598;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152590: 0x10000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1525D8; return;
    }
label_152598:
    // 0x152598: 0xc054918
    SET_GPR_U32(ctx, 31, 0x1525a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1525a0
// Address: 0x1525a0 - 0x1525b0

void entry_1525a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1525a0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1525a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1525a8: 0xc054918
    SET_GPR_U32(ctx, 31, 0x1525b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1525b0
// Address: 0x1525b0 - 0x1525c4

void entry_1525b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1525b0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1525b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1525b8: 0x8e300004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1525bc: 0xc054918
    SET_GPR_U32(ctx, 31, 0x1525c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1525c4
// Address: 0x1525c4 - 0x1525f8

void entry_1525c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1525c4) {
        switch (ctx->pc) {
            case 0x1525d8: ctx->pc = 0; goto label_1525d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1525c4: 0xae500004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    // 0x1525c8: 0xae530000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 19));
    // 0x1525cc: 0xae340004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 20));
    // 0x1525d0: 0xac540000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 20));
    // 0x1525d4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1525d8:
    // 0x1525d8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1525dc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1525e0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1525e4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1525e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1525ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1525f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1525f8; return;
}


// Function: junk_001525F8
// Address: 0x1525f8 - 0x152600

void entry_15261c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15261c) {
        switch (ctx->pc) {
            case 0x152638: ctx->pc = 0; goto label_152638;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15261c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x152620: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x152624: 0x8c50b314
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4294947604)));
    // 0x152628: 0x5200000f
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x152668; return;
    }
    // 0x152630: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152634: 0x0
    // NOP
label_152638:
    // 0x152638: 0x54510008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x15265C; return;
    }
    // 0x152640: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x152644: 0x50a00004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 18));
        ctx->pc = 0x152658; return;
    }
    // 0x15264c: 0xc054918
    SET_GPR_U32(ctx, 31, 0x152654);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_152654
// Address: 0x152654 - 0x152678

void entry_152654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152654) {
        switch (ctx->pc) {
            case 0x152658: ctx->pc = 0; goto label_152658;
            case 0x15265c: ctx->pc = 0; goto label_15265c;
            case 0x152668: ctx->pc = 0; goto label_152668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152654: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_152658:
    // 0x152658: 0x8e10000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_15265c:
    // 0x15265c: 0x5600fff6
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x152638; return;
    }
    // 0x152664: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_152668:
    // 0x152668: 0x50a00006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x152684; return;
    }
    // 0x152670: 0xc054918
    SET_GPR_U32(ctx, 31, 0x152678);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_152678
// Address: 0x152678 - 0x15269c

void entry_152678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152678) {
        switch (ctx->pc) {
            case 0x152684: ctx->pc = 0; goto label_152684;
            case 0x152688: ctx->pc = 0; goto label_152688;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152678: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15267c: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_152688;
    }
label_152684:
    // 0x152684: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
label_152688:
    // 0x152688: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15268c: 0x50a00006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x1526A8; return;
    }
    // 0x152694: 0xc054918
    SET_GPR_U32(ctx, 31, 0x15269c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15269c
// Address: 0x15269c - 0x1526d0

void entry_15269c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15269c) {
        switch (ctx->pc) {
            case 0x1526a8: ctx->pc = 0; goto label_1526a8;
            case 0x1526ac: ctx->pc = 0; goto label_1526ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15269c: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1526a0: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1526ac;
    }
label_1526a8:
    // 0x1526a8: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
label_1526ac:
    // 0x1526ac: 0xae200004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
    // 0x1526b0: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x1526b4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1526b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1526bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1526c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1526c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1526cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1526d0; return;
}


// Function: FFindDlEntry__FP2DLPv
// Address: 0x1526d0 - 0x1526ec

void entry_1526ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1526ec) {
        switch (ctx->pc) {
            case 0x152704: ctx->pc = 0; goto label_152704;
            case 0x15270c: ctx->pc = 0; goto label_15270c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1526ec: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1526f0: 0x14600004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_152704;
    }
    // 0x1526f8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1526fc: 0x14510003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        goto label_15270c;
    }
label_152704:
    // 0x152704: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x152708: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_15270c:
    // 0x15270c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x152710: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152714: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152718: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIsDlEmpty__FP2DL
// Address: 0x152720 - 0x152730

void entry_152780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152780) {
        switch (ctx->pc) {
            case 0x152788: ctx->pc = 0; goto label_152788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152780: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1527C4; return;
    }
label_152788:
    // 0x152788: 0xc054918
    SET_GPR_U32(ctx, 31, 0x152790);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_152790
// Address: 0x152790 - 0x1527a0

void entry_152790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152790: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x152794: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x152798: 0xc054918
    SET_GPR_U32(ctx, 31, 0x1527a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PdleFromDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1527a0
// Address: 0x1527a0 - 0x1527c0

void entry_1527a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1527a0: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1527a4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1527a8: 0xae050000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 5));
    // 0x1527ac: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1527b0: 0xac430004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    // 0x1527b4: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1527b8: 0xc054910
    SET_GPR_U32(ctx, 31, 0x1527c0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_1527c0
// Address: 0x1527c0 - 0x1527d8

void entry_1527c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1527c0) {
        switch (ctx->pc) {
            case 0x1527c4: ctx->pc = 0; goto label_1527c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1527c0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1527c4:
    // 0x1527c4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1527c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1527cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1527d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CPvDl__FP2DL
// Address: 0x1527d8 - 0x152810

void entry_152820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152820: 0xc08063a
    SET_GPR_U32(ctx, 31, 0x152828);
    sceGsResetPath(rdram, ctx, runtime); return;
}


// Function: entry_152828
// Address: 0x152828 - 0x152830

void entry_152828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152828: 0xc0809e8
    SET_GPR_U32(ctx, 31, 0x152830);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceDmaGetChan(rdram, ctx, runtime); return;
}


// Function: entry_152830
// Address: 0x152830 - 0x152840

void entry_152830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152830: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x152834: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x152838: 0xc0809e8
    SET_GPR_U32(ctx, 31, 0x152840);
    WRITE32(ADD32(GPR_U32(ctx, 3), 7956), GPR_U32(ctx, 2));
    sceDmaGetChan(rdram, ctx, runtime); return;
}


// Function: entry_152840
// Address: 0x152840 - 0x152850

void entry_152840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152840: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x152844: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x152848: 0xc0809e8
    SET_GPR_U32(ctx, 31, 0x152850);
    WRITE32(ADD32(GPR_U32(ctx, 3), 7960), GPR_U32(ctx, 2));
    sceDmaGetChan(rdram, ctx, runtime); return;
}


// Function: entry_152850
// Address: 0x152850 - 0x152860

void entry_152850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152850: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x152854: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x152858: 0xc0809e8
    SET_GPR_U32(ctx, 31, 0x152860);
    WRITE32(ADD32(GPR_U32(ctx, 3), 7964), GPR_U32(ctx, 2));
    sceDmaGetChan(rdram, ctx, runtime); return;
}


// Function: entry_152860
// Address: 0x152860 - 0x152870

void entry_152860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152860: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x152864: 0x24040009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 9));
    // 0x152868: 0xc0809e8
    SET_GPR_U32(ctx, 31, 0x152870);
    WRITE32(ADD32(GPR_U32(ctx, 3), 7968), GPR_U32(ctx, 2));
    sceDmaGetChan(rdram, ctx, runtime); return;
}


// Function: entry_152870
// Address: 0x152870 - 0x152888

void entry_152870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152870: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x152874: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152878: 0xac621f24
    WRITE32(ADD32(GPR_U32(ctx, 3), 7972), GPR_U32(ctx, 2));
    // 0x15287c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152888; return;
}


// Function: fn___4DMAS
// Address: 0x152888 - 0x1528b0

void entry_1528b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1528b0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1528b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1528b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1528bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1528c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1528c8; return;
}


// Function: Clear__4DMAS
// Address: 0x1528c8 - 0x1528e0

void entry_152910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152910: 0x508021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x152914: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x152918: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x15291c: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x152920: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152924: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152928: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15292c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152934: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152938; return;
}


// Function: AllocSw__4DMASii
// Address: 0x152938 - 0x152958

void entry_152958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152958: 0x508021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x15295c: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x152960: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x152964: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x152968: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15296c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152970: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152974: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15297c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152980; return;
}


// Function: AllocStack__4DMASi
// Address: 0x152980 - 0x1529a0

void entry_1529a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1529a0: 0x508021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1529a4: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x1529a8: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x1529ac: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x1529b0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1529b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1529b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1529bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1529c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1529c8; return;
}


// Function: AllocStatic__4DMASiP2QW
// Address: 0x1529c8 - 0x1529e0

void entry_152a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152a04) {
        switch (ctx->pc) {
            case 0x152a20: ctx->pc = 0; goto label_152a20;
            case 0x152a30: ctx->pc = 0; goto label_152a30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152a04: 0x12200006
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_152a20;
    }
    // 0x152a0c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152a10: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152a14: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x152a18: 0x21102
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 4));
    // 0x152a1c: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_152a20:
    // 0x152a20: 0x12400003
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_152a30;
    }
    // 0x152a28: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152a2c: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
label_152a30:
    // 0x152a30: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x152a38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_152a38
// Address: 0x152a38 - 0x152a50

void entry_152a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152a38: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x152a3c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152a40: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152a44: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152a48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DetachCopySw__4DMASPiPP2QWT2i
// Address: 0x152a50 - 0x152a7c

void entry_152a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152a7c) {
        switch (ctx->pc) {
            case 0x152a94: ctx->pc = 0; goto label_152a94;
            case 0x152aa4: ctx->pc = 0; goto label_152aa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152a7c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152a80: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152a84: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x152a88: 0x12200002
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 2), 4));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_152a94;
    }
    // 0x152a90: 0xae240000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 4));
label_152a94:
    // 0x152a94: 0x12400003
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_152aa4;
    }
    // 0x152a9c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152aa0: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
label_152aa4:
    // 0x152aa4: 0x12600005
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x152ABC; return;
    }
    // 0x152aac: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152ab0: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x152ab8);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_152ab8
// Address: 0x152ab8 - 0x152ac4

void entry_152ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152ab8) {
        switch (ctx->pc) {
            case 0x152abc: ctx->pc = 0; goto label_152abc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152ab8: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
label_152abc:
    // 0x152abc: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x152ac4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_152ac4
// Address: 0x152ac4 - 0x152ae0

void entry_152ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152ac4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x152ac8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x152acc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152ad0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152ad4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152ad8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Send__4DMASP10sceDmaChan
// Address: 0x152ae0 - 0x152afc

void entry_152afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152afc: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x152b04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_152b04
// Address: 0x152b04 - 0x152b10

void entry_152b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152b04: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152b08: 0xc080aa0
    SET_GPR_U32(ctx, 31, 0x152b10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceDmaSend(rdram, ctx, runtime); return;
}


// Function: entry_152b10
// Address: 0x152b10 - 0x152b30

void entry_152b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152b10: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x152b14: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152b18: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x152b1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152b20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152b24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152b2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152b30; return;
}


// Function: junk_00152B30
// Address: 0x152b30 - 0x152b38

void entry_152b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152b4c: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152b50: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x152b54: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152b58: 0x24620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    // 0x152b5c: 0xae030008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 3));
    // 0x152b60: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x152b64: 0xfc640000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 4));
    // 0x152b68: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x152b6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152b70: 0xfc400008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 0));
    // 0x152b74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152b7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152b80; return;
}


// Function: AddDmaRefs__4DMASiP2QW
// Address: 0x152b80 - 0x152bb4

void entry_152bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152bb4) {
        switch (ctx->pc) {
            case 0x152bb8: ctx->pc = 0; goto label_152bb8;
            case 0x152c00: ctx->pc = 0; goto label_152c00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152bb4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
label_152bb8:
    // 0x152bb8: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152bbc: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x152bc0: 0x2421025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x152bc4: 0x11183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) << (32 + 0));
    // 0x152bc8: 0x24850010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 16));
    // 0x152bcc: 0x431825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x152bd0: 0xae05000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 5));
    // 0x152bd4: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x152bd8: 0x10c00009
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_152c00;
    }
    // 0x152be0: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152be4: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x152be8: 0x24620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    // 0x152bec: 0xae030008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 3));
    // 0x152bf0: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x152bf4: 0xfc640000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 4));
    // 0x152bf8: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x152bfc: 0xfc400008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 0));
label_152c00:
    // 0x152c00: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x152c04: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152c08: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152c0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152c10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddDmaCall__4DMASP2QW
// Address: 0x152c18 - 0x152c44

void entry_152c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152c44) {
        switch (ctx->pc) {
            case 0x152c48: ctx->pc = 0; goto label_152c48;
            case 0x152c8c: ctx->pc = 0; goto label_152c8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152c44: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
label_152c48:
    // 0x152c48: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152c4c: 0x11103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) << (32 + 0));
    // 0x152c50: 0x3c045000
    SET_GPR_U32(ctx, 4, ((uint32_t)20480 << 16));
    // 0x152c54: 0x24650010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 16));
    // 0x152c58: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x152c5c: 0xae05000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 5));
    // 0x152c60: 0xfc620000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 2));
    // 0x152c64: 0x10c00009
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_152c8c;
    }
    // 0x152c6c: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152c70: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x152c74: 0x24620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    // 0x152c78: 0xae030008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 3));
    // 0x152c7c: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x152c80: 0xfc640000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 4));
    // 0x152c84: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x152c88: 0xfc400008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 0));
label_152c8c:
    // 0x152c8c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152c90: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152c94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152c98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddDmaRet__4DMAS
// Address: 0x152ca0 - 0x152cb4

void entry_152cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152cb4: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152cb8: 0x3c046000
    SET_GPR_U32(ctx, 4, ((uint32_t)24576 << 16));
    // 0x152cbc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152cc0: 0x24620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    // 0x152cc4: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x152cc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152ccc: 0xfc640000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 4));
    // 0x152cd0: 0xfc600008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 0));
    // 0x152cd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152cdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152ce0; return;
}


// Function: AddDmaBulk__4DMASiP2QW
// Address: 0x152ce0 - 0x152d08

void entry_152d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152d08: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x152d0c: 0x108100
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 4));
    // 0x152d10: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x152d14: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x152d18: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x152d1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152d20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152d24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152d2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152d30; return;
}


// Function: AddDmaEnd__4DMAS
// Address: 0x152d30 - 0x152d44

void entry_152d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152d44: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152d48: 0x3c047000
    SET_GPR_U32(ctx, 4, ((uint32_t)28672 << 16));
    // 0x152d4c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x152d50: 0x24620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    // 0x152d54: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x152d58: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152d5c: 0xfc640000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 4));
    // 0x152d60: 0xfc600008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 0));
    // 0x152d64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152d6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152d70; return;
}


// Function: EndDmaCnt__4DMAS
// Address: 0x152d70 - 0x152de0

void entry_152de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x152de0) {
        switch (ctx->pc) {
            case 0x152e0c: ctx->pc = 0; goto label_152e0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x152de0: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x152de4: 0x10800009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_152e0c;
    }
    // 0x152dec: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x152df0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x152df4: 0x441023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x152df8: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x152dfc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x152e00: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x152e04: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x152e08: 0xae000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
label_152e0c:
    // 0x152e0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152e10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EndPrim__4DMASi
// Address: 0x152e18 - 0x152e20

void entry_152e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152e38: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x152e3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x152e44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x152e48; return;
}


// Function: SetDyshShadow__FP4DYSHP6SHADOW
// Address: 0x152e48 - 0x152ea0

void entry_152ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152ea0: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x152ea4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x152ea8: 0xc07b8c6
    SET_GPR_U32(ctx, 31, 0x152eb0);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_152eb0
// Address: 0x152eb0 - 0x152eb8

void entry_152eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152eb0: 0xc063582
    SET_GPR_U32(ctx, 31, 0x152eb8);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_152eb8
// Address: 0x152eb8 - 0x152ec4

void entry_152eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152eb8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152ebc: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x152ec4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_152ec4
// Address: 0x152ec4 - 0x152ed0

void entry_152ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152ec4: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x152ec8: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x152ed0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_152ed0
// Address: 0x152ed0 - 0x152ed8

void entry_152ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152ed0: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x152ed8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_152ed8
// Address: 0x152ed8 - 0x152ee4

void entry_152ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152ed8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152edc: 0xc05a6c6
    SET_GPR_U32(ctx, 31, 0x152ee4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DrawOnBitmap__FP3BMPP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_152ee4
// Address: 0x152ee4 - 0x152ef8

void entry_152ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152ee4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152ee8: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x152eec: 0x24070551
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1361));
    // 0x152ef0: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x152ef8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 582));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_152ef8
// Address: 0x152ef8 - 0x152f04

void entry_152ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152ef8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152efc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x152f04);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_152f04
// Address: 0x152f04 - 0x152f18

void entry_152f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152f04: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152f08: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152f0c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152f10: 0xc058562
    SET_GPR_U32(ctx, 31, 0x152f18);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_152f18
// Address: 0x152f18 - 0x152f34

void entry_152f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152f18: 0x96450000
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x152f1c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152f20: 0x96460002
    SET_GPR_U32(ctx, 6, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x152f24: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152f28: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x152f2c: 0xc058562
    SET_GPR_U32(ctx, 31, 0x152f34);
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_152f34
// Address: 0x152f34 - 0x152f48

void entry_152f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152f34: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152f38: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x152f3c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x152f40: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x152f48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_152f48
// Address: 0x152f48 - 0x152f80

void entry_152f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152f48: 0x96460002
    SET_GPR_U32(ctx, 6, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x152f4c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x152f50: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x152f54: 0x34630001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 1));
    // 0x152f58: 0x96420000
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x152f5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152f60: 0x24c6fffe
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967294));
    // 0x152f64: 0x24050041
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 65));
    // 0x152f68: 0x2442fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x152f6c: 0x6343c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 16));
    // 0x152f70: 0xc33025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x152f74: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x152f78: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x152f80);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_152f80
// Address: 0x152f80 - 0x152f88

void entry_152f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152f80: 0xc058480
    SET_GPR_U32(ctx, 31, 0x152f88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_152f88
// Address: 0x152f88 - 0x152f94

void entry_152f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152f88: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x152f8c: 0xc07ba34
    SET_GPR_U32(ctx, 31, 0x152f94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifGifs__4VIFSP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_152f94
// Address: 0x152f94 - 0x15302c

void entry_152f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x152f94: 0x96420000
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x152f98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x152f9c: 0x3c014480
    SET_GPR_U32(ctx, 1, ((uint32_t)17536 << 16));
    // 0x152fa0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x152fa4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152fa8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x152fac: 0x3c015000
    SET_GPR_U32(ctx, 1, ((uint32_t)20480 << 16));
    // 0x152fb0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x152fb4: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x152fb8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x152fbc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x152fc0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x152fc4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x152fc8: 0xe7a00060
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x152fcc: 0x96420002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x152fd0: 0xafa00068
    WRITE32(ADD32(GPR_U32(ctx, 29), 104), GPR_U32(ctx, 0));
    // 0x152fd4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x152fd8: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x152fdc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x152fe0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x152fe4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x152fe8: 0xe7a00064
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 100), *(uint32_t*)&val); }
    // 0x152fec: 0x96420000
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x152ff0: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x152ff4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x152ff8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x152ffc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x153000: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x153004: 0xe7a00070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x153008: 0x96420002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x15300c: 0xafa00078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 0));
    // 0x153010: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x153014: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x153018: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15301c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x153020: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x153024: 0xc07b8ee
    SET_GPR_U32(ctx, 31, 0x15302c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 116), *(uint32_t*)&val); }
    AddVifBaseOffset__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15302c
// Address: 0x15302c - 0x153044

void entry_15302c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15302c: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x153030: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153034: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x153038: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15303c: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x153044);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_153044
// Address: 0x153044 - 0x15305c

void entry_153044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153044: 0x27a70070
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 112));
    // 0x153048: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15304c: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x153050: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x153054: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x15305c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_15305c
// Address: 0x15305c - 0x153064

void entry_15305c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15305c: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x153064);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_153064
// Address: 0x153064 - 0x153078

void entry_153064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153064: 0x27b10080
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 128));
    // 0x153068: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15306c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153070: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x153078);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_153078
// Address: 0x153078 - 0x153094

void entry_153078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153078: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15307c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153080: 0x2405024d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 589));
    // 0x153084: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153088: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15308c: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x153094);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1042));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_153094
// Address: 0x153094 - 0x1530ac

void entry_153094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153094: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153098: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15309c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1530a0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1530a4: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x1530ac);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_1530ac
// Address: 0x1530ac - 0x1530c4

void entry_1530ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530ac: 0x24080013
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1530b0: 0x266702d8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 728));
    // 0x1530b4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1530b8: 0x266502d4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 724));
    // 0x1530bc: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x1530c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_1530c4
// Address: 0x1530c4 - 0x1530cc

void entry_1530c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530c4: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1530cc);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1530cc
// Address: 0x1530cc - 0x1530d4

void entry_1530cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530cc: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1530d4);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1530d4
// Address: 0x1530d4 - 0x1530dc

void entry_1530d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530d4: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x1530dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1530dc
// Address: 0x1530dc - 0x1530e4

void entry_1530dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530dc: 0xc054a32
    SET_GPR_U32(ctx, 31, 0x1530e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Clear__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1530e4
// Address: 0x1530e4 - 0x1530f0

void entry_1530e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530e4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1530e8: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x1530f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_1530f0
// Address: 0x1530f0 - 0x1530fc

void entry_1530f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1530f4: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x1530fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_1530fc
// Address: 0x1530fc - 0x153138

void entry_1530fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1530fc: 0xde500018
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x153100: 0x2402ffe7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967271));
    // 0x153104: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x153108: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x15310c: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x153110: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x153114: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x153118: 0x31d38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 20);
    // 0x15311c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153120: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x153124: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x153128: 0x2038025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x15312c: 0x24050200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    // 0x153130: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x153138);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_153138
// Address: 0x153138 - 0x153148

void entry_153138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153138: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15313c: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x153140: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x153148);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_153148
// Address: 0x153148 - 0x153158

void entry_153148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153148: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15314c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153150: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x153158);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_153158
// Address: 0x153158 - 0x153168

void entry_153158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153158: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15315c: 0x24050015
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 21));
    // 0x153160: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x153168);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 97));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_153168
// Address: 0x153168 - 0x15317c

void entry_153168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153168: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15316c: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x153170: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x153174: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15317c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 72));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15317c
// Address: 0x15317c - 0x153194

void entry_15317c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15317c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153180: 0x24050316
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 790));
    // 0x153184: 0x3c07000e
    SET_GPR_U32(ctx, 7, ((uint32_t)14 << 16));
    // 0x153188: 0x34e75353
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 21331));
    // 0x15318c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x153194);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_153194
// Address: 0x153194 - 0x1531c0

void entry_153194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153194) {
        switch (ctx->pc) {
            case 0x1531b0: ctx->pc = 0; goto label_1531b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153194: 0x96420002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x153198: 0x96430000
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x15319c: 0x28900
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1531a0: 0x38100
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1531a4: 0x26330008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1531a8: 0x26120008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1531ac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1531b0:
    // 0x1531b0: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1531b4: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1531b8: 0xc058532
    SET_GPR_U32(ctx, 31, 0x1531c0);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1531c0
// Address: 0x1531c0 - 0x1531d4

void entry_1531c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1531c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1531c4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1531c8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1531cc: 0xc058562
    SET_GPR_U32(ctx, 31, 0x1531d4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_1531d4
// Address: 0x1531d4 - 0x1531e4

void entry_1531d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1531d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1531d8: 0x26050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1531dc: 0xc058532
    SET_GPR_U32(ctx, 31, 0x1531e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1531e4
// Address: 0x1531e4 - 0x1531f8

void entry_1531e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1531e4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1531e8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1531ec: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1531f0: 0xc058562
    SET_GPR_U32(ctx, 31, 0x1531f8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_1531f8
// Address: 0x1531f8 - 0x153208

void entry_1531f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1531f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1531fc: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x153200: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x153208);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_153208
// Address: 0x153208 - 0x153218

void entry_153208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153208: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15320c: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x153210: 0xc058532
    SET_GPR_U32(ctx, 31, 0x153218);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_153218
// Address: 0x153218 - 0x15322c

void entry_153218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153218: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15321c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153220: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153224: 0xc058562
    SET_GPR_U32(ctx, 31, 0x15322c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_15322c
// Address: 0x15322c - 0x15323c

void entry_15322c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15322c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153230: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x153234: 0xc058532
    SET_GPR_U32(ctx, 31, 0x15323c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 16));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15323c
// Address: 0x15323c - 0x153250

void entry_15323c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15323c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153240: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153244: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153248: 0xc058562
    SET_GPR_U32(ctx, 31, 0x153250);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_153250
// Address: 0x153250 - 0x153260

void entry_153250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153250: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153254: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x153258: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x153260);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_153260
// Address: 0x153260 - 0x153270

void entry_153260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153260: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153264: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x153268: 0xc058532
    SET_GPR_U32(ctx, 31, 0x153270);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_153270
// Address: 0x153270 - 0x153284

void entry_153270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153270: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153274: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153278: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x15327c: 0xc058562
    SET_GPR_U32(ctx, 31, 0x153284);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_153284
// Address: 0x153284 - 0x153294

void entry_153284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153284: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153288: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15328c: 0xc058532
    SET_GPR_U32(ctx, 31, 0x153294);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_153294
// Address: 0x153294 - 0x1532a8

void entry_153294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153294: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x153298: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15329c: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1532a0: 0xc058562
    SET_GPR_U32(ctx, 31, 0x1532a8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZ__4GIFSiii(rdram, ctx, runtime); return;
}


// Function: entry_1532a8
// Address: 0x1532a8 - 0x1532b8

void entry_1532a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1532a8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1532ac: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1532b0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1532b8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1532b8
// Address: 0x1532b8 - 0x1532c8

void entry_1532b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1532b8: 0x681ffbd
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) >= 0) {
        ctx->pc = 0x1531B0; return;
    }
    // 0x1532c0: 0xc058480
    SET_GPR_U32(ctx, 31, 0x1532c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1532c8
// Address: 0x1532c8 - 0x1532d0

void entry_1532c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1532c8: 0xc07b914
    SET_GPR_U32(ctx, 31, 0x1532d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddVifFlush__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_1532d0
// Address: 0x1532d0 - 0x1532dc

void entry_1532d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1532d0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1532d4: 0xc07ba34
    SET_GPR_U32(ctx, 31, 0x1532dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddVifGifs__4VIFSP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1532dc
// Address: 0x1532dc - 0x1532f4

void entry_1532dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1532dc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1532e0: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1532e4: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1532e8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1532ec: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x1532f4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 19));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_1532f4
// Address: 0x1532f4 - 0x1532fc

void entry_1532f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1532f4: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1532fc);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1532fc
// Address: 0x1532fc - 0x153328

void entry_1532fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1532fc: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x153300: 0x7bb70100
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x153304: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x153308: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x15330c: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x153310: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x153314: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x153318: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x15331c: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x153320: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderDyshSelf__FP4DYSHP2CMP2RO
// Address: 0x153328 - 0x153358

void entry_153358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153358: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15335c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153360: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x153368);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_153368
// Address: 0x153368 - 0x153388

void entry_153368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153368: 0x3c030015
    SET_GPR_U32(ctx, 3, ((uint32_t)21 << 16));
    // 0x15336c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153370: 0x246333a8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 13224));
    // 0x153374: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153378: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x15337c: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x153380: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x153388);
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_153388
// Address: 0x153388 - 0x153394

void entry_153388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153388: 0xafb00060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 16));
    // 0x15338c: 0xc067504
    SET_GPR_U32(ctx, 31, 0x153394);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_153394
// Address: 0x153394 - 0x1533a8

void entry_153394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153394: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x153398: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15339c: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1533a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawDysh__FP3RPL
// Address: 0x1533a8 - 0x1533e4

void entry_1533e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1533e4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1533e8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1533ec: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1533f4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1533f4
// Address: 0x1533f4 - 0x153468

void entry_1533f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1533f4) {
        switch (ctx->pc) {
            case 0x15341c: ctx->pc = 0; goto label_15341c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1533f4: 0x3c020016
    SET_GPR_U32(ctx, 2, ((uint32_t)22 << 16));
    // 0x1533f8: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1533fc: 0x24426690
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 26256));
    // 0x153400: 0x26050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 80));
    // 0x153404: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x153408: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x15340c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x153410: 0x27b30080
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 128));
    // 0x153414: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x153418: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
label_15341c:
    // 0x15341c: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x153420: 0x7a060010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x153424: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x153428: 0x7c660010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 6));
    // 0x15342c: 0x26100020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    // 0x153430: 0x1605fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 5)) {
        goto label_15341c;
    }
    // 0x153438: 0x7a050000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15343c: 0x2622022c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 556));
    // 0x153440: 0x7c650000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 5));
    // 0x153444: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153448: 0xafa20074
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 2));
    // 0x15344c: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x153450: 0xafb10070
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 17));
    // 0x153454: 0x24a51f30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 7984));
    // 0x153458: 0x269022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 8872));
    // 0x15345c: 0x8e2602d0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x153460: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x153468);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 112));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_153468
// Address: 0x153468 - 0x153490

void entry_153468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153468: 0x7ba600c0
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x15346c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153470: 0x7ba200d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x153474: 0x7ba500f0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x153478: 0x7ba300e0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x15347c: 0x7fa60080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 6));
    // 0x153480: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x153484: 0x7fa500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 5));
    // 0x153488: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x153490);
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 3));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_153490
// Address: 0x153490 - 0x1534a0

void entry_153490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153490: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153494: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153498: 0xc07b8ee
    SET_GPR_U32(ctx, 31, 0x1534a0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifBaseOffset__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1534a0
// Address: 0x1534a0 - 0x1534b8

void entry_1534a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1534a0: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1534a4: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1534a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1534ac: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1534b0: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x1534b8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_1534b8
// Address: 0x1534b8 - 0x1534c0

void entry_1534b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1534b8: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1534c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1534c0
// Address: 0x1534c0 - 0x1534e8

void entry_1534c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1534c0) {
        switch (ctx->pc) {
            case 0x1534d0: ctx->pc = 0; goto label_1534d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1534c0: 0x8e220238
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 568)));
    // 0x1534c4: 0x1840000c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1534F8; return;
    }
    // 0x1534cc: 0x8e22023c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 572)));
label_1534d0:
    // 0x1534d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1534d4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1534d8: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1534dc: 0xafa20078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 2));
    // 0x1534e0: 0xc0599a4
    SET_GPR_U32(ctx, 31, 0x1534e8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 112));
    DrawGlob__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1534e8
// Address: 0x1534e8 - 0x153508

void entry_1534e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1534e8) {
        switch (ctx->pc) {
            case 0x1534f8: ctx->pc = 0; goto label_1534f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1534e8: 0x8e220238
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 568)));
    // 0x1534ec: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1534f0: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 572)));
        ctx->pc = 0x1534D0; return;
    }
label_1534f8:
    // 0x1534f8: 0x8e2602e0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 736)));
    // 0x1534fc: 0x268422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 8872));
    // 0x153500: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x153508);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 732)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_153508
// Address: 0x153508 - 0x153528

void entry_153508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153508: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x15350c: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x153510: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x153514: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x153518: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x15351c: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x153520: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitDzg__FP3DZGi
// Address: 0x153528 - 0x153554

void entry_153554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153554: 0x138840
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 19), 1));
    // 0x153558: 0x24100060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 96));
    // 0x15355c: 0xae510000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 17));
    // 0x153560: 0x2308018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x153564: 0x1398c0
    SET_GPR_U32(ctx, 19, SLL32(GPR_U32(ctx, 19), 3));
    // 0x153568: 0xc063596
    SET_GPR_U32(ctx, 31, 0x153570);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_153570
// Address: 0x153570 - 0x153584

void entry_153570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153570: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153574: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x153578: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15357c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x153584);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_153584
// Address: 0x153584 - 0x153590

void entry_153584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153584: 0x2644000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 12));
    // 0x153588: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x153590);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_153590
// Address: 0x153590 - 0x15359c

void entry_153590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153590: 0x26440018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 24));
    // 0x153594: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x15359c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_15359c
// Address: 0x15359c - 0x1535a8

void entry_15359c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15359c: 0x26440024
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 36));
    // 0x1535a0: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1535a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1535a8
// Address: 0x1535a8 - 0x1535b4

void entry_1535a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1535a8: 0x2405004c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    // 0x1535ac: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1535b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 48));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1535b4
// Address: 0x1535b4 - 0x1535c4

void entry_1535b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1535b4: 0x2318818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1535b8: 0x118880
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1535bc: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1535c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1535c4
// Address: 0x1535c4 - 0x1535d0

void entry_1535c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1535c4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1535c8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1535d0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 64), GPR_U32(ctx, 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1535d0
// Address: 0x1535d0 - 0x1535dc

void entry_1535d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1535d0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1535d4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1535dc);
    WRITE32(ADD32(GPR_U32(ctx, 18), 68), GPR_U32(ctx, 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1535dc
// Address: 0x1535dc - 0x1535e8

void entry_1535dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1535dc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1535e0: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1535e8);
    WRITE32(ADD32(GPR_U32(ctx, 18), 72), GPR_U32(ctx, 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1535e8
// Address: 0x1535e8 - 0x153608

void entry_1535e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1535e8: 0xae42004c
    WRITE32(ADD32(GPR_U32(ctx, 18), 76), GPR_U32(ctx, 2));
    // 0x1535ec: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1535f0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1535f4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1535f8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1535fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x153600: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearDzgSolution__FP3DZG
// Address: 0x153608 - 0x153638

void entry_153638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153638: 0xc054910
    SET_GPR_U32(ctx, 31, 0x153640);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 24));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_153640
// Address: 0x153640 - 0x153648

void entry_153640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153640: 0xc054910
    SET_GPR_U32(ctx, 31, 0x153648);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 36));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_153648
// Address: 0x153648 - 0x153650

void entry_153648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153648: 0xc054910
    SET_GPR_U32(ctx, 31, 0x153650);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 48));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_153650
// Address: 0x153650 - 0x15368c

void entry_153650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153650) {
        switch (ctx->pc) {
            case 0x153668: ctx->pc = 0; goto label_153668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153650: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x153654: 0x18400014
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1536A8; return;
    }
    // 0x15365c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x153660: 0x8e300008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x153664: 0x0
    // NOP
label_153668:
    // 0x153668: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15366c: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x153670: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x153674: 0x2138021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    // 0x153678: 0xe6140038
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x15367c: 0x2604004c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 76));
    // 0x153680: 0xe6140034
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x153684: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x15368c);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 96));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_15368c
// Address: 0x15368c - 0x153698

void entry_15368c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15368c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153690: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x153698);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 48));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153698
// Address: 0x153698 - 0x1536c8

void entry_153698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153698) {
        switch (ctx->pc) {
            case 0x1536a8: ctx->pc = 0; goto label_1536a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153698: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x15369c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1536a0: 0x5440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x153668; return;
    }
label_1536a8:
    // 0x1536a8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1536ac: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1536b0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1536b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1536b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1536bc: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1536c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AppendDzgDz__FP3DZGP2DZ
// Address: 0x1536c8 - 0x153764

void entry_153764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153764: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x153768: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15376c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x153770: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x153774: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x153778: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FillDzgDz__FP3DZGiP2DZiPP2XPPiPPP2SO
// Address: 0x153780 - 0x15380c

void entry_15380c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15380c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x153810: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x153814: 0xaeb00000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 16));
    // 0x153818: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x15381c: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x153820: 0x3c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x153824: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x153828: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15382c: 0x8c6200e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 232)));
    // 0x153830: 0x40f809
    SET_GPR_U32(ctx, 31, 0x153838);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_153838
// Address: 0x153838 - 0x153860

void entry_153838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153838: 0x8fa40030
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15383c: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153840: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x153844: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x153848: 0x2248821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x15384c: 0x8e460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x153850: 0x8c6200ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 236)));
    // 0x153854: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x153858: 0x40f809
    SET_GPR_U32(ctx, 31, 0x153860);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_153860
// Address: 0x153860 - 0x153880

void entry_153860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153860) {
        switch (ctx->pc) {
            case 0x153864: ctx->pc = 0; goto label_153864;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153860: 0x26d60001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
label_153864:
    // 0x153864: 0x26b50004
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
    // 0x153868: 0x2ac20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), 2));
    // 0x15386c: 0x1440ffdc
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1537E0; return;
    }
    // 0x153874: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x153878: 0xc063596
    SET_GPR_U32(ctx, 31, 0x153880);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_153880
// Address: 0x153880 - 0x153940

void entry_153880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153880) {
        switch (ctx->pc) {
            case 0x1538a0: ctx->pc = 0; goto label_1538a0;
            case 0x1538e0: ctx->pc = 0; goto label_1538e0;
            case 0x153918: ctx->pc = 0; goto label_153918;
            case 0x153930: ctx->pc = 0; goto label_153930;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153880: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x153884: 0xafd70040
    WRITE32(ADD32(GPR_U32(ctx, 30), 64), GPR_U32(ctx, 23));
    // 0x153888: 0x8fa40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x15388c: 0x18800041
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x153994; return;
    }
    // 0x153894: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x153898: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15389c: 0x0
    // NOP
label_1538a0:
    // 0x1538a0: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1538a4: 0x26e40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 16));
    // 0x1538a8: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1538ac: 0xafa40054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 4));
    // 0x1538b0: 0xafa30050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 3));
    // 0x1538b4: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1538b8: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1538bc: 0x3a0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1538c0: 0x3a0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1538c4: 0x24160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1538c8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1538cc: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1538d0: 0x24720010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1538d4: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1538d8: 0x240982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1538dc: 0x0
    // NOP
label_1538e0:
    // 0x1538e0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1538e4: 0x10600019
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15394C; return;
    }
    // 0x1538ec: 0x8c6204bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1212)));
    // 0x1538f0: 0x4400015
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x153948; return;
    }
    // 0x1538f8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1538fc: 0x54620006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 64)));
        goto label_153918;
    }
    // 0x153904: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x153908: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15390c: 0x8fc20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 32)));
    // 0x153910: 0x10000007
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_153930;
    }
label_153918:
    // 0x153918: 0x1462000c
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x15394C; return;
    }
    // 0x153920: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x153924: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x153928: 0x8fc20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 36)));
    // 0x15392c: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_153930:
    // 0x153930: 0x8c8604c0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 1216)));
    // 0x153934: 0x63140
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 5));
    // 0x153938: 0xc06f1fe
    SET_GPR_U32(ctx, 31, 0x153940);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    CalculateSoEffect__FP2SOP6VECTORP2FXT1(rdram, ctx, runtime); return;
}


// Function: entry_153940
// Address: 0x153940 - 0x1539a4

void entry_153940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153940) {
        switch (ctx->pc) {
            case 0x153948: ctx->pc = 0; goto label_153948;
            case 0x15394c: ctx->pc = 0; goto label_15394c;
            case 0x153954: ctx->pc = 0; goto label_153954;
            case 0x153994: ctx->pc = 0; goto label_153994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153940: 0x10000004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_153954;
    }
label_153948:
    // 0x153948: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_15394c:
    // 0x15394c: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x153950: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
label_153954:
    // 0x153954: 0x26b50010
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
    // 0x153958: 0x26520040
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 64));
    // 0x15395c: 0x26940010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 16));
    // 0x153960: 0x26730040
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 64));
    // 0x153964: 0x26d6ffff
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 4294967295));
    // 0x153968: 0x6c1ffdd
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_S32(ctx, 22) >= 0) {
        ctx->pc = 0x1538E0; return;
    }
    // 0x153970: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x153974: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x153978: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15397c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x153980: 0x8fa40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x153984: 0xfae10000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x153988: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x15398c: 0x1440ffc4
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1538A0; return;
    }
label_153994:
    // 0x153994: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x153998: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15399c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1539a4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1539a4
// Address: 0x1539a4 - 0x153a50

void entry_1539a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1539a4) {
        switch (ctx->pc) {
            case 0x1539c0: ctx->pc = 0; goto label_1539c0;
            case 0x153a1c: ctx->pc = 0; goto label_153a1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1539a4: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1539a8: 0xafc60044
    WRITE32(ADD32(GPR_U32(ctx, 30), 68), GPR_U32(ctx, 6));
    // 0x1539ac: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1539b0: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1539b4: 0x18400019
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_153a1c;
    }
    // 0x1539bc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1539c0:
    // 0x1539c0: 0x8fa40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1539c4: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1539c8: 0x8fc50040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 64)));
    // 0x1539cc: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1539d0: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1539d4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1539d8: 0x25080060
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 96));
    // 0x1539dc: 0xd8620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1539e0: 0x8c8200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 204)));
    // 0x1539e4: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1539e8: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1539ec: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1539f0: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1539f4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1539f8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1539fc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x153a00: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x153a04: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x153a08: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x153a0c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x153a10: 0xe2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x153a14: 0x1440ffea
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1539c0;
    }
label_153a1c:
    // 0x153a1c: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x153a20: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x153a24: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x153a28: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x153a2c: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x153a30: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x153a34: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x153a38: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x153a3c: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x153a40: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x153a44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x153a4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x153a50; return;
}


// Function: EnforceDzgDz__FP3DZGP2DZ
// Address: 0x153a50 - 0x153a7c

void entry_153a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153a7c: 0x2604000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 12));
    // 0x153a80: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x153a88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153a88
// Address: 0x153a88 - 0x153b0c

void entry_153a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153a88) {
        switch (ctx->pc) {
            case 0x153a94: ctx->pc = 0; goto label_153a94;
            case 0x153aa0: ctx->pc = 0; goto label_153aa0;
            case 0x153ab0: ctx->pc = 0; goto label_153ab0;
            case 0x153ac0: ctx->pc = 0; goto label_153ac0;
            case 0x153af4: ctx->pc = 0; goto label_153af4;
            case 0x153afc: ctx->pc = 0; goto label_153afc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153a88: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x153a8c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x153a90: 0xae02003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 2));
label_153a94:
    // 0x153a94: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153a98: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x153a9c: 0x0
    // NOP
label_153aa0:
    // 0x153aa0: 0x10800016
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_153afc;
    }
    // 0x153aa8: 0x8e05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x153aac: 0x0
    // NOP
label_153ab0:
    // 0x153ab0: 0x50a00010
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
        goto label_153af4;
    }
    // 0x153ab8: 0x3c06aaaa
    SET_GPR_U32(ctx, 6, ((uint32_t)43690 << 16));
    // 0x153abc: 0x34c6aaab
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 43691));
label_153ac0:
    // 0x153ac0: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x153ac4: 0x8c830044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 68)));
    // 0x153ac8: 0xa21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x153acc: 0x461018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x153ad0: 0x21143
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 5));
    // 0x153ad4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x153ad8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x153adc: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x153ae0: 0xe4e00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 0), *(uint32_t*)&val); }
    // 0x153ae4: 0x8ca5004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x153ae8: 0x14a0fff5
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_153ac0;
    }
    // 0x153af0: 0x8c84004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
label_153af4:
    // 0x153af4: 0x5480ffee
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_153ab0;
    }
label_153afc:
    // 0x153afc: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x153b00: 0x8e050040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x153b04: 0xc052c30
    SET_GPR_U32(ctx, 31, 0x153b0c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    CroutDecomp__FiPfT1(rdram, ctx, runtime); return;
}


// Function: entry_153b0c
// Address: 0x153b0c - 0x153b44

void entry_153b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153b0c) {
        switch (ctx->pc) {
            case 0x153b18: ctx->pc = 0; goto label_153b18;
            case 0x153b30: ctx->pc = 0; goto label_153b30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153b0c: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x153b10: 0x10800007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_153b30;
    }
label_153b18:
    // 0x153b18: 0xc4800038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 56)); ctx->f[0] = *(float*)&val; }
    // 0x153b1c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x153b20: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x153b24: 0x8c84004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
    // 0x153b28: 0x1480fffb
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_153b18;
    }
label_153b30:
    // 0x153b30: 0x8e050044
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x153b34: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x153b38: 0x8e060048
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x153b3c: 0xc052cf8
    SET_GPR_U32(ctx, 31, 0x153b44);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    CroutSolve__FiPfN21(rdram, ctx, runtime); return;
}


// Function: entry_153b44
// Address: 0x153b44 - 0x153e08

void entry_153b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153b44) {
        switch (ctx->pc) {
            case 0x153b58: ctx->pc = 0; goto label_153b58;
            case 0x153b70: ctx->pc = 0; goto label_153b70;
            case 0x153b94: ctx->pc = 0; goto label_153b94;
            case 0x153bb4: ctx->pc = 0; goto label_153bb4;
            case 0x153c00: ctx->pc = 0; goto label_153c00;
            case 0x153c54: ctx->pc = 0; goto label_153c54;
            case 0x153c8c: ctx->pc = 0; goto label_153c8c;
            case 0x153c90: ctx->pc = 0; goto label_153c90;
            case 0x153c98: ctx->pc = 0; goto label_153c98;
            case 0x153cb8: ctx->pc = 0; goto label_153cb8;
            case 0x153cf4: ctx->pc = 0; goto label_153cf4;
            case 0x153d00: ctx->pc = 0; goto label_153d00;
            case 0x153d18: ctx->pc = 0; goto label_153d18;
            case 0x153d54: ctx->pc = 0; goto label_153d54;
            case 0x153d60: ctx->pc = 0; goto label_153d60;
            case 0x153d70: ctx->pc = 0; goto label_153d70;
            case 0x153da0: ctx->pc = 0; goto label_153da0;
            case 0x153db0: ctx->pc = 0; goto label_153db0;
            case 0x153dd0: ctx->pc = 0; goto label_153dd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153b44: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x153b48: 0x1840001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_153bb4;
    }
    // 0x153b50: 0x24090060
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 96));
    // 0x153b54: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_153b58:
    // 0x153b58: 0x24a80001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 5), 1));
    // 0x153b5c: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x153b60: 0x8e03004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x153b64: 0x1080000b
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_153b94;
    }
    // 0x153b6c: 0x53080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 5), 2));
label_153b70:
    // 0x153b70: 0x8c820044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 68)));
    // 0x153b74: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x153b78: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x153b7c: 0x8c84004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
    // 0x153b80: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x153b84: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x153b88: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x153b8c: 0x1480fff8
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_153b70;
    }
label_153b94:
    // 0x153b94: 0xa91018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x153b98: 0x100282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x153b9c: 0x471821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x153ba0: 0xe462003c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 3), 60), *(uint32_t*)&val); }
    // 0x153ba4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x153ba8: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x153bac: 0x5440ffea
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_153b58;
    }
label_153bb4:
    // 0x153bb4: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x153bb8: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153bbc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x153bc0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x153bc4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153bc8: 0x8e03004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x153bcc: 0x8e090004
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x153bd0: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x153bd4: 0x10800030
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_153c98;
    }
    // 0x153bdc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x153be0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x153be4: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x153be8: 0x24070002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    // 0x153bec: 0x3c01b8d1
    SET_GPR_U32(ctx, 1, ((uint32_t)47313 << 16));
    // 0x153bf0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x153bf4: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x153bf8: 0xc4620000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[2] = *(float*)&val; }
    // 0x153bfc: 0x0
    // NOP
label_153c00:
    // 0x153c00: 0x8c820028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 40)));
    // 0x153c04: 0x10470021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 7)) {
        goto label_153c8c;
    }
    // 0x153c0c: 0x46022834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153c10: 0x45000010
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_153c54;
    }
    // 0x153c18: 0x8c82002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 44)));
    // 0x153c1c: 0x5040001c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
        goto label_153c90;
    }
    // 0x153c24: 0xc4800030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 48)); ctx->f[0] = *(float*)&val; }
    // 0x153c28: 0xc4810034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 52)); ctx->f[1] = *(float*)&val; }
    // 0x153c2c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x153c30: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x153c34: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153c38: 0x0
    // NOP
    // 0x153c3c: 0x45020014
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
        goto label_153c90;
    }
    // 0x153c44: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x153c48: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x153c4c: 0x1000000f
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_153c8c;
    }
label_153c54:
    // 0x153c54: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153c58: 0x0
    // NOP
    // 0x153c5c: 0x4502000c
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
        goto label_153c90;
    }
    // 0x153c64: 0xc4800034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 52)); ctx->f[0] = *(float*)&val; }
    // 0x153c68: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x153c6c: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x153c70: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153c74: 0x0
    // NOP
    // 0x153c78: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
        goto label_153c90;
    }
    // 0x153c80: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x153c84: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x153c88: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
label_153c8c:
    // 0x153c8c: 0x8c84004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
label_153c90:
    // 0x153c90: 0x5480ffdb
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[2] = *(float*)&val; }
        goto label_153c00;
    }
label_153c98:
    // 0x153c98: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x153c9c: 0x50400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
        goto label_153d00;
    }
    // 0x153ca4: 0x3c01b8d1
    SET_GPR_U32(ctx, 1, ((uint32_t)47313 << 16));
    // 0x153ca8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x153cac: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x153cb0: 0xc441003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 60)); ctx->f[1] = *(float*)&val; }
    // 0x153cb4: 0x0
    // NOP
label_153cb8:
    // 0x153cb8: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153cbc: 0x0
    // NOP
    // 0x153cc0: 0x4503000c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
        goto label_153cf4;
    }
    // 0x153cc8: 0xc4400038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 56)); ctx->f[0] = *(float*)&val; }
    // 0x153ccc: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x153cd0: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x153cd4: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153cd8: 0x0
    // NOP
    // 0x153cdc: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
        goto label_153cf4;
    }
    // 0x153ce4: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x153ce8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x153cec: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x153cf0: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
label_153cf4:
    // 0x153cf4: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 60)); ctx->f[1] = *(float*)&val; }
        goto label_153cb8;
    }
    // 0x153cfc: 0x100102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
label_153d00:
    // 0x153d00: 0x10400017
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_153d60;
    }
    // 0x153d08: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x153d0c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x153d10: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x153d14: 0xc441003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 60)); ctx->f[1] = *(float*)&val; }
label_153d18:
    // 0x153d18: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153d1c: 0x0
    // NOP
    // 0x153d20: 0x4503000c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
        goto label_153d54;
    }
    // 0x153d28: 0xc4400038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 56)); ctx->f[0] = *(float*)&val; }
    // 0x153d2c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x153d30: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x153d34: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153d38: 0x0
    // NOP
    // 0x153d3c: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
        goto label_153d54;
    }
    // 0x153d44: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x153d48: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x153d4c: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x153d50: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
label_153d54:
    // 0x153d54: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 60)); ctx->f[1] = *(float*)&val; }
        goto label_153d18;
    }
    // 0x153d5c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_153d60:
    // 0x153d60: 0x1920000f
    SET_GPR_U32(ctx, 7, SLTU32(GPR_U32(ctx, 6), 5));
    if (GPR_S32(ctx, 9) <= 0) {
        goto label_153da0;
    }
    // 0x153d68: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x153d6c: 0x0
    // NOP
label_153d70:
    // 0x153d70: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x153d74: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x153d78: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x153d7c: 0xc461003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 60)); ctx->f[1] = *(float*)&val; }
    // 0x153d80: 0xc4600038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 56)); ctx->f[0] = *(float*)&val; }
    // 0x153d84: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x153d88: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x153d8c: 0xe4600038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 56), *(uint32_t*)&val); }
    // 0x153d90: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x153d94: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x153d98: 0x1440fff5
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 96));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_153d70;
    }
label_153da0:
    // 0x153da0: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x153da4: 0x1080000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_153dd0;
    }
    // 0x153dac: 0x0
    // NOP
label_153db0:
    // 0x153db0: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x153db4: 0xc4810034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 52)); ctx->f[1] = *(float*)&val; }
    // 0x153db8: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x153dbc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x153dc0: 0xe4810034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 52), *(uint32_t*)&val); }
    // 0x153dc4: 0x8c84004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 76)));
    // 0x153dc8: 0x1480fff9
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_153db0;
    }
label_153dd0:
    // 0x153dd0: 0x10e00030
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_153e94(rdram, ctx, runtime); return;
    }
    // 0x153dd8: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x153ddc: 0x2442a100
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942976));
    // 0x153de0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x153de4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x153de8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x153df0: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x153df4: 0x2604000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 12));
    // 0x153df8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153dfc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x153e00: 0xc054980
    SET_GPR_U32(ctx, 31, 0x153e08);
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 2));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153e08
// Address: 0x153e08 - 0x153e28

void entry_153e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153e08: 0x10000013
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 24));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x153E58; return;
    }
    // 0x153e10: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x153e14: 0x26040018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 24));
    // 0x153e18: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153e1c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x153e20: 0xc054980
    SET_GPR_U32(ctx, 31, 0x153e28);
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 2));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153e28
// Address: 0x153e28 - 0x153e34

void entry_153e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153e28: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153e2c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x153e34);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 12));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153e34
// Address: 0x153e34 - 0x153e54

void entry_153e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153e34: 0x10000018
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x153E98; return;
    }
    // 0x153e3c: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x153e40: 0x2604000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 12));
    // 0x153e44: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153e48: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x153e4c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x153e54);
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 2));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153e54
// Address: 0x153e54 - 0x153e60

void entry_153e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153e54) {
        switch (ctx->pc) {
            case 0x153e58: ctx->pc = 0; goto label_153e58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153e54: 0x26040024
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 36));
label_153e58:
    // 0x153e58: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x153e60);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153e60
// Address: 0x153e60 - 0x153e88

void entry_153e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153e60: 0x12320010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x153EA4; return;
    }
    // 0x153e68: 0x1000000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 10));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x153E9C; return;
    }
    // 0x153e70: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x153e74: 0x26040024
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 36));
    // 0x153e78: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153e7c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x153e80: 0xc054980
    SET_GPR_U32(ctx, 31, 0x153e88);
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 2));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153e88
// Address: 0x153e88 - 0x153e94

void entry_153e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153e88: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153e8c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x153e94);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 12));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153e94
// Address: 0x153e94 - 0x153ec0

void entry_153e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153e94) {
        switch (ctx->pc) {
            case 0x153e98: ctx->pc = 0; goto label_153e98;
            case 0x153e9c: ctx->pc = 0; goto label_153e9c;
            case 0x153ea4: ctx->pc = 0; goto label_153ea4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153e94: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_153e98:
    // 0x153e98: 0x2a62000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 10));
label_153e9c:
    // 0x153e9c: 0x5440ff00
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x153AA0; return;
    }
label_153ea4:
    // 0x153ea4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x153ea8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x153eac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x153eb0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x153eb4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x153eb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SolveDzg__FP3DZGiiPP2XPPiPPP2SO
// Address: 0x153ec0 - 0x153f80

void entry_153f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153f80) {
        switch (ctx->pc) {
            case 0x153f84: ctx->pc = 0; goto label_153f84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153f80: 0x26240030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 48));
label_153f84:
    // 0x153f84: 0xc054980
    SET_GPR_U32(ctx, 31, 0x153f8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153f8c
// Address: 0x153f8c - 0x153f98

void entry_153f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x153f8c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x153f90: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x153f98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 12));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_153f98
// Address: 0x153f98 - 0x153fcc

void entry_153f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153f98) {
        switch (ctx->pc) {
            case 0x153fa8: ctx->pc = 0; goto label_153fa8;
            case 0x153fc0: ctx->pc = 0; goto label_153fc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153f98: 0x8e22003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x153f9c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x153fa0: 0xae22003c
    WRITE32(ADD32(GPR_U32(ctx, 17), 60), GPR_U32(ctx, 2));
    // 0x153fa4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_153fa8:
    // 0x153fa8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x153fac: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x153fb0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x153fb4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x153fb8: 0x1600ffe3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x153F48; return;
    }
label_153fc0:
    // 0x153fc0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x153fc4: 0xc054e94
    SET_GPR_U32(ctx, 31, 0x153fcc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EnforceDzgDz__FP3DZGP2DZ(rdram, ctx, runtime); return;
}


// Function: entry_153fcc
// Address: 0x153fcc - 0x154048

void entry_153fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x153fcc) {
        switch (ctx->pc) {
            case 0x153fd8: ctx->pc = 0; goto label_153fd8;
            case 0x153ff0: ctx->pc = 0; goto label_153ff0;
            case 0x15400c: ctx->pc = 0; goto label_15400c;
            case 0x154014: ctx->pc = 0; goto label_154014;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x153fcc: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x153fd0: 0xafc2b314
    WRITE32(ADD32(GPR_U32(ctx, 30), 4294947604), GPR_U32(ctx, 2));
    // 0x153fd4: 0x8e220030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 48)));
label_153fd8:
    // 0x153fd8: 0x3c01bc23
    SET_GPR_U32(ctx, 1, ((uint32_t)48163 << 16));
    // 0x153fdc: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x153fe0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x153fe4: 0x1040000b
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_154014;
    }
    // 0x153fec: 0xc4400038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 56)); ctx->f[0] = *(float*)&val; }
label_153ff0:
    // 0x153ff0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x153ff4: 0x0
    // NOP
    // 0x153ff8: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
        goto label_15400c;
    }
    // 0x154000: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x154004: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x154008: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
label_15400c:
    // 0x15400c: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 56)); ctx->f[0] = *(float*)&val; }
        goto label_153ff0;
    }
label_154014:
    // 0x154014: 0x12000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15405C; return;
    }
    // 0x15401c: 0x8e020044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x154020: 0x1440000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15404C; return;
    }
    // 0x154028: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15402c: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x154030: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x154034: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x154038: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15403c: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x154040: 0xc054de0
    SET_GPR_U32(ctx, 31, 0x154048);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FillDzgDz__FP3DZGiP2DZiPP2XPPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_154048
// Address: 0x154048 - 0x154054

void entry_154048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154048) {
        switch (ctx->pc) {
            case 0x15404c: ctx->pc = 0; goto label_15404c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154048: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_15404c:
    // 0x15404c: 0xc054e94
    SET_GPR_U32(ctx, 31, 0x154054);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    EnforceDzgDz__FP3DZGP2DZ(rdram, ctx, runtime); return;
}


// Function: entry_154054
// Address: 0x154054 - 0x154088

void entry_154054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154054) {
        switch (ctx->pc) {
            case 0x15405c: ctx->pc = 0; goto label_15405c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154054: 0x1000ffe0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x153FD8; return;
    }
label_15405c:
    // 0x15405c: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x154060: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x154064: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x154068: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15406c: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x154070: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x154074: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x154078: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15407c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x154080: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SolveDzgFric__FP3DZGiiPP2XPPiPPP2SOf
// Address: 0x154088 - 0x154100

void entry_154100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154100) {
        switch (ctx->pc) {
            case 0x154138: ctx->pc = 0; goto label_154138;
            case 0x1541b0: ctx->pc = 0; goto label_1541b0;
            case 0x1541f0: ctx->pc = 0; goto label_1541f0;
            case 0x1541f8: ctx->pc = 0; goto label_1541f8;
            case 0x154254: ctx->pc = 0; goto label_154254;
            case 0x154258: ctx->pc = 0; goto label_154258;
            case 0x154264: ctx->pc = 0; goto label_154264;
            case 0x1542e0: ctx->pc = 0; goto label_1542e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154100: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x154104: 0x240affff
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x154108: 0x3c013c23
    SET_GPR_U32(ctx, 1, ((uint32_t)15395 << 16));
    // 0x15410c: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x154110: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x154114: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154118: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x15411c: 0x1a800051
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_154264;
    }
    // 0x154124: 0x8e6d0008
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x154128: 0x240c0060
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 96));
    // 0x15412c: 0x240b0002
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 2));
    // 0x154130: 0xec1018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 12); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x154134: 0x0
    // NOP
label_154138:
    // 0x154138: 0x4d1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 13)));
    // 0x15413c: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x154140: 0x14400044
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 7), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_154254;
    }
    // 0x154148: 0xc4600034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[0] = *(float*)&val; }
    // 0x15414c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x154150: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x154154: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x154158: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15415c: 0x0
    // NOP
    // 0x154160: 0x4503003d
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 7, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
        goto label_154258;
    }
    // 0x154168: 0x8c620028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 40)));
    // 0x15416c: 0x104b0039
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 11)) {
        goto label_154254;
    }
    // 0x154174: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x154178: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15417c: 0xc4a00094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 148)); ctx->f[0] = *(float*)&val; }
    // 0x154180: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x154184: 0x0
    // NOP
    // 0x154188: 0x45030033
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 7, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
        goto label_154258;
    }
    // 0x154190: 0x78a200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 176)));
    // 0x154194: 0x8e630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x154198: 0x18600017
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1541f8;
    }
    // 0x1541a0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1541a4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1541a8: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1541ac: 0x73100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 7), 4));
label_1541b0:
    // 0x1541b0: 0xc4600034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1541b4: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1541b8: 0x0
    // NOP
    // 0x1541bc: 0x4503000c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
        goto label_1541f0;
    }
    // 0x1541c4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1541c8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1541cc: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1541d0: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1541d4: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1541d8: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1541dc: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1541e0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1541e4: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1541e8: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1541ec: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
label_1541f0:
    // 0x1541f0: 0x1480ffef
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 96));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1541b0;
    }
label_1541f8:
    // 0x1541f8: 0xd8a10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 128)));
    // 0x1541fc: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x154200: 0x4bc118aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x154204: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x154208: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15420c: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154210: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x154214: 0x4be218ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x154218: 0x4bc2112a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15421c: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x154220: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x154224: 0x4b04090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154228: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x15422c: 0x48232000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x154230: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x154234: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x154238: 0x0
    // NOP
    // 0x15423c: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 7, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
        goto label_154258;
    }
    // 0x154244: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x154248: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    // 0x15424c: 0xe0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x154250: 0xa0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_154254:
    // 0x154254: 0x120382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
label_154258:
    // 0x154258: 0xf4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 20)));
    // 0x15425c: 0x1440ffb6
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 12); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_154138;
    }
label_154264:
    // 0x154264: 0x11000035
    { int64_t result = (int64_t)GPR_S32(ctx, 10) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15433C; return;
    }
    // 0x15426c: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x154270: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x154274: 0x5e1018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x154278: 0xa32021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x15427c: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x154280: 0xae040048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 4));
    // 0x154284: 0xac900048
    WRITE32(ADD32(GPR_U32(ctx, 4), 72), GPR_U32(ctx, 16));
    // 0x154288: 0x46020004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x15428c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x154290: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x154294: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x154298: 0xae080000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 8));
    // 0x15429c: 0x25110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 8), 4));
    // 0x1542a0: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x1542a4: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1542a8: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1542ac: 0xe6000038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x1542b0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1542b4: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1542b8: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1542bc: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1542c0: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1542c4: 0xfa010010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1542c8: 0xae170028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 23));
    // 0x1542cc: 0xae17002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 23));
    // 0x1542d0: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1542d4: 0xc5010094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 148)); ctx->f[1] = *(float*)&val; }
    // 0x1542d8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1542dc: 0xe6000030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
label_1542e0:
    // 0x1542e0: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1542e4: 0xc06ed50
    SET_GPR_U32(ctx, 31, 0x1542ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 264));
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1542ec
// Address: 0x1542ec - 0x154318

void entry_1542ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1542ec: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1542f0: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x15431C; return;
    }
    // 0x1542f8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1542fc: 0x8c420108
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 264)));
    // 0x154300: 0x10400005
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 22), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_154318(rdram, ctx, runtime); return;
    }
    // 0x154308: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15430c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x154310: 0x40f809
    SET_GPR_U32(ctx, 31, 0x154318);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_154318
// Address: 0x154318 - 0x154334

void entry_154318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154318) {
        switch (ctx->pc) {
            case 0x15431c: ctx->pc = 0; goto label_15431c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154318: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_15431c:
    // 0x15431c: 0x2a420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    // 0x154320: 0x1440ffef
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1542E0; return;
    }
    // 0x154328: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15432c: 0xc054db2
    SET_GPR_U32(ctx, 31, 0x154334);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AppendDzgDz__FP3DZGP2DZ(rdram, ctx, runtime); return;
}


// Function: entry_154334
// Address: 0x154334 - 0x154370

void entry_154334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154334) {
        switch (ctx->pc) {
            case 0x15433c: ctx->pc = 0; goto label_15433c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154334: 0x1000ff6c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1540E8; return;
    }
label_15433c:
    // 0x15433c: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x154340: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x154344: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x154348: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x15434c: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x154350: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x154354: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x154358: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15435c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x154360: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x154364: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x154368: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyDzg__FP3DZGiPiPPP2SOff
// Address: 0x154370 - 0x1543c8

void entry_1543c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1543c8: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1543cc: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1543d4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1543d4
// Address: 0x1543d4 - 0x154404

void entry_1543d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1543d4) {
        switch (ctx->pc) {
            case 0x1543f0: ctx->pc = 0; goto label_1543f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1543d4: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1543d8: 0x1860000d
    WRITE32(ADD32(GPR_U32(ctx, 29), 92), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x154410; return;
    }
    // 0x1543e0: 0x8fb10054
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1543e4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1543e8: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1543ec: 0x0
    // NOP
label_1543f0:
    // 0x1543f0: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1543f4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1543f8: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x1543fc: 0xc0635aa
    SET_GPR_U32(ctx, 31, 0x154404);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 5));
    PvAllocStackClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_154404
// Address: 0x154404 - 0x1545c8

void entry_154404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154404) {
        switch (ctx->pc) {
            case 0x154410: ctx->pc = 0; goto label_154410;
            case 0x154430: ctx->pc = 0; goto label_154430;
            case 0x154458: ctx->pc = 0; goto label_154458;
            case 0x1544b0: ctx->pc = 0; goto label_1544b0;
            case 0x154508: ctx->pc = 0; goto label_154508;
            case 0x154518: ctx->pc = 0; goto label_154518;
            case 0x15452c: ctx->pc = 0; goto label_15452c;
            case 0x154540: ctx->pc = 0; goto label_154540;
            case 0x154588: ctx->pc = 0; goto label_154588;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154404: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x154408: 0x1600fff9
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1543F0; return;
    }
label_154410:
    // 0x154410: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x154414: 0x4615adc2
    ctx->f[23] = FPU_MUL_S(ctx->f[21], ctx->f[21]);
    // 0x154418: 0x4614a582
    ctx->f[22] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x15441c: 0x18400043
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_15452c;
    }
    // 0x154424: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x154428: 0x240c0060
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 96));
    // 0x15442c: 0x8c1818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 12); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_154430:
    // 0x154430: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x154434: 0x433821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x154438: 0xc4e00034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 52)); ctx->f[0] = *(float*)&val; }
    // 0x15443c: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x154440: 0x0
    // NOP
    // 0x154444: 0x45010034
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 4), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_154518;
    }
    // 0x15444c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154450: 0x24ea0020
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 7), 32));
    // 0x154454: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
label_154458:
    // 0x154458: 0x41980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 6));
    // 0x15445c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x154460: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154464: 0x10400028
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_154508;
    }
    // 0x15446c: 0x8c4204bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 1212)));
    // 0x154470: 0x4400025
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    if (GPR_S32(ctx, 2) < 0) {
        goto label_154508;
    }
    // 0x154478: 0x8fa50054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x15447c: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x154480: 0x452021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x154484: 0x1431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 3)));
    // 0x154488: 0x8fa5005c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    // 0x15448c: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154490: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x154494: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154498: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15449c: 0x1840001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_154508;
    }
    // 0x1544a4: 0x80402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1544a8: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1544ac: 0x0
    // NOP
label_1544b0:
    // 0x1544b0: 0x8ce20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 52)));
    // 0x1544b4: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1544b8: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1544bc: 0xd8830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1544c0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1544c4: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1544c8: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1544cc: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1544d0: 0xd8840010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1544d4: 0xf8830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1544d8: 0x8ce20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 52)));
    // 0x1544dc: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1544e0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1544e4: 0xd8610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1544e8: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1544ec: 0x4be20908
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1544f0: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1544f4: 0xf8840010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1544f8: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1544fc: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x154500: 0x1440ffeb
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1544b0;
    }
label_154508:
    // 0x154508: 0x120202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x15450c: 0x28820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    // 0x154510: 0x5440ffd1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
        goto label_154458;
    }
label_154518:
    // 0x154518: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x15451c: 0x160202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x154520: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x154524: 0x1440ffc2
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 12); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_154430;
    }
label_15452c:
    // 0x15452c: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x154530: 0x186000c0
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x154834; return;
    }
    // 0x154538: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x15453c: 0x0
    // NOP
label_154540:
    // 0x154540: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x154544: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x154548: 0x8fa50058
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    // 0x15454c: 0xafb00064
    WRITE32(ADD32(GPR_U32(ctx, 29), 100), GPR_U32(ctx, 16));
    // 0x154550: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x154554: 0x452021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x154558: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15455c: 0x8c7e0000
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154560: 0x8fa3005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 92)));
    // 0x154564: 0x8c840000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x154568: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15456c: 0x8c570000
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154570: 0x1bc000ab
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 4));
    if (GPR_S32(ctx, 30) <= 0) {
        ctx->pc = 0x154820; return;
    }
    // 0x154578: 0x27b60020
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 32));
    // 0x15457c: 0x27b50030
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 48));
    // 0x154580: 0x8fa40060
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x154584: 0x0
    // NOP
label_154588:
    // 0x154588: 0x141080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 20), 2));
    // 0x15458c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x154590: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154594: 0x8e2204c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1216)));
    // 0x154598: 0x8e320018
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x15459c: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1545a0: 0x12400068
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x154744; return;
    }
    // 0x1545a8: 0x8e5004c0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 1216)));
    // 0x1545ac: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1545b0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1545b4: 0x26250140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1545b8: 0x108140
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 5));
    // 0x1545bc: 0x2f08021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 16)));
    // 0x1545c0: 0xc06f1fe
    SET_GPR_U32(ctx, 31, 0x1545c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateSoEffect__FP2SOP6VECTORP2FXT1(rdram, ctx, runtime); return;
}


// Function: entry_1545c8
// Address: 0x1545c8 - 0x154674

void entry_1545c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1545c8: 0xda660000
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1545cc: 0x26420110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 272));
    // 0x1545d0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1545d4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1545d8: 0x4be131ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1545dc: 0x26250440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1088));
    // 0x1545e0: 0xfba60000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1545e4: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1545e8: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1545ec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1545f0: 0xda010010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1545f4: 0xda650010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1545f8: 0x4be1296c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1545fc: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x154600: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x154604: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x154608: 0xda430110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 272)));
    // 0x15460c: 0x4be61a6a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x154610: 0x4be00293
    // Unhandled VU0 Special1 function: 0x13
    // 0x154614: 0x4be6122a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x154618: 0x4be609ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15461c: 0x4b09483d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x154620: 0x4b09510a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154624: 0x4a88403c
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x154628: 0x4a88510a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15462c: 0x4a47383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x154630: 0x4a475109
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154634: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x154638: 0xda430110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 272)));
    // 0x15463c: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x154640: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x154644: 0x4be51a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x154648: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x15464c: 0x4be509ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x154650: 0x4be511aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x154654: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x154658: 0x4b08490a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15465c: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x154660: 0x4a87490a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154664: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x154668: 0x4a464909
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15466c: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x154674);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_154674
// Address: 0x154674 - 0x15468c

void entry_154674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154674: 0x26250460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1120));
    // 0x154678: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15467c: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x154680: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x154684: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x15468c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_15468c
// Address: 0x15468c - 0x15483c

void entry_15468c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15468c) {
        switch (ctx->pc) {
            case 0x1546e4: ctx->pc = 0; goto label_1546e4;
            case 0x1546ec: ctx->pc = 0; goto label_1546ec;
            case 0x154744: ctx->pc = 0; goto label_154744;
            case 0x1547a0: ctx->pc = 0; goto label_1547a0;
            case 0x1547a8: ctx->pc = 0; goto label_1547a8;
            case 0x154804: ctx->pc = 0; goto label_154804;
            case 0x154808: ctx->pc = 0; goto label_154808;
            case 0x154810: ctx->pc = 0; goto label_154810;
            case 0x154820: ctx->pc = 0; goto label_154820;
            case 0x154834: ctx->pc = 0; goto label_154834;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15468c: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x154690: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x154694: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x154698: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15469c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1546a0: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1546a4: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1546a8: 0x4600b834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1546ac: 0x0
    // NOP
    // 0x1546b0: 0x4502000c
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1168)));
        goto label_1546e4;
    }
    // 0x1546b8: 0xda220490
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1168)));
    // 0x1546bc: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x1546c0: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    // 0x1546c4: 0x4600a803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[0] = ctx->f[21] / ctx->f[0];
    // 0x1546c8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1546cc: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1546d0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1546d4: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1546d8: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1546dc: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 17), 1168), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1546ec;
    }
label_1546e4:
    // 0x1546e4: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1546e8: 0xfa210490
    WRITE128(ADD32(GPR_U32(ctx, 17), 1168), _mm_castps_si128(ctx->vu0_vf[1]));
label_1546ec:
    // 0x1546ec: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1546f0: 0x4bc318aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1546f4: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1546f8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1546fc: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154700: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x154704: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x154708: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15470c: 0x0
    // NOP
    // 0x154710: 0x4500003c
    ctx->vu0_i = (float)ctx->vi[4];
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_154804;
    }
    // 0x154718: 0xda2204a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1184)));
    // 0x15471c: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x154720: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    // 0x154724: 0x4600a003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[0] = ctx->f[20] / ctx->f[0];
    // 0x154728: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x15472c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x154730: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x154734: 0x4be12088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154738: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15473c: 0x10000034
    WRITE128(ADD32(GPR_U32(ctx, 17), 1184), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_154810;
    }
label_154744:
    // 0x154744: 0xda630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x154748: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x15474c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x154750: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x154754: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154758: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15475c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x154760: 0x4600b834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x154764: 0x0
    // NOP
    // 0x154768: 0x4502000d
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1168)));
        goto label_1547a0;
    }
    // 0x154770: 0xda230490
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1168)));
    // 0x154774: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x154778: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    // 0x15477c: 0x4600a803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[0] = ctx->f[21] / ctx->f[0];
    // 0x154780: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x154784: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x154788: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x15478c: 0xda610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x154790: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x154794: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154798: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 17), 1168), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1547a8;
    }
label_1547a0:
    // 0x1547a0: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1547a4: 0xfa210490
    WRITE128(ADD32(GPR_U32(ctx, 17), 1168), _mm_castps_si128(ctx->vu0_vf[1]));
label_1547a8:
    // 0x1547a8: 0xda630010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1547ac: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1547b0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1547b4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1547b8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1547bc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1547c0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1547c4: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1547c8: 0x0
    // NOP
    // 0x1547cc: 0x4502000e
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1184)));
        goto label_154808;
    }
    // 0x1547d4: 0xda2304a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1184)));
    // 0x1547d8: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x1547dc: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    // 0x1547e0: 0x4600a003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[0] = ctx->f[20] / ctx->f[0];
    // 0x1547e4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1547e8: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1547ec: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1547f0: 0xda610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1547f4: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1547f8: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1547fc: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 17), 1184), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_154810;
    }
label_154804:
    // 0x154804: 0xda2104a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1184)));
label_154808:
    // 0x154808: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15480c: 0xfa2104a0
    WRITE128(ADD32(GPR_U32(ctx, 17), 1184), _mm_castps_si128(ctx->vu0_vf[1]));
label_154810:
    // 0x154810: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x154814: 0x29e102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 30)));
    // 0x154818: 0x1440ff5b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x154588; return;
    }
label_154820:
    // 0x154820: 0x8fb00064
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 100)));
    // 0x154824: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x154828: 0x203102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x15482c: 0x1440ff44
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x154540; return;
    }
label_154834:
    // 0x154834: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x15483c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15483c
// Address: 0x15483c - 0x154880

void entry_15483c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15483c: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x154840: 0x7bbe00f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x154844: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x154848: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x15484c: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x154850: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x154854: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x154858: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15485c: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x154860: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x154864: 0xc7b70128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[23] = *(float*)&val; }
    // 0x154868: 0xc7b60120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[22] = *(float*)&val; }
    // 0x15486c: 0xc7b50118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[21] = *(float*)&val; }
    // 0x154870: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x154874: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15487c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x154880; return;
}


// Function: SolveInequalities__FiPfN21
// Address: 0x154880 - 0x1548c0

void entry_1548c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1548c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1548c4: 0xc054d4a
    SET_GPR_U32(ctx, 31, 0x1548cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    InitDzg__FP3DZGi(rdram, ctx, runtime); return;
}


// Function: entry_1548cc
// Address: 0x1548cc - 0x154900

void entry_1548cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1548cc) {
        switch (ctx->pc) {
            case 0x1548f0: ctx->pc = 0; goto label_1548f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1548cc: 0x5a80001c
    if (GPR_S32(ctx, 20) <= 0) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 20));
        ctx->pc = 0x154940; return;
    }
    // 0x1548d4: 0x14a880
    SET_GPR_U32(ctx, 21, SLL32(GPR_U32(ctx, 20), 2));
    // 0x1548d8: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1548dc: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1548e0: 0x2a0b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1548e4: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1548e8: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1548ec: 0x8fb00008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_1548f0:
    // 0x1548f0: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1548f4: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1548f8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x154900);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 22)));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_154900
// Address: 0x154900 - 0x154918

void entry_154900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154900: 0x26d60060
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 96));
    // 0x154904: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x154908: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15490c: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x154910: 0xc063600
    SET_GPR_U32(ctx, 31, 0x154918);
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 2));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_154918
// Address: 0x154918 - 0x154934

void entry_154918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154918: 0x2579021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 23)));
    // 0x15491c: 0xc6600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[0] = *(float*)&val; }
    // 0x154920: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x154924: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x154928: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x15492c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x154934);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_154934
// Address: 0x154934 - 0x15495c

void entry_154934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154934) {
        switch (ctx->pc) {
            case 0x154940: ctx->pc = 0; goto label_154940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154934: 0x5620ffee
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 8)));
        ctx->pc = 0x1548F0; return;
    }
    // 0x15493c: 0xafb40004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 20));
label_154940:
    // 0x154940: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x154944: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154948: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15494c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154950: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154954: 0xc054fb0
    SET_GPR_U32(ctx, 31, 0x15495c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SolveDzg__FP3DZGiiPP2XPPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_15495c
// Address: 0x15495c - 0x154994

void entry_15495c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15495c) {
        switch (ctx->pc) {
            case 0x154970: ctx->pc = 0; goto label_154970;
            case 0x15498c: ctx->pc = 0; goto label_15498c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15495c: 0x1a80000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_15498c;
    }
    // 0x154964: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x154968: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15496c: 0x24420034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 52));
label_154970:
    // 0x154970: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x154974: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x154978: 0x24420060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 96));
    // 0x15497c: 0xe4e00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 0), *(uint32_t*)&val); }
    // 0x154980: 0x0
    // NOP
    // 0x154984: 0x1620fffa
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_154970;
    }
label_15498c:
    // 0x15498c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x154994);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_154994
// Address: 0x154994 - 0x1549c8

void entry_154994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154994: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x154998: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x15499c: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1549a0: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1549a4: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1549a8: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1549ac: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1549b0: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1549b4: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1549b8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1549bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1549c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1549c8; return;
}


// Function: InitEmitb__FP5EMITB
// Address: 0x1549c8 - 0x154a2c

void entry_154a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154a2c) {
        switch (ctx->pc) {
            case 0x154a58: ctx->pc = 0; goto label_154a58;
            case 0x154a84: ctx->pc = 0; goto label_154a84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154a2c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x154a30: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x154a34: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x154a38: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x154a3c: 0x78640000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154a40: 0x27a60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 128));
    // 0x154a44: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154a48: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x154a4c: 0x7fa40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 4));
    // 0x154a50: 0x7fa50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 5));
    // 0x154a54: 0x7fa50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 5));
label_154a58:
    // 0x154a58: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154a5c: 0x78640010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x154a60: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x154a64: 0x7e040010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 4));
    // 0x154a68: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x154a6c: 0x1466fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 6)) {
        goto label_154a58;
    }
    // 0x154a74: 0x78680000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154a78: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x154a7c: 0x7e080000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 8));
    // 0x154a80: 0xae421f70
    WRITE32(ADD32(GPR_U32(ctx, 18), 8048), GPR_U32(ctx, 2));
label_154a84:
    // 0x154a84: 0x8e821f74
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8052)));
    // 0x154a88: 0x26320010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 16));
    // 0x154a8c: 0x263300a0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 160));
    // 0x154a90: 0x1440002a
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 288));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x154B3C; return;
    }
    // 0x154a98: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x154a9c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154aa0: 0x24060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    // 0x154aa4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x154aac);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 23), 4294951072));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_154aac
// Address: 0x154aac - 0x154b4c

void entry_154aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154aac) {
        switch (ctx->pc) {
            case 0x154b18: ctx->pc = 0; goto label_154b18;
            case 0x154b3c: ctx->pc = 0; goto label_154b3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154aac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x154ab0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x154ab4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x154ab8: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x154abc: 0x3c01443b
    SET_GPR_U32(ctx, 1, ((uint32_t)17467 << 16));
    // 0x154ac0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x154ac4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x154ac8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154acc: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x154ad0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x154ad4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x154ad8: 0x240200c8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 200));
    // 0x154adc: 0x3c01c4bb
    SET_GPR_U32(ctx, 1, ((uint32_t)50363 << 16));
    // 0x154ae0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x154ae4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x154ae8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x154aec: 0xe7a20004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x154af0: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x154af4: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    // 0x154af8: 0xafa2004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 2));
    // 0x154afc: 0xe7a20000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x154b00: 0xe7a10008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x154b04: 0xe7a30020
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x154b08: 0xe7a10050
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x154b0c: 0xe7a10054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x154b10: 0xe7a10070
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x154b14: 0xe7a30078
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 120), *(uint32_t*)&val); }
label_154b18:
    // 0x154b18: 0x78870000
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x154b1c: 0x78880010
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x154b20: 0x7e070000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 7));
    // 0x154b24: 0x7e080010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 8));
    // 0x154b28: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x154b2c: 0x1485fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 5)) {
        goto label_154b18;
    }
    // 0x154b34: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x154b38: 0xae821f74
    WRITE32(ADD32(GPR_U32(ctx, 20), 8052), GPR_U32(ctx, 2));
label_154b3c:
    // 0x154b3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x154b40: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154b44: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x154b4c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 512));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_154b4c
// Address: 0x154b4c - 0x154c10

void entry_154b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154b4c) {
        switch (ctx->pc) {
            case 0x154b60: ctx->pc = 0; goto label_154b60;
            case 0x154b90: ctx->pc = 0; goto label_154b90;
            case 0x154bb8: ctx->pc = 0; goto label_154bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154b4c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x154b50: 0x26c4c010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 4294950928));
    // 0x154b54: 0xae230000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
    // 0x154b58: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x154b5c: 0x24830080
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 128));
label_154b60:
    // 0x154b60: 0x78850000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x154b64: 0x78860010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x154b68: 0x7c450000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 5));
    // 0x154b6c: 0x7c460010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 6));
    // 0x154b70: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x154b74: 0x1483fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_154b60;
    }
    // 0x154b7c: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x154b80: 0x26f0c0a0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 23), 4294951072));
    // 0x154b84: 0x7c430000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    // 0x154b88: 0x26030080
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 128));
    // 0x154b8c: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_154b90:
    // 0x154b90: 0x7a080000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x154b94: 0x7a040010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x154b98: 0x7c480000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 8));
    // 0x154b9c: 0x7c440010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 4));
    // 0x154ba0: 0x26100020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    // 0x154ba4: 0x1603fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        goto label_154b90;
    }
    // 0x154bac: 0x27c31f80
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 30), 8064));
    // 0x154bb0: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x154bb4: 0x246400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 192));
label_154bb8:
    // 0x154bb8: 0x78670000
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154bbc: 0x78680010
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x154bc0: 0x7c470000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 7));
    // 0x154bc4: 0x7c480010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 8));
    // 0x154bc8: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x154bcc: 0x1464fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_154bb8;
    }
    // 0x154bd4: 0x78670000
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154bd8: 0x7c470000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 7));
    // 0x154bdc: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x154be0: 0x7bbe0110
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x154be4: 0x7bb70100
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x154be8: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x154bec: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x154bf0: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x154bf4: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x154bf8: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x154bfc: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x154c00: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x154c04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x154c0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x154c10; return;
}


// Function: InitEmitter__FP7EMITTER
// Address: 0x154c10 - 0x154c24

void entry_154c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154c24: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x154c28: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x154c2c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x154c30: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x154c34: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x154c38: 0x26040314
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 788));
    // 0x154c3c: 0xe60102dc
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 732), *(uint32_t*)&val); }
    // 0x154c40: 0x24050320
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 800));
    // 0x154c44: 0xe6000340
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 832), *(uint32_t*)&val); }
    // 0x154c48: 0xae020310
    WRITE32(ADD32(GPR_U32(ctx, 16), 784), GPR_U32(ctx, 2));
    // 0x154c4c: 0xae0202d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 2));
    // 0x154c50: 0xe60102e0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 736), *(uint32_t*)&val); }
    // 0x154c54: 0xae0202f8
    WRITE32(ADD32(GPR_U32(ctx, 16), 760), GPR_U32(ctx, 2));
    // 0x154c58: 0xae0202fc
    WRITE32(ADD32(GPR_U32(ctx, 16), 764), GPR_U32(ctx, 2));
    // 0x154c5c: 0xae020304
    WRITE32(ADD32(GPR_U32(ctx, 16), 772), GPR_U32(ctx, 2));
    // 0x154c60: 0xae020300
    WRITE32(ADD32(GPR_U32(ctx, 16), 768), GPR_U32(ctx, 2));
    // 0x154c64: 0xae02030c
    WRITE32(ADD32(GPR_U32(ctx, 16), 780), GPR_U32(ctx, 2));
    // 0x154c68: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x154c70);
    WRITE32(ADD32(GPR_U32(ctx, 16), 724), GPR_U32(ctx, 2));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_154c70
// Address: 0x154c70 - 0x154c80

void entry_154c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154c70: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x154c74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x154c78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadEmitmeshFromBrx__FP8EMITMESHP18CBinaryInputStream
// Address: 0x154c80 - 0x154cb8

void entry_154cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154cb8: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x154cbc: 0xc063540
    SET_GPR_U32(ctx, 31, 0x154cc4);
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_154cc4
// Address: 0x154cc4 - 0x154cd4

void entry_154cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154cc4: 0x8e640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x154cc8: 0xae620004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 2));
    // 0x154ccc: 0xc063570
    SET_GPR_U32(ctx, 31, 0x154cd4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_154cd4
// Address: 0x154cd4 - 0x154cfc

void entry_154cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154cd4) {
        switch (ctx->pc) {
            case 0x154ce8: ctx->pc = 0; goto label_154ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154cd4: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x154cd8: 0x1860000c
    WRITE32(ADD32(GPR_U32(ctx, 19), 16), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x154D0C; return;
    }
    // 0x154ce0: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x154ce4: 0x0
    // NOP
label_154ce8:
    // 0x154ce8: 0x112900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 4));
    // 0x154cec: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x154cf0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x154cf4: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x154cfc);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_154cfc
// Address: 0x154cfc - 0x154d18

void entry_154cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154cfc) {
        switch (ctx->pc) {
            case 0x154d0c: ctx->pc = 0; goto label_154d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154cfc: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x154d00: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x154d04: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x154CE8; return;
    }
label_154d0c:
    // 0x154d0c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x154d10: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x154d18);
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 19), 32));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_154d18
// Address: 0x154d18 - 0x154d24

void entry_154d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154d18: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x154d1c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x154d24);
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_154d24
// Address: 0x154d24 - 0x154d64

void entry_154d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154d24) {
        switch (ctx->pc) {
            case 0x154d40: ctx->pc = 0; goto label_154d40;
            case 0x154d58: ctx->pc = 0; goto label_154d58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154d24: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x154d28: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x154d2c: 0xae62000c
    WRITE32(ADD32(GPR_U32(ctx, 19), 12), GPR_U32(ctx, 2));
    // 0x154d30: 0x18600038
    WRITE32(ADD32(GPR_U32(ctx, 19), 20), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x154E14; return;
    }
    // 0x154d38: 0x8e63000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x154d3c: 0x0
    // NOP
label_154d40:
    // 0x154d40: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x154d44: 0x24950001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 4), 1));
    // 0x154d48: 0x24110002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    // 0x154d4c: 0x629021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x154d50: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x154d54: 0x0
    // NOP
label_154d58:
    // 0x154d58: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x154d5c: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x154d64);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_154d64
// Address: 0x154d64 - 0x154d7c

void entry_154d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154d64: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x154d68: 0x621fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x154D58; return;
    }
    // 0x154d70: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x154d74: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x154d7c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_154d7c
// Address: 0x154d7c - 0x154e20

void entry_154d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154d7c) {
        switch (ctx->pc) {
            case 0x154dd8: ctx->pc = 0; goto label_154dd8;
            case 0x154e14: ctx->pc = 0; goto label_154e14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154d7c: 0xe640000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
    // 0x154d80: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x154d84: 0xc6610014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 20)); ctx->f[1] = *(float*)&val; }
    // 0x154d88: 0x8e650004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x154d8c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x154d90: 0xe6610014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 20), *(uint32_t*)&val); }
    // 0x154d94: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x154d98: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x154d9c: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x154da0: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x154da4: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x154da8: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x154dac: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x154db0: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x154db4: 0x852021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x154db8: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154dbc: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x154dc0: 0xd8810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x154dc4: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x154dc8: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x154dcc: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x154dd0: 0x4bc208ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154dd4: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
label_154dd8:
    // 0x154dd8: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x154ddc: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x154de0: 0x8e620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x154de4: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x154de8: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x154dec: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x154df0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154df4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x154df8: 0x621fff7
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_154dd8;
    }
    // 0x154e00: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x154e04: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x154e08: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x154e0c: 0x5440ffcc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 12)));
        ctx->pc = 0x154D40; return;
    }
label_154e14:
    // 0x154e14: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x154e18: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x154e20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_154e20
// Address: 0x154e20 - 0x154ee0

void entry_154e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154e20) {
        switch (ctx->pc) {
            case 0x154e48: ctx->pc = 0; goto label_154e48;
            case 0x154e90: ctx->pc = 0; goto label_154e90;
            case 0x154e9c: ctx->pc = 0; goto label_154e9c;
            case 0x154eb4: ctx->pc = 0; goto label_154eb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154e20: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x154e24: 0x18400023
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_154eb4;
    }
    // 0x154e2c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x154e30: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x154e34: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x154e38: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x154e3c: 0x24458d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x154e40: 0x8e630010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x154e44: 0x0
    // NOP
label_154e48:
    // 0x154e48: 0x111100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 4));
    // 0x154e4c: 0x78a40000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x154e50: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x154e54: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x154e58: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x154e5c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x154e60: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x154e64: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x154e68: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x154e6c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x154e70: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x154e74: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x154e78: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x154e7c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x154e80: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_154e90;
    }
    // 0x154e88: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_154e9c;
    }
label_154e90:
    // 0x154e90: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x154e94: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x154e98: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_154e9c:
    // 0x154e9c: 0xf8410000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x154ea0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x154ea4: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x154ea8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x154eac: 0x5440ffe6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
        goto label_154e48;
    }
label_154eb4:
    // 0x154eb4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x154eb8: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x154ebc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x154ec0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x154ec4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x154ec8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x154ecc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x154ed0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x154ed4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x154edc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x154ee0; return;
}


// Function: LoadEmitblipColorsFromBrx__FP8EMITBLIPiP2LOP18CBinaryInputStream
// Address: 0x154ee0 - 0x154f24

void entry_154f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154f24: 0xae220050
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 2));
    // 0x154f28: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x154f30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_154f30
// Address: 0x154f30 - 0x154f40

void entry_154f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154f30) {
        switch (ctx->pc) {
            case 0x154f38: ctx->pc = 0; goto label_154f38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154f30: 0x1a400012
    WRITE32(ADD32(GPR_U32(ctx, 17), 84), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x154F7C; return;
    }
label_154f38:
    // 0x154f38: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x154f40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_154f40
// Address: 0x154f40 - 0x154f98

void entry_154f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x154f40) {
        switch (ctx->pc) {
            case 0x154f6c: ctx->pc = 0; goto label_154f6c;
            case 0x154f7c: ctx->pc = 0; goto label_154f7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x154f40: 0x8e23004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x154f44: 0x203182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x154f48: 0x10600008
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_154f6c;
    }
    // 0x154f50: 0x8e230050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x154f54: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x154f58: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x154f5c: 0x8ba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x154f60: 0x9ba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x154f64: 0xa8430003
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x154f68: 0xb8430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
label_154f6c:
    // 0x154f6c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x154f70: 0x212102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 18)));
    // 0x154f74: 0x1440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x154F38; return;
    }
label_154f7c:
    // 0x154f7c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x154f80: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x154f84: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x154f88: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x154f8c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x154f90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadEmitterFromBrx__FP7EMITTERP18CBinaryInputStream
// Address: 0x154f98 - 0x154fbc

void entry_154fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154fbc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x154fc0: 0xc055272
    SET_GPR_U32(ctx, 31, 0x154fc8);
    WRITE32(ADD32(GPR_U32(ctx, 17), 720), GPR_U32(ctx, 2));
    InitEmitb__FP5EMITB(rdram, ctx, runtime); return;
}


// Function: entry_154fc8
// Address: 0x154fc8 - 0x154fd4

void entry_154fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154fc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x154fcc: 0xc04a270
    SET_GPR_U32(ctx, 31, 0x154fd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadAloFromBrx__FP3ALOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_154fd4
// Address: 0x154fd4 - 0x154fdc

void entry_154fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154fd4: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x154fdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_154fdc
// Address: 0x154fdc - 0x154ff4

void entry_154fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154fdc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x154fe0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x154fe4: 0x5082000d
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x15501C; return;
    }
    // 0x154fec: 0xc05366a
    SET_GPR_U32(ctx, 31, 0x154ff4);
    PcrvNew__F4CRVK(rdram, ctx, runtime); return;
}


// Function: entry_154ff4
// Address: 0x154ff4 - 0x155018

void entry_154ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x154ff4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x154ff8: 0x8e2202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x154ffc: 0xac440020
    WRITE32(ADD32(GPR_U32(ctx, 2), 32), GPR_U32(ctx, 4));
    // 0x155000: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x155004: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x155008: 0x50600004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x15501C; return;
    }
    // 0x155010: 0x60f809
    SET_GPR_U32(ctx, 31, 0x155018);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_155018
// Address: 0x155018 - 0x155034

void entry_155018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155018) {
        switch (ctx->pc) {
            case 0x15501c: ctx->pc = 0; goto label_15501c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155018: 0x8e2402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 720)));
label_15501c:
    // 0x15501c: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x155020: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x155024: 0x14430003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        entry_155034(rdram, ctx, runtime); return;
    }
    // 0x15502c: 0xc055320
    SET_GPR_U32(ctx, 31, 0x155034);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadEmitmeshFromBrx__FP8EMITMESHP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_155034
// Address: 0x155034 - 0x15503c

void entry_155034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155034: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x15503c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_15503c
// Address: 0x15503c - 0x155050

void entry_15503c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15503c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x155040: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_155064(rdram, ctx, runtime); return;
    }
    // 0x155048: 0xc0555de
    SET_GPR_U32(ctx, 31, 0x155050);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PemitbEnsureEmitter__FP7EMITTER4ENSK(rdram, ctx, runtime); return;
}


// Function: entry_155050
// Address: 0x155050 - 0x155064

void entry_155050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155050: 0x24440130
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 304));
    // 0x155054: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x155058: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15505c: 0xc0553b8
    SET_GPR_U32(ctx, 31, 0x155064);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadEmitblipColorsFromBrx__FP8EMITBLIPiP2LOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_155064
// Address: 0x155064 - 0x155080

void entry_155064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155064: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x155068: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15506c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x155070: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x155074: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15507c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x155080; return;
}


// Function: CloneEmitter__FP7EMITTERT0
// Address: 0x155080 - 0x155094

void entry_155094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155094: 0x8e0302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x155098: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15509c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1550a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1550a4: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1550a8: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1550ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1550b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1550b8; return;
}


// Function: BindEmitterCallback__FP7EMITTER5MSGIDPv
// Address: 0x1550b8 - 0x1550d8

void entry_1550d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1550d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1550dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1550e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1550e8; return;
}


// Function: BindEmitter__FP7EMITTER
// Address: 0x1550e8 - 0x155104

void entry_155104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155104) {
        switch (ctx->pc) {
            case 0x155164: ctx->pc = 0; goto label_155164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155104: 0xde0302f8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 760)));
    // 0x155108: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15510c: 0x14620015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_155164;
    }
    // 0x155114: 0x8e030304
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 772)));
    // 0x155118: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15511c: 0x14620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_155164;
    }
    // 0x155124: 0x8e02030c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 780)));
    // 0x155128: 0x1443000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_155164;
    }
    // 0x155130: 0x8e050300
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 768)));
    // 0x155134: 0x14a2000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_155164;
    }
    // 0x15513c: 0x8e0402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x155140: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x155144: 0x50430007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_155164;
    }
    // 0x15514c: 0x8c820120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 288)));
    // 0x155150: 0x1440003e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15524C; return;
    }
    // 0x155158: 0x8c820188
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 392)));
    // 0x15515c: 0x1045003a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x155248; return;
    }
label_155164:
    // 0x155164: 0xc0555de
    SET_GPR_U32(ctx, 31, 0x15516c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PemitbEnsureEmitter__FP7EMITTER4ENSK(rdram, ctx, runtime); return;
}


// Function: entry_15516c
// Address: 0x15516c - 0x15518c

void entry_15516c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15516c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x155170: 0x8e0602f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 760)));
    // 0x155174: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x155178: 0x10c2000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        entry_1551b0(rdram, ctx, runtime); return;
    }
    // 0x155180: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x155184: 0xc056906
    SET_GPR_U32(ctx, 31, 0x15518c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_15518c
// Address: 0x15518c - 0x1551b0

void entry_15518c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15518c: 0x10400008
    WRITE32(ADD32(GPR_U32(ctx, 18), 124), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1551b0(rdram, ctx, runtime); return;
    }
    // 0x155194: 0x3c050015
    SET_GPR_U32(ctx, 5, ((uint32_t)21 << 16));
    // 0x155198: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x15519c: 0x24a550b8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 20664));
    // 0x1551a0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1551a4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1551a8: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1551b0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1551b0
// Address: 0x1551b0 - 0x1551cc

void entry_1551b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1551b0: 0x8e0602fc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 764)));
    // 0x1551b4: 0x2411ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1551b8: 0x10d10005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1551D0; return;
    }
    // 0x1551c0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1551c4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1551cc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1551cc
// Address: 0x1551cc - 0x1551e8

void entry_1551cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1551cc) {
        switch (ctx->pc) {
            case 0x1551d0: ctx->pc = 0; goto label_1551d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1551cc: 0xae4201d8
    WRITE32(ADD32(GPR_U32(ctx, 18), 472), GPR_U32(ctx, 2));
label_1551d0:
    // 0x1551d0: 0x8e060304
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 772)));
    // 0x1551d4: 0x10d10005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1551EC; return;
    }
    // 0x1551dc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1551e0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1551e8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1551e8
// Address: 0x1551e8 - 0x155204

void entry_1551e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1551e8) {
        switch (ctx->pc) {
            case 0x1551ec: ctx->pc = 0; goto label_1551ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1551e8: 0xae4201dc
    WRITE32(ADD32(GPR_U32(ctx, 18), 476), GPR_U32(ctx, 2));
label_1551ec:
    // 0x1551ec: 0x8e060300
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 768)));
    // 0x1551f0: 0x10d1000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x15521C; return;
    }
    // 0x1551f8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1551fc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x155204);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_155204
// Address: 0x155204 - 0x155214

void entry_155204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155204: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x155208: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15520c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x155214);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_155214
// Address: 0x155214 - 0x155238

void entry_155214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155214) {
        switch (ctx->pc) {
            case 0x15521c: ctx->pc = 0; goto label_15521c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155214: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 480), GPR_U32(ctx, 17));
        goto label_15521c;
    }
label_15521c:
    // 0x15521c: 0x8e06030c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 780)));
    // 0x155220: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x155224: 0x10c20008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x155248; return;
    }
    // 0x15522c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x155230: 0xc056906
    SET_GPR_U32(ctx, 31, 0x155238);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_155238
// Address: 0x155238 - 0x155254

void entry_155238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155238) {
        switch (ctx->pc) {
            case 0x155248: ctx->pc = 0; goto label_155248;
            case 0x15524c: ctx->pc = 0; goto label_15524c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155238: 0x8c430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x15523c: 0xae430020
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 3));
    // 0x155240: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x155244: 0xae44007c
    WRITE32(ADD32(GPR_U32(ctx, 18), 124), GPR_U32(ctx, 4));
label_155248:
    // 0x155248: 0x8e0402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 720)));
label_15524c:
    // 0x15524c: 0xc0560a2
    SET_GPR_U32(ctx, 31, 0x155254);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BindEmitb__FP5EMITBP2LO(rdram, ctx, runtime); return;
}


// Function: entry_155254
// Address: 0x155254 - 0x155270

void entry_155254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155254: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x155258: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15525c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x155260: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x155264: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15526c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x155270; return;
}


// Function: PostEmitterLoad__FP7EMITTER
// Address: 0x155270 - 0x155288

void entry_155288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155288) {
        switch (ctx->pc) {
            case 0x1552a0: ctx->pc = 0; goto label_1552a0;
            case 0x1552d0: ctx->pc = 0; goto label_1552d0;
            case 0x1552d8: ctx->pc = 0; goto label_1552d8;
            case 0x1552f4: ctx->pc = 0; goto label_1552f4;
            case 0x1552f8: ctx->pc = 0; goto label_1552f8;
            case 0x15531c: ctx->pc = 0; goto label_15531c;
            case 0x15532c: ctx->pc = 0; goto label_15532c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155288: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x15528c: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x155290: 0x8c6201b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 432)));
    // 0x155294: 0x10440002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_1552a0;
    }
    // 0x15529c: 0xac620120
    WRITE32(ADD32(GPR_U32(ctx, 3), 288), GPR_U32(ctx, 2));
label_1552a0:
    // 0x1552a0: 0x8e2202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 724)));
    // 0x1552a4: 0x54440014
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 724)));
        goto label_1552f8;
    }
    // 0x1552ac: 0xc62002e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 744)); ctx->f[0] = *(float*)&val; }
    // 0x1552b0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1552b4: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1552b8: 0x0
    // NOP
    // 0x1552bc: 0x45000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1552d0;
    }
    // 0x1552c4: 0x8e220308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 776)));
    // 0x1552c8: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1552d8;
    }
label_1552d0:
    // 0x1552d0: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1552f4;
    }
label_1552d8:
    // 0x1552d8: 0xc62002f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 756)); ctx->f[0] = *(float*)&val; }
    // 0x1552dc: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1552e0: 0x0
    // NOP
    // 0x1552e4: 0x45030003
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 0));
        goto label_1552f4;
    }
    // 0x1552ec: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1552f0: 0xae2202d4
    WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 2));
label_1552f4:
    // 0x1552f4: 0x8e2302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 724)));
label_1552f8:
    // 0x1552f8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1552fc: 0x1062000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_15532c;
    }
    // 0x155304: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15531c;
    }
    // 0x15530c: 0x4600039
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x1553F4; return;
    }
    // 0x155314: 0x10000030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1553D8; return;
    }
label_15531c:
    // 0x15531c: 0x1062000e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x155358; return;
    }
    // 0x155324: 0x10000033
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1553F4; return;
    }
label_15532c:
    // 0x15532c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x155330: 0xc62c02dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
    // 0x155334: 0xc440a120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294943008)); ctx->f[0] = *(float*)&val; }
    // 0x155338: 0xc62d02e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 736)); ctx->f[13] = *(float*)&val; }
    // 0x15533c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155344);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 816), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155344
// Address: 0x155344 - 0x15536c

void entry_155344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155344) {
        switch (ctx->pc) {
            case 0x155358: ctx->pc = 0; goto label_155358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155344: 0x8e220308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 776)));
    // 0x155348: 0x1440000e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 808), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x155384; return;
    }
    // 0x155350: 0x10000010
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155394; return;
    }
label_155358:
    // 0x155358: 0xc62c02dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
    // 0x15535c: 0xc440a120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294943008)); ctx->f[0] = *(float*)&val; }
    // 0x155360: 0xc62d02e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 736)); ctx->f[13] = *(float*)&val; }
    // 0x155364: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15536c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 816), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15536c
// Address: 0x15536c - 0x15538c

void entry_15536c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15536c) {
        switch (ctx->pc) {
            case 0x155384: ctx->pc = 0; goto label_155384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15536c: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x155370: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x155374: 0x8e220308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 776)));
    // 0x155378: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15537c: 0x10400005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 808), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155394; return;
    }
label_155384:
    // 0x155384: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x15538c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_15538c
// Address: 0x15538c - 0x1553a8

void entry_15538c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15538c) {
        switch (ctx->pc) {
            case 0x155394: ctx->pc = 0; goto label_155394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15538c: 0x10000019
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1553F4; return;
    }
label_155394:
    // 0x155394: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x155398: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15539c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1553a0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1553a8);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1553a8
// Address: 0x1553a8 - 0x1553c4

void entry_1553a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1553a8: 0xc62102e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 744)); ctx->f[1] = *(float*)&val; }
    // 0x1553ac: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1553b0: 0x45000010
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1553F4; return;
    }
    // 0x1553b8: 0xc62c02ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 748)); ctx->f[12] = *(float*)&val; }
    // 0x1553bc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1553c4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 752)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1553c4
// Address: 0x1553c4 - 0x1553d0

void entry_1553c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1553c4: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1553c8: 0xc0557de
    SET_GPR_U32(ctx, 31, 0x1553d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PauseEmitter__FP7EMITTERf(rdram, ctx, runtime); return;
}


// Function: entry_1553d0
// Address: 0x1553d0 - 0x1553f0

void entry_1553d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1553d0) {
        switch (ctx->pc) {
            case 0x1553d8: ctx->pc = 0; goto label_1553d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1553d0: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1553F4; return;
    }
label_1553d8:
    // 0x1553d8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1553dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1553e0: 0xc62d02e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 736)); ctx->f[13] = *(float*)&val; }
    // 0x1553e4: 0xe620032c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 812), *(uint32_t*)&val); }
    // 0x1553e8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1553f0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 816), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1553f0
// Address: 0x1553f0 - 0x15551c

void entry_1553f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1553f0) {
        switch (ctx->pc) {
            case 0x1553f4: ctx->pc = 0; goto label_1553f4;
            case 0x155468: ctx->pc = 0; goto label_155468;
            case 0x15546c: ctx->pc = 0; goto label_15546c;
            case 0x15547c: ctx->pc = 0; goto label_15547c;
            case 0x1554d4: ctx->pc = 0; goto label_1554d4;
            case 0x1554f4: ctx->pc = 0; goto label_1554f4;
            case 0x155504: ctx->pc = 0; goto label_155504;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1553f0: 0xe6200328
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 808), *(uint32_t*)&val); }
label_1553f4:
    // 0x1553f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1553f8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1553fc: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x155400: 0x8e2502d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x155404: 0xe6200334
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 820), *(uint32_t*)&val); }
    // 0x155408: 0x8ca20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x15540c: 0x5443003d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 784)));
        goto label_155504;
    }
    // 0x155414: 0x8e2302f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x155418: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15541c: 0x10620017
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 32));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_15547c;
    }
    // 0x155424: 0xc4a30020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 32)); ctx->f[3] = *(float*)&val; }
    // 0x155428: 0xc4810010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 16)); ctx->f[1] = *(float*)&val; }
    // 0x15542c: 0xc4840004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[4] = *(float*)&val; }
    // 0x155430: 0xc4820014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20)); ctx->f[2] = *(float*)&val; }
    // 0x155434: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x155438: 0xc4800018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[0] = *(float*)&val; }
    // 0x15543c: 0x46041081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[4]);
    // 0x155440: 0xc4830008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[3] = *(float*)&val; }
    // 0x155444: 0x46000905
    ctx->f[4] = FPU_ABS_S(ctx->f[1]);
    // 0x155448: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x15544c: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x155450: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155454: 0x0
    // NOP
    // 0x155458: 0x45000003
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_155468;
    }
    // 0x155460: 0x10000002
    ctx->f[1] = std::max(ctx->f[0], ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15546c;
    }
label_155468:
    // 0x155468: 0x46010068
    ctx->f[1] = std::max(ctx->f[0], ctx->f[1]);
label_15546c:
    // 0x15546c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x155470: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x155474: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x155478: 0xe6200338
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 824), *(uint32_t*)&val); }
label_15547c:
    // 0x15547c: 0x8e2202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 740)));
    // 0x155480: 0x50400020
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 784)));
        goto label_155504;
    }
    // 0x155488: 0xc62102f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 756)); ctx->f[1] = *(float*)&val; }
    // 0x15548c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x155490: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155494: 0x0
    // NOP
    // 0x155498: 0x4501000e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[4] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1554d4;
    }
    // 0x1554a0: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1554a4: 0xc4830004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1554a8: 0xc4800010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1554ac: 0xc4820014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20)); ctx->f[2] = *(float*)&val; }
    // 0x1554b0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1554b4: 0x46031081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[3]);
    // 0x1554b8: 0xc4810018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1554bc: 0x3c013586
    SET_GPR_U32(ctx, 1, ((uint32_t)13702 << 16));
    // 0x1554c0: 0x342137bd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 14269));
    // 0x1554c4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1554c8: 0x46040841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[4]);
    // 0x1554cc: 0x10000009
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1554f4;
    }
label_1554d4:
    // 0x1554d4: 0xc4800014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20)); ctx->f[0] = *(float*)&val; }
    // 0x1554d8: 0xc4820004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1554dc: 0xc4810018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1554e0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1554e4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1554e8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1554ec: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1554f0: 0x46040841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[4]);
label_1554f4:
    // 0x1554f4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1554f8: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1554fc: 0xe6200334
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 820), *(uint32_t*)&val); }
    // 0x155500: 0x8e250310
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 784)));
label_155504:
    // 0x155504: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x155508: 0x10a20057
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x155668; return;
    }
    // 0x155510: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x155514: 0xc056920
    SET_GPR_U32(ctx, 31, 0x15551c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15551c
// Address: 0x15551c - 0x155540

void entry_15551c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15551c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x155520: 0x5600004b
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 844), GPR_U32(ctx, 0));
        ctx->pc = 0x155650; return;
    }
    // 0x155528: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x15552c: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x155530: 0x8e270310
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 784)));
    // 0x155534: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x155538: 0xc047960
    SET_GPR_U32(ctx, 31, 0x155540);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_155540
// Address: 0x155540 - 0x15554c

void entry_155540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155540: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x155544: 0xc063540
    SET_GPR_U32(ctx, 31, 0x15554c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 512));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_15554c
// Address: 0x15554c - 0x15564c

void entry_15554c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15554c) {
        switch (ctx->pc) {
            case 0x155558: ctx->pc = 0; goto label_155558;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15554c: 0xae0202d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 2));
    // 0x155550: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x155554: 0x24640200
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 512));
label_155558:
    // 0x155558: 0x78650000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15555c: 0x78660010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x155560: 0x7c450000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 5));
    // 0x155564: 0x7c460010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 6));
    // 0x155568: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x15556c: 0x1464fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_155558;
    }
    // 0x155574: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x155578: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x15557c: 0x42478
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 17);
    // 0x155580: 0x2406fcff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x155584: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x155588: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x15558c: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x155590: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x155594: 0x34078000
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 0), 32768));
    // 0x155598: 0x73e78
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 25);
    // 0x15559c: 0xac40007c
    WRITE32(ADD32(GPR_U32(ctx, 2), 124), GPR_U32(ctx, 0));
    // 0x1555a0: 0x26080110
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1555a4: 0x8e2202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 724)));
    // 0x1555a8: 0xae0202d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 724), GPR_U32(ctx, 2));
    // 0x1555ac: 0x8e2302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x1555b0: 0xae0302d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 3));
    // 0x1555b4: 0x6a2902e3
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 739); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1555b8: 0x6e2902dc
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 732); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1555bc: 0xb20902e3
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 739); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1555c0: 0xb60902dc
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 732); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1555c4: 0x8e2202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 740)));
    // 0x1555c8: 0xae0202e4
    WRITE32(ADD32(GPR_U32(ctx, 16), 740), GPR_U32(ctx, 2));
    // 0x1555cc: 0xc62002e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 744)); ctx->f[0] = *(float*)&val; }
    // 0x1555d0: 0xe60002e8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 744), *(uint32_t*)&val); }
    // 0x1555d4: 0x6a2902f3
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 755); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1555d8: 0x6e2902ec
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 748); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1555dc: 0xb20902f3
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 755); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1555e0: 0xb60902ec
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 748); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1555e4: 0xc62002f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 756)); ctx->f[0] = *(float*)&val; }
    // 0x1555e8: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1555ec: 0xe60002f4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 756), *(uint32_t*)&val); }
    // 0x1555f0: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1555f4: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1555f8: 0x8e230308
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 776)));
    // 0x1555fc: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x155600: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x155604: 0xae030308
    WRITE32(ADD32(GPR_U32(ctx, 16), 776), GPR_U32(ctx, 3));
    // 0x155608: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x15560c: 0x7a2400d0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 17), 208)));
    // 0x155610: 0x7e040110
    WRITE128(ADD32(GPR_U32(ctx, 16), 272), GPR_VEC(ctx, 4));
    // 0x155614: 0x7a2200e0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 224)));
    // 0x155618: 0x7e020120
    WRITE128(ADD32(GPR_U32(ctx, 16), 288), GPR_VEC(ctx, 2));
    // 0x15561c: 0x7a2300f0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 240)));
    // 0x155620: 0x7e0400d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 208), GPR_VEC(ctx, 4));
    // 0x155624: 0x7e030130
    WRITE128(ADD32(GPR_U32(ctx, 16), 304), GPR_VEC(ctx, 3));
    // 0x155628: 0x79020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 8), 16)));
    // 0x15562c: 0x7e0200e0
    WRITE128(ADD32(GPR_U32(ctx, 16), 224), GPR_VEC(ctx, 2));
    // 0x155630: 0x79030020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 8), 32)));
    // 0x155634: 0x7e0300f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 240), GPR_VEC(ctx, 3));
    // 0x155638: 0x8ca2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x15563c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 844), GPR_U32(ctx, 0));
        ctx->pc = 0x155650; return;
    }
    // 0x155644: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15564c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15564c
// Address: 0x15564c - 0x15565c

void entry_15564c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15564c) {
        switch (ctx->pc) {
            case 0x155650: ctx->pc = 0; goto label_155650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15564c: 0xae20034c
    WRITE32(ADD32(GPR_U32(ctx, 17), 844), GPR_U32(ctx, 0));
label_155650:
    // 0x155650: 0x26040314
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 788));
    // 0x155654: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x15565c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15565c
// Address: 0x15565c - 0x155664

void entry_15565c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15565c: 0xc0557ca
    SET_GPR_U32(ctx, 31, 0x155664);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_00155f28(rdram, ctx, runtime); return;
}


// Function: entry_155664
// Address: 0x155664 - 0x155678

void entry_155664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155664) {
        switch (ctx->pc) {
            case 0x155668: ctx->pc = 0; goto label_155668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155664: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_155668:
    // 0x155668: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15566c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x155670: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleEmitterMessage__FP7EMITTER5MSGIDPv
// Address: 0x155678 - 0x1556b0

void entry_1556b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1556b0) {
        switch (ctx->pc) {
            case 0x1556b8: ctx->pc = 0; goto label_1556b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1556b0: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 836), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1556D4; return;
    }
label_1556b8:
    // 0x1556b8: 0x14820007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1556D8; return;
    }
    // 0x1556c0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1556c4: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1556c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1556d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1556d0
// Address: 0x1556d0 - 0x1556e8

void entry_1556d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1556d0) {
        switch (ctx->pc) {
            case 0x1556d4: ctx->pc = 0; goto label_1556d4;
            case 0x1556d8: ctx->pc = 0; goto label_1556d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1556d0: 0xae000348
    WRITE32(ADD32(GPR_U32(ctx, 16), 840), GPR_U32(ctx, 0));
label_1556d4:
    // 0x1556d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1556d8:
    // 0x1556d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1556dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1556e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1556e8; return;
}


// Function: PemitbCopyOnWrite__FP5EMITB
// Address: 0x1556e8 - 0x155718

void entry_155718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155718: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15571c: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x155720: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x155724: 0x14620009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x15574C; return;
    }
    // 0x15572c: 0x8e050024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x155730: 0x10a00005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155748; return;
    }
    // 0x155738: 0x8e020020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x15573c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x155744);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_155744
// Address: 0x155744 - 0x155778

void entry_155744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155744) {
        switch (ctx->pc) {
            case 0x155748: ctx->pc = 0; goto label_155748;
            case 0x15574c: ctx->pc = 0; goto label_15574c;
            case 0x155760: ctx->pc = 0; goto label_155760;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155744: 0xae220024
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 2));
label_155748:
    // 0x155748: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
label_15574c:
    // 0x15574c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x155750: 0xae240000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 4));
    // 0x155754: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x155758: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x15575c: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
label_155760:
    // 0x155760: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x155764: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x155768: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15576c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x155774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x155778; return;
}


// Function: PemitbEnsureEmitter__FP7EMITTER4ENSK
// Address: 0x155778 - 0x15579c

void entry_15579c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15579c) {
        switch (ctx->pc) {
            case 0x1557a0: ctx->pc = 0; goto label_1557a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15579c: 0xae0202d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 2));
label_1557a0:
    // 0x1557a0: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x1557a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1557a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1557ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1557b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1557b8; return;
}


// Function: PemitterEnsureEmitter__FP7EMITTER4ENSK
// Address: 0x1557b8 - 0x1557d0

void entry_155818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155818: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15581c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x155820: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x155824: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x155828: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x15582c: 0x4600bbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[23]);
    // 0x155830: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x155834: 0xc056066
    SET_GPR_U32(ctx, 31, 0x15583c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 16));
    AddEmitoSkeleton__FP5EMITO3OIDT1ffffP2LO(rdram, ctx, runtime); return;
}


// Function: entry_15583c
// Address: 0x15583c - 0x155868

void entry_15583c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15583c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x155840: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x155844: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x155848: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15584c: 0xc7b70058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[23] = *(float*)&val; }
    // 0x155850: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x155854: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x155858: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x15585c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x155864: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x155868; return;
}


// Function: ModifyEmitterParticles__FP7EMITTER
// Address: 0x155868 - 0x1559a0

void entry_1559a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1559a0) {
        switch (ctx->pc) {
            case 0x1559c4: ctx->pc = 0; goto label_1559c4;
            case 0x1559f0: ctx->pc = 0; goto label_1559f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1559a0: 0xc7a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1559a4: 0xc6020000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1559a8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1559ac: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1559b0: 0xe7a10030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x1559b4: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1559b8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1559bc: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1559c0: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
label_1559c4:
    // 0x1559c4: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1559c8: 0x46016034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1559cc: 0x0
    // NOP
    // 0x1559d0: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
        goto label_1559f0;
    }
    // 0x1559d8: 0xc7a00024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[0] = *(float*)&val; }
    // 0x1559dc: 0x460c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1559e0: 0x0
    // NOP
    // 0x1559e4: 0x4502000d
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x155A1C; return;
    }
    // 0x1559ec: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
label_1559f0:
    // 0x1559f0: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1559f8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1559f8
// Address: 0x1559f8 - 0x155a50

void entry_1559f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1559f8) {
        switch (ctx->pc) {
            case 0x155a1c: ctx->pc = 0; goto label_155a1c;
            case 0x155a48: ctx->pc = 0; goto label_155a48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1559f8: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1559fc: 0xc6020004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[2] = *(float*)&val; }
    // 0x155a00: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x155a04: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x155a08: 0xe7a10034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    // 0x155a0c: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x155a10: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x155a14: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x155a18: 0xc60c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
label_155a1c:
    // 0x155a1c: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x155a20: 0x46016034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155a24: 0x0
    // NOP
    // 0x155a28: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
        goto label_155a48;
    }
    // 0x155a30: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x155a34: 0x460c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155a38: 0x0
    // NOP
    // 0x155a3c: 0x4502000d
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
        ctx->pc = 0x155A74; return;
    }
    // 0x155a44: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
label_155a48:
    // 0x155a48: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x155a50);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[13] = *(float*)&val; }
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155a50
// Address: 0x155a50 - 0x155ab0

void entry_155a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155a50) {
        switch (ctx->pc) {
            case 0x155a74: ctx->pc = 0; goto label_155a74;
            case 0x155a84: ctx->pc = 0; goto label_155a84;
            case 0x155a94: ctx->pc = 0; goto label_155a94;
            case 0x155a98: ctx->pc = 0; goto label_155a98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155a50: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x155a54: 0xc6020008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[2] = *(float*)&val; }
    // 0x155a58: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x155a5c: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x155a60: 0xe7a10038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    // 0x155a64: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
    // 0x155a68: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x155a6c: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x155a70: 0x8e221084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
label_155a74:
    // 0x155a74: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x155a78: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x155a7c: 0x1440ffba
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x155968; return;
    }
label_155a84:
    // 0x155a84: 0x8e311090
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4240)));
    // 0x155a88: 0x5620ffb1
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4224)));
        ctx->pc = 0x155950; return;
    }
    // 0x155a90: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_155a94:
    // 0x155a94: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_155a98:
    // 0x155a98: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x155a9c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x155aa0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x155aa4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x155aac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x155ab0; return;
}


// Function: UpdateEmitter__FP7EMITTERf
// Address: 0x155ab0 - 0x155ae4

void entry_155ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155ae4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x155ae8: 0xc0493f0
    SET_GPR_U32(ctx, 31, 0x155af0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateAlo__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_155af0
// Address: 0x155af0 - 0x155b08

void entry_155af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155af0: 0x8e230310
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 784)));
    // 0x155af4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x155af8: 0x14620103
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x155F08; return;
    }
    // 0x155b00: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x155b08);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 788));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_155b08
// Address: 0x155b08 - 0x155b3c

void entry_155b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155b08) {
        switch (ctx->pc) {
            case 0x155b28: ctx->pc = 0; goto label_155b28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155b08: 0x5440002a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x155BB4; return;
    }
    // 0x155b10: 0x8e300314
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 788)));
    // 0x155b14: 0x120000fb
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_155f04(rdram, ctx, runtime); return;
    }
    // 0x155b1c: 0x34138000
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 0), 32768));
    // 0x155b20: 0x139df8
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << 23);
    // 0x155b24: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
label_155b28:
    // 0x155b28: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x155b2c: 0x5440001d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 800)));
        ctx->pc = 0x155BA4; return;
    }
    // 0x155b34: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x155b3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_155b3c
// Address: 0x155b3c - 0x155c18

void entry_155b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155b3c) {
        switch (ctx->pc) {
            case 0x155b98: ctx->pc = 0; goto label_155b98;
            case 0x155ba4: ctx->pc = 0; goto label_155ba4;
            case 0x155bb4: ctx->pc = 0; goto label_155bb4;
            case 0x155c08: ctx->pc = 0; goto label_155c08;
            case 0x155c10: ctx->pc = 0; goto label_155c10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155b3c: 0x50400019
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 800)));
        goto label_155ba4;
    }
    // 0x155b44: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x155b48: 0x10400031
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_155c10;
    }
    // 0x155b50: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x155b54: 0xc6010080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 128)); ctx->f[1] = *(float*)&val; }
    // 0x155b58: 0xc44000b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 176)); ctx->f[0] = *(float*)&val; }
    // 0x155b5c: 0xd8430040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x155b60: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x155b64: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x155b68: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x155b6c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x155b70: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x155b74: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x155b78: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x155b7c: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x155b80: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x155b84: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x155b88: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155b8c: 0x0
    // NOP
    // 0x155b90: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_155b98;
    }
label_155b98:
    // 0x155b98: 0x1460001d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_155c10;
    }
    // 0x155ba0: 0x8e100320
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 800)));
label_155ba4:
    // 0x155ba4: 0x5600ffe0
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
        ctx->pc = 0x155B28; return;
    }
    // 0x155bac: 0x100000d6
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155F08; return;
    }
label_155bb4:
    // 0x155bb4: 0x10400016
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_155c10;
    }
    // 0x155bbc: 0xc6200080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 128)); ctx->f[0] = *(float*)&val; }
    // 0x155bc0: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x155bc4: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x155bc8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x155bcc: 0xc46100b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 176)); ctx->f[1] = *(float*)&val; }
    // 0x155bd0: 0xd8620040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x155bd4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x155bd8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x155bdc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x155be0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x155be4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x155be8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x155bec: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x155bf0: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x155bf4: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x155bf8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155bfc: 0x0
    // NOP
    // 0x155c00: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_155c08;
    }
label_155c08:
    // 0x155c08: 0x144000bf
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x155F08; return;
    }
label_155c10:
    // 0x155c10: 0xc0557ec
    SET_GPR_U32(ctx, 31, 0x155c18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FPausedEmitter__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_155c18
// Address: 0x155c18 - 0x155ccc

void entry_155c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155c18) {
        switch (ctx->pc) {
            case 0x155c4c: ctx->pc = 0; goto label_155c4c;
            case 0x155cb8: ctx->pc = 0; goto label_155cb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155c18: 0x144000bb
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x155F08; return;
    }
    // 0x155c20: 0x8e2302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 724)));
    // 0x155c24: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x155c28: 0x10620077
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x155E08; return;
    }
    // 0x155c30: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x155c34: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_155c4c;
    }
    // 0x155c3c: 0x5060005f
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 808)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x155DBC; return;
    }
    // 0x155c44: 0x10000088
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155E68; return;
    }
label_155c4c:
    // 0x155c4c: 0x10620036
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x155D28; return;
    }
    // 0x155c54: 0x14620084
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x155E68; return;
    }
    // 0x155c5c: 0xc6200328
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 808)); ctx->f[0] = *(float*)&val; }
    // 0x155c60: 0xc6220334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 820)); ctx->f[2] = *(float*)&val; }
    // 0x155c64: 0xc621033c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 828)); ctx->f[1] = *(float*)&val; }
    // 0x155c68: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x155c6c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x155c70: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x155c74: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x155c78: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x155c7c: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x155c80: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x155c84: 0x44900000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 16);
    // 0x155c88: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x155c8c: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x155c90: 0x46006834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155c94: 0x0
    // NOP
    // 0x155c98: 0x45000073
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 828), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x155E68; return;
    }
    // 0x155ca0: 0x8e2302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x155ca4: 0x4600004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_155cb8;
    }
    // 0x155cac: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x155cb0: 0x701823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x155cb4: 0xae2302d8
    WRITE32(ADD32(GPR_U32(ctx, 17), 728), GPR_U32(ctx, 3));
label_155cb8:
    // 0x155cb8: 0x8e220308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 776)));
    // 0x155cbc: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155CD4; return;
    }
    // 0x155cc4: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x155ccc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_155ccc
// Address: 0x155ccc - 0x155ce0

void entry_155ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155ccc) {
        switch (ctx->pc) {
            case 0x155cd4: ctx->pc = 0; goto label_155cd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155ccc: 0x1000000f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155D0C; return;
    }
label_155cd4:
    // 0x155cd4: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x155cd8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155ce0);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155ce0
// Address: 0x155ce0 - 0x155cfc

void entry_155ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155ce0: 0xc62102e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 744)); ctx->f[1] = *(float*)&val; }
    // 0x155ce4: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155ce8: 0x4500005f
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x155E68; return;
    }
    // 0x155cf0: 0xc62d02f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 752)); ctx->f[13] = *(float*)&val; }
    // 0x155cf4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155cfc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 748)); ctx->f[12] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155cfc
// Address: 0x155cfc - 0x155d08

void entry_155cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155cfc: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x155d00: 0xc0557de
    SET_GPR_U32(ctx, 31, 0x155d08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PauseEmitter__FP7EMITTERf(rdram, ctx, runtime); return;
}


// Function: entry_155d08
// Address: 0x155d08 - 0x155d14

void entry_155d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155d08) {
        switch (ctx->pc) {
            case 0x155d0c: ctx->pc = 0; goto label_155d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155d08: 0xc62c02dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
label_155d0c:
    // 0x155d0c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155d14);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 736)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155d14
// Address: 0x155d14 - 0x155d60

void entry_155d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155d14) {
        switch (ctx->pc) {
            case 0x155d28: ctx->pc = 0; goto label_155d28;
            case 0x155d4c: ctx->pc = 0; goto label_155d4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155d14: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x155d18: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x155d1c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x155d20: 0x10000051
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 808), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155E68; return;
    }
label_155d28:
    // 0x155d28: 0xc6200328
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 808)); ctx->f[0] = *(float*)&val; }
    // 0x155d2c: 0x8e2302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x155d30: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x155d34: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x155d38: 0x4600004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_155d4c;
    }
    // 0x155d40: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x155d44: 0x701823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x155d48: 0xae2302d8
    WRITE32(ADD32(GPR_U32(ctx, 17), 728), GPR_U32(ctx, 3));
label_155d4c:
    // 0x155d4c: 0x8e220308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 776)));
    // 0x155d50: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155D68; return;
    }
    // 0x155d58: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x155d60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_155d60
// Address: 0x155d60 - 0x155d7c

void entry_155d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155d60) {
        switch (ctx->pc) {
            case 0x155d68: ctx->pc = 0; goto label_155d68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155d60: 0x10000012
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155DAC; return;
    }
label_155d68:
    // 0x155d68: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x155d6c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x155d70: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x155d74: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155d7c);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155d7c
// Address: 0x155d7c - 0x155d9c

void entry_155d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155d7c: 0xc62102e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 744)); ctx->f[1] = *(float*)&val; }
    // 0x155d80: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155d84: 0x0
    // NOP
    // 0x155d88: 0x45020008
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x155DAC; return;
    }
    // 0x155d90: 0xc62c02ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 748)); ctx->f[12] = *(float*)&val; }
    // 0x155d94: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155d9c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 752)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155d9c
// Address: 0x155d9c - 0x155da8

void entry_155d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x155d9c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x155da0: 0xc0557de
    SET_GPR_U32(ctx, 31, 0x155da8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PauseEmitter__FP7EMITTERf(rdram, ctx, runtime); return;
}


// Function: entry_155da8
// Address: 0x155da8 - 0x155db4

void entry_155da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155da8) {
        switch (ctx->pc) {
            case 0x155dac: ctx->pc = 0; goto label_155dac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155da8: 0xc62c02dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
label_155dac:
    // 0x155dac: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155db4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 736)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155db4
// Address: 0x155db4 - 0x155e50

void entry_155db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155db4) {
        switch (ctx->pc) {
            case 0x155dbc: ctx->pc = 0; goto label_155dbc;
            case 0x155e08: ctx->pc = 0; goto label_155e08;
            case 0x155e40: ctx->pc = 0; goto label_155e40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155db4: 0x1000002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 808), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155E68; return;
    }
label_155dbc:
    // 0x155dbc: 0xc6220334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 820)); ctx->f[2] = *(float*)&val; }
    // 0x155dc0: 0xc621033c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 828)); ctx->f[1] = *(float*)&val; }
    // 0x155dc4: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x155dc8: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x155dcc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x155dd0: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x155dd4: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x155dd8: 0x44900000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 16);
    // 0x155ddc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x155de0: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x155de4: 0x12000036
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 828), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155EC0; return;
    }
    // 0x155dec: 0x8e2302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x155df0: 0x460001d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x155E68; return;
    }
    // 0x155df8: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x155dfc: 0x701823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x155e00: 0x10000019
    WRITE32(ADD32(GPR_U32(ctx, 17), 728), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155E68; return;
    }
label_155e08:
    // 0x155e08: 0xc6210334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 820)); ctx->f[1] = *(float*)&val; }
    // 0x155e0c: 0xc62002f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 756)); ctx->f[0] = *(float*)&val; }
    // 0x155e10: 0x8e2202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x155e14: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x155e18: 0x8c430120
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 288)));
    // 0x155e1c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x155e20: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x155e24: 0x54600006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 836)));
        goto label_155e40;
    }
    // 0x155e2c: 0x8e240348
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 840)));
    // 0x155e30: 0x10800009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155E58; return;
    }
    // 0x155e38: 0x10000007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1568)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155E58; return;
    }
label_155e40:
    // 0x155e40: 0x10800005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155E58; return;
    }
    // 0x155e48: 0xc0549f6
    SET_GPR_U32(ctx, 31, 0x155e50);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1368));
    CPvDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_155e50
// Address: 0x155e50 - 0x155e7c

void entry_155e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155e50) {
        switch (ctx->pc) {
            case 0x155e58: ctx->pc = 0; goto label_155e58;
            case 0x155e5c: ctx->pc = 0; goto label_155e5c;
            case 0x155e68: ctx->pc = 0; goto label_155e68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155e50: 0x10000002
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_155e5c;
    }
label_155e58:
    // 0x155e58: 0x2021823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_155e5c:
    // 0x155e5c: 0x3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 3)));
    // 0x155e60: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x155e64: 0x62800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
label_155e68:
    // 0x155e68: 0x12000015
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x155EC0; return;
    }
    // 0x155e70: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x155e74: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x155e7c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_155e7c
// Address: 0x155e7c - 0x155eb8

void entry_155e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155e7c) {
        switch (ctx->pc) {
            case 0x155ea8: ctx->pc = 0; goto label_155ea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155e7c: 0x8e2502d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x155e80: 0x26230344
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 836));
    // 0x155e84: 0x26220348
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 840));
    // 0x155e88: 0xafa30014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    // 0x155e8c: 0xafb10018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 17));
    // 0x155e90: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x155e94: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x155e98: 0x8e2202f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x155e9c: 0x14440002
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 5), 124)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_155ea8;
    }
    // 0x155ea4: 0xacb1007c
    WRITE32(ADD32(GPR_U32(ctx, 5), 124), GPR_U32(ctx, 17));
label_155ea8:
    // 0x155ea8: 0x8e2502d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x155eac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x155eb0: 0xc055f80
    SET_GPR_U32(ctx, 31, 0x155eb8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    EmitParticles__FiP5EMITBP5EMITG(rdram, ctx, runtime); return;
}


// Function: entry_155eb8
// Address: 0x155eb8 - 0x155ee8

void entry_155eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155eb8) {
        switch (ctx->pc) {
            case 0x155ec0: ctx->pc = 0; goto label_155ec0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155eb8: 0x8e2202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x155ebc: 0xac52007c
    WRITE32(ADD32(GPR_U32(ctx, 2), 124), GPR_U32(ctx, 18));
label_155ec0:
    // 0x155ec0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x155ec4: 0xc6210330
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 816)); ctx->f[1] = *(float*)&val; }
    // 0x155ec8: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x155ecc: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x155ed0: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x155ed4: 0x45000009
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x155EFC; return;
    }
    // 0x155edc: 0xc62c02dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 732)); ctx->f[12] = *(float*)&val; }
    // 0x155ee0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x155ee8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 736)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_155ee8
// Address: 0x155ee8 - 0x155f04

void entry_155ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155ee8) {
        switch (ctx->pc) {
            case 0x155efc: ctx->pc = 0; goto label_155efc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155ee8: 0xe6200328
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 808), *(uint32_t*)&val); }
    // 0x155eec: 0xc621032c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 812)); ctx->f[1] = *(float*)&val; }
    // 0x155ef0: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x155ef4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x155ef8: 0xe6200330
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 816), *(uint32_t*)&val); }
label_155efc:
    // 0x155efc: 0xc05561a
    SET_GPR_U32(ctx, 31, 0x155f04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ModifyEmitterParticles__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_155f04
// Address: 0x155f04 - 0x155f28

void entry_155f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155f04) {
        switch (ctx->pc) {
            case 0x155f08: ctx->pc = 0; goto label_155f08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155f04: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_155f08:
    // 0x155f08: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x155f0c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x155f10: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x155f14: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x155f18: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x155f1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x155f24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x155f28; return;
}


// Function: FUN_00155f28
// Address: 0x155f28 - 0x155f78

void FUN_00155f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x155f28) {
        switch (ctx->pc) {
            case 0x155f48: ctx->pc = 0; goto label_155f48;
            case 0x155f70: ctx->pc = 0; goto label_155f70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x155f28: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x155f2c: 0x3c060c00
    SET_GPR_U32(ctx, 6, ((uint32_t)3072 << 16));
    // 0x155f30: 0x3c050800
    SET_GPR_U32(ctx, 5, ((uint32_t)2048 << 16));
    // 0x155f34: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x155f38: 0x1045000d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_155f70;
    }
    // 0x155f40: 0x8c830018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x155f44: 0x0
    // NOP
label_155f48:
    // 0x155f48: 0x10600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_155f70;
    }
    // 0x155f50: 0xdc6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 712)));
    // 0x155f54: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x155f58: 0x5445fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 24)));
        goto label_155f48;
    }
    // 0x155f60: 0x10600003
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_155f70;
    }
    // 0x155f68: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x155f6c: 0xac820088
    WRITE32(ADD32(GPR_U32(ctx, 4), 136), GPR_U32(ctx, 2));
label_155f70:
    // 0x155f70: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PauseEmitter__FP7EMITTERf
// Address: 0x155f78 - 0x155f90

void entry_156014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156014) {
        switch (ctx->pc) {
            case 0x15601c: ctx->pc = 0; goto label_15601c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156014: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156028; return;
    }
label_15601c:
    // 0x15601c: 0xc0557e4
    SET_GPR_U32(ctx, 31, 0x156024);
    PauseEmitterIndefinite__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_156024
// Address: 0x156024 - 0x156030

void entry_156024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156024) {
        switch (ctx->pc) {
            case 0x156028: ctx->pc = 0; goto label_156028;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156024: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_156028:
    // 0x156028: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetEmitterEnabled__FP7EMITTERPi
// Address: 0x156030 - 0x156044

void entry_156044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156044: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x156048: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15604c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x156050: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156054: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15605c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x156060; return;
}


// Function: GetEmitterPaused__FP7EMITTERPi
// Address: 0x156060 - 0x156074

void entry_156074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156074: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x156078: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15607c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156080: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnEmitterValuesChanged__FP7EMITTER
// Address: 0x156088 - 0x1560b0

void entry_1560b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1560b0) {
        switch (ctx->pc) {
            case 0x1560b4: ctx->pc = 0; goto label_1560b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1560b0: 0x8e040344
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 836)));
label_1560b4:
    // 0x1560b4: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 724)));
        ctx->pc = 0x1560C8; return;
    }
    // 0x1560bc: 0xc067856
    SET_GPR_U32(ctx, 31, 0x1560c4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    SetRipgEmitb__FP4RIPGP5EMITB(rdram, ctx, runtime); return;
}


// Function: entry_1560c4
// Address: 0x1560c4 - 0x1560dc

void entry_1560c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1560c4) {
        switch (ctx->pc) {
            case 0x1560c8: ctx->pc = 0; goto label_1560c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1560c4: 0x8e0302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 724)));
label_1560c8:
    // 0x1560c8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1560cc: 0x14620007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 732)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1560EC; return;
    }
    // 0x1560d4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1560dc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 736)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1560dc
// Address: 0x1560dc - 0x1560f4

void entry_1560dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1560dc) {
        switch (ctx->pc) {
            case 0x1560ec: ctx->pc = 0; goto label_1560ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1560dc: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x1560e0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1560e4: 0x10000003
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1560f4(rdram, ctx, runtime); return;
    }
label_1560ec:
    // 0x1560ec: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1560f4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 736)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1560f4
// Address: 0x1560f4 - 0x156108

void entry_1560f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1560f4: 0xe6000328
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 808), *(uint32_t*)&val); }
    // 0x1560f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1560fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156100: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetEmitterParticleCount__FP7EMITTERi
// Address: 0x156108 - 0x156140

void entry_156140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156140) {
        switch (ctx->pc) {
            case 0x156148: ctx->pc = 0; goto label_156148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156140: 0x10000008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156164; return;
    }
label_156148:
    // 0x156148: 0x54a30005
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 3)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 5));
        ctx->pc = 0x156160; return;
    }
    // 0x156150: 0xc0557e8
    SET_GPR_U32(ctx, 31, 0x156158);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UnpauseEmitter__FP7EMITTER(rdram, ctx, runtime); return;
}


// Function: entry_156158
// Address: 0x156158 - 0x156178

void entry_156158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156158) {
        switch (ctx->pc) {
            case 0x156160: ctx->pc = 0; goto label_156160;
            case 0x156164: ctx->pc = 0; goto label_156164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156158: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156164;
    }
label_156160:
    // 0x156160: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_156164:
    // 0x156164: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x156168: 0xae02034c
    WRITE32(ADD32(GPR_U32(ctx, 16), 844), GPR_U32(ctx, 2));
    // 0x15616c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156170: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetEmitterAutoPause__FP7EMITTERi
// Address: 0x156178 - 0x156188

void entry_1561b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1561b4) {
        switch (ctx->pc) {
            case 0x1561e0: ctx->pc = 0; goto label_1561e0;
            case 0x156204: ctx->pc = 0; goto label_156204;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1561b4: 0x24030018
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1561b8: 0x12230009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 27));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 3)) {
        goto label_1561e0;
    }
    // 0x1561c0: 0x16220010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_156204;
    }
    // 0x1561c8: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1561cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1561d0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1561d4: 0xae0201f0
    WRITE32(ADD32(GPR_U32(ctx, 16), 496), GPR_U32(ctx, 2));
    // 0x1561d8: 0x1000000a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 500), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156204;
    }
label_1561e0:
    // 0x1561e0: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1561e4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1561e8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1561ec: 0x3c0141c8
    SET_GPR_U32(ctx, 1, ((uint32_t)16840 << 16));
    // 0x1561f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1561f4: 0xe60101f8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 504), *(uint32_t*)&val); }
    // 0x1561f8: 0xe60001f0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 496), *(uint32_t*)&val); }
    // 0x1561fc: 0xe60101f4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 500), *(uint32_t*)&val); }
    // 0x156200: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_156204:
    // 0x156204: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x156208: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15620c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x156214: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x156218; return;
}


// Function: SetEmitterRipt__FP7EMITTER4RIPT
// Address: 0x156218 - 0x156230

void entry_156230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156230: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x156234: 0xc055862
    SET_GPR_U32(ctx, 31, 0x15623c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetEmitbRipt__FP5EMITB4RIPT(rdram, ctx, runtime); return;
}


// Function: entry_15623c
// Address: 0x15623c - 0x156250

void entry_15623c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15623c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x156240: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156244: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15624c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x156250; return;
}


// Function: SetExploRipt__FP5EXPLO4RIPT
// Address: 0x156250 - 0x156268

void entry_156268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156268: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15626c: 0xc055862
    SET_GPR_U32(ctx, 31, 0x156274);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetEmitbRipt__FP5EMITB4RIPT(rdram, ctx, runtime); return;
}


// Function: entry_156274
// Address: 0x156274 - 0x156288

void entry_156274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156274: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x156278: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15627c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x156284: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x156288; return;
}


// Function: WakeSoWater__FP2SOP5WATERfP6VECTORT3ff
// Address: 0x156288 - 0x15632c

void entry_15632c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15632c) {
        switch (ctx->pc) {
            case 0x15633c: ctx->pc = 0; goto label_15633c;
            case 0x156368: ctx->pc = 0; goto label_156368;
            case 0x1563a8: ctx->pc = 0; goto label_1563a8;
            case 0x1563ec: ctx->pc = 0; goto label_1563ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15632c: 0x46170034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156330: 0x0
    // NOP
    // 0x156334: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_15633c;
    }
label_15633c:
    // 0x15633c: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x156340: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156344: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x156348: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15634c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x156350: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156354: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x156358: 0x45010003
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 20));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_156368;
    }
    // 0x156360: 0x124000c4
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156674; return;
    }
label_156368:
    // 0x156368: 0x4600b041
    ctx->f[1] = FPU_SUB_S(ctx->f[22], ctx->f[0]);
    // 0x15636c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x156370: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x156374: 0x3c013aa5
    SET_GPR_U32(ctx, 1, ((uint32_t)15013 << 16));
    // 0x156378: 0x3421e9f7
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 59895));
    // 0x15637c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x156380: 0x46000b02
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x156384: 0x46146034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156388: 0x0
    // NOP
    // 0x15638c: 0x45010006
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1563a8;
    }
    // 0x156394: 0x460c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156398: 0x0
    // NOP
    // 0x15639c: 0x45000002
    ctx->f[21] = FPU_MOV_S(ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1563a8;
    }
    // 0x1563a4: 0x46001546
    ctx->f[21] = FPU_MOV_S(ctx->f[2]);
label_1563a8:
    // 0x1563a8: 0x12200025
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_156440(rdram, ctx, runtime); return;
    }
    // 0x1563b0: 0x8e620584
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1412)));
    // 0x1563b4: 0x10400022
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_156440(rdram, ctx, runtime); return;
    }
    // 0x1563bc: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x1563c0: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1563c4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1563c8: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1563cc: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1563d0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1563d4: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1563d8: 0x8e220574
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1396)));
    // 0x1563dc: 0x10400003
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1563ec;
    }
    // 0x1563e4: 0x10000016
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_156440(rdram, ctx, runtime); return;
    }
label_1563ec:
    // 0x1563ec: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1563f0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1563f4: 0x26102050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8272));
    // 0x1563f8: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x156400);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_156400
// Address: 0x156400 - 0x156440

void entry_156400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156400: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x156404: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x156408: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x15640c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x156410: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x156414: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156418: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x15641c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x156420: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x156424: 0x26250574
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1396));
    // 0x156428: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15642c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156430: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x156434: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156438: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x156440);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_156440
// Address: 0x156440 - 0x1564c4

void entry_156440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156440) {
        switch (ctx->pc) {
            case 0x156488: ctx->pc = 0; goto label_156488;
            case 0x1564b4: ctx->pc = 0; goto label_1564b4;
            case 0x1564bc: ctx->pc = 0; goto label_1564bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156440: 0x1640001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1564bc;
    }
    // 0x156448: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15644c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x156450: 0x46180801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[24]);
    // 0x156454: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x156458: 0x1220000b
    ctx->f[12] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_156488;
    }
    // 0x156460: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x156464: 0xc6210570
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1392)); ctx->f[1] = *(float*)&val; }
    // 0x156468: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x15646c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x156470: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156474: 0x0
    // NOP
    // 0x156478: 0x4501000e
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1564b4;
    }
    // 0x156480: 0x1000000c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1564b4;
    }
label_156488:
    // 0x156488: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15648c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x156490: 0x46170040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x156494: 0x460c0003
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[12];
    // 0x156498: 0x460c0843
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[12];
    // 0x15649c: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1564a0: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1564a4: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1564a8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1564ac: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1564b0: 0x2902b
    SET_GPR_U32(ctx, 18, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1564b4:
    // 0x1564b4: 0x12400074
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_156688(rdram, ctx, runtime); return;
    }
label_1564bc:
    // 0x1564bc: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x1564c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_1564c4
// Address: 0x1564c4 - 0x1564e4

void entry_1564c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1564c4: 0x10400070
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_156688(rdram, ctx, runtime); return;
    }
    // 0x1564cc: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1564d0: 0x4600cb06
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    // 0x1564d4: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1564d8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1564dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1564e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1564e4
// Address: 0x1564e4 - 0x15652c

void entry_1564e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1564e4) {
        switch (ctx->pc) {
            case 0x1564f4: ctx->pc = 0; goto label_1564f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1564e4: 0x12200003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1564f4;
    }
    // 0x1564ec: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1564f0: 0xe6200570
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1392), *(uint32_t*)&val); }
label_1564f4:
    // 0x1564f4: 0x8e620588
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1416)));
    // 0x1564f8: 0x10400064
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15668C; return;
    }
    // 0x156500: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x156504: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x156508: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15650c: 0x0
    // NOP
    // 0x156510: 0x4500005e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x15668C; return;
    }
    // 0x156518: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15651c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x156520: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x156524: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x15652c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_15652c
// Address: 0x15652c - 0x156574

void entry_15652c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15652c: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x156530: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x156534: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x156538: 0x3c014140
    SET_GPR_U32(ctx, 1, ((uint32_t)16704 << 16));
    // 0x15653c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x156540: 0x27b000c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 192));
    // 0x156544: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x156548: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x15654c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x156550: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156554: 0xe7a10020
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x156558: 0x24060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    // 0x15655c: 0xe7a00024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x156560: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x156564: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x156568: 0xe7b40010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x15656c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x156574);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 19));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_156574
// Address: 0x156574 - 0x15664c

void entry_156574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156574) {
        switch (ctx->pc) {
            case 0x156604: ctx->pc = 0; goto label_156604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156574: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x156578: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15657c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x156580: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x156584: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x156588: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15658c: 0x4600b002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x156590: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x156594: 0x4601b042
    ctx->f[1] = FPU_MUL_S(ctx->f[22], ctx->f[1]);
    // 0x156598: 0xe7b400c8
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 200), *(uint32_t*)&val); }
    // 0x15659c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1565a0: 0x3c013ec9
    SET_GPR_U32(ctx, 1, ((uint32_t)16073 << 16));
    // 0x1565a4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1565a8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1565ac: 0xe7a000c0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 192), *(uint32_t*)&val); }
    // 0x1565b0: 0x27a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 320));
    // 0x1565b4: 0xe7a100c4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    // 0x1565b8: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1565bc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1565c0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1565c4: 0x78821ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 7904)));
    // 0x1565c8: 0xe7a00114
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 276), *(uint32_t*)&val); }
    // 0x1565cc: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1565d0: 0x3c013f86
    SET_GPR_U32(ctx, 1, ((uint32_t)16262 << 16));
    // 0x1565d4: 0x34210a92
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2706));
    // 0x1565d8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1565dc: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1565e0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1565e4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1565e8: 0x7fa300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 3));
    // 0x1565ec: 0x7fa200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 2));
    // 0x1565f0: 0xe7a20104
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 260), *(uint32_t*)&val); }
    // 0x1565f4: 0xe7a10108
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 264), *(uint32_t*)&val); }
    // 0x1565f8: 0xe7b40110
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 272), *(uint32_t*)&val); }
    // 0x1565fc: 0xe7b40130
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 304), *(uint32_t*)&val); }
    // 0x156600: 0xe7a00138
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 312), *(uint32_t*)&val); }
label_156604:
    // 0x156604: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x156608: 0x7a030010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x15660c: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x156610: 0x7c830010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 3));
    // 0x156614: 0x26100020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    // 0x156618: 0x1605fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 5)) {
        goto label_156604;
    }
    // 0x156620: 0x7aa20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x156624: 0x24d08d20
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x156628: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x15662c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x156630: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x156634: 0x7fa200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    // 0x156638: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15663c: 0xc7a000c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[0] = *(float*)&val; }
    // 0x156640: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x156644: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x15664c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 200), *(uint32_t*)&val); }
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_15664c
// Address: 0x15664c - 0x15666c

void entry_15664c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15664c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x156650: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x156654: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x156658: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15665c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x156660: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156664: 0xc055fbe
    SET_GPR_U32(ctx, 31, 0x15666c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EmitRipsSphere__FP6VECTORT0iP7EMITRIPP5EMITVPP4RIPGP2LO(rdram, ctx, runtime); return;
}


// Function: entry_15666c
// Address: 0x15666c - 0x156688

void entry_15666c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15666c) {
        switch (ctx->pc) {
            case 0x156674: ctx->pc = 0; goto label_156674;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15666c: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15668C; return;
    }
label_156674:
    // 0x156674: 0x12200005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15668C; return;
    }
    // 0x15667c: 0x8e240574
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1396)));
    // 0x156680: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x156688);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_156688
// Address: 0x156688 - 0x1566c8

void entry_156688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156688) {
        switch (ctx->pc) {
            case 0x15668c: ctx->pc = 0; goto label_15668c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156688: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
label_15668c:
    // 0x15668c: 0x7bb50190
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x156690: 0x7bb40180
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x156694: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x156698: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x15669c: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1566a0: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1566a4: 0xc7b901d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[25] = *(float*)&val; }
    // 0x1566a8: 0xc7b801d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[24] = *(float*)&val; }
    // 0x1566ac: 0xc7b701c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 456)); ctx->f[23] = *(float*)&val; }
    // 0x1566b0: 0xc7b601c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 448)); ctx->f[22] = *(float*)&val; }
    // 0x1566b4: 0xc7b501b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 440)); ctx->f[21] = *(float*)&val; }
    // 0x1566b8: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x1566bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 480));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1566c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1566c8; return;
}


// Function: StandardSmokeCloud__FP6VECTORf
// Address: 0x1566c8 - 0x15670c

void entry_15670c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15670c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x156710: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChooseEmitoPos__FP5EMITOiiP6VECTORT3
// Address: 0x156718 - 0x1567a4

void entry_1567a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1567a4: 0xe6a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 0), *(uint32_t*)&val); }
    // 0x1567a8: 0xc62c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1567ac: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1567b4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 36)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1567b4
// Address: 0x1567b4 - 0x1567c4

void entry_1567b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1567b4: 0xe6a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 4), *(uint32_t*)&val); }
    // 0x1567b8: 0xc62c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[12] = *(float*)&val; }
    // 0x1567bc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1567c4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 40)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1567c4
// Address: 0x1567c4 - 0x156804

void entry_1567c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1567c4: 0x10000158
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156D28; return;
    }
    // 0x1567cc: 0x8e300010
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1567d0: 0x44860000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 6);
    // 0x1567d4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1567d8: 0x44856000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 5);
    // 0x1567dc: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x1567e0: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1567e4: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1567e8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1567ec: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1567f0: 0xc44dfffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[13] = *(float*)&val; }
    // 0x1567f4: 0x46006b43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[0];
    // 0x1567f8: 0x460d6302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[13]);
    // 0x1567fc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x156804);
    ctx->f[13] = FPU_ADD_S(ctx->f[12], ctx->f[13]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_156804
// Address: 0x156804 - 0x15683c

void entry_156804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156804: 0x8e230040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x156808: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15680c: 0x1062000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x156844; return;
    }
    // 0x156814: 0x10620017
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x156874; return;
    }
    // 0x15681c: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x156820: 0x10400142
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156D2C; return;
    }
    // 0x156828: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15682c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x156830: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x156834: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15683c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15683c
// Address: 0x15683c - 0x15686c

void entry_15683c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15683c) {
        switch (ctx->pc) {
            case 0x156844: ctx->pc = 0; goto label_156844;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15683c: 0x1000013b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156D2C; return;
    }
label_156844:
    // 0x156844: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x156848: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x15684c: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x156850: 0x10400177
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156E30; return;
    }
    // 0x156858: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15685c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x156860: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x156864: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15686c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15686c
// Address: 0x15686c - 0x156890

void entry_15686c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15686c) {
        switch (ctx->pc) {
            case 0x156874: ctx->pc = 0; goto label_156874;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15686c: 0x10000171
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156E34; return;
    }
label_156874:
    // 0x156874: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x156878: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_156890(rdram, ctx, runtime); return;
    }
    // 0x156880: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x156884: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x156888: 0x40f809
    SET_GPR_U32(ctx, 31, 0x156890);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_156890
// Address: 0x156890 - 0x1568ec

void entry_156890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156890: 0xda220050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x156894: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x156898: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15689c: 0x26330060
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    // 0x1568a0: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1568a4: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1568a8: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1568ac: 0x10000160
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156E30; return;
    }
    // 0x1568b4: 0x44860800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 6);
    // 0x1568b8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1568bc: 0xc6200018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1568c0: 0x24a20001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1568c4: 0x44856000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 5);
    // 0x1568c8: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x1568cc: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1568d0: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1568d4: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x1568d8: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1568dc: 0x26330060
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    // 0x1568e0: 0x46006b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    // 0x1568e4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1568ec);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1568ec
// Address: 0x1568ec - 0x1569e4

void entry_1568ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1568ec) {
        switch (ctx->pc) {
            case 0x156938: ctx->pc = 0; goto label_156938;
            case 0x156964: ctx->pc = 0; goto label_156964;
            case 0x156968: ctx->pc = 0; goto label_156968;
            case 0x1569c4: ctx->pc = 0; goto label_1569c4;
            case 0x1569d0: ctx->pc = 0; goto label_1569d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1568ec: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1568f0: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1568f4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1568f8: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1568fc: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x156900: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x156904: 0x18400017
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_156964;
    }
    // 0x15690c: 0x8e300014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x156910: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x156914: 0xc6000024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 36)); ctx->f[0] = *(float*)&val; }
    // 0x156918: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x15691c: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156920: 0x0
    // NOP
    // 0x156924: 0x45030010
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        goto label_156968;
    }
    // 0x15692c: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x156930: 0x26040024
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 36));
    // 0x156934: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_156938:
    // 0x156938: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x15693c: 0x24840028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 40));
    // 0x156940: 0xc8102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 8)));
    // 0x156944: 0x10400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 40));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_156964;
    }
    // 0x15694c: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x156950: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x156954: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156958: 0x0
    // NOP
    // 0x15695c: 0x4500fff6
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_156938;
    }
label_156964:
    // 0x156964: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
label_156968:
    // 0x156968: 0x26e48d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 4294937856));
    // 0x15696c: 0x8e03001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x156970: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x156974: 0xd8620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x156978: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15697c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x156980: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x156984: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x156988: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x15698c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x156990: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156994: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156998: 0x78840000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15699c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1569a0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1569a4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1569a8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1569ac: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1569b0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1569b4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1569c4;
    }
    // 0x1569bc: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1569d0;
    }
label_1569c4:
    // 0x1569c4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1569c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1569cc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1569d0:
    // 0x1569d0: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1569d4: 0x24e78d20
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937888));
    // 0x1569d8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1569dc: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x1569e4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 23), 4294937856));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_1569e4
// Address: 0x1569e4 - 0x156a24

void entry_1569e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1569e4: 0xc60c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[12] = *(float*)&val; }
    // 0x1569e8: 0xc60d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[13] = *(float*)&val; }
    // 0x1569ec: 0xc6000024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 36)); ctx->f[0] = *(float*)&val; }
    // 0x1569f0: 0x460d6032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1569f4: 0x0
    // NOP
    // 0x1569f8: 0x4501000c
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x156A2C; return;
    }
    // 0x156a00: 0x460d6301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[13]);
    // 0x156a04: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x156a08: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x156a0c: 0xc6010020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[1] = *(float*)&val; }
    // 0x156a10: 0x4600a387
    ctx->f[14] = FPU_NEG_S(ctx->f[20]);
    // 0x156a14: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x156a18: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x156a1c: 0xc07ab28
    SET_GPR_U32(ctx, 31, 0x156a24);
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    CSolveQuadratic__FfffPf(rdram, ctx, runtime); return;
}


// Function: entry_156a24
// Address: 0x156a24 - 0x156a5c

void entry_156a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156a24) {
        switch (ctx->pc) {
            case 0x156a2c: ctx->pc = 0; goto label_156a2c;
            case 0x156a38: ctx->pc = 0; goto label_156a38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156a24: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156a38;
    }
label_156a2c:
    // 0x156a2c: 0x460da003
    if (ctx->f[13] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[0] = ctx->f[20] / ctx->f[13];
    // 0x156a30: 0xe7a00060
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x156a34: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
label_156a38:
    // 0x156a38: 0xc6000020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[0] = *(float*)&val; }
    // 0x156a3c: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x156a40: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x156a44: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x156a48: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x156a4c: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x156a50: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x156a54: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x156a5c);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[0];
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_156a5c
// Address: 0x156a5c - 0x156a8c

void entry_156a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156a5c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x156a60: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x156a64: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x156a68: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x156a6c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x156a70: 0xc6000014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[0] = *(float*)&val; }
    // 0x156a74: 0x46146b41
    ctx->f[13] = FPU_SUB_S(ctx->f[13], ctx->f[20]);
    // 0x156a78: 0xc7ae0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[14] = *(float*)&val; }
    // 0x156a7c: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x156a80: 0x46016b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[1]);
    // 0x156a84: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x156a8c);
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[20]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_156a8c
// Address: 0x156a8c - 0x156acc

void entry_156a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156a8c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x156a90: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x156a94: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156a98: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156a9c: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x156aa0: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x156aa4: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x156aa8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x156aac: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x156ab0: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x156ab4: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x156ab8: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156abc: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156ac0: 0x8e25006c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 108)));
    // 0x156ac4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x156acc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_156acc
// Address: 0x156acc - 0x156b80

void entry_156acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156acc) {
        switch (ctx->pc) {
            case 0x156aec: ctx->pc = 0; goto label_156aec;
            case 0x156afc: ctx->pc = 0; goto label_156afc;
            case 0x156b5c: ctx->pc = 0; goto label_156b5c;
            case 0x156b68: ctx->pc = 0; goto label_156b68;
            case 0x156b78: ctx->pc = 0; goto label_156b78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156acc: 0x8e230040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x156ad0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x156ad4: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_156aec;
    }
    // 0x156adc: 0x10620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_156afc;
    }
    // 0x156ae4: 0x10000092
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156D30; return;
    }
label_156aec:
    // 0x156aec: 0x8e25006c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 108)));
    // 0x156af0: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x156af4: 0x10000020
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156b78;
    }
label_156afc:
    // 0x156afc: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x156b00: 0x26e28d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 4294937856));
    // 0x156b04: 0xda210050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x156b08: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x156b0c: 0x4bc208ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156b10: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x156b14: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x156b18: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x156b1c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x156b20: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x156b24: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x156b28: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156b2c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156b30: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156b34: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156b38: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x156b3c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x156b40: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x156b44: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x156b48: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156b4c: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_156b5c;
    }
    // 0x156b54: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156b68;
    }
label_156b5c:
    // 0x156b5c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x156b60: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x156b64: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_156b68:
    // 0x156b68: 0x8e25006c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 108)));
    // 0x156b6c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156b70: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x156b74: 0x27a60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
label_156b78:
    // 0x156b78: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x156b80);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_156b80
// Address: 0x156b80 - 0x156ba8

void entry_156b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156b80: 0x100000ac
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x156E34; return;
    }
    // 0x156b88: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x156b8c: 0x26300010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 16));
    // 0x156b90: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x156b94: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x156b98: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x156b9c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x156ba0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x156ba8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_156ba8
// Address: 0x156ba8 - 0x156c6c

void entry_156ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156ba8) {
        switch (ctx->pc) {
            case 0x156be8: ctx->pc = 0; goto label_156be8;
            case 0x156c14: ctx->pc = 0; goto label_156c14;
            case 0x156c18: ctx->pc = 0; goto label_156c18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156ba8: 0xc6010014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[1] = *(float*)&val; }
    // 0x156bac: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156bb0: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x156bb4: 0x18400017
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_156c14;
    }
    // 0x156bbc: 0x8e12000c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x156bc0: 0xc640000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[0] = *(float*)&val; }
    // 0x156bc4: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x156bc8: 0x46140836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156bcc: 0x0
    // NOP
    // 0x156bd0: 0x45030011
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_156c18;
    }
    // 0x156bd8: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x156bdc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x156be0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x156be4: 0x2643000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 12));
label_156be8:
    // 0x156be8: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x156bec: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    // 0x156bf0: 0x10400008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_156c14;
    }
    // 0x156bf8: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x156bfc: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x156c00: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x156c04: 0x460c0836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156c08: 0x0
    // NOP
    // 0x156c0c: 0x4500fff6
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_156be8;
    }
label_156c14:
    // 0x156c14: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_156c18:
    // 0x156c18: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x156c1c: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x156c20: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x156c24: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x156c28: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x156c2c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x156c30: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156c34: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x156c38: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x156c3c: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x156c40: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x156c44: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x156c48: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x156c4c: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156c50: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x156c54: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x156c58: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x156c5c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x156c60: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156c64: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x156c6c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_156c6c
// Address: 0x156c6c - 0x156c80

void entry_156c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156c6c: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x156c70: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x156c74: 0x4615a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[21]);
    // 0x156c78: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x156c80);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_156c80
// Address: 0x156c80 - 0x156eac

void entry_156c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156c80) {
        switch (ctx->pc) {
            case 0x156d28: ctx->pc = 0; goto label_156d28;
            case 0x156d2c: ctx->pc = 0; goto label_156d2c;
            case 0x156d30: ctx->pc = 0; goto label_156d30;
            case 0x156d50: ctx->pc = 0; goto label_156d50;
            case 0x156d60: ctx->pc = 0; goto label_156d60;
            case 0x156d6c: ctx->pc = 0; goto label_156d6c;
            case 0x156d84: ctx->pc = 0; goto label_156d84;
            case 0x156df8: ctx->pc = 0; goto label_156df8;
            case 0x156e28: ctx->pc = 0; goto label_156e28;
            case 0x156e2c: ctx->pc = 0; goto label_156e2c;
            case 0x156e30: ctx->pc = 0; goto label_156e30;
            case 0x156e34: ctx->pc = 0; goto label_156e34;
            case 0x156e80: ctx->pc = 0; goto label_156e80;
            case 0x156e90: ctx->pc = 0; goto label_156e90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156c80: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x156c84: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156c88: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x156c8c: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x156c90: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x156c94: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x156c98: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x156c9c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x156ca0: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x156ca4: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x156ca8: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x156cac: 0xfba60030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x156cb0: 0x4be611bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x156cb4: 0x4be518bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x156cb8: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156cbc: 0xfaa20000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x156cc0: 0xfba50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x156cc4: 0x8e220040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x156cc8: 0x14430017
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_156d28;
    }
    // 0x156cd0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x156cd4: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x156cd8: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x156cdc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x156ce0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156ce4: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x156ce8: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x156cec: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x156cf0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x156cf4: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156cf8: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x156cfc: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x156d00: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x156d04: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x156d08: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156d0c: 0x4be609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x156d10: 0x4be518bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x156d14: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156d18: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x156d1c: 0xfa810000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x156d20: 0x10000043
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e30;
    }
label_156d28:
    // 0x156d28: 0x8e230040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 64)));
label_156d2c:
    // 0x156d2c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_156d30:
    // 0x156d30: 0x1062000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_156d6c;
    }
    // 0x156d38: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_156d50;
    }
    // 0x156d40: 0x10600007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 23), 4294937856));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_156d60;
    }
    // 0x156d48: 0x10000037
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e28;
    }
label_156d50:
    // 0x156d50: 0x1062000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 23), 4294937856));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_156d84;
    }
    // 0x156d58: 0x10000033
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e28;
    }
label_156d60:
    // 0x156d60: 0x7a220050
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x156d64: 0x10000031
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e2c;
    }
label_156d6c:
    // 0x156d6c: 0xdaa10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x156d70: 0x26330060
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    // 0x156d74: 0xda220050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x156d78: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156d7c: 0x1000002c
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e30;
    }
label_156d84:
    // 0x156d84: 0x8e25006c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 108)));
    // 0x156d88: 0x10a0001b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_156df8;
    }
    // 0x156d90: 0xda230050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x156d94: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x156d98: 0x24a40110
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 272));
    // 0x156d9c: 0xd8a50110
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 272)));
    // 0x156da0: 0x26330060
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    // 0x156da4: 0x24620080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 128));
    // 0x156da8: 0xd8660080
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x156dac: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x156db0: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x156db4: 0x4bc331bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x156db8: 0x4bc308bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x156dbc: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156dc0: 0xd8820020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x156dc4: 0xd8810010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x156dc8: 0x4be32a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x156dcc: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x156dd0: 0x4be309ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156dd4: 0x4be311aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x156dd8: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x156ddc: 0x4b08490a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156de0: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x156de4: 0x4a87490a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156de8: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x156dec: 0x4a464909
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156df0: 0x1000000f
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e30;
    }
label_156df8:
    // 0x156df8: 0xda220050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x156dfc: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x156e00: 0x26330060
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    // 0x156e04: 0x24620080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 128));
    // 0x156e08: 0xd8640080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x156e0c: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x156e10: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x156e14: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x156e18: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x156e1c: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156e20: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e30;
    }
label_156e28:
    // 0x156e28: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
label_156e2c:
    // 0x156e2c: 0x7e820000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), GPR_VEC(ctx, 2));
label_156e30:
    // 0x156e30: 0xda830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
label_156e34:
    // 0x156e34: 0x26e28d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 4294937856));
    // 0x156e38: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x156e3c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x156e40: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156e44: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x156e48: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x156e4c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x156e50: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x156e54: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156e58: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x156e5c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x156e60: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x156e64: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x156e68: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x156e6c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x156e70: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_156e80;
    }
    // 0x156e78: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_156e90;
    }
label_156e80:
    // 0x156e80: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x156e84: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x156e88: 0x4be0189c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x156e8c: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
label_156e90:
    // 0x156e90: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x156e94: 0x7e820000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), GPR_VEC(ctx, 2));
    // 0x156e98: 0x7aa30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x156e9c: 0xc62c0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 96)); ctx->f[12] = *(float*)&val; }
    // 0x156ea0: 0xc66d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[13] = *(float*)&val; }
    // 0x156ea4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x156eac);
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 3));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_156eac
// Address: 0x156eac - 0x156f08

void entry_156eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156eac: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x156eb0: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x156eb4: 0xdba30080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x156eb8: 0x4be11898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x156ebc: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x156ec0: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x156ec4: 0x4be21868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x156ec8: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x156ecc: 0xfaa10000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x156ed0: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x156ed4: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x156ed8: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x156edc: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x156ee0: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x156ee4: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x156ee8: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x156eec: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x156ef0: 0xc7b60140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[22] = *(float*)&val; }
    // 0x156ef4: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x156ef8: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x156efc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x156f04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x156f08; return;
}


// Function: ConvertEmitoPosVec__FP5EMITOP6VECTORT1
// Address: 0x156f08 - 0x156f40

void entry_156f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x156f40: 0x8e030070
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 112)));
    // 0x156f44: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x156f48: 0x10620019
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x156FB0; return;
    }
    // 0x156f50: 0x8e04006c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 108)));
    // 0x156f54: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x156f58: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x156f60);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_156f60
// Address: 0x156f60 - 0x156fa0

void entry_156f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156f60) {
        switch (ctx->pc) {
            case 0x156f80: ctx->pc = 0; goto label_156f80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156f60: 0x8e030070
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 112)));
    // 0x156f64: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x156f68: 0x10620011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x156FB0; return;
    }
    // 0x156f70: 0x10620003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_156f80;
    }
    // 0x156f78: 0x8e02006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 108)));
    // 0x156f7c: 0x24450140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 320));
label_156f80:
    // 0x156f80: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x156f84: 0x8e04006c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 108)));
    // 0x156f88: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156f8c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x156f90: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156f94: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x156f98: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x156fa0);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_156fa0
// Address: 0x156fa0 - 0x156fc8

void entry_156fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x156fa0) {
        switch (ctx->pc) {
            case 0x156fb0: ctx->pc = 0; goto label_156fb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x156fa0: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x156fa4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x156fa8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x156fac: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_156fb0:
    // 0x156fb0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x156fb4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x156fb8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x156fbc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x156fc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateEmitvx__FiP2LMiP6EMITVX
// Address: 0x156fc8 - 0x157028

void entry_157028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157028: 0xc6220000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[2] = *(float*)&val; }
    // 0x15702c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x157030: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x157034: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x157038: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x15703c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x157040: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x157044: 0x46000b46
    ctx->f[13] = FPU_MOV_S(ctx->f[1]);
    // 0x157048: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x15704c: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x157050: 0x44901000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 16);
    // 0x157054: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x157058: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x15705c: 0xe6210008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x157060: 0xe6200004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    // 0x157064: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x157068: 0xc6410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[1] = *(float*)&val; }
    // 0x15706c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x157070: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x157078);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_157078
// Address: 0x157078 - 0x157098

void entry_157078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157078: 0xe6200010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x15707c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x157080: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x157084: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x157088: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15708c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x157094: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x157098; return;
}


// Function: ChooseEmitVelocity__FP6EMITVXffP2LMP6VECTORiT4
// Address: 0x157098 - 0x157150

void entry_157150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157150: 0x4600c002
    ctx->f[0] = FPU_MUL_S(ctx->f[24], ctx->f[0]);
    // 0x157154: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x157158: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x15715c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x157160: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x157164: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15716c);
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15716c
// Address: 0x15716c - 0x157190

void entry_15716c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15716c) {
        switch (ctx->pc) {
            case 0x15717c: ctx->pc = 0; goto label_15717c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15716c: 0x4600c002
    ctx->f[0] = FPU_MUL_S(ctx->f[24], ctx->f[0]);
    // 0x157170: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x157174: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x157178: 0x4600b580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[0]);
label_15717c:
    // 0x15717c: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x157180: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x157184: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x157188: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x157190);
    ctx->f[12] = FPU_ADD_S(ctx->f[23], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_157190
// Address: 0x157190 - 0x15719c

void entry_157190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157190: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x157194: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x15719c);
    ctx->f[23] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_15719c
// Address: 0x15719c - 0x1571ac

void entry_15719c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15719c: 0xc62d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1571a0: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x1571a4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1571ac);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[12] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1571ac
// Address: 0x1571ac - 0x1571c0

void entry_1571ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1571ac: 0x46000386
    ctx->f[14] = FPU_MOV_S(ctx->f[0]);
    // 0x1571b0: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1571b4: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x1571b8: 0xc07b5ac
    SET_GPR_U32(ctx, 31, 0x1571c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVectorSphere__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1571c0
// Address: 0x1571c0 - 0x1571f0

void entry_1571c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1571c0: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1571c4: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1571c8: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1571cc: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1571d0: 0x46190002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[25]);
    // 0x1571d4: 0x24c68d00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937856));
    // 0x1571d8: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1571dc: 0x24e78d20
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937888));
    // 0x1571e0: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1571e4: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1571e8: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x1571f0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_1571f0
// Address: 0x1571f0 - 0x157248

void entry_1571f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1571f0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1571f4: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1571f8: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1571fc: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x157200: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x157204: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x157208: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15720c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x157210: 0xfa620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x157214: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x157218: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15721c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x157220: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x157224: 0xc7b900b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[25] = *(float*)&val; }
    // 0x157228: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x15722c: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x157230: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x157234: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x157238: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x15723c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x157244: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x157248; return;
}


// Function: ChooseEmitvVelocityAge__FP5EMITVP6EMITVXP5EMITOiP6VECTORN24PfT7
// Address: 0x157248 - 0x157294

void entry_157294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157294: 0xc60c0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 96)); ctx->f[12] = *(float*)&val; }
    // 0x157298: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1572a0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 100)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1572a0
// Address: 0x1572a0 - 0x1572c8

void entry_1572a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1572a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1572a4: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1572a8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1572ac: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1572b0: 0xc6000054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 84)); ctx->f[0] = *(float*)&val; }
    // 0x1572b4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1572b8: 0xe6410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x1572bc: 0xc60d005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 92)); ctx->f[13] = *(float*)&val; }
    // 0x1572c0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1572c8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[12] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1572c8
// Address: 0x1572c8 - 0x157320

void entry_1572c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1572c8) {
        switch (ctx->pc) {
            case 0x157304: ctx->pc = 0; goto label_157304;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1572c8: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1572cc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1572d0: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1572d4: 0x0
    // NOP
    // 0x1572d8: 0x4501000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_157304;
    }
    // 0x1572e0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1572e4: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1572e8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1572ec: 0xda810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1572f0: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1572f4: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1572f8: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1572fc: 0xfa810000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x157300: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_157304:
    // 0x157304: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x157308: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15730c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x157310: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x157314: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x157318: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EmitRips__FP5EMITBP5EMITGiP6VECTORT3PfT5
// Address: 0x157320 - 0x15739c

void entry_15739c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15739c) {
        switch (ctx->pc) {
            case 0x1573c0: ctx->pc = 0; goto label_1573c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15739c: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1573a0: 0x12a00081
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1575A8; return;
    }
    // 0x1573a8: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1573c0;
    }
    // 0x1573b0: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1573b4: 0x54400002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 21));
        goto label_1573c0;
    }
    // 0x1573bc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_1573c0:
    // 0x1573c0: 0xc067856
    SET_GPR_U32(ctx, 31, 0x1573c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SetRipgEmitb__FP4RIPGP5EMITB(rdram, ctx, runtime); return;
}


// Function: entry_1573c8
// Address: 0x1573c8 - 0x1573ec

void entry_1573c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1573c8: 0x12000008
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1573ec(rdram, ctx, runtime); return;
    }
    // 0x1573d0: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1573d4: 0x10a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1573ec(rdram, ctx, runtime); return;
    }
    // 0x1573dc: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1573e0: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x1573e4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1573ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1573ec
// Address: 0x1573ec - 0x15741c

void entry_1573ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1573ec) {
        switch (ctx->pc) {
            case 0x1573f8: ctx->pc = 0; goto label_1573f8;
            case 0x157404: ctx->pc = 0; goto label_157404;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1573ec: 0x12a0006d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        entry_1575a4(rdram, ctx, runtime); return;
    }
    // 0x1573f4: 0x0
    // NOP
label_1573f8:
    // 0x1573f8: 0x26a20558
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 1368));
    // 0x1573fc: 0x10000057
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15755C; return;
    }
label_157404:
    // 0x157404: 0x1e9100
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 30), 4));
    // 0x157408: 0xc68c00b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 176)); ctx->f[12] = *(float*)&val; }
    // 0x15740c: 0xc68d00b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 180)); ctx->f[13] = *(float*)&val; }
    // 0x157410: 0x728821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x157414: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15741c);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15741c
// Address: 0x15741c - 0x157434

void entry_15741c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15741c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x157420: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157424: 0x8e8600c0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 192)));
    // 0x157428: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x15742c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x157434);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_157434
// Address: 0x157434 - 0x1574bc

void entry_157434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157434) {
        switch (ctx->pc) {
            case 0x157464: ctx->pc = 0; goto label_157464;
            case 0x157470: ctx->pc = 0; goto label_157470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157434: 0xc68100a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 164)); ctx->f[1] = *(float*)&val; }
    // 0x157438: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x15743c: 0x46020832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x157440: 0x0
    // NOP
    // 0x157444: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 52), *(uint32_t*)&val); }
        goto label_157464;
    }
    // 0x15744c: 0xc68000a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 168)); ctx->f[0] = *(float*)&val; }
    // 0x157450: 0x46020032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x157454: 0x0
    // NOP
    // 0x157458: 0x45010005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_157470;
    }
    // 0x157460: 0xe6610034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 52), *(uint32_t*)&val); }
label_157464:
    // 0x157464: 0xc68000a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 168)); ctx->f[0] = *(float*)&val; }
    // 0x157468: 0xe6600038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 56), *(uint32_t*)&val); }
    // 0x15746c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_157470:
    // 0x157470: 0x1e3080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 30), 2));
    // 0x157474: 0x266400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 176));
    // 0x157478: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15747c: 0x2431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x157480: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x157484: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x157488: 0xc23821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x15748c: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x157490: 0x7e6300a0
    WRITE128(ADD32(GPR_U32(ctx, 19), 160), GPR_VEC(ctx, 3));
    // 0x157494: 0xc23021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x157498: 0xc4e00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[0] = *(float*)&val; }
    // 0x15749c: 0xe6600018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 24), *(uint32_t*)&val); }
    // 0x1574a0: 0xc4c10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1574a4: 0xc4e00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1574a8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1574ac: 0xe661001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 28), *(uint32_t*)&val); }
    // 0x1574b0: 0x7ac20110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 272)));
    // 0x1574b4: 0xc0560fa
    SET_GPR_U32(ctx, 31, 0x1574bc);
    WRITE128(ADD32(GPR_U32(ctx, 19), 64), GPR_VEC(ctx, 2));
    SetEmitdvEmitb__FP6EMITDVP5EMITB(rdram, ctx, runtime); return;
}


// Function: entry_1574bc
// Address: 0x1574bc - 0x157500

void entry_1574bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1574bc) {
        switch (ctx->pc) {
            case 0x1574c8: ctx->pc = 0; goto label_1574c8;
            case 0x1574ec: ctx->pc = 0; goto label_1574ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1574bc: 0x8e8200b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 184)));
    // 0x1574c0: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 32), GPR_U32(ctx, 2));
        goto label_1574c8;
    }
label_1574c8:
    // 0x1574c8: 0x52e00008
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 148)));
        goto label_1574ec;
    }
    // 0x1574d0: 0x7ae20110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 23), 272)));
    // 0x1574d4: 0x7e620050
    WRITE128(ADD32(GPR_U32(ctx, 19), 80), GPR_VEC(ctx, 2));
    // 0x1574d8: 0x7ae30120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 23), 288)));
    // 0x1574dc: 0x7e630060
    WRITE128(ADD32(GPR_U32(ctx, 19), 96), GPR_VEC(ctx, 3));
    // 0x1574e0: 0x7ae20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 23), 304)));
    // 0x1574e4: 0x7e620070
    WRITE128(ADD32(GPR_U32(ctx, 19), 112), GPR_VEC(ctx, 2));
    // 0x1574e8: 0x8e840094
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 148)));
label_1574ec:
    // 0x1574ec: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1574f0: 0x50820014
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x157544; return;
    }
    // 0x1574f8: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x157500);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_157500
// Address: 0x157500 - 0x157530

void entry_157500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157500: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x157504: 0x1200001f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157584; return;
    }
    // 0x15750c: 0xc6600030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 48)); ctx->f[0] = *(float*)&val; }
    // 0x157510: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x157514: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x157518: 0x26650080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 128));
    // 0x15751c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x157520: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x157524: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x157528: 0x40f809
    SET_GPR_U32(ctx, 31, 0x157530);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_157530
// Address: 0x157530 - 0x157540

void entry_157530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157530: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x157534: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x157538: 0xc0680ce
    SET_GPR_U32(ctx, 31, 0x157540);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetTrailTrls__FP5TRAIL4TRLSPv(rdram, ctx, runtime); return;
}


// Function: entry_157540
// Address: 0x157540 - 0x157558

void entry_157540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157540) {
        switch (ctx->pc) {
            case 0x157544: ctx->pc = 0; goto label_157544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157540: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_157544:
    // 0x157544: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x157548: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_157558(rdram, ctx, runtime); return;
    }
    // 0x157550: 0x40f809
    SET_GPR_U32(ctx, 31, 0x157558);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_157558
// Address: 0x157558 - 0x157578

void entry_157558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157558) {
        switch (ctx->pc) {
            case 0x15755c: ctx->pc = 0; goto label_15755c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157558: 0x27de0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 1));
label_15755c:
    // 0x15755c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x157560: 0x3c3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 30), GPR_S32(ctx, 3)));
    // 0x157564: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157584; return;
    }
    // 0x15756c: 0x8e840090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 144)));
    // 0x157570: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x157578);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_157578
// Address: 0x157578 - 0x15758c

void entry_157578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157578) {
        switch (ctx->pc) {
            case 0x157584: ctx->pc = 0; goto label_157584;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157578: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15757c: 0x1660ffa1
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x157404; return;
    }
label_157584:
    // 0x157584: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x15758c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15758c
// Address: 0x15758c - 0x1575a4

void entry_15758c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15758c: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1575A8; return;
    }
    // 0x157594: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x157598: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x15759c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1575a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1575a4
// Address: 0x1575a4 - 0x1575d8

void entry_1575a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1575a4) {
        switch (ctx->pc) {
            case 0x1575a8: ctx->pc = 0; goto label_1575a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1575a4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_1575a8:
    // 0x1575a8: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1575ac: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1575b0: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1575b4: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1575b8: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1575bc: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1575c0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1575c4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1575c8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1575cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1575d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1575d8; return;
}


// Function: EmitBlips__FP5EMITBP5EMITGiP6VECTORT3PfT5T3T3
// Address: 0x1575d8 - 0x157674

void entry_157674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157674) {
        switch (ctx->pc) {
            case 0x157698: ctx->pc = 0; goto label_157698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157674: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x157678: 0x128000c1
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157980; return;
    }
    // 0x157680: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_157698;
    }
    // 0x157688: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15768c: 0x54400002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 20));
        goto label_157698;
    }
    // 0x157694: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_157698:
    // 0x157698: 0xc04e84a
    SET_GPR_U32(ctx, 31, 0x1576a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SetBlipgEmitb__FP5BLIPGP5EMITB(rdram, ctx, runtime); return;
}


// Function: entry_1576a0
// Address: 0x1576a0 - 0x1576c4

void entry_1576a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1576a0: 0x12000008
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1576c4(rdram, ctx, runtime); return;
    }
    // 0x1576a8: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1576ac: 0x10a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1576c4(rdram, ctx, runtime); return;
    }
    // 0x1576b4: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1576b8: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x1576bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1576c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1576c4
// Address: 0x1576c4 - 0x15778c

void entry_1576c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1576c4) {
        switch (ctx->pc) {
            case 0x1576d0: ctx->pc = 0; goto label_1576d0;
            case 0x1576d8: ctx->pc = 0; goto label_1576d8;
            case 0x157758: ctx->pc = 0; goto label_157758;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1576c4: 0x128000ae
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157980; return;
    }
    // 0x1576cc: 0x8e910624
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 20), 1572)));
label_1576d0:
    // 0x1576d0: 0x1000009e
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15794C; return;
    }
label_1576d8:
    // 0x1576d8: 0x2e62002c
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 44));
    // 0x1576dc: 0x1040009a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 2112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157948; return;
    }
    // 0x1576e4: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x1576e8: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1576ec: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1576f0: 0x10400095
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157948; return;
    }
    // 0x1576f8: 0x131100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 4));
    // 0x1576fc: 0x24430580
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 1408));
    // 0x157700: 0x8fa70018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x157704: 0x469021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x157708: 0x718021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x15770c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x157710: 0x72880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 7), 2));
    // 0x157714: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x157718: 0x26a7019c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 412));
    // 0x15771c: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x157720: 0xafa7001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 7));
    // 0x157724: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x157728: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x15772c: 0x8fa200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x157730: 0xafa30028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 3));
    // 0x157734: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x157738: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x15773c: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x157740: 0x8fa70010
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x157744: 0x83f021
    SET_GPR_U32(ctx, 30, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x157748: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x15774c: 0xa7b821
    SET_GPR_U32(ctx, 23, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x157750: 0x82b021
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x157754: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
label_157758:
    // 0x157758: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15775c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x157760: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x157764: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x157768: 0x7e02fa80
    WRITE128(ADD32(GPR_U32(ctx, 16), 4294965888), GPR_VEC(ctx, 2));
    // 0x15776c: 0x8fa70024
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x157770: 0xc4e00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[0] = *(float*)&val; }
    // 0x157774: 0xe600fa8c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4294965900), *(uint32_t*)&val); }
    // 0x157778: 0x7ac20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x15777c: 0x7e02fd40
    WRITE128(ADD32(GPR_U32(ctx, 16), 4294966592), GPR_VEC(ctx, 2));
    // 0x157780: 0xc6e00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 0)); ctx->f[0] = *(float*)&val; }
    // 0x157784: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x15778c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4294966604), *(uint32_t*)&val); }
    memset(rdram, ctx, runtime); return;
}


// Function: entry_15778c
// Address: 0x15778c - 0x15779c

void entry_15778c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15778c: 0x8e850590
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 1424)));
    // 0x157790: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x157794: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x15779c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_15779c
// Address: 0x15779c - 0x1577d8

void entry_15779c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15779c) {
        switch (ctx->pc) {
            case 0x1577c4: ctx->pc = 0; goto label_1577c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15779c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1577a0: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x1577a4: 0x8e820614
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1556)));
    // 0x1577a8: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 376)));
        goto label_1577c4;
    }
    // 0x1577b0: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1577b4: 0x3442fffe
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65534));
    // 0x1577b8: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1577bc: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1577c0: 0x8ea20178
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 376)));
label_1577c4:
    // 0x1577c4: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1577DC; return;
    }
    // 0x1577cc: 0x8e850384
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 900)));
    // 0x1577d0: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x1577d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1577d8
// Address: 0x1577d8 - 0x1577fc

void entry_1577d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1577d8) {
        switch (ctx->pc) {
            case 0x1577dc: ctx->pc = 0; goto label_1577dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1577d8: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_1577dc:
    // 0x1577dc: 0x8e820618
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1560)));
    // 0x1577e0: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1577e4: 0x54430029
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 800)));
        ctx->pc = 0x15788C; return;
    }
    // 0x1577ec: 0x8fa4001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x1577f0: 0xc6ac019c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 412)); ctx->f[12] = *(float*)&val; }
    // 0x1577f4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1577fc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1577fc
// Address: 0x1577fc - 0x157880

void entry_1577fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1577fc) {
        switch (ctx->pc) {
            case 0x157858: ctx->pc = 0; goto label_157858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1577fc: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    // 0x157800: 0xe6020008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x157804: 0x8ea20198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 408)));
    // 0x157808: 0x54400013
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 420)));
        goto label_157858;
    }
    // 0x157810: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x157814: 0xda02fd40
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294966592)));
    // 0x157818: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x15781c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x157820: 0xd8610090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x157824: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x157828: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x15782c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x157830: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x157834: 0x48270800
    SET_GPR_VEC(ctx, 7, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x157838: 0x44870000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 7);
    // 0x15783c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x157840: 0x0
    // NOP
    // 0x157844: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 420)));
        goto label_157858;
    }
    // 0x15784c: 0x46001007
    ctx->f[0] = FPU_NEG_S(ctx->f[2]);
    // 0x157850: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x157854: 0x8ea201a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 420)));
label_157858:
    // 0x157858: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 800)));
        ctx->pc = 0x157888; return;
    }
    // 0x157860: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x157864: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x157868: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15786c: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x157870: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x157874: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x157878: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x157880);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_157880
// Address: 0x157880 - 0x157970

void entry_157880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157880) {
        switch (ctx->pc) {
            case 0x157888: ctx->pc = 0; goto label_157888;
            case 0x15788c: ctx->pc = 0; goto label_15788c;
            case 0x1578b8: ctx->pc = 0; goto label_1578b8;
            case 0x157948: ctx->pc = 0; goto label_157948;
            case 0x15794c: ctx->pc = 0; goto label_15794c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157880: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x157884: 0x8e820320
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 800)));
label_157888:
    // 0x157888: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
label_15788c:
    // 0x15788c: 0x1443000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1578b8;
    }
    // 0x157894: 0x8e241088
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4232)));
    // 0x157898: 0x131140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 5));
    // 0x15789c: 0x7bc30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x1578a0: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1578a4: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x1578a8: 0x8fa70020
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1578ac: 0x78e20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1578b0: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1578b4: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_1578b8:
    // 0x1578b8: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1578bc: 0x7a02fa80
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 4294965888)));
    // 0x1578c0: 0x27de0010
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 16));
    // 0x1578c4: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1578c8: 0x26f70004
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 4));
    // 0x1578cc: 0xafa30020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 3));
    // 0x1578d0: 0x26d60010
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 16));
    // 0x1578d4: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x1578d8: 0x8fa20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x1578dc: 0x8fa40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1578e0: 0x8fa70028
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1578e4: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1578e8: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1578ec: 0xafa40024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 4));
    // 0x1578f0: 0x24e70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    // 0x1578f4: 0x2e64002c
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 19), 44));
    // 0x1578f8: 0x7a03fd40
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 4294966592)));
    // 0x1578fc: 0xafa70028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 7));
    // 0x157900: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x157904: 0x7e4302c0
    WRITE128(ADD32(GPR_U32(ctx, 18), 704), GPR_VEC(ctx, 3));
    // 0x157908: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15790c: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x157910: 0x7e420580
    WRITE128(ADD32(GPR_U32(ctx, 18), 1408), GPR_VEC(ctx, 2));
    // 0x157914: 0x26520010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 16));
    // 0x157918: 0x8e221084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
    // 0x15791c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x157920: 0xae221084
    WRITE32(ADD32(GPR_U32(ctx, 17), 4228), GPR_U32(ctx, 2));
    // 0x157924: 0x8e830620
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1568)));
    // 0x157928: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x15792c: 0x10800006
    WRITE32(ADD32(GPR_U32(ctx, 20), 1568), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_157948;
    }
    // 0x157934: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x157938: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15793c: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x157940: 0x1440ff85
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x157758; return;
    }
label_157948:
    // 0x157948: 0x8e311090
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4240)));
label_15794c:
    // 0x15794c: 0x8fa70018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x157950: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x157954: 0xe3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 3)));
    // 0x157958: 0x10400009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157980; return;
    }
    // 0x157960: 0x5620ff5d
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
        ctx->pc = 0x1576D8; return;
    }
    // 0x157968: 0xc04e71c
    SET_GPR_U32(ctx, 31, 0x157970);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PblipNew__FP5BLIPG(rdram, ctx, runtime); return;
}


// Function: entry_157970
// Address: 0x157970 - 0x1579b0

void entry_157970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157970) {
        switch (ctx->pc) {
            case 0x15797c: ctx->pc = 0; goto label_15797c;
            case 0x157980: ctx->pc = 0; goto label_157980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157970: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x157974: 0x5620ff58
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 4228)));
        ctx->pc = 0x1576D8; return;
    }
label_15797c:
    // 0x15797c: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_157980:
    // 0x157980: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x157984: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x157988: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15798c: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x157990: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x157994: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x157998: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15799c: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1579a0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1579a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1579ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1579b0; return;
}


// Function: OriginateParticles__FiP5EMITBP7EMITGEN
// Address: 0x1579b0 - 0x1579f4

void entry_1579f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1579f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1579f8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x157a00);
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_157a00
// Address: 0x157a00 - 0x157a0c

void entry_157a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157a00: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157a04: 0xc063596
    SET_GPR_U32(ctx, 31, 0x157a0c);
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_157a0c
// Address: 0x157a0c - 0x157a18

void entry_157a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157a0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157a10: 0xc063596
    SET_GPR_U32(ctx, 31, 0x157a18);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_157a18
// Address: 0x157a18 - 0x157a30

void entry_157a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157a18: 0xae42000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    // 0x157a1c: 0x26a500e4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 21), 228));
    // 0x157a20: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x157a24: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x157a28: 0xc055bf2
    SET_GPR_U32(ctx, 31, 0x157a30);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 236)));
    CalculateEmitvx__FiP2LMiP6EMITVX(rdram, ctx, runtime); return;
}


// Function: entry_157a30
// Address: 0x157a30 - 0x157a5c

void entry_157a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157a30) {
        switch (ctx->pc) {
            case 0x157a40: ctx->pc = 0; goto label_157a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157a30: 0x1a80004b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 21), 16));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x157B60; return;
    }
    // 0x157a38: 0x27b60030
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 48));
    // 0x157a3c: 0x8e470000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_157a40:
    // 0x157a40: 0x138100
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 19), 4));
    // 0x157a44: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x157a48: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157a4c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x157a50: 0xf03821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 16)));
    // 0x157a54: 0xc0559c6
    SET_GPR_U32(ctx, 31, 0x157a5c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ChooseEmitoPos__FP5EMITOiiP6VECTORT3(rdram, ctx, runtime); return;
}


// Function: entry_157a5c
// Address: 0x157a5c - 0x157a9c

void entry_157a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157a5c: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x157a60: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x157a64: 0x8e480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x157a68: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x157a6c: 0x8e4a0004
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x157a70: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x157a74: 0x8e4b0008
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x157a78: 0x26a400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 160));
    // 0x157a7c: 0x1104021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 16)));
    // 0x157a80: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x157a84: 0x1505021
    SET_GPR_U32(ctx, 10, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 16)));
    // 0x157a88: 0x1635821
    SET_GPR_U32(ctx, 11, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 3)));
    // 0x157a8c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157a90: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x157a94: 0xc055c92
    SET_GPR_U32(ctx, 31, 0x157a9c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ChooseEmitvVelocityAge__FP5EMITVP6EMITVXP5EMITOiP6VECTORN24PfT7(rdram, ctx, runtime); return;
}


// Function: entry_157a9c
// Address: 0x157a9c - 0x157b50

void entry_157a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157a9c) {
        switch (ctx->pc) {
            case 0x157b30: ctx->pc = 0; goto label_157b30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157a9c: 0x8ea50078
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 120)));
    // 0x157aa0: 0x10a00023
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_157b30;
    }
    // 0x157aa8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x157aac: 0xd8a50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x157ab0: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x157ab4: 0xd8840010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x157ab8: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x157abc: 0xd8810020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x157ac0: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x157ac4: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x157ac8: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x157acc: 0xd8a20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x157ad0: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x157ad4: 0xf8430000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x157ad8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x157adc: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x157ae0: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x157ae4: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x157ae8: 0xd8450000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x157aec: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x157af0: 0x4be1296c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x157af4: 0xd8860020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x157af8: 0xd8810010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x157afc: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x157b00: 0xd8a30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x157b04: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x157b08: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x157b0c: 0x4bc2308a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x157b10: 0xd8a40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 64)));
    // 0x157b14: 0xd8a10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 80)));
    // 0x157b18: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x157b1c: 0x4bc50afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x157b20: 0x4bc1286e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x157b24: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x157b28: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x157b2c: 0xf8620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_157b30:
    // 0x157b30: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x157b34: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_157b50(rdram, ctx, runtime); return;
    }
    // 0x157b3c: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x157b40: 0x8e460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x157b44: 0xb02821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    // 0x157b48: 0xc055bc2
    SET_GPR_U32(ctx, 31, 0x157b50);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 16)));
    ConvertEmitoPosVec__FP5EMITOP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_157b50
// Address: 0x157b50 - 0x157b88

void entry_157b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157b50) {
        switch (ctx->pc) {
            case 0x157b60: ctx->pc = 0; goto label_157b60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157b50: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x157b54: 0x274102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 20)));
    // 0x157b58: 0x5440ffb9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x157A40; return;
    }
label_157b60:
    // 0x157b60: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x157b64: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x157b68: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x157b6c: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x157b70: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x157b74: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x157b78: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x157b7c: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x157b80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OriginateSplineSinkParticles__FiP5EMITBR7EMITGENT2
// Address: 0x157b88 - 0x157bdc

void entry_157bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157bdc) {
        switch (ctx->pc) {
            case 0x157c00: ctx->pc = 0; goto label_157c00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157bdc: 0x8e10018c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 396)));
    // 0x157be0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x157be4: 0x8e040090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157be8: 0x8e020094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 148)));
    // 0x157bec: 0x8c85007c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 124)));
    // 0x157bf0: 0x14430003
    WRITE32(ADD32(GPR_U32(ctx, 29), 208), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_157c00;
    }
    // 0x157bf8: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x157bfc: 0xac82007c
    WRITE32(ADD32(GPR_U32(ctx, 4), 124), GPR_U32(ctx, 2));
label_157c00:
    // 0x157c00: 0x8e020090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157c04: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x157c08: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x157c0c: 0x54640008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 0));
        ctx->pc = 0x157C30; return;
    }
    // 0x157c14: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x157c18: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x157c1c: 0xc05618c
    SET_GPR_U32(ctx, 31, 0x157c24);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    CalculateExplTransform__FP4EXPLP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_157c24
// Address: 0x157c24 - 0x157c44

void entry_157c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157c24) {
        switch (ctx->pc) {
            case 0x157c30: ctx->pc = 0; goto label_157c30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157c24: 0x8e020090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157c28: 0xac5d0078
    WRITE32(ADD32(GPR_U32(ctx, 2), 120), GPR_U32(ctx, 29));
    // 0x157c2c: 0xae200010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 0));
label_157c30:
    // 0x157c30: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x157c34: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157c38: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x157c3c: 0xc055e6c
    SET_GPR_U32(ctx, 31, 0x157c44);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    OriginateParticles__FiP5EMITBP7EMITGEN(rdram, ctx, runtime); return;
}


// Function: entry_157c44
// Address: 0x157c44 - 0x157cac

void entry_157c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157c44) {
        switch (ctx->pc) {
            case 0x157c70: ctx->pc = 0; goto label_157c70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157c44: 0x8e030090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157c48: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x157c4c: 0xc455a144
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294943044)); ctx->f[21] = *(float*)&val; }
    // 0x157c50: 0x1a80005a
    WRITE32(ADD32(GPR_U32(ctx, 3), 120), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x157DBC; return;
    }
    // 0x157c58: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x157c5c: 0x3c1ebf80
    SET_GPR_U32(ctx, 30, ((uint32_t)49024 << 16));
    // 0x157c60: 0x24571858
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x157c64: 0x24160003
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 3));
    // 0x157c68: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x157c6c: 0x0
    // NOP
label_157c70:
    // 0x157c70: 0x8e020090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157c74: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x157c78: 0x10600045
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x157D90; return;
    }
    // 0x157c80: 0x8ea3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 12)));
    // 0x157c84: 0xc6e10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[1] = *(float*)&val; }
    // 0x157c88: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x157c8c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x157c90: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x157c94: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x157c98: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x157c9c: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x157ca0: 0x46010501
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x157ca4: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x157cac);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_157cac
// Address: 0x157cac - 0x157cdc

void entry_157cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157cac: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x157CE0; return;
    }
    // 0x157cb4: 0x8e020090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157cb8: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
    // 0x157cbc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x157cc0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x157cc4: 0x8c44007c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x157cc8: 0x27a60060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 96));
    // 0x157ccc: 0x27a70090
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 144));
    // 0x157cd0: 0x27a80070
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 112));
    // 0x157cd4: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x157cdc);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 128));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_157cdc
// Address: 0x157cdc - 0x157e00

void entry_157cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157cdc) {
        switch (ctx->pc) {
            case 0x157ce0: ctx->pc = 0; goto label_157ce0;
            case 0x157d78: ctx->pc = 0; goto label_157d78;
            case 0x157d90: ctx->pc = 0; goto label_157d90;
            case 0x157dbc: ctx->pc = 0; goto label_157dbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157cdc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_157ce0:
    // 0x157ce0: 0xdba50090
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x157ce4: 0x2631821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 3)));
    // 0x157ce8: 0xdba400a0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x157cec: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x157cf0: 0xdba100b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x157cf4: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x157cf8: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x157cfc: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x157d00: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x157d04: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x157d08: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x157d0c: 0xf8620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x157d10: 0x8e020090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157d14: 0x8c440080
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 128)));
    // 0x157d18: 0x1096001d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 22)) {
        goto label_157d90;
    }
    // 0x157d20: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x157d24: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x157d28: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x157d2c: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x157d30: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x157d34: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x157d38: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x157d3c: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x157d40: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x157d44: 0x10830012
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_157d90;
    }
    // 0x157d4c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x157d50: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x157d54: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x157d58: 0x2622821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x157d5c: 0xdba30080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x157d60: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x157d64: 0x4be208a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x157d68: 0x54830003
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 192));
        goto label_157d78;
    }
    // 0x157d70: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x157d74: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
label_157d78:
    // 0x157d78: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x157d7c: 0x4bc11afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x157d80: 0x4bc3086e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x157d84: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x157d88: 0x4be11068
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x157d8c: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_157d90:
    // 0x157d90: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x157d94: 0x48be1000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 30));
    // 0x157d98: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x157d9c: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x157da0: 0x254182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 20)));
    // 0x157da4: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x157da8: 0x26730010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 16));
    // 0x157dac: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x157db0: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x157db4: 0x1460ffae
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x157C70; return;
    }
label_157dbc:
    // 0x157dbc: 0x8e020090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x157dc0: 0x8fa300d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x157dc4: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x157dc8: 0x7bbe0160
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x157dcc: 0x7bb70150
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x157dd0: 0x7bb60140
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x157dd4: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x157dd8: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x157ddc: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x157de0: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x157de4: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x157de8: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x157dec: 0xc7b50188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 392)); ctx->f[21] = *(float*)&val; }
    // 0x157df0: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x157df4: 0xac43007c
    WRITE32(ADD32(GPR_U32(ctx, 2), 124), GPR_U32(ctx, 3));
    // 0x157df8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EmitParticles__FiP5EMITBP5EMITG
// Address: 0x157e00 - 0x157e30

void entry_157e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157e30: 0xafb00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 16));
    // 0x157e34: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x157e38: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157e3c: 0xc055e6c
    SET_GPR_U32(ctx, 31, 0x157e44);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    OriginateParticles__FiP5EMITBP7EMITGEN(rdram, ctx, runtime); return;
}


// Function: entry_157e44
// Address: 0x157e44 - 0x157e70

void entry_157e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157e44: 0x8e220120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x157e48: 0x5450000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 304)));
        ctx->pc = 0x157E78; return;
    }
    // 0x157e50: 0x8fa70010
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x157e54: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157e58: 0x8fa80014
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x157e5c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x157e60: 0x8fa90018
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x157e64: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x157e68: 0xc055cc8
    SET_GPR_U32(ctx, 31, 0x157e70);
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    EmitRips__FP5EMITBP5EMITGiP6VECTORT3PfT5(rdram, ctx, runtime); return;
}


// Function: entry_157e70
// Address: 0x157e70 - 0x157e98

void entry_157e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157e70) {
        switch (ctx->pc) {
            case 0x157e78: ctx->pc = 0; goto label_157e78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157e70: 0x10000017
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_157ed0(rdram, ctx, runtime); return;
    }
label_157e78:
    // 0x157e78: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x157e7c: 0x54620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 0));
        ctx->pc = 0x157EA0; return;
    }
    // 0x157e84: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x157e88: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157e8c: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x157e90: 0xc055ee2
    SET_GPR_U32(ctx, 31, 0x157e98);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    OriginateSplineSinkParticles__FiP5EMITBR7EMITGENT2(rdram, ctx, runtime); return;
}


// Function: entry_157e98
// Address: 0x157e98 - 0x157ed0

void entry_157e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157e98) {
        switch (ctx->pc) {
            case 0x157ea0: ctx->pc = 0; goto label_157ea0;
            case 0x157ea8: ctx->pc = 0; goto label_157ea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157e98: 0x10000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_157ea8;
    }
label_157ea0:
    // 0x157ea0: 0xafa00034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 0));
    // 0x157ea4: 0x8fa20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 52)));
label_157ea8:
    // 0x157ea8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x157eac: 0x8fa70010
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x157eb0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x157eb4: 0x8fa80014
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x157eb8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x157ebc: 0x8fa90018
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x157ec0: 0x8faa001c
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x157ec4: 0x8fab0030
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x157ec8: 0xc055d76
    SET_GPR_U32(ctx, 31, 0x157ed0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    EmitBlips__FP5EMITBP5EMITGiP6VECTORT3PfT5T3T3(rdram, ctx, runtime); return;
}


// Function: entry_157ed0
// Address: 0x157ed0 - 0x157ed8

void entry_157ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157ed0: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x157ed8);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_157ed8
// Address: 0x157ed8 - 0x157ef8

void entry_157ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157ed8: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x157edc: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x157ee0: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x157ee4: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x157ee8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x157eec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x157ef4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x157ef8; return;
}


// Function: EmitRipsSphere__FP6VECTORT0iP7EMITRIPP5EMITVPP4RIPGP2LO
// Address: 0x157ef8 - 0x157f40

void entry_157f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157f40: 0x27a40200
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 512));
    // 0x157f44: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x157f48: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x157f50);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_157f50
// Address: 0x157f50 - 0x157fc4

void entry_157f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x157f50) {
        switch (ctx->pc) {
            case 0x157f68: ctx->pc = 0; goto label_157f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x157f50: 0x7a030000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x157f54: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x157f58: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x157f5c: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x157f60: 0x26430080
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 128));
    // 0x157f64: 0x27a200a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 160));
label_157f68:
    // 0x157f68: 0x7a440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x157f6c: 0x7a450010
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x157f70: 0x7c440000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 4));
    // 0x157f74: 0x7c450010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 5));
    // 0x157f78: 0x26520020
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 32));
    // 0x157f7c: 0x1643fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 3)) {
        goto label_157f68;
    }
    // 0x157f84: 0x7a680030
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 19), 48)));
    // 0x157f88: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x157f8c: 0x7a670000
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x157f90: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x157f94: 0x7a630010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x157f98: 0x27a60200
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 512));
    // 0x157f9c: 0x7a620020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x157fa0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x157fa4: 0xafb50204
    WRITE32(ADD32(GPR_U32(ctx, 29), 516), GPR_U32(ctx, 21));
    // 0x157fa8: 0xafb60208
    WRITE32(ADD32(GPR_U32(ctx, 29), 520), GPR_U32(ctx, 22));
    // 0x157fac: 0xafa90120
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 9));
    // 0x157fb0: 0x7fa701b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 432), GPR_VEC(ctx, 7));
    // 0x157fb4: 0x7fa301c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 448), GPR_VEC(ctx, 3));
    // 0x157fb8: 0x7fa201d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 464), GPR_VEC(ctx, 2));
    // 0x157fbc: 0xc055f80
    SET_GPR_U32(ctx, 31, 0x157fc4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 480), GPR_VEC(ctx, 8));
    EmitParticles__FiP5EMITBP5EMITG(rdram, ctx, runtime); return;
}


// Function: entry_157fc4
// Address: 0x157fc4 - 0x157ff8

void entry_157fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x157fc4: 0x7bbf0280
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 640)));
    // 0x157fc8: 0x7bb60270
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x157fcc: 0x7bb50260
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x157fd0: 0x7bb40250
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x157fd4: 0x7bb30240
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x157fd8: 0x7bb20230
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x157fdc: 0x7bb10220
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x157fe0: 0x7bb00210
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x157fe4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 656));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x157fec: 0x0
    // NOP
    // 0x157ff0: 0x27bd0290
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 656));
    // 0x157ff4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x157ff8; return;
}


// Function: StockSplashBig__FP6VECTORfP2SO
// Address: 0x157ff8 - 0x1580c4

void entry_1580c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1580c4) {
        switch (ctx->pc) {
            case 0x1580d4: ctx->pc = 0; goto label_1580d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1580c4: 0x8e420090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 144)));
    // 0x1580c8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1580cc: 0x5440ffe6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 0)));
        ctx->pc = 0x158068; return;
    }
label_1580d4:
    // 0x1580d4: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1580d8: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1580dc: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1580e0: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1580e4: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1580e8: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1580ec: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1580f0: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1580f4: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1580f8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1580fc: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x158100: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StockSplashSmall__FP6VECTORfP2SO
// Address: 0x158108 - 0x158138

void entry_158138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158138: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15813c: 0x1200000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15817C; return;
    }
    // 0x158144: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x158148: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x15814c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x158150: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x158154: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15815c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15815c
// Address: 0x15815c - 0x158198

void entry_15815c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15815c) {
        switch (ctx->pc) {
            case 0x15817c: ctx->pc = 0; goto label_15817c;
            case 0x158180: ctx->pc = 0; goto label_158180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15815c: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x158160: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x158164: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x158168: 0x8e450278
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 632)));
    // 0x15816c: 0x10a00004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_158180;
    }
    // 0x158174: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x158178: 0xae020114
    WRITE32(ADD32(GPR_U32(ctx, 16), 276), GPR_U32(ctx, 2));
label_15817c:
    // 0x15817c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_158180:
    // 0x158180: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158184: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158188: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15818c: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x158190: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddEmitoSkeleton__FP5EMITO3OIDT1ffffP2LO
// Address: 0x158198 - 0x1581f0

void entry_1581f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1581f0) {
        switch (ctx->pc) {
            case 0x1581f4: ctx->pc = 0; goto label_1581f4;
            case 0x158238: ctx->pc = 0; goto label_158238;
            case 0x158240: ctx->pc = 0; goto label_158240;
            case 0x158258: ctx->pc = 0; goto label_158258;
            case 0x15825c: ctx->pc = 0; goto label_15825c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1581f0: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
label_1581f4:
    // 0x1581f4: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1581f8: 0x28620020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 32));
    // 0x1581fc: 0x10400017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15825c;
    }
    // 0x158204: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x158208: 0x621018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x15820c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x158210: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x158214: 0x46140036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x158218: 0xae030010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 3));
    // 0x15821c: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x158220: 0xac910000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 17));
    // 0x158224: 0xac920004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 18));
    // 0x158228: 0x45000003
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 4), 8), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_158238;
    }
    // 0x158230: 0x10000003
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 4), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_158240;
    }
label_158238:
    // 0x158238: 0xe495000c
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 4), 12), *(uint32_t*)&val); }
    // 0x15823c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
label_158240:
    // 0x158240: 0x46160036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x158244: 0x0
    // NOP
    // 0x158248: 0x45000003
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 4), 16), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_158258;
    }
    // 0x158250: 0x10000002
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 4), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15825c;
    }
label_158258:
    // 0x158258: 0xe4970014
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 4), 20), *(uint32_t*)&val); }
label_15825c:
    // 0x15825c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x158260: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158264: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158268: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15826c: 0xc7b70058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[23] = *(float*)&val; }
    // 0x158270: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x158274: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x158278: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x15827c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158284: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158288; return;
}


// Function: BindEmitb__FP5EMITBP2LO
// Address: 0x158288 - 0x1582e0

void entry_1582e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1582e0) {
        switch (ctx->pc) {
            case 0x1582e4: ctx->pc = 0; goto label_1582e4;
            case 0x158310: ctx->pc = 0; goto label_158310;
            case 0x158328: ctx->pc = 0; goto label_158328;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1582e0: 0xae62018c
    WRITE32(ADD32(GPR_U32(ctx, 19), 396), GPR_U32(ctx, 2));
label_1582e4:
    // 0x1582e4: 0x8e630010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1582e8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1582ec: 0x14620033
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1583BC; return;
    }
    // 0x1582f4: 0x8e620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1582f8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1582fc: 0x1840002d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1583B4; return;
    }
    // 0x158304: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x158308: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x15830c: 0x24160028
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 40));
label_158310:
    // 0x158310: 0x961818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x158314: 0x8e620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x158318: 0x24940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 4), 1));
    // 0x15831c: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x158320: 0x438821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x158324: 0x220802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_158328:
    // 0x158328: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15832c: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x158330: 0x8ea40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 20)));
    // 0x158334: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x158338: 0xc056906
    SET_GPR_U32(ctx, 31, 0x158340);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158340
// Address: 0x158340 - 0x1583e8

void entry_158340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158340) {
        switch (ctx->pc) {
            case 0x1583b4: ctx->pc = 0; goto label_1583b4;
            case 0x1583bc: ctx->pc = 0; goto label_1583bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158340: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x158344: 0x641fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x158328; return;
    }
    // 0x15834c: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x158350: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x158354: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x158358: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x15835c: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x158360: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x158364: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x158368: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15836c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x158370: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x158374: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x158378: 0xc623000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[3] = *(float*)&val; }
    // 0x15837c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x158380: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x158384: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x158388: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15838c: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x158390: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x158394: 0x46150882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x158398: 0xe6210020
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 32), *(uint32_t*)&val); }
    // 0x15839c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1583a0: 0xe6200024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 36), *(uint32_t*)&val); }
    // 0x1583a4: 0x8e620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1583a8: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1583ac: 0x1440ffd8
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x158310; return;
    }
label_1583b4:
    // 0x1583b4: 0xe6740028
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 19), 40), *(uint32_t*)&val); }
    // 0x1583b8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1583bc:
    // 0x1583bc: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1583c0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1583c4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1583c8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1583cc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1583d0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1583d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1583d8: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x1583dc: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1583e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetEmitdvEmitb__FP6EMITDVP5EMITB
// Address: 0x1583e8 - 0x158480

void entry_158548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158548) {
        switch (ctx->pc) {
            case 0x158550: ctx->pc = 0; goto label_158550;
            case 0x158554: ctx->pc = 0; goto label_158554;
            case 0x15855c: ctx->pc = 0; goto label_15855c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158548: 0x10000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15855c;
    }
label_158550:
    // 0x158550: 0x7a220030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 48)));
label_158554:
    // 0x158554: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x158558: 0x7fa20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
label_15855c:
    // 0x15855c: 0xc62c0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[12] = *(float*)&val; }
    // 0x158560: 0x27a20040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 64));
    // 0x158564: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158568: 0x46146302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    // 0x15856c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x158574);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_158574
// Address: 0x158574 - 0x15858c

void entry_158574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158574: 0x27b00110
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 272));
    // 0x158578: 0x27b100d0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 208));
    // 0x15857c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x158580: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x158584: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x15858c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_15858c
// Address: 0x15858c - 0x1585a4

void entry_15858c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15858c: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x158590: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x158594: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x158598: 0x700234a9
    SET_GPR_VEC(ctx, 6, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x15859c: 0xc06218a
    SET_GPR_U32(ctx, 31, 0x1585a4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    fn___ml__FRC7MATRIX4G8VU_FLOAT(rdram, ctx, runtime); return;
}


// Function: entry_1585a4
// Address: 0x1585a4 - 0x1585d4

void entry_1585a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1585a4: 0x7ba800d0
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1585a8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1585ac: 0x7ba700e0
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1585b0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1585b4: 0x7ba300f0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1585b8: 0x27a50090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1585bc: 0x7ba20100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1585c0: 0x7fa80090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 8));
    // 0x1585c4: 0x7fa700a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 7));
    // 0x1585c8: 0x7fa300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 3));
    // 0x1585cc: 0xc062204
    SET_GPR_U32(ctx, 31, 0x1585d4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    AddMatrix4Matrix4__FP7MATRIX4N20(rdram, ctx, runtime); return;
}


// Function: entry_1585d4
// Address: 0x1585d4 - 0x1585f8

void entry_1585d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1585d4: 0x7bbf0190
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1585d8: 0x7bb30180
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1585dc: 0x7bb20170
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1585e0: 0x7bb10160
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1585e4: 0x7bb00150
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1585e8: 0xc7b401a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 416)); ctx->f[20] = *(float*)&val; }
    // 0x1585ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 432));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1585f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1585f8; return;
}


// Function: PostExplLoad__FP4EXPL
// Address: 0x1585f8 - 0x15860c

void entry_15860c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15860c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x158610: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x158614: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15861c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15861c
// Address: 0x15861c - 0x158630

void entry_15861c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15861c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158620: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158624: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15862c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158630; return;
}


// Function: CalculateExplTransform__FP4EXPLP6VECTORP7MATRIX3
// Address: 0x158630 - 0x158730

void entry_158750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158750: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x158754: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x158758: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x15875c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x158764);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_158764
// Address: 0x158764 - 0x158778

void entry_158764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158764: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x158768: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15876c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158778; return;
}


// Function: ExplodeExplParams__FP4EXPLUiP3ALOP6VECTORT3ff
// Address: 0x158778 - 0x1587b4

void entry_1587b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1587b4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1587b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ExplodeExplExplso__FP4EXPLP6EXPLSO
// Address: 0x1587c0 - 0x1587c8

void entry_158800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158800: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x158808);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158808
// Address: 0x158808 - 0x158820

void entry_158808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158808) {
        switch (ctx->pc) {
            case 0x158818: ctx->pc = 0; goto label_158818;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158808: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15880c: 0x1ae00051
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_S32(ctx, 23) <= 0) {
        ctx->pc = 0x158954; return;
    }
    // 0x158814: 0x0
    // NOP
label_158818:
    // 0x158818: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x158820);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158820
// Address: 0x158820 - 0x15882c

void entry_158820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158820: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158824: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x15882c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_15882c
// Address: 0x15882c - 0x158838

void entry_15882c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15882c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158830: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x158838);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158838
// Address: 0x158838 - 0x158850

void entry_158838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158838: 0x8e660018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15883c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x158840: 0x8e650014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x158844: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158848: 0xc047960
    SET_GPR_U32(ctx, 31, 0x158850);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_158850
// Address: 0x158850 - 0x158868

void entry_158850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158850: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158854: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x158858: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15885c: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x158860: 0x40f809
    SET_GPR_U32(ctx, 31, 0x158868);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_158868
// Address: 0x158868 - 0x1588e8

void entry_158868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158868) {
        switch (ctx->pc) {
            case 0x158890: ctx->pc = 0; goto label_158890;
            case 0x1588ac: ctx->pc = 0; goto label_1588ac;
            case 0x1588bc: ctx->pc = 0; goto label_1588bc;
            case 0x1588c4: ctx->pc = 0; goto label_1588c4;
            case 0x1588d8: ctx->pc = 0; goto label_1588d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158868: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15886c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x158870: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x158874: 0x10400011
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1588bc;
    }
    // 0x15887c: 0x8e0302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x158880: 0x10600010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1588c4;
    }
    // 0x158888: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15888c: 0x2ca20008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 8));
label_158890:
    // 0x158890: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8)));
        goto label_1588ac;
    }
    // 0x158898: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15889c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1588a0: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x1588a4: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1588a8: 0x8c630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8)));
label_1588ac:
    // 0x1588ac: 0x1460fff8
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 8));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_158890;
    }
    // 0x1588b4: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1588c4;
    }
label_1588bc:
    // 0x1588bc: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1588c0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1588c4:
    // 0x1588c4: 0x18a0001f
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x158944; return;
    }
    // 0x1588cc: 0x26750094
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 19), 148));
    // 0x1588d0: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1588d4: 0x0
    // NOP
label_1588d8:
    // 0x1588d8: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1588dc: 0x24050078
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 120));
    // 0x1588e0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1588e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1588e8
// Address: 0x1588e8 - 0x1588fc

void entry_1588e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1588e8: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x158908; return;
    }
    // 0x1588f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1588f4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1588fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 122));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1588fc
// Address: 0x1588fc - 0x158914

void entry_1588fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1588fc) {
        switch (ctx->pc) {
            case 0x158908: ctx->pc = 0; goto label_158908;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1588fc: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
        ctx->pc = 0x15893C; return;
    }
    // 0x158904: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_158908:
    // 0x158908: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x15890c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x158914);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_158914
// Address: 0x158914 - 0x158980

void entry_158914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158914) {
        switch (ctx->pc) {
            case 0x158938: ctx->pc = 0; goto label_158938;
            case 0x15893c: ctx->pc = 0; goto label_15893c;
            case 0x158944: ctx->pc = 0; goto label_158944;
            case 0x158954: ctx->pc = 0; goto label_158954;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158914: 0x8e630090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 144)));
    // 0x158918: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x15891c: 0x10400006
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_158938;
    }
    // 0x158924: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x158928: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x15892c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x158930: 0xae630090
    WRITE32(ADD32(GPR_U32(ctx, 19), 144), GPR_U32(ctx, 3));
    // 0x158934: 0xae130080
    WRITE32(ADD32(GPR_U32(ctx, 16), 128), GPR_U32(ctx, 19));
label_158938:
    // 0x158938: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
label_15893c:
    // 0x15893c: 0x1640ffe6
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1588D8; return;
    }
label_158944:
    // 0x158944: 0x2c0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x158948: 0x257102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 23)));
    // 0x15894c: 0x1440ffb2
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x158818; return;
    }
label_158954:
    // 0x158954: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x158958: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15895c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x158960: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x158964: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x158968: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15896c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x158970: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158974: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15897c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158980; return;
}


// Function: CloneExplg__FP5EXPLGT0
// Address: 0x158980 - 0x1589a4

void entry_1589a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1589a4) {
        switch (ctx->pc) {
            case 0x1589b0: ctx->pc = 0; goto label_1589b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1589a4: 0x8e420090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 144)));
    // 0x1589a8: 0x18400011
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 148));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1589F0; return;
    }
label_1589b0:
    // 0x1589b0: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1589b4: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1589b8: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1589bc: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x1589c4);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1589c4
// Address: 0x1589c4 - 0x1589d8

void entry_1589c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1589c4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1589c8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1589cc: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1589d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1589d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1589d8
// Address: 0x1589d8 - 0x158a10

void entry_1589d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1589d8) {
        switch (ctx->pc) {
            case 0x1589f0: ctx->pc = 0; goto label_1589f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1589d8: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x1589dc: 0xae120080
    WRITE32(ADD32(GPR_U32(ctx, 16), 128), GPR_U32(ctx, 18));
    // 0x1589e0: 0x8e420090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 144)));
    // 0x1589e4: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1589e8: 0x1440fff1
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1589B0; return;
    }
label_1589f0:
    // 0x1589f0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1589f4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1589f8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1589fc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158a00: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158a04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158a0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158a10; return;
}


// Function: BindExplg__FP5EXPLG
// Address: 0x158a10 - 0x158a54

void entry_158a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158a54) {
        switch (ctx->pc) {
            case 0x158a58: ctx->pc = 0; goto label_158a58;
            case 0x158a68: ctx->pc = 0; goto label_158a68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158a54: 0x8e420090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 144)));
label_158a58:
    // 0x158a58: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x158a5c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x158a60: 0x1440fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x158A38; return;
    }
label_158a68:
    // 0x158a68: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x158a6c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158a70: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158a74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158a78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ExplodeExplgExplso__FP5EXPLGP6EXPLSO
// Address: 0x158a80 - 0x158ad0

void entry_158ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158ad0) {
        switch (ctx->pc) {
            case 0x158ae0: ctx->pc = 0; goto label_158ae0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158ad0: 0x8e420090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 144)));
    // 0x158ad4: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x158ad8: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x158AB8; return;
    }
label_158ae0:
    // 0x158ae0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x158ae4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x158ae8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158aec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158af0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158af4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158afc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158b00; return;
}


// Function: InitExplo__FP5EXPLO
// Address: 0x158b00 - 0x158b14

void entry_158b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158b14: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x158b18: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158b1c: 0xae020098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 2));
    // 0x158b20: 0xae020094
    WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 2));
    // 0x158b24: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158b28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadExploFromBrx__FP5EXPLOP18CBinaryInputStream
// Address: 0x158b30 - 0x158b58

void entry_158b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158b58: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158b5c: 0xc055272
    SET_GPR_U32(ctx, 31, 0x158b64);
    WRITE32(ADD32(GPR_U32(ctx, 18), 144), GPR_U32(ctx, 2));
    InitEmitb__FP5EMITB(rdram, ctx, runtime); return;
}


// Function: entry_158b64
// Address: 0x158b64 - 0x158b70

void entry_158b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158b64: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x158b68: 0xc07ce90
    SET_GPR_U32(ctx, 31, 0x158b70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadXfmFromBrx__FP3XFMP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158b70
// Address: 0x158b70 - 0x158b78

void entry_158b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158b70: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x158b78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158b78
// Address: 0x158b78 - 0x158b90

void entry_158b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158b78: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158b7c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x158b80: 0x1222000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        entry_158bbc(rdram, ctx, runtime); return;
    }
    // 0x158b88: 0xc056376
    SET_GPR_U32(ctx, 31, 0x158b90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PemitbEnsureExplo__FP5EXPLO4ENSK(rdram, ctx, runtime); return;
}


// Function: entry_158b90
// Address: 0x158b90 - 0x158b9c

void entry_158b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158b90: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158b94: 0xc05366a
    SET_GPR_U32(ctx, 31, 0x158b9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PcrvNew__F4CRVK(rdram, ctx, runtime); return;
}


// Function: entry_158b9c
// Address: 0x158b9c - 0x158bbc

void entry_158b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158b9c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158ba0: 0xae040020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 4));
    // 0x158ba4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x158ba8: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x158bac: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 144)));
        ctx->pc = 0x158BC0; return;
    }
    // 0x158bb4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x158bbc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_158bbc
// Address: 0x158bbc - 0x158bd8

void entry_158bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158bbc) {
        switch (ctx->pc) {
            case 0x158bc0: ctx->pc = 0; goto label_158bc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158bbc: 0x8e440090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 144)));
label_158bc0:
    // 0x158bc0: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x158bc4: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x158bc8: 0x14430003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        entry_158bd8(rdram, ctx, runtime); return;
    }
    // 0x158bd0: 0xc055320
    SET_GPR_U32(ctx, 31, 0x158bd8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadEmitmeshFromBrx__FP8EMITMESHP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158bd8
// Address: 0x158bd8 - 0x158be0

void entry_158bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158bd8: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x158be0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158be0
// Address: 0x158be0 - 0x158bf4

void entry_158be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158be0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158be4: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_158c08(rdram, ctx, runtime); return;
    }
    // 0x158bec: 0xc056376
    SET_GPR_U32(ctx, 31, 0x158bf4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PemitbEnsureExplo__FP5EXPLO4ENSK(rdram, ctx, runtime); return;
}


// Function: entry_158bf4
// Address: 0x158bf4 - 0x158c08

void entry_158bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158bf4: 0x24440130
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 304));
    // 0x158bf8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x158bfc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x158c00: 0xc0553b8
    SET_GPR_U32(ctx, 31, 0x158c08);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadEmitblipColorsFromBrx__FP8EMITBLIPiP2LOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_158c08
// Address: 0x158c08 - 0x158c28

void entry_158c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158c08: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x158c0c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x158c10: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158c14: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158c18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158c1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158c24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158c28; return;
}


// Function: CloneExplo__FP5EXPLOT0
// Address: 0x158c28 - 0x158c3c

void entry_158c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158c3c: 0x8e030090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x158c40: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158c44: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x158c48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158c4c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x158c50: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x158c54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158c5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158c60; return;
}


// Function: BindExplo__FP5EXPLO
// Address: 0x158c60 - 0x158cc4

void entry_158cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158cc4: 0x2412ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x158cc8: 0x8e060094
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 148)));
    // 0x158ccc: 0x10d20006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x158CE8; return;
    }
    // 0x158cd4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x158cd8: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x158cdc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x158ce4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158ce4
// Address: 0x158ce4 - 0x158d00

void entry_158ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158ce4) {
        switch (ctx->pc) {
            case 0x158ce8: ctx->pc = 0; goto label_158ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158ce4: 0xae22007c
    WRITE32(ADD32(GPR_U32(ctx, 17), 124), GPR_U32(ctx, 2));
label_158ce8:
    // 0x158ce8: 0x8e060098
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 152)));
    // 0x158cec: 0x10d20008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x158D10; return;
    }
    // 0x158cf4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x158cf8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x158d00);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158d00
// Address: 0x158d00 - 0x158d1c

void entry_158d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158d00) {
        switch (ctx->pc) {
            case 0x158d10: ctx->pc = 0; goto label_158d10;
            case 0x158d14: ctx->pc = 0; goto label_158d14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158d00: 0x8c430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x158d04: 0xae230020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 3));
    // 0x158d08: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x158d0c: 0xae24007c
    WRITE32(ADD32(GPR_U32(ctx, 17), 124), GPR_U32(ctx, 4));
label_158d10:
    // 0x158d10: 0x8e040090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 144)));
label_158d14:
    // 0x158d14: 0xc0560a2
    SET_GPR_U32(ctx, 31, 0x158d1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BindEmitb__FP5EMITBP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158d1c
// Address: 0x158d1c - 0x158d38

void entry_158d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158d1c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x158d20: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158d24: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158d28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158d2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158d34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158d38; return;
}


// Function: ExplodeExploExplso__FP5EXPLOP6EXPLSO
// Address: 0x158d38 - 0x158d40

void entry_158d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158d88: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x158d8c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x158d90: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x158d94: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x158d98: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x158d9c: 0x4600bbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[23]);
    // 0x158da0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x158da4: 0xc056066
    SET_GPR_U32(ctx, 31, 0x158dac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 16));
    AddEmitoSkeleton__FP5EMITO3OIDT1ffffP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158dac
// Address: 0x158dac - 0x158dd8

void entry_158dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158dac: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x158db0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158db4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158db8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158dbc: 0xc7b70058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[23] = *(float*)&val; }
    // 0x158dc0: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x158dc4: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x158dc8: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x158dcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158dd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158dd8; return;
}


// Function: PemitbEnsureExplo__FP5EXPLO4ENSK
// Address: 0x158dd8 - 0x158df8

void entry_158df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158df8) {
        switch (ctx->pc) {
            case 0x158dfc: ctx->pc = 0; goto label_158dfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158df8: 0xae020090
    WRITE32(ADD32(GPR_U32(ctx, 16), 144), GPR_U32(ctx, 2));
label_158dfc:
    // 0x158dfc: 0x8e020090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x158e00: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158e04: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158e08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitExpls__FP5EXPLS
// Address: 0x158e10 - 0x158e24

void entry_158e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158e24: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x158e28: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158e2c: 0xae0200b4
    WRITE32(ADD32(GPR_U32(ctx, 16), 180), GPR_U32(ctx, 2));
    // 0x158e30: 0xae0200ac
    WRITE32(ADD32(GPR_U32(ctx, 16), 172), GPR_U32(ctx, 2));
    // 0x158e34: 0xae0200b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 176), GPR_U32(ctx, 2));
    // 0x158e38: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158e3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158e44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158e48; return;
}


// Function: BindExpls__FP5EXPLS
// Address: 0x158e48 - 0x158e68

void entry_158e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158e68) {
        switch (ctx->pc) {
            case 0x158e84: ctx->pc = 0; goto label_158e84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158e68: 0x8e0200ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 172)));
    // 0x158e6c: 0x14520005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        goto label_158e84;
    }
    // 0x158e74: 0xde0300b0
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 176)));
    // 0x158e78: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x158e7c: 0x1062001f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x158EFC; return;
    }
label_158e84:
    // 0x158e84: 0xc056376
    SET_GPR_U32(ctx, 31, 0x158e8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PemitbEnsureExplo__FP5EXPLO4ENSK(rdram, ctx, runtime); return;
}


// Function: entry_158e8c
// Address: 0x158e8c - 0x158ea8

void entry_158e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158e8c: 0x8e0600ac
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 172)));
    // 0x158e90: 0x10d20006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x158EAC; return;
    }
    // 0x158e98: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x158e9c: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x158ea0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x158ea8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158ea8
// Address: 0x158ea8 - 0x158ec4

void entry_158ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158ea8) {
        switch (ctx->pc) {
            case 0x158eac: ctx->pc = 0; goto label_158eac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158ea8: 0xae2201d8
    WRITE32(ADD32(GPR_U32(ctx, 17), 472), GPR_U32(ctx, 2));
label_158eac:
    // 0x158eac: 0x8e0600b0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 176)));
    // 0x158eb0: 0x10d20005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x158EC8; return;
    }
    // 0x158eb8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x158ebc: 0xc056906
    SET_GPR_U32(ctx, 31, 0x158ec4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158ec4
// Address: 0x158ec4 - 0x158ee0

void entry_158ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158ec4) {
        switch (ctx->pc) {
            case 0x158ec8: ctx->pc = 0; goto label_158ec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158ec4: 0xae2201dc
    WRITE32(ADD32(GPR_U32(ctx, 17), 476), GPR_U32(ctx, 2));
label_158ec8:
    // 0x158ec8: 0x8e0600b4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 180)));
    // 0x158ecc: 0x10d2000a
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x158EF8; return;
    }
    // 0x158ed4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x158ed8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x158ee0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_158ee0
// Address: 0x158ee0 - 0x158ef0

void entry_158ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x158ee0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158ee4: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x158ee8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x158ef0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_158ef0
// Address: 0x158ef0 - 0x158f10

void entry_158ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158ef0) {
        switch (ctx->pc) {
            case 0x158ef8: ctx->pc = 0; goto label_158ef8;
            case 0x158efc: ctx->pc = 0; goto label_158efc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158ef0: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 480), GPR_U32(ctx, 16));
        goto label_158ef8;
    }
label_158ef8:
    // 0x158ef8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_158efc:
    // 0x158efc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x158f00: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x158f04: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158f08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleExplsMessage__FP5EXPLS5MSGIDPv
// Address: 0x158f10 - 0x158f48

void entry_158f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158f48) {
        switch (ctx->pc) {
            case 0x158f50: ctx->pc = 0; goto label_158f50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158f48: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 192), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x158F6C; return;
    }
label_158f50:
    // 0x158f50: 0x14820007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x158F70; return;
    }
    // 0x158f58: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x158f5c: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x158f60: 0x40f809
    SET_GPR_U32(ctx, 31, 0x158f68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_158f68
// Address: 0x158f68 - 0x158f80

void entry_158f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158f68) {
        switch (ctx->pc) {
            case 0x158f6c: ctx->pc = 0; goto label_158f6c;
            case 0x158f70: ctx->pc = 0; goto label_158f70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158f68: 0xae0000c4
    WRITE32(ADD32(GPR_U32(ctx, 16), 196), GPR_U32(ctx, 0));
label_158f6c:
    // 0x158f6c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_158f70:
    // 0x158f70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x158f74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x158f7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x158f80; return;
}


// Function: ExplodeExplsExplso__FP5EXPLSP6EXPLSO
// Address: 0x158f80 - 0x158fc4

void entry_158fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x158fc4) {
        switch (ctx->pc) {
            case 0x158fe0: ctx->pc = 0; goto label_158fe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x158fc4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x158fc8: 0x1200001a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_159034(rdram, ctx, runtime); return;
    }
    // 0x158fd0: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x158fd4: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x158fd8: 0x26450040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 64));
    // 0x158fdc: 0x26040064
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 100));
label_158fe0:
    // 0x158fe0: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x158fe4: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x158fe8: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x158fec: 0x7c670010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 7));
    // 0x158ff0: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x158ff4: 0x1445fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_158fe0;
    }
    // 0x158ffc: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x159000: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x159004: 0x7c650000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 5));
    // 0x159008: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15900c: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x159010: 0xc62100b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 184)); ctx->f[1] = *(float*)&val; }
    // 0x159014: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x159018: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15901c: 0xc054914
    SET_GPR_U32(ctx, 31, 0x159024);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 96), *(uint32_t*)&val); }
    ClearDle__FP3DLE(rdram, ctx, runtime); return;
}


// Function: entry_159024
// Address: 0x159024 - 0x159034

void entry_159024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159024: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x159028: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15902c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x159034);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7132));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_159034
// Address: 0x159034 - 0x159048

void entry_159034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159034: 0x16600005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15904C; return;
    }
    // 0x15903c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x159040: 0xc056428
    SET_GPR_U32(ctx, 31, 0x159048);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FireExplsExplso__FP5EXPLSP6EXPLSO(rdram, ctx, runtime); return;
}


// Function: entry_159048
// Address: 0x159048 - 0x159068

void entry_159048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159048) {
        switch (ctx->pc) {
            case 0x15904c: ctx->pc = 0; goto label_15904c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159048: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_15904c:
    // 0x15904c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x159050: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x159054: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x159058: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15905c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x159064: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x159068; return;
}


// Function: PsfxEnsureExpls__FP5EXPLS4ENSK
// Address: 0x159068 - 0x15908c

void entry_15908c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15908c) {
        switch (ctx->pc) {
            case 0x159094: ctx->pc = 0; goto label_159094;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15908c: 0x8e0200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x159090: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_159094:
    // 0x159094: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159098: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FireExplsExplso__FP5EXPLSP6EXPLSO
// Address: 0x1590a0 - 0x159110

void entry_159110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159110) {
        switch (ctx->pc) {
            case 0x159118: ctx->pc = 0; goto label_159118;
            case 0x159134: ctx->pc = 0; goto label_159134;
            case 0x15914c: ctx->pc = 0; goto label_15914c;
            case 0x159168: ctx->pc = 0; goto label_159168;
            case 0x159184: ctx->pc = 0; goto label_159184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159110: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x159114: 0x44130800
    SET_GPR_U32(ctx, 19, *(uint32_t*)&ctx->f[1]);
label_159118:
    // 0x159118: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x15911c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x159120: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_159134;
    }
    // 0x159128: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x15912c: 0xafa2007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 2));
    // 0x159130: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_159134:
    // 0x159134: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x159138: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_15914c;
    }
    // 0x159140: 0x7a420010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x159144: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x159148: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_15914c:
    // 0x15914c: 0x30620004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4));
    // 0x159150: 0x10400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_159168;
    }
    // 0x159158: 0x7a420020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x15915c: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x159160: 0x10000017
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1591C0; return;
    }
label_159168:
    // 0x159168: 0x10400006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 512));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_159184;
    }
    // 0x159170: 0x8e42003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x159174: 0x8e830018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x159178: 0xafa20078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 2));
    // 0x15917c: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1591C0; return;
    }
label_159184:
    // 0x159184: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159188: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x159190);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 96));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_159190
// Address: 0x159190 - 0x1591a4

void entry_159190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159190: 0x27b00200
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 512));
    // 0x159194: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x159198: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15919c: 0xc05618c
    SET_GPR_U32(ctx, 31, 0x1591a4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 528));
    CalculateExplTransform__FP4EXPLP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1591a4
// Address: 0x1591a4 - 0x15926c

void entry_1591a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1591a4) {
        switch (ctx->pc) {
            case 0x1591c0: ctx->pc = 0; goto label_1591c0;
            case 0x159204: ctx->pc = 0; goto label_159204;
            case 0x159228: ctx->pc = 0; goto label_159228;
            case 0x159234: ctx->pc = 0; goto label_159234;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1591a4: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1591a8: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x1591ac: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1591b0: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1591c0;
    }
    // 0x1591b8: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x1591bc: 0xafa2007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 2));
label_1591c0:
    // 0x1591c0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1591c4: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1591c8: 0x1040003f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1592c8(rdram, ctx, runtime); return;
    }
    // 0x1591d0: 0x1440003e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1592CC; return;
    }
    // 0x1591d8: 0xc64c0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 48)); ctx->f[12] = *(float*)&val; }
    // 0x1591dc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1591e0: 0x46006032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1591e4: 0x0
    // NOP
    // 0x1591e8: 0x45000006
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_159204;
    }
    // 0x1591f0: 0xc6410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1591f4: 0x3c013c23
    SET_GPR_U32(ctx, 1, ((uint32_t)15395 << 16));
    // 0x1591f8: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x1591fc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x159200: 0x46000d02
    ctx->f[20] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
label_159204:
    // 0x159204: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x159208: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15920c: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159210: 0x45000005
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_159228;
    }
    // 0x159218: 0x44930000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 19);
    // 0x15921c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x159220: 0x10000004
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_159234;
    }
label_159228:
    // 0x159228: 0x44930000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 19);
    // 0x15922c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x159230: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
label_159234:
    // 0x159234: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x159238: 0x44130800
    SET_GPR_U32(ctx, 19, *(uint32_t*)&ctx->f[1]);
    // 0x15923c: 0xc68000a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 168)); ctx->f[0] = *(float*)&val; }
    // 0x159240: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x159244: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x159248: 0x24842178
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8568));
    // 0x15924c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x159250: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x159254: 0x21fc2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 2), 31));
    // 0x159258: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15925c: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x159260: 0x53182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 19)));
    // 0x159264: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x15926c);
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 2));
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_15926c
// Address: 0x15926c - 0x1592a0

void entry_15926c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15926c: 0xc7a200a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[2] = *(float*)&val; }
    // 0x159270: 0x27b10140
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 320));
    // 0x159274: 0xc7a300a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[3] = *(float*)&val; }
    // 0x159278: 0x27a40290
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 656));
    // 0x15927c: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x159280: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x159284: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x159288: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x15928c: 0x46140d28
    ctx->f[20] = std::max(ctx->f[1], ctx->f[20]);
    // 0x159290: 0xe7a200a0
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 160), *(uint32_t*)&val); }
    // 0x159294: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x159298: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1592a0);
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 164), *(uint32_t*)&val); }
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1592a0
// Address: 0x1592a0 - 0x1592b0

void entry_1592a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1592a0: 0x7bb00290
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 656)));
    // 0x1592a4: 0x27a402a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 672));
    // 0x1592a8: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1592b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1592b0
// Address: 0x1592b0 - 0x1592bc

void entry_1592b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1592b0: 0x7ba502a0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 672)));
    // 0x1592b4: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1592bc);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1592bc
// Address: 0x1592bc - 0x1592c8

void entry_1592bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1592bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1592c0: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1592c8);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1592c8
// Address: 0x1592c8 - 0x159340

void entry_1592c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1592c8) {
        switch (ctx->pc) {
            case 0x1592cc: ctx->pc = 0; goto label_1592cc;
            case 0x1592f8: ctx->pc = 0; goto label_1592f8;
            case 0x159310: ctx->pc = 0; goto label_159310;
            case 0x159330: ctx->pc = 0; goto label_159330;
            case 0x159334: ctx->pc = 0; goto label_159334;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1592c8: 0x8fa30120
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 288)));
label_1592cc:
    // 0x1592cc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1592d0: 0x5462000f
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 188)));
        goto label_159310;
    }
    // 0x1592d8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1592dc: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1592e0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_1592f8;
    }
    // 0x1592e8: 0xc6400030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1592ec: 0xe7a001d4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 468), *(uint32_t*)&val); }
    // 0x1592f0: 0xe7a001d0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 464), *(uint32_t*)&val); }
    // 0x1592f4: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1592f8:
    // 0x1592f8: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1592fc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 188)));
        goto label_159310;
    }
    // 0x159304: 0x8e420038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 56)));
    // 0x159308: 0xafa201e0
    WRITE32(ADD32(GPR_U32(ctx, 29), 480), GPR_U32(ctx, 2));
    // 0x15930c: 0x8e8200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 188)));
label_159310:
    // 0x159310: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 196));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_159330;
    }
    // 0x159318: 0x268300c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 192));
    // 0x15931c: 0xafa20260
    WRITE32(ADD32(GPR_U32(ctx, 29), 608), GPR_U32(ctx, 2));
    // 0x159320: 0x27a60260
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 608));
    // 0x159324: 0xafa30264
    WRITE32(ADD32(GPR_U32(ctx, 29), 612), GPR_U32(ctx, 3));
    // 0x159328: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 29), 616), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_159334;
    }
label_159330:
    // 0x159330: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_159334:
    // 0x159334: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x159338: 0xc055f80
    SET_GPR_U32(ctx, 31, 0x159340);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EmitParticles__FiP5EMITBP5EMITG(rdram, ctx, runtime); return;
}


// Function: entry_159340
// Address: 0x159340 - 0x159420

void entry_159340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159340) {
        switch (ctx->pc) {
            case 0x1593d0: ctx->pc = 0; goto label_1593d0;
            case 0x1593d4: ctx->pc = 0; goto label_1593d4;
            case 0x159408: ctx->pc = 0; goto label_159408;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159340: 0x8e8200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 160)));
    // 0x159344: 0x10400043
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_159454(rdram, ctx, runtime); return;
    }
    // 0x15934c: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x159350: 0x10400020
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1593d4;
    }
    // 0x159358: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x15935c: 0x2442a150
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294943056));
    // 0x159360: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x159364: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x159368: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x159370: 0x10000017
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1593d0;
    }
    // 0x159378: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x15937c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x159380: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x159384: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x159388: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x15938c: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x159390: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x159394: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x159398: 0xfba10280
    WRITE128(ADD32(GPR_U32(ctx, 29), 640), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15939c: 0x1000000d
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1593d4;
    }
    // 0x1593a4: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1593a8: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1593ac: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1593b0: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1593d4;
    }
    // 0x1593b8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1593bc: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1593c0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1593c4: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1593d4;
    }
    // 0x1593cc: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1593d0:
    // 0x1593d0: 0x7fa20270
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), GPR_VEC(ctx, 2));
label_1593d4:
    // 0x1593d4: 0x8fa30078
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 120)));
    // 0x1593d8: 0x1060000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_159408;
    }
    // 0x1593e0: 0xdba30270
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x1593e4: 0xd8450020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1593e8: 0xd8640010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1593ec: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1593f0: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1593f4: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1593f8: 0x4bc308bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1593fc: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x159400: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x159404: 0xfba30270
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), _mm_castps_si128(ctx->vu0_vf[3]));
label_159408:
    // 0x159408: 0x27b00270
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 624));
    // 0x15940c: 0x8fa4007c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 124)));
    // 0x159410: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159414: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x159418: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x159420);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_159420
// Address: 0x159420 - 0x159454

void entry_159420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159420: 0x8e8200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 160)));
    // 0x159424: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x159428: 0x44808000
    *(uint32_t*)&ctx->f[16] = GPR_U32(ctx, 0);
    // 0x15942c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159430: 0xc44f0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[15] = *(float*)&val; }
    // 0x159434: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159438: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15943c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159440: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x159444: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159448: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x15944c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x159454);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[14] = *(float*)&val; }
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_159454
// Address: 0x159454 - 0x159478

void entry_159454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159454: 0x7bbf0300
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 768)));
    // 0x159458: 0x7bb402f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 752)));
    // 0x15945c: 0x7bb302e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 736)));
    // 0x159460: 0x7bb202d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 720)));
    // 0x159464: 0x7bb102c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 704)));
    // 0x159468: 0x7bb002b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 688)));
    // 0x15946c: 0xc7b40310
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 784)); ctx->f[20] = *(float*)&val; }
    // 0x159470: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 800));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InferExpl__FPP4EXPLP3ALO
// Address: 0x159478 - 0x1594b8

void entry_1594b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1594b8) {
        switch (ctx->pc) {
            case 0x1594d4: ctx->pc = 0; goto label_1594d4;
            case 0x1594dc: ctx->pc = 0; goto label_1594dc;
            case 0x1594e4: ctx->pc = 0; goto label_1594e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1594b8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1594bc: 0x12600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1594d4;
    }
    // 0x1594c4: 0x12620005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_1594dc;
    }
    // 0x1594cc: 0x10000005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1594e4;
    }
label_1594d4:
    // 0x1594d4: 0x10000023
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159564; return;
    }
label_1594dc:
    // 0x1594dc: 0x10000021
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159564; return;
    }
label_1594e4:
    // 0x1594e4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1594e8: 0x24040078
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 120));
    // 0x1594ec: 0x24070202
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 514));
    // 0x1594f0: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1594f4: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1594fc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1594fc
// Address: 0x1594fc - 0x159524

void entry_1594fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1594fc: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x159500: 0x24030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 8));
    // 0x159504: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x159508: 0x26440094
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 148));
    // 0x15950c: 0x53102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 19)));
    // 0x159510: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x159514: 0x262180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 19));
    // 0x159518: 0x33080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 3), 2));
    // 0x15951c: 0xc063600
    SET_GPR_U32(ctx, 31, 0x159524);
    WRITE32(ADD32(GPR_U32(ctx, 18), 144), GPR_U32(ctx, 3));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_159524
// Address: 0x159524 - 0x159554

void entry_159524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159524) {
        switch (ctx->pc) {
            case 0x159530: ctx->pc = 0; goto label_159530;
            case 0x159540: ctx->pc = 0; goto label_159540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159524: 0x1a60000e
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x159560; return;
    }
    // 0x15952c: 0x8e420090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 144)));
label_159530:
    // 0x159530: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x159534: 0x10400002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_159540;
    }
    // 0x15953c: 0xac920080
    WRITE32(ADD32(GPR_U32(ctx, 4), 128), GPR_U32(ctx, 18));
label_159540:
    // 0x159540: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x159544: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x159548: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x15954c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x159554);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_159554
// Address: 0x159554 - 0x159588

void entry_159554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159554) {
        switch (ctx->pc) {
            case 0x159560: ctx->pc = 0; goto label_159560;
            case 0x159564: ctx->pc = 0; goto label_159564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159554: 0x213102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 19)));
    // 0x159558: 0x5440fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 144)));
        ctx->pc = 0x159530; return;
    }
label_159560:
    // 0x159560: 0xae920000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 18));
label_159564:
    // 0x159564: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x159568: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x15956c: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x159570: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x159574: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x159578: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15957c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x159584: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x159588; return;
}


// Function: FireSwTimedExplodeStyles__FP2SW
// Address: 0x159588 - 0x15960c

void entry_15960c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15960c: 0x26241bdc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 7132));
    // 0x159610: 0xc054980
    SET_GPR_U32(ctx, 31, 0x159618);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_159618
// Address: 0x159618 - 0x159624

void entry_159618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159618: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15961c: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x159624);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 7120));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_159624
// Address: 0x159624 - 0x159680

void entry_159624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159624) {
        switch (ctx->pc) {
            case 0x159628: ctx->pc = 0; goto label_159628;
            case 0x159640: ctx->pc = 0; goto label_159640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159624: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_159628:
    // 0x159628: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x15962c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x159630: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x159634: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x159638: 0x1600ffeb
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1595E8; return;
    }
label_159640:
    // 0x159640: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x159644: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x159648: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x15964c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x159650: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x159654: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x159658: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15965c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x159664: 0x0
    // NOP
    // 0x159668: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x15966c: 0x0
    // NOP
    // 0x159670: 0x7c450000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 5));
    // 0x159674: 0x0
    // NOP
    // 0x159678: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15967c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x159680; return;
}


// Function: InitEyes__FP4EYESP4SAAF
// Address: 0x159680 - 0x15969c

void entry_15969c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15969c: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1596a0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1596a4: 0xae020040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 2));
    // 0x1596a8: 0x86230014
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1596ac: 0xae03003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 3));
    // 0x1596b0: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1596b4: 0xe600002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    // 0x1596b8: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1596bc: 0xe6010030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x1596c0: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1596c4: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1596c8: 0xc6210010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1596cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1596d0: 0xe6010038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x1596d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1596d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostEyesLoad__FP4EYES
// Address: 0x1596e0 - 0x1596f4

void entry_1596f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1596f4: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1596fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1596fc
// Address: 0x1596fc - 0x159760

void entry_1596fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1596fc) {
        switch (ctx->pc) {
            case 0x159720: ctx->pc = 0; goto label_159720;
            case 0x159724: ctx->pc = 0; goto label_159724;
            case 0x159730: ctx->pc = 0; goto label_159730;
            case 0x159740: ctx->pc = 0; goto label_159740;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1596fc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x159700: 0x10800007
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_159720;
    }
    // 0x159708: 0x8c820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 36)));
    // 0x15970c: 0x14400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_159724;
    }
    // 0x159714: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x159718: 0x50700001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 16)) {
        WRITE32(ADD32(GPR_U32(ctx, 4), 36), GPR_U32(ctx, 16));
        goto label_159720;
    }
label_159720:
    // 0x159720: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_159724:
    // 0x159724: 0x10400002
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_159730;
    }
    // 0x15972c: 0x8c450020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 32)));
label_159730:
    // 0x159730: 0x8e020044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x159734: 0x10400002
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_159740;
    }
    // 0x15973c: 0x8c440020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 32)));
label_159740:
    // 0x159740: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x159744: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x159748: 0x82280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 4));
    // 0x15974c: 0xae030060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 3));
    // 0x159750: 0xae05005c
    WRITE32(ADD32(GPR_U32(ctx, 16), 92), GPR_U32(ctx, 5));
    // 0x159754: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x159758: 0xc0565dc
    SET_GPR_U32(ctx, 31, 0x159760);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetEyesEyess__FP4EYES5EYESS(rdram, ctx, runtime); return;
}


// Function: entry_159760
// Address: 0x159760 - 0x159770

void entry_159760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159760: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x159764: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159768: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetEyesEyess__FP4EYES5EYESS
// Address: 0x159770 - 0x159814

void entry_159814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159814) {
        switch (ctx->pc) {
            case 0x159830: ctx->pc = 0; goto label_159830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159814: 0xc6010038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[1] = *(float*)&val; }
    // 0x159818: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15981c: 0x0
    // NOP
    // 0x159820: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[12] = *(float*)&val; }
        goto label_159830;
    }
    // 0x159828: 0x1000000e
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 104), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159864; return;
    }
label_159830:
    // 0x159830: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x159838);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_159838
// Address: 0x159838 - 0x159890

void entry_159838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159838) {
        switch (ctx->pc) {
            case 0x159840: ctx->pc = 0; goto label_159840;
            case 0x159864: ctx->pc = 0; goto label_159864;
            case 0x159868: ctx->pc = 0; goto label_159868;
            case 0x159874: ctx->pc = 0; goto label_159874;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159838: 0x1000000a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 104), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_159864;
    }
label_159840:
    // 0x159840: 0x8e02005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 92)));
    // 0x159844: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x159848: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x15984c: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x159850: 0x50620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 17));
        goto label_159868;
    }
    // 0x159858: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15985c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x159860: 0xe6000070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 112), *(uint32_t*)&val); }
label_159864:
    // 0x159864: 0xae110060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 17));
label_159868:
    // 0x159868: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15986c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x159870: 0xe6000064
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 100), *(uint32_t*)&val); }
label_159874:
    // 0x159874: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x159878: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15987c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159880: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x159884: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15988c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x159890; return;
}


// Function: UpdateEyes__FP4EYESf
// Address: 0x159890 - 0x1599c4

void entry_1599c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1599c4: 0xc6000070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[0] = *(float*)&val; }
    // 0x1599c8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1599cc: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1599d0: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x1599d8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_1599d8
// Address: 0x1599d8 - 0x1599ec

void entry_1599d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1599d8: 0xc6000070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[0] = *(float*)&val; }
    // 0x1599dc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1599e0: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1599e4: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x1599ec);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 64));
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_1599ec
// Address: 0x1599ec - 0x159a00

void entry_1599ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1599ec) {
        switch (ctx->pc) {
            case 0x1599f0: ctx->pc = 0; goto label_1599f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1599ec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1599f0:
    // 0x1599f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1599f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1599fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x159a00; return;
}


// Function: SetEyesClosed__FP4EYESf
// Address: 0x159a00 - 0x159a2c

void entry_159a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159a2c) {
        switch (ctx->pc) {
            case 0x159a34: ctx->pc = 0; goto label_159a34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159a2c: 0x10000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159A4C; return;
    }
label_159a34:
    // 0x159a34: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x159a38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x159a3c: 0xae020060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 2));
    // 0x159a40: 0xc0565dc
    SET_GPR_U32(ctx, 31, 0x159a48);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetEyesEyess__FP4EYES5EYESS(rdram, ctx, runtime); return;
}


// Function: entry_159a48
// Address: 0x159a48 - 0x159a5c

void entry_159a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159a48) {
        switch (ctx->pc) {
            case 0x159a4c: ctx->pc = 0; goto label_159a4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159a48: 0xc6000070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[0] = *(float*)&val; }
label_159a4c:
    // 0x159a4c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x159a50: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x159a54: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x159a5c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_159a5c
// Address: 0x159a5c - 0x159a70

void entry_159a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159a5c: 0xc6000070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[0] = *(float*)&val; }
    // 0x159a60: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x159a64: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x159a68: 0xc06d1b8
    SET_GPR_U32(ctx, 31, 0x159a70);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 64));
    SetSaiIframe__FP3SAIi(rdram, ctx, runtime); return;
}


// Function: entry_159a70
// Address: 0x159a70 - 0x159a80

void entry_159a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159a70: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x159a74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159a78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsaiFromEyesShd__FP4EYESP3SHD
// Address: 0x159a80 - 0x159a9c

void entry_159a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159a9c) {
        switch (ctx->pc) {
            case 0x159abc: ctx->pc = 0; goto label_159abc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159a9c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x159aa0: 0x14c00006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_159abc;
    }
    // 0x159aa8: 0x86220002
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 17), 2)));
    // 0x159aac: 0x26060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 64));
    // 0x159ab0: 0x8e03003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x159ab4: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x159ab8: 0x2300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 0));
label_159abc:
    // 0x159abc: 0xc0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x159ac0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x159ac4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159ac8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateFader__FP5FADERf
// Address: 0x159ad0 - 0x159b04

void entry_159b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159b04) {
        switch (ctx->pc) {
            case 0x159b10: ctx->pc = 0; goto label_159b10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159b04: 0x10400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_159b54(rdram, ctx, runtime); return;
    }
    // 0x159b0c: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
label_159b10:
    // 0x159b10: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x159b14: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x159b18: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x159b1c: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x159b20: 0x46020036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159b24: 0x0
    // NOP
    // 0x159b28: 0x4500000e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x159B64; return;
    }
    // 0x159b30: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159b34: 0x0
    // NOP
    // 0x159b38: 0x4502000b
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x159B68; return;
    }
    // 0x159b40: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x159b44: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x159b48: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x159b4c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x159b54);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_159b54
// Address: 0x159b54 - 0x159b5c

void entry_159b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159b54: 0xc05670a
    SET_GPR_U32(ctx, 31, 0x159b5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveFader__FP5FADER(rdram, ctx, runtime); return;
}


// Function: entry_159b5c
// Address: 0x159b5c - 0x159b98

void entry_159b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159b5c) {
        switch (ctx->pc) {
            case 0x159b64: ctx->pc = 0; goto label_159b64;
            case 0x159b68: ctx->pc = 0; goto label_159b68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159b5c: 0x1000000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159B9C; return;
    }
label_159b64:
    // 0x159b64: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
label_159b68:
    // 0x159b68: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x159b6c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x159b70: 0x46001036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159b74: 0x0
    // NOP
    // 0x159b78: 0x45000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x159B9C; return;
    }
    // 0x159b80: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159b84: 0x0
    // NOP
    // 0x159b88: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x159BA0; return;
    }
    // 0x159b90: 0xc05670a
    SET_GPR_U32(ctx, 31, 0x159b98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveFader__FP5FADER(rdram, ctx, runtime); return;
}


// Function: entry_159b98
// Address: 0x159b98 - 0x159bb0

void entry_159b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159b98) {
        switch (ctx->pc) {
            case 0x159b9c: ctx->pc = 0; goto label_159b9c;
            case 0x159ba0: ctx->pc = 0; goto label_159ba0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159b98: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_159b9c:
    // 0x159b9c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_159ba0:
    // 0x159ba0: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x159ba4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x159bac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x159bb0; return;
}


// Function: PfaderNew__FP3ALO
// Address: 0x159bb0 - 0x159bd8

void entry_159bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159bd8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x159bdc: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x159be0: 0x8e020294
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 660)));
    // 0x159be4: 0x10400006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159C00; return;
    }
    // 0x159bec: 0x8e445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x159bf0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x159bf8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7216));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_159bf8
// Address: 0x159bf8 - 0x159c0c

void entry_159bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159bf8) {
        switch (ctx->pc) {
            case 0x159c00: ctx->pc = 0; goto label_159c00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159bf8: 0x10000005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159C10; return;
    }
label_159c00:
    // 0x159c00: 0x8e445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x159c04: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x159c0c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7204));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_159c0c
// Address: 0x159c0c - 0x159c28

void entry_159c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159c0c) {
        switch (ctx->pc) {
            case 0x159c10: ctx->pc = 0; goto label_159c10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159c0c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_159c10:
    // 0x159c10: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x159c14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x159c18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x159c1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159c20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveFader__FP5FADER
// Address: 0x159c28 - 0x159c5c

void entry_159c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159c5c) {
        switch (ctx->pc) {
            case 0x159c64: ctx->pc = 0; goto label_159c64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159c5c: 0x10000006
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159C78; return;
    }
label_159c64:
    // 0x159c64: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x159c68: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x159c6c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x159c74);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7204));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_159c74
// Address: 0x159c74 - 0x159c8c

void entry_159c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159c74) {
        switch (ctx->pc) {
            case 0x159c78: ctx->pc = 0; goto label_159c78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159c74: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
label_159c78:
    // 0x159c78: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x159c7c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x159c80: 0x24841c18
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7192));
    // 0x159c84: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x159c8c);
    WRITE32(ADD32(GPR_U32(ctx, 2), 664), GPR_U32(ctx, 0));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_159c8c
// Address: 0x159c8c - 0x159ca0

void entry_159c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159c8c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x159c90: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x159c94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159c98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00159ca0
// Address: 0x159ca0 - 0x159cc4

void FUN_00159ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159ca0: 0x27bdfd10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966544));
    // 0x159ca4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159ca8: 0x7fbf02e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 736), GPR_VEC(ctx, 31));
    // 0x159cac: 0x27a502c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 704));
    // 0x159cb0: 0x7fb002d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 720), GPR_VEC(ctx, 16));
    // 0x159cb4: 0x8c820060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 96)));
    // 0x159cb8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x159cbc: 0xc05a1dc
    SET_GPR_U32(ctx, 31, 0x159cc4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 704), GPR_U32(ctx, 2));
    BuildClearGifs__FP2QWG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_159cc4
// Address: 0x159cc4 - 0x159cd4

void entry_159cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159cc4: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x159cc8: 0x261022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x159ccc: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x159cd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_159cd4
// Address: 0x159cd4 - 0x159ce8

void entry_159cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159cd4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x159cd8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159cdc: 0x2405002c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 44));
    // 0x159ce0: 0xc07b9f4
    SET_GPR_U32(ctx, 31, 0x159ce8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddVifDirect__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_159ce8
// Address: 0x159ce8 - 0x159cf0

void entry_159ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159ce8: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x159cf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_159cf0
// Address: 0x159cf0 - 0x159d00

void entry_159cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159cf0: 0x7bbf02e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 736)));
    // 0x159cf4: 0x7bb002d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 720)));
    // 0x159cf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 752));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00159d00
// Address: 0x159d00 - 0x159de8

void FUN_00159d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159d00) {
        switch (ctx->pc) {
            case 0x159d80: ctx->pc = 0; goto label_159d80;
            case 0x159dc0: ctx->pc = 0; goto label_159dc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159d00: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x159d04: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x159d08: 0x27bdff40
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967104));
    // 0x159d0c: 0x8c445bc4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 23492)));
    // 0x159d10: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x159d14: 0x1483006b
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        entry_159ec4(rdram, ctx, runtime); return;
    }
    // 0x159d1c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x159d20: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x159d24: 0x8c440458
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x159d28: 0x10830066
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        entry_159ec4(rdram, ctx, runtime); return;
    }
    // 0x159d30: 0x10820064
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        entry_159ec4(rdram, ctx, runtime); return;
    }
    // 0x159d38: 0xc4e10054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 84)); ctx->f[1] = *(float*)&val; }
    // 0x159d3c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x159d40: 0xc4e20048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 72)); ctx->f[2] = *(float*)&val; }
    // 0x159d44: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x159d48: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159d4c: 0x0
    // NOP
    // 0x159d50: 0x4500000b
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_159d80;
    }
    // 0x159d58: 0x88e2003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 63); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x159d5c: 0x98e2003c
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 60); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x159d60: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159d64: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159d68: 0x88e20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x159d6c: 0x98e20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x159d70: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159d74: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159d78: 0x10000026
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[2] = ctx->f[0] / ctx->f[1];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159E14; return;
    }
label_159d80:
    // 0x159d80: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x159d84: 0xc4e1004c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 76)); ctx->f[1] = *(float*)&val; }
    // 0x159d88: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159d8c: 0x0
    // NOP
    // 0x159d90: 0x4502000b
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
        goto label_159dc0;
    }
    // 0x159d98: 0x88e20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x159d9c: 0x98e20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x159da0: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159da4: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159da8: 0x88e20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x159dac: 0x98e20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x159db0: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159db4: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159db8: 0x10000016
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[2] = ctx->f[0] / ctx->f[1];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159E14; return;
    }
label_159dc0:
    // 0x159dc0: 0xc4e10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 80)); ctx->f[1] = *(float*)&val; }
    // 0x159dc4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x159dc8: 0x0
    // NOP
    // 0x159dcc: 0x45010008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x159DF0; return;
    }
    // 0x159dd4: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x159dd8: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x159ddc: 0xace0005c
    WRITE32(ADD32(GPR_U32(ctx, 7), 92), GPR_U32(ctx, 0));
    // 0x159de0: 0xc054980
    SET_GPR_U32(ctx, 31, 0x159de8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7384));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_159de8
// Address: 0x159de8 - 0x159ec4

void entry_159de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159de8) {
        switch (ctx->pc) {
            case 0x159df0: ctx->pc = 0; goto label_159df0;
            case 0x159e14: ctx->pc = 0; goto label_159e14;
            case 0x159e30: ctx->pc = 0; goto label_159e30;
            case 0x159eb4: ctx->pc = 0; goto label_159eb4;
            case 0x159eb8: ctx->pc = 0; goto label_159eb8;
            case 0x159ebc: ctx->pc = 0; goto label_159ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159de8: 0x10000037
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x159EC8; return;
    }
label_159df0:
    // 0x159df0: 0x88e20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x159df4: 0x98e20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x159df8: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159dfc: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159e00: 0x88e20047
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 71); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x159e04: 0x98e20044
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 68); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x159e08: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159e0c: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x159e10: 0x46010083
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[2] = ctx->f[0] / ctx->f[1];
label_159e14:
    // 0x159e14: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x159e18: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x159e1c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x159e20: 0x27aa0030
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 48));
    // 0x159e24: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x159e28: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x159e2c: 0x460200c1
    ctx->f[3] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
label_159e30:
    // 0x159e30: 0x1261021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 6)));
    // 0x159e34: 0x1061821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 6)));
    // 0x159e38: 0x90440000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x159e3c: 0x3a62821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 6)));
    // 0x159e40: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x159e44: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x159e48: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x159e4c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x159e50: 0x28c30004
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 4));
    // 0x159e54: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x159e58: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x159e5c: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x159e60: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x159e64: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x159e68: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x159e6c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x159e70: 0x1460ffef
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_159e30;
    }
    // 0x159e78: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x159e7c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x159e80: 0x3c020016
    SET_GPR_U32(ctx, 2, ((uint32_t)22 << 16));
    // 0x159e84: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x159e88: 0x24429ca0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941856));
    // 0x159e8c: 0x8ce40058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 88)));
    // 0x159e90: 0xe7a00034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    // 0x159e94: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
    // 0x159e98: 0x10800006
    WRITE32(ADD32(GPR_U32(ctx, 29), 144), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_159eb4;
    }
    // 0x159ea0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x159ea4: 0x10820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_159eb8;
    }
    // 0x159eac: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_159ebc;
    }
label_159eb4:
    // 0x159eb4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_159eb8:
    // 0x159eb8: 0xafa20038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 2));
label_159ebc:
    // 0x159ebc: 0xc067504
    SET_GPR_U32(ctx, 31, 0x159ec4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_159ec4
// Address: 0x159ec4 - 0x159ed0

void entry_159ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159ec4) {
        switch (ctx->pc) {
            case 0x159ec8: ctx->pc = 0; goto label_159ec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159ec4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_159ec8:
    // 0x159ec8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00159ed0
// Address: 0x159ed0 - 0x159f10

void FUN_00159ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x159ed0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x159ed4: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x159ed8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x159edc: 0x8ce2005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 92)));
    // 0x159ee0: 0x1440000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x159F14; return;
    }
    // 0x159ee8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x159eec: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x159ef0: 0x8c645710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x159ef4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x159ef8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x159efc: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x159f00: 0xace6005c
    WRITE32(ADD32(GPR_U32(ctx, 7), 92), GPR_U32(ctx, 6));
    // 0x159f04: 0x24841cd8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7384));
    // 0x159f08: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x159f10);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 84), *(uint32_t*)&val); }
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_159f10
// Address: 0x159f10 - 0x159f20

void entry_159f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x159f10) {
        switch (ctx->pc) {
            case 0x159f14: ctx->pc = 0; goto label_159f14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x159f10: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_159f14:
    // 0x159f14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x159f1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x159f20; return;
}


// Function: PdlFromSwOid__FP2SW3OID
// Address: 0x159f20 - 0x159f48

void entry_15a150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a150) {
        switch (ctx->pc) {
            case 0x15a15c: ctx->pc = 0; goto label_15a15c;
            case 0x15a170: ctx->pc = 0; goto label_15a170;
            case 0x15a17c: ctx->pc = 0; goto label_15a17c;
            case 0x15a180: ctx->pc = 0; goto label_15a180;
            case 0x15a184: ctx->pc = 0; goto label_15a184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a150: 0x1040000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a180;
    }
    // 0x15a158: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_15a15c:
    // 0x15a15c: 0x73102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 19)));
    // 0x15a160: 0x10400003
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a170;
    }
    // 0x15a168: 0x521021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x15a16c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
label_15a170:
    // 0x15a170: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15a174: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15a178: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_15a17c:
    // 0x15a17c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_15a180:
    // 0x15a180: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_15a184:
    // 0x15a184: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15a188: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a18c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a190: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CploFindSwObjects__FP2SWi3OIDP2LOiPP2LO
// Address: 0x15a198 - 0x15a1e4

void entry_15a1e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a1e4) {
        switch (ctx->pc) {
            case 0x15a21c: ctx->pc = 0; goto label_15a21c;
            case 0x15a23c: ctx->pc = 0; goto label_15a23c;
            case 0x15a240: ctx->pc = 0; goto label_15a240;
            case 0x15a260: ctx->pc = 0; goto label_15a260;
            case 0x15a284: ctx->pc = 0; goto label_15a284;
            case 0x15a2a0: ctx->pc = 0; goto label_15a2a0;
            case 0x15a2a8: ctx->pc = 0; goto label_15a2a8;
            case 0x15a2ac: ctx->pc = 0; goto label_15a2ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a1e4: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x15a1e8: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15a1ec: 0x1043002c
    SET_GPR_U32(ctx, 19, AND32(GPR_U32(ctx, 22), 255));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_15a2a0;
    }
    // 0x15a1f4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15a1f8: 0x12620008
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_15a21c;
    }
    // 0x15a200: 0x12600029
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 5));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_15a2a8;
    }
    // 0x15a208: 0x10400027
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a2a8;
    }
    // 0x15a210: 0x14400026
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15a2ac;
    }
    // 0x15a218: 0x2a0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_15a21c:
    // 0x15a21c: 0x12800008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_15a240;
    }
    // 0x15a224: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x15a228: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x15a22c: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x15a230: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x15a234: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 20), 24)));
        goto label_15a23c;
    }
label_15a23c:
    // 0x15a23c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_15a240:
    // 0x15a240: 0x10800010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_15a284;
    }
    // 0x15a248: 0x2406c3ff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294951935));
    // 0x15a24c: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15a250: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x15a254: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15a258: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x15a25c: 0xdc8302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 712)));
label_15a260:
    // 0x15a260: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x15a264: 0x30a2000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 15));
    // 0x15a268: 0x212bc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 10));
    // 0x15a26c: 0x661824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x15a270: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15a274: 0xfc8302c8
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 3));
    // 0x15a278: 0x8c840018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x15a27c: 0x5480fff8
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 712)));
        goto label_15a260;
    }
label_15a284:
    // 0x15a284: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x15a288: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x15a28c: 0x16a00007
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        goto label_15a2ac;
    }
    // 0x15a294: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15a298: 0x16620004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        goto label_15a2ac;
    }
label_15a2a0:
    // 0x15a2a0: 0x10000051
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A3E8; return;
    }
label_15a2a8:
    // 0x15a2a8: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_15a2ac:
    // 0x15a2ac: 0x32c20200
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 22), 512));
    // 0x15a2b0: 0x8fa5001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x15a2b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15a2b8: 0xafa00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    // 0x15a2bc: 0xc0567c8
    SET_GPR_U32(ctx, 31, 0x15a2c4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    PdlFromSwOid__FP2SW3OID(rdram, ctx, runtime); return;
}


// Function: entry_15a2c4
// Address: 0x15a2c4 - 0x15a32c

void entry_15a2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a2c4) {
        switch (ctx->pc) {
            case 0x15a2d8: ctx->pc = 0; goto label_15a2d8;
            case 0x15a308: ctx->pc = 0; goto label_15a308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a2c4: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15a2c8: 0x1220002f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 24));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A388; return;
    }
    // 0x15a2d0: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x15a2d4: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_15a2d8:
    // 0x15a2d8: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x15a2dc: 0x54820028
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x15A380; return;
    }
    // 0x15a2e4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15a2e8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x15a2ec: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x15a2f0: 0x50400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 48)));
        ctx->pc = 0x15A340; return;
    }
    // 0x15a2f8: 0x8e3002d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x15a2fc: 0x1200001f
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 24));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_15a37c(rdram, ctx, runtime); return;
    }
    // 0x15a304: 0xafb20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
label_15a308:
    // 0x15a308: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15a30c: 0x32c60100
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 22), 256));
    // 0x15a310: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15a314: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15a318: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x15a31c: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x15a320: 0x27aa0014
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 20));
    // 0x15a324: 0xc0567d2
    SET_GPR_U32(ctx, 31, 0x15a32c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime); return;
}


// Function: entry_15a32c
// Address: 0x15a32c - 0x15a37c

void entry_15a32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a32c) {
        switch (ctx->pc) {
            case 0x15a340: ctx->pc = 0; goto label_15a340;
            case 0x15a354: ctx->pc = 0; goto label_15a354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a32c: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15a330: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
        ctx->pc = 0x15A308; return;
    }
    // 0x15a338: 0x10000011
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A380; return;
    }
label_15a340:
    // 0x15a340: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
        goto label_15a354;
    }
    // 0x15a348: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x15a34c: 0x1044000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        entry_15a37c(rdram, ctx, runtime); return;
    }
label_15a354:
    // 0x15a354: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15a358: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15a35c: 0x32c60100
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 22), 256));
    // 0x15a360: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x15a364: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15a368: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x15a36c: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x15a370: 0x27aa0014
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 20));
    // 0x15a374: 0xc0567d2
    SET_GPR_U32(ctx, 31, 0x15a37c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime); return;
}


// Function: entry_15a37c
// Address: 0x15a37c - 0x15a418

void entry_15a37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a37c) {
        switch (ctx->pc) {
            case 0x15a380: ctx->pc = 0; goto label_15a380;
            case 0x15a388: ctx->pc = 0; goto label_15a388;
            case 0x15a3b0: ctx->pc = 0; goto label_15a3b0;
            case 0x15a3d0: ctx->pc = 0; goto label_15a3d0;
            case 0x15a3e4: ctx->pc = 0; goto label_15a3e4;
            case 0x15a3e8: ctx->pc = 0; goto label_15a3e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a37c: 0x8e31000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_15a380:
    // 0x15a380: 0x5620ffd5
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x15A2D8; return;
    }
label_15a388:
    // 0x15a388: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15a38c: 0x10800010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_15a3d0;
    }
    // 0x15a394: 0x2403c3ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294951935));
    // 0x15a398: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x15a39c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x15a3a0: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x15a3a4: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x15a3a8: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x15a3ac: 0x0
    // NOP
label_15a3b0:
    // 0x15a3b0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15a3b4: 0xfc8202c8
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    // 0x15a3b8: 0x8c840018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x15a3bc: 0x0
    // NOP
    // 0x15a3c0: 0x0
    // NOP
    // 0x15a3c4: 0x5480fffa
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
        goto label_15a3b0;
    }
    // 0x15a3cc: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
label_15a3d0:
    // 0x15a3d0: 0x14400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15a3e8;
    }
    // 0x15a3d8: 0x2e2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 23), GPR_S32(ctx, 2)));
    // 0x15a3dc: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 23));
        goto label_15a3e4;
    }
label_15a3e4:
    // 0x15a3e4: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
label_15a3e8:
    // 0x15a3e8: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x15a3ec: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x15a3f0: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x15a3f4: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15a3f8: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15a3fc: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15a400: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15a404: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15a408: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15a40c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15a410: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PloFindSwObject__FP2SWi3OIDP2LO
// Address: 0x15a418 - 0x15a434

void entry_15a434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a434: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a438: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a43c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15a444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15a448; return;
}


// Function: PloFindSwNearest__FP2SW3OIDP2LO
// Address: 0x15a448 - 0x15a46c

void entry_15a46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a46c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a470: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a474: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15a47c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15a480; return;
}


// Function: PloFindSwChild__FP2SW3OIDP3ALO
// Address: 0x15a480 - 0x15a4a4

void entry_15a4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a4a4: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a4a8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a4ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15a4b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15a4b8; return;
}


// Function: FIsCidDerivedFrom__F3CIDT0
// Address: 0x15a4b8 - 0x15a4f0

void entry_15a590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a590: 0x50400011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x15A5D8; return;
    }
    // 0x15a598: 0x16200005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A5B0; return;
    }
    // 0x15a5a0: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x15a5a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_15a5a8
// Address: 0x15a5a8 - 0x15a638

void entry_15a5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a5a8) {
        switch (ctx->pc) {
            case 0x15a5b0: ctx->pc = 0; goto label_15a5b0;
            case 0x15a5c8: ctx->pc = 0; goto label_15a5c8;
            case 0x15a5d4: ctx->pc = 0; goto label_15a5d4;
            case 0x15a5d8: ctx->pc = 0; goto label_15a5d8;
            case 0x15a5e8: ctx->pc = 0; goto label_15a5e8;
            case 0x15a618: ctx->pc = 0; goto label_15a618;
            case 0x15a620: ctx->pc = 0; goto label_15a620;
            case 0x15a630: ctx->pc = 0; goto label_15a630;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a5a8: 0x1040000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a5d4;
    }
label_15a5b0:
    // 0x15a5b0: 0x77102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 23)));
    // 0x15a5b4: 0x10400004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a5c8;
    }
    // 0x15a5bc: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x15a5c0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15a5c4: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
label_15a5c8:
    // 0x15a5c8: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a5cc: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15a5d0: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
label_15a5d4:
    // 0x15a5d4: 0x8e100018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
label_15a5d8:
    // 0x15a5d8: 0x1600ffeb
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A588; return;
    }
    // 0x15a5e0: 0x10000083
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A7F0; return;
    }
label_15a5e8:
    // 0x15a5e8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15a5ec: 0x16620022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x15A678; return;
    }
    // 0x15a5f4: 0x32a20100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 256));
    // 0x15a5f8: 0x1440001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A678; return;
    }
    // 0x15a600: 0x8ec30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x15a604: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x15a608: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x15a60c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x15a610: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 22), 52)));
        goto label_15a620;
    }
label_15a618:
    // 0x15a618: 0x1000007b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A808; return;
    }
label_15a620:
    // 0x15a620: 0x32b50200
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 21), 512));
    // 0x15a624: 0x12000071
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A7EC; return;
    }
    // 0x15a62c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_15a630:
    // 0x15a630: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x15a638);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_15a638
// Address: 0x15a638 - 0x15a77c

void entry_15a638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a638) {
        switch (ctx->pc) {
            case 0x15a658: ctx->pc = 0; goto label_15a658;
            case 0x15a664: ctx->pc = 0; goto label_15a664;
            case 0x15a678: ctx->pc = 0; goto label_15a678;
            case 0x15a69c: ctx->pc = 0; goto label_15a69c;
            case 0x15a6bc: ctx->pc = 0; goto label_15a6bc;
            case 0x15a6c0: ctx->pc = 0; goto label_15a6c0;
            case 0x15a6e8: ctx->pc = 0; goto label_15a6e8;
            case 0x15a70c: ctx->pc = 0; goto label_15a70c;
            case 0x15a71c: ctx->pc = 0; goto label_15a71c;
            case 0x15a720: ctx->pc = 0; goto label_15a720;
            case 0x15a728: ctx->pc = 0; goto label_15a728;
            case 0x15a738: ctx->pc = 0; goto label_15a738;
            case 0x15a758: ctx->pc = 0; goto label_15a758;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a638: 0x1040000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a664;
    }
    // 0x15a640: 0x77102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 23)));
    // 0x15a644: 0x10400004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a658;
    }
    // 0x15a64c: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x15a650: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15a654: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
label_15a658:
    // 0x15a658: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a65c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15a660: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
label_15a664:
    // 0x15a664: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x15a668: 0x1600fff1
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A630; return;
    }
    // 0x15a670: 0x1000005f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A7F0; return;
    }
label_15a678:
    // 0x15a678: 0x12620008
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_15a69c;
    }
    // 0x15a680: 0x12600026
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 5));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_15a71c;
    }
    // 0x15a688: 0x10400024
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15a71c;
    }
    // 0x15a690: 0x14400023
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 21), 512));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15a720;
    }
    // 0x15a698: 0x2c0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_15a69c:
    // 0x15a69c: 0x12800008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 512));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_15a6c0;
    }
    // 0x15a6a4: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x15a6a8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x15a6ac: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x15a6b0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x15a6b4: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 20), 24)));
        goto label_15a6bc;
    }
label_15a6bc:
    // 0x15a6bc: 0x32a20200
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 512));
label_15a6c0:
    // 0x15a6c0: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15a6c4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15a6c8: 0x10a00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_15a70c;
    }
    // 0x15a6d0: 0x2407c3ff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294951935));
    // 0x15a6d4: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x15a6d8: 0x34e7ffff
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65535));
    // 0x15a6dc: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x15a6e0: 0x34e7ffff
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65535));
    // 0x15a6e4: 0xdca302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 5), 712)));
label_15a6e8:
    // 0x15a6e8: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x15a6ec: 0x30c2000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), 15));
    // 0x15a6f0: 0x212bc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 10));
    // 0x15a6f4: 0x671824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x15a6f8: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15a6fc: 0xfca302c8
    WRITE64(ADD32(GPR_U32(ctx, 5), 712), GPR_U64(ctx, 3));
    // 0x15a700: 0x8ca50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x15a704: 0x54a0fff8
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 5), 712)));
        goto label_15a6e8;
    }
label_15a70c:
    // 0x15a70c: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x15a710: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x15a714: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15a728;
    }
label_15a71c:
    // 0x15a71c: 0x32a30200
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 21), 512));
label_15a720:
    // 0x15a720: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15a724: 0xafa30020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 3));
label_15a728:
    // 0x15a728: 0x24841884
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6276));
    // 0x15a72c: 0x3c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x15a730: 0x10000016
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A78C; return;
    }
label_15a738:
    // 0x15a738: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x15a73c: 0x26120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1));
    // 0x15a740: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15a744: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15a748: 0x52000010
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x15A78C; return;
    }
    // 0x15a750: 0x27b10014
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 20));
    // 0x15a754: 0x8fab0018
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 24)));
label_15a758:
    // 0x15a758: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15a75c: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x15a760: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15a764: 0x32a60100
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 21), 256));
    // 0x15a768: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15a76c: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15a770: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x15a774: 0xc0567d2
    SET_GPR_U32(ctx, 31, 0x15a77c);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 16));
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime); return;
}


// Function: entry_15a77c
// Address: 0x15a77c - 0x15a7a0

void entry_15a77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a77c) {
        switch (ctx->pc) {
            case 0x15a78c: ctx->pc = 0; goto label_15a78c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a77c: 0x8e100024
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x15a780: 0x1600fff5
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A758; return;
    }
    // 0x15a788: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_15a78c:
    // 0x15a78c: 0x2e020095
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 149));
    // 0x15a790: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A7A8; return;
    }
    // 0x15a798: 0xc05692e
    SET_GPR_U32(ctx, 31, 0x15a7a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    FIsCidDerivedFrom__F3CIDT0(rdram, ctx, runtime); return;
}


// Function: entry_15a7a0
// Address: 0x15a7a0 - 0x15a838

void entry_15a7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15a7a0) {
        switch (ctx->pc) {
            case 0x15a7a8: ctx->pc = 0; goto label_15a7a8;
            case 0x15a7d0: ctx->pc = 0; goto label_15a7d0;
            case 0x15a7ec: ctx->pc = 0; goto label_15a7ec;
            case 0x15a7f0: ctx->pc = 0; goto label_15a7f0;
            case 0x15a804: ctx->pc = 0; goto label_15a804;
            case 0x15a808: ctx->pc = 0; goto label_15a808;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15a7a0: 0x1440ffe5
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15A738; return;
    }
label_15a7a8:
    // 0x15a7a8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15a7ac: 0x10a00010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_15a7f0;
    }
    // 0x15a7b4: 0x2403c3ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294951935));
    // 0x15a7b8: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x15a7bc: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x15a7c0: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x15a7c4: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x15a7c8: 0xdca202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 712)));
    // 0x15a7cc: 0x0
    // NOP
label_15a7d0:
    // 0x15a7d0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15a7d4: 0xfca202c8
    WRITE64(ADD32(GPR_U32(ctx, 5), 712), GPR_U64(ctx, 2));
    // 0x15a7d8: 0x8ca50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x15a7dc: 0x0
    // NOP
    // 0x15a7e0: 0x0
    // NOP
    // 0x15a7e4: 0x54a0fffa
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 712)));
        goto label_15a7d0;
    }
label_15a7ec:
    // 0x15a7ec: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_15a7f0:
    // 0x15a7f0: 0x14400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15a808;
    }
    // 0x15a7f8: 0x2e2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 23), GPR_S32(ctx, 2)));
    // 0x15a7fc: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 23));
        goto label_15a804;
    }
label_15a804:
    // 0x15a804: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
label_15a808:
    // 0x15a808: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x15a80c: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x15a810: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x15a814: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15a818: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15a81c: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15a820: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15a824: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15a828: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15a82c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15a830: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PloFindSwObjectByClass__FP2SWi3CIDP2LO
// Address: 0x15a838 - 0x15a854

void entry_15a854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a854: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a858: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a85c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15a864: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15a868; return;
}


// Function: PaloFindLoCommonParent__FP2LOT0
// Address: 0x15a868 - 0x15a8b0

void entry_15a8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a8cc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15a8d0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15a8d4: 0x260202e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 736));
    // 0x15a8d8: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x15a8dc: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x15a8e0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x15a8e4: 0xe60002e0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 736), *(uint32_t*)&val); }
    // 0x15a8e8: 0xe60002f0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 752), *(uint32_t*)&val); }
    // 0x15a8ec: 0xe60002ec
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 748), *(uint32_t*)&val); }
    // 0x15a8f0: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x15a8f4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x15a8f8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x15a8fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a900: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a904: 0xe4410008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x15a908: 0xe4420004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x15a90c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15a914: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15a918; return;
}


// Function: LoadFlashFromBrx__FP5FLASHP18CBinaryInputStream
// Address: 0x15a918 - 0x15a934

void entry_15a934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a934: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15a938: 0x260802dc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 732));
    // 0x15a93c: 0x260502d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 720));
    // 0x15a940: 0x260602d4
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 724));
    // 0x15a944: 0xc079312
    SET_GPR_U32(ctx, 31, 0x15a94c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 728));
    LoadTbspFromBrx__FP18CBinaryInputStreamPiPP5TSURFT1PP4TBSP(rdram, ctx, runtime); return;
}


// Function: entry_15a94c
// Address: 0x15a94c - 0x15a960

void entry_15a94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a94c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15a950: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a954: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a958: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateFlash__FP5FLASHf
// Address: 0x15a960 - 0x15a974

void entry_15a974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a974: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15a978: 0xc60c02ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 748)); ctx->f[12] = *(float*)&val; }
    // 0x15a97c: 0xc60d02f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 752)); ctx->f[13] = *(float*)&val; }
    // 0x15a980: 0x260402e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 736));
    // 0x15a984: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x15a988: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x15a990);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_15a990
// Address: 0x15a990 - 0x15a9a8

void entry_15a990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a990: 0xe60002ec
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 748), *(uint32_t*)&val); }
    // 0x15a994: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15a998: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15a99c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15a9a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15a9a8; return;
}


// Function: RenderFlashSelf__FP5FLASHP2CMP2RO
// Address: 0x15a9a8 - 0x15a9dc

void entry_15a9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a9dc: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x15a9e0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15a9e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15a9e8: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x15a9f0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_15a9f0
// Address: 0x15a9f0 - 0x15aa00

void entry_15a9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15a9f0: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x15a9f4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15a9f8: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x15aa00);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_15aa00
// Address: 0x15aa00 - 0x15aa30

void entry_15aa00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15aa00: 0x7ba80090
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15aa04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15aa08: 0x7ba700a0
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x15aa0c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15aa10: 0x7ba300b0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x15aa14: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15aa18: 0x7ba200c0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x15aa1c: 0x7fa80040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 8));
    // 0x15aa20: 0x7fa70050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 7));
    // 0x15aa24: 0x7fa30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 3));
    // 0x15aa28: 0xc049870
    SET_GPR_U32(ctx, 31, 0x15aa30);
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    RenderAloSelf__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_15aa30
// Address: 0x15aa30 - 0x15aa50

void entry_15aa30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15aa30: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x15aa34: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x15aa38: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x15aa3c: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x15aa40: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x15aa44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15aa4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15aa50; return;
}


// Function: FPosFlashWithin__FP5FLASHP6VECTOR
// Address: 0x15aa50 - 0x15aa94

void entry_15aa94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15aa94: 0xc60102ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 748)); ctx->f[1] = *(float*)&val; }
    // 0x15aa98: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15aa9c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15aaa0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15aaa4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15aaa8: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x15aaac: 0x8e0402dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 732)));
    // 0x15aab0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x15aab4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x15aab8: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15aabc: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15aac0: 0xc079370
    SET_GPR_U32(ctx, 31, 0x15aac8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    FCheckTbspPoint__FP4TBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_15aac8
// Address: 0x15aac8 - 0x15aae0

void entry_15aac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15aac8) {
        switch (ctx->pc) {
            case 0x15aad0: ctx->pc = 0; goto label_15aad0;
            case 0x15aad4: ctx->pc = 0; goto label_15aad4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15aac8: 0x10000002
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15aad4;
    }
label_15aad0:
    // 0x15aad0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_15aad4:
    // 0x15aad4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15aad8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitFly__FP3FLY
// Address: 0x15aae0 - 0x15aaf4

void entry_15aaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15aaf4: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15aaf8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15aafc: 0xae070554
    WRITE32(ADD32(GPR_U32(ctx, 16), 1364), GPR_U32(ctx, 7));
    // 0x15ab00: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15ab04: 0x24482180
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 8576));
    // 0x15ab08: 0x69040007
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15ab0c: 0x6d040000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15ab10: 0xb2040617
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1559); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab14: 0xb6040610
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1552); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab18: 0x24662188
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 8584));
    // 0x15ab1c: 0x68c90007
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x15ab20: 0x6cc90000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x15ab24: 0xb209061f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1567); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab28: 0xb6090618
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1560); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab2c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15ab30: 0x24852190
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 8592));
    // 0x15ab34: 0x68a80007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x15ab38: 0x6ca80000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x15ab3c: 0xb2080627
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1575); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab40: 0xb6080620
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1568); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab44: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ab48: 0x24442198
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 8600));
    // 0x15ab4c: 0x68860007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x15ab50: 0x6c860000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x15ab54: 0xb206062f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1583); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab58: 0xb6060628
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1576); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab5c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15ab60: 0xae070630
    WRITE32(ADD32(GPR_U32(ctx, 16), 1584), GPR_U32(ctx, 7));
    // 0x15ab64: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15ab68: 0x246221a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8608));
    // 0x15ab6c: 0x68460007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x15ab70: 0x6c460000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x15ab74: 0xb2060643
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1603); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab78: 0xb606063c
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1596); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab7c: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x15ab80: 0x248221a8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 8616));
    // 0x15ab84: 0x68430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x15ab88: 0x6c430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x15ab8c: 0xb2030657
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1623); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab90: 0xb6030650
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1616); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ab94: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x15ab98: 0x24a221b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 8624));
    // 0x15ab9c: 0x68440007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15aba0: 0x6c440000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15aba4: 0xb204065f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1631); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15aba8: 0xb6040658
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1624); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15abac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15abb0: 0x24c921b8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 6), 8632));
    // 0x15abb4: 0x69240007
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15abb8: 0x6d240000
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15abbc: 0xb2040667
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1639); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15abc0: 0xb6040660
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1632); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15abc4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15abc8: 0x246921c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 3), 8640));
    // 0x15abcc: 0x69240007
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15abd0: 0x6d240000
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x15abd4: 0xb2040677
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1655); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15abd8: 0xb6040670
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1648); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15abdc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15abe0: 0xae02068c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1676), GPR_U32(ctx, 2));
    // 0x15abe4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x15abe8: 0xae070690
    WRITE32(ADD32(GPR_U32(ctx, 16), 1680), GPR_U32(ctx, 7));
    // 0x15abec: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x15abf4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7240));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15abf4
// Address: 0x15abf4 - 0x15ac08

void entry_15abf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15abf4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15abf8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15abfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15ac04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15ac08; return;
}


// Function: LoadFlyFromBrx__FP3FLYP18CBinaryInputStream
// Address: 0x15ac08 - 0x15ac3c

void entry_15ac3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ac3c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x15ac40: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15ac44: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15ac48: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x15ac50);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8648));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_15ac50
// Address: 0x15ac50 - 0x15ac5c

void entry_15ac50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ac50: 0x262405d4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1492));
    // 0x15ac54: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x15ac5c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15ac5c
// Address: 0x15ac5c - 0x15ac70

void entry_15ac5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ac5c) {
        switch (ctx->pc) {
            case 0x15ac60: ctx->pc = 0; goto label_15ac60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ac5c: 0x2672023c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 572));
label_15ac60:
    // 0x15ac60: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x15ac64: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15ac68: 0xc056920
    SET_GPR_U32(ctx, 31, 0x15ac70);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15ac70
// Address: 0x15ac70 - 0x15ac84

void entry_15ac70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ac70: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15ac74: 0x52000012
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        ctx->pc = 0x15ACC0; return;
    }
    // 0x15ac7c: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x15ac84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_15ac84
// Address: 0x15ac84 - 0x15acf4

void entry_15ac84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ac84) {
        switch (ctx->pc) {
            case 0x15aca8: ctx->pc = 0; goto label_15aca8;
            case 0x15acc0: ctx->pc = 0; goto label_15acc0;
            case 0x15ace8: ctx->pc = 0; goto label_15ace8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ac84: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x15ac88: 0x54550007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        goto label_15aca8;
    }
    // 0x15ac90: 0x8e220630
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1584)));
    // 0x15ac94: 0x54520004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
        goto label_15aca8;
    }
    // 0x15ac9c: 0x8e220564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
    // 0x15aca0: 0xae220634
    WRITE32(ADD32(GPR_U32(ctx, 17), 1588), GPR_U32(ctx, 2));
    // 0x15aca4: 0x8e230564
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
label_15aca8:
    // 0x15aca8: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x15acac: 0x2821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x15acb0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x15acb4: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x15acb8: 0xae230564
    WRITE32(ADD32(GPR_U32(ctx, 17), 1380), GPR_U32(ctx, 3));
    // 0x15acbc: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_15acc0:
    // 0x15acc0: 0x2e620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 16));
    // 0x15acc4: 0x1440ffe6
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 572));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15AC60; return;
    }
    // 0x15accc: 0x8e230550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x15acd0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15acd4: 0x54620017
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
        ctx->pc = 0x15AD34; return;
    }
    // 0x15acdc: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15ace0: 0x263205b0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1456));
    // 0x15ace4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_15ace8:
    // 0x15ace8: 0x2665024d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 589));
    // 0x15acec: 0xc056920
    SET_GPR_U32(ctx, 31, 0x15acf4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15acf4
// Address: 0x15acf4 - 0x15ad08

void entry_15acf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15acf4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15acf8: 0x5200000a
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        ctx->pc = 0x15AD24; return;
    }
    // 0x15ad00: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x15ad08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_15ad08
// Address: 0x15ad08 - 0x15ad48

void entry_15ad08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ad08) {
        switch (ctx->pc) {
            case 0x15ad24: ctx->pc = 0; goto label_15ad24;
            case 0x15ad34: ctx->pc = 0; goto label_15ad34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ad08: 0x8e2305ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1452)));
    // 0x15ad0c: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x15ad10: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x15ad14: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x15ad18: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x15ad1c: 0xae2305ac
    WRITE32(ADD32(GPR_U32(ctx, 17), 1452), GPR_U32(ctx, 3));
    // 0x15ad20: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_15ad24:
    // 0x15ad24: 0x2e620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 8));
    // 0x15ad28: 0x5440ffef
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x15ACE8; return;
    }
    // 0x15ad30: 0x8e220550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
label_15ad34:
    // 0x15ad34: 0x10400009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15ad5c(rdram, ctx, runtime); return;
    }
    // 0x15ad3c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x15ad40: 0xc0549b4
    SET_GPR_U32(ctx, 31, 0x15ad48);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7240));
    FFindDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15ad48
// Address: 0x15ad48 - 0x15ad5c

void entry_15ad48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ad48: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15ad5c(rdram, ctx, runtime); return;
    }
    // 0x15ad50: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x15ad54: 0xc054980
    SET_GPR_U32(ctx, 31, 0x15ad5c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7240));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15ad5c
// Address: 0x15ad5c - 0x15ad80

void entry_15ad5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ad5c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15ad60: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15ad64: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15ad68: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15ad6c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15ad70: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ad74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ad78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneFly__FP3FLYT0
// Address: 0x15ad80 - 0x15ada8

void entry_15ada8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ada8: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x15adac: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x15adb0: 0xb20205e3
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1507); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15adb4: 0xb60205dc
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1500); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15adb8: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x15adbc: 0x54400012
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x15AE08; return;
    }
    // 0x15adc4: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x15adc8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15adcc: 0x3c01442f
    SET_GPR_U32(ctx, 1, ((uint32_t)17455 << 16));
    // 0x15add0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15add4: 0x24040041
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 65));
    // 0x15add8: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x15addc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x15ade0: 0x260505e4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1508));
    // 0x15ade4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15ade8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x15adec: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15adf0: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x15adf4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15adf8: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x15ae00);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_15ae00
// Address: 0x15ae00 - 0x15ae14

void entry_15ae00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ae00) {
        switch (ctx->pc) {
            case 0x15ae08: ctx->pc = 0; goto label_15ae08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ae00: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15AE2C; return;
    }
label_15ae08:
    // 0x15ae08: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15ae0c: 0xc0549b4
    SET_GPR_U32(ctx, 31, 0x15ae14);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7240));
    FFindDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15ae14
// Address: 0x15ae14 - 0x15ae28

void entry_15ae14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ae14: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15ae28(rdram, ctx, runtime); return;
    }
    // 0x15ae1c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x15ae20: 0xc054980
    SET_GPR_U32(ctx, 31, 0x15ae28);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7240));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15ae28
// Address: 0x15ae28 - 0x15ae38

void entry_15ae28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ae28) {
        switch (ctx->pc) {
            case 0x15ae2c: ctx->pc = 0; goto label_15ae2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ae28: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_15ae2c:
    // 0x15ae2c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ae30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreezeFly__FP3FLYi
// Address: 0x15ae38 - 0x15ae64

void entry_15ae64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ae64) {
        switch (ctx->pc) {
            case 0x15ae6c: ctx->pc = 0; goto label_15ae6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ae64: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15AEA8; return;
    }
label_15ae6c:
    // 0x15ae6c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x15ae70: 0x3c01442f
    SET_GPR_U32(ctx, 1, ((uint32_t)17455 << 16));
    // 0x15ae74: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15ae78: 0x24040041
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 65));
    // 0x15ae7c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x15ae80: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x15ae84: 0x246505e4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 1508));
    // 0x15ae88: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15ae8c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x15ae90: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15ae94: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x15ae98: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15ae9c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x15aea4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_15aea4
// Address: 0x15aea4 - 0x15aeb0

void entry_15aea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15aea4) {
        switch (ctx->pc) {
            case 0x15aea8: ctx->pc = 0; goto label_15aea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15aea4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_15aea8:
    // 0x15aea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostFlyLoad__FP3FLY
// Address: 0x15aeb0 - 0x15aed4

void entry_15aed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15aed4: 0x8e230550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x15aed8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15aedc: 0x54620010
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
        ctx->pc = 0x15AF20; return;
    }
    // 0x15aee4: 0xc62c063c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1596)); ctx->f[12] = *(float*)&val; }
    // 0x15aee8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15aef0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1600)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15aef0
// Address: 0x15aef0 - 0x15af10

void entry_15aef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15aef0: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x15aef4: 0xc62c0670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1648)); ctx->f[12] = *(float*)&val; }
    // 0x15aef8: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x15aefc: 0xc62d0674
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1652)); ctx->f[13] = *(float*)&val; }
    // 0x15af00: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15af04: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15af08: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15af10);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1672), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15af10
// Address: 0x15af10 - 0x15af28

void entry_15af10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15af10) {
        switch (ctx->pc) {
            case 0x15af20: ctx->pc = 0; goto label_15af20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15af10: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15af14: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15af18: 0xe6210680
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1664), *(uint32_t*)&val); }
    // 0x15af1c: 0x8e250560
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
label_15af20:
    // 0x15af20: 0xc056dee
    SET_GPR_U32(ctx, 31, 0x15af28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetFlyFlys__FP3FLY4FLYS(rdram, ctx, runtime); return;
}


// Function: entry_15af28
// Address: 0x15af28 - 0x15af30

void entry_15af28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15af28: 0xc049292
    SET_GPR_U32(ctx, 31, 0x15af30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15af30
// Address: 0x15af30 - 0x15af50

void entry_15af30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15af30: 0xc62003cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[0] = *(float*)&val; }
    // 0x15af34: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15af38: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x15af3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15af40: 0xe620064c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1612), *(uint32_t*)&val); }
    // 0x15af44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15af48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetFlyAccel__FP3FLYf
// Address: 0x15af50 - 0x15afe8

void entry_15afe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15afe8: 0x4615a503
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[21];
    // 0x15afec: 0xda620150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 336)));
    // 0x15aff0: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15aff4: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x15aff8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15affc: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x15b000: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x15b004: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15b008: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15b00c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b010: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b014: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x15b018: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x15b01c: 0x4be30898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15b020: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x15b024: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x15b02c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_15b02c
// Address: 0x15b02c - 0x15b038

void entry_15b02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b02c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b030: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x15b038);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_15b038
// Address: 0x15b038 - 0x15b05c

void entry_15b038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b038: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15b03c: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x15b040: 0xda620350
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 848)));
    // 0x15b044: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b048: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15b04c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15b050: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15b054: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x15b05c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_15b05c
// Address: 0x15b05c - 0x15b080

void entry_15b05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b05c: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x15b060: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x15b064: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15b068: 0x266400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 208));
    // 0x15b06c: 0x24c621f8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8696));
    // 0x15b070: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x15b074: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b078: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x15b080);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_15b080
// Address: 0x15b080 - 0x15b094

void entry_15b080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b080: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x15b084: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15b088: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x15b08c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15b094);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15b094
// Address: 0x15b094 - 0x15b0a8

void entry_15b094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b094: 0x1000001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B108; return;
    }
    // 0x15b09c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15b0a0: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x15b0a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 848));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_15b0a8
// Address: 0x15b0a8 - 0x15b0d0

void entry_15b0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b0a8: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x15b0ac: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x15b0b0: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x15b0b4: 0x25082210
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 8720));
    // 0x15b0b8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15b0bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b0c0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b0c4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b0c8: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x15b0d0);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_15b0d0
// Address: 0x15b0d0 - 0x15b0f0

void entry_15b0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b0d0: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x15b0d4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15b0d8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b0dc: 0x25082220
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 8736));
    // 0x15b0e0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x15b0e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b0e8: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x15b0f0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_15b0f0
// Address: 0x15b0f0 - 0x15b104

void entry_15b0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b0f0: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B108; return;
    }
    // 0x15b0f8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15b0fc: 0xc06e4ce
    SET_GPR_U32(ctx, 31, 0x15b104);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    PresetSoAccel__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_15b104
// Address: 0x15b104 - 0x15b128

void entry_15b104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b104) {
        switch (ctx->pc) {
            case 0x15b108: ctx->pc = 0; goto label_15b108;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b104: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_15b108:
    // 0x15b108: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x15b10c: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15b110: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15b114: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15b118: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x15b11c: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x15b120: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateFly__FP3FLYf
// Address: 0x15b128 - 0x15b144

void entry_15b144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b144: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15b148: 0xc601055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x15b14c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15b150: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x15b154: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b158: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b15c: 0x0
    // NOP
    // 0x15b160: 0x4502001a
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
        ctx->pc = 0x15B1CC; return;
    }
    // 0x15b168: 0x8e050554
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x15b16c: 0x2ca20007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 7));
    // 0x15b170: 0x10400013
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B1C0; return;
    }
    // 0x15b178: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x15b17c: 0x2442a1b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294943152));
    // 0x15b180: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15b184: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15b188: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x15b190: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15b194: 0xc056dee
    SET_GPR_U32(ctx, 31, 0x15b19c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetFlyFlys__FP3FLY4FLYS(rdram, ctx, runtime); return;
}


// Function: entry_15b19c
// Address: 0x15b19c - 0x15b1b4

void entry_15b19c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b19c: 0x10000008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B1C0; return;
    }
    // 0x15b1a4: 0x10000006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B1C0; return;
    }
    // 0x15b1ac: 0xc056fbc
    SET_GPR_U32(ctx, 31, 0x15b1b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FlysAttemptedFlyLanding__FP3FLY(rdram, ctx, runtime); return;
}


// Function: entry_15b1b4
// Address: 0x15b1b4 - 0x15b1c8

void entry_15b1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b1b4) {
        switch (ctx->pc) {
            case 0x15b1c0: ctx->pc = 0; goto label_15b1c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b1b4: 0x10000002
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15b1c0;
    }
    // 0x15b1bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_15b1c0:
    // 0x15b1c0: 0xc056dee
    SET_GPR_U32(ctx, 31, 0x15b1c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetFlyFlys__FP3FLY4FLYS(rdram, ctx, runtime); return;
}


// Function: entry_15b1c8
// Address: 0x15b1c8 - 0x15b26c

void entry_15b1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b1c8) {
        switch (ctx->pc) {
            case 0x15b1cc: ctx->pc = 0; goto label_15b1cc;
            case 0x15b1f0: ctx->pc = 0; goto label_15b1f0;
            case 0x15b208: ctx->pc = 0; goto label_15b208;
            case 0x15b20c: ctx->pc = 0; goto label_15b20c;
            case 0x15b224: ctx->pc = 0; goto label_15b224;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b1c8: 0x8e030554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
label_15b1cc:
    // 0x15b1cc: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15b1d0: 0x1062000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_15b208;
    }
    // 0x15b1d8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15b1f0;
    }
    // 0x15b1e0: 0x5060000a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        goto label_15b20c;
    }
    // 0x15b1e8: 0x100000a9
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B490; return;
    }
label_15b1f0:
    // 0x15b1f0: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_15b208;
    }
    // 0x15b1f8: 0x1062007c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x15B3EC; return;
    }
    // 0x15b200: 0x100000a3
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B490; return;
    }
label_15b208:
    // 0x15b208: 0x8e040550
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
label_15b20c:
    // 0x15b20c: 0x10800005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_15b224;
    }
    // 0x15b214: 0x1082001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x15B290; return;
    }
    // 0x15b21c: 0x10000057
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1368)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B37C; return;
    }
label_15b224:
    // 0x15b224: 0x8e0205e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1508)));
    // 0x15b228: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
        ctx->pc = 0x15B270; return;
    }
    // 0x15b230: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x15b234: 0x24040041
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 65));
    // 0x15b238: 0x3c01442f
    SET_GPR_U32(ctx, 1, ((uint32_t)17455 << 16));
    // 0x15b23c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15b240: 0x260505e4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1508));
    // 0x15b244: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x15b248: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x15b24c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b250: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15b254: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x15b258: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b25c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x15b260: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b264: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x15b26c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_15b26c
// Address: 0x15b26c - 0x15b2bc

void entry_15b26c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b26c) {
        switch (ctx->pc) {
            case 0x15b270: ctx->pc = 0; goto label_15b270;
            case 0x15b284: ctx->pc = 0; goto label_15b284;
            case 0x15b290: ctx->pc = 0; goto label_15b290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b26c: 0x8e020568
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
label_15b270:
    // 0x15b270: 0x8e030564
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x15b274: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15b278: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x15b27c: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_15b284;
    }
label_15b284:
    // 0x15b284: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x15b288: 0x1000003a
    WRITE32(ADD32(GPR_U32(ctx, 16), 1384), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B374; return;
    }
label_15b290:
    // 0x15b290: 0x5460001a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1608)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x15B2FC; return;
    }
    // 0x15b298: 0x26511858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x15b29c: 0xc6010688
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1672)); ctx->f[1] = *(float*)&val; }
    // 0x15b2a0: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b2a4: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b2a8: 0x0
    // NOP
    // 0x15b2ac: 0x45000011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x15B2F4; return;
    }
    // 0x15b2b4: 0xc056f52
    SET_GPR_U32(ctx, 31, 0x15b2bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindFlyClosestLandingPos__FP3FLYP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_15b2bc
// Address: 0x15b2bc - 0x15b2d4

void entry_15b2bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b2bc: 0x10400007
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B2DC; return;
    }
    // 0x15b2c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b2c8: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x15b2cc: 0xc056dee
    SET_GPR_U32(ctx, 31, 0x15b2d4);
    WRITE128(ADD32(GPR_U32(ctx, 16), 1520), GPR_VEC(ctx, 2));
    SetFlyFlys__FP3FLY4FLYS(rdram, ctx, runtime); return;
}


// Function: entry_15b2d4
// Address: 0x15b2d4 - 0x15b2e8

void entry_15b2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b2d4) {
        switch (ctx->pc) {
            case 0x15b2dc: ctx->pc = 0; goto label_15b2dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b2d4: 0x10000008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B2F8; return;
    }
label_15b2dc:
    // 0x15b2dc: 0xc60c063c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1596)); ctx->f[12] = *(float*)&val; }
    // 0x15b2e0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b2e8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1600)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b2e8
// Address: 0x15b2e8 - 0x15b3f4

void entry_15b2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b2e8) {
        switch (ctx->pc) {
            case 0x15b2f4: ctx->pc = 0; goto label_15b2f4;
            case 0x15b2f8: ctx->pc = 0; goto label_15b2f8;
            case 0x15b2fc: ctx->pc = 0; goto label_15b2fc;
            case 0x15b34c: ctx->pc = 0; goto label_15b34c;
            case 0x15b360: ctx->pc = 0; goto label_15b360;
            case 0x15b364: ctx->pc = 0; goto label_15b364;
            case 0x15b374: ctx->pc = 0; goto label_15b374;
            case 0x15b378: ctx->pc = 0; goto label_15b378;
            case 0x15b37c: ctx->pc = 0; goto label_15b37c;
            case 0x15b3c8: ctx->pc = 0; goto label_15b3c8;
            case 0x15b3ec: ctx->pc = 0; goto label_15b3ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b2e8: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15b2ec: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15b2f0: 0xe6010688
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1672), *(uint32_t*)&val); }
label_15b2f4:
    // 0x15b2f4: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
label_15b2f8:
    // 0x15b2f8: 0xc6010648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1608)); ctx->f[1] = *(float*)&val; }
label_15b2fc:
    // 0x15b2fc: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b300: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b304: 0x0
    // NOP
    // 0x15b308: 0x4500001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_15b378;
    }
    // 0x15b310: 0x8e040564
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x15b314: 0x28820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    // 0x15b318: 0x14400017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15b378;
    }
    // 0x15b320: 0x8e020568
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
    // 0x15b324: 0x8e03068c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1676)));
    // 0x15b328: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15b32c: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x15b330: 0x14400006
    WRITE32(ADD32(GPR_U32(ctx, 16), 1384), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15b34c;
    }
    // 0x15b338: 0x2482fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294967294));
    // 0x15b33c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15b340: 0xae020568
    WRITE32(ADD32(GPR_U32(ctx, 16), 1384), GPR_U32(ctx, 2));
    // 0x15b344: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 16), 1676), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15b360;
    }
label_15b34c:
    // 0x15b34c: 0x4610005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_15b364;
    }
    // 0x15b354: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15b358: 0xae02068c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1676), GPR_U32(ctx, 2));
    // 0x15b35c: 0xae020568
    WRITE32(ADD32(GPR_U32(ctx, 16), 1384), GPR_U32(ctx, 2));
label_15b360:
    // 0x15b360: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
label_15b364:
    // 0x15b364: 0xc6010644
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1604)); ctx->f[1] = *(float*)&val; }
    // 0x15b368: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b36c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15b370: 0xe6000648
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1608), *(uint32_t*)&val); }
label_15b374:
    // 0x15b374: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
label_15b378:
    // 0x15b378: 0xc6000558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1368)); ctx->f[0] = *(float*)&val; }
label_15b37c:
    // 0x15b37c: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x15b380: 0x3c013e19
    SET_GPR_U32(ctx, 1, ((uint32_t)15897 << 16));
    // 0x15b384: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x15b388: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x15b38c: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x15b390: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b394: 0x0
    // NOP
    // 0x15b398: 0x4502003d
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        ctx->pc = 0x15B490; return;
    }
    // 0x15b3a0: 0x8e020480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1152)));
    // 0x15b3a4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15b3a8: 0x50600039
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        ctx->pc = 0x15B490; return;
    }
    // 0x15b3b0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15b3b4: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
        goto label_15b3c8;
    }
    // 0x15b3bc: 0x10000033
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 1372), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B48C; return;
    }
    // 0x15b3c4: 0x0
    // NOP
label_15b3c8:
    // 0x15b3c8: 0x50600031
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        ctx->pc = 0x15B490; return;
    }
    // 0x15b3d0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15b3d4: 0x5040fffc
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
        goto label_15b3c8;
    }
    // 0x15b3dc: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x15b3e0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b3e4: 0x10000029
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1372), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B48C; return;
    }
label_15b3ec:
    // 0x15b3ec: 0xc057028
    SET_GPR_U32(ctx, 31, 0x15b3f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FCheckFlyOpenSpaceBelow__FP3FLY(rdram, ctx, runtime); return;
}


// Function: entry_15b3f4
// Address: 0x15b3f4 - 0x15b404

void entry_15b3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b3f4: 0x14400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B40C; return;
    }
    // 0x15b3fc: 0xc056ff0
    SET_GPR_U32(ctx, 31, 0x15b404);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FShouldFlyFlee__FP3FLY(rdram, ctx, runtime); return;
}


// Function: entry_15b404
// Address: 0x15b404 - 0x15b414

void entry_15b404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b404) {
        switch (ctx->pc) {
            case 0x15b40c: ctx->pc = 0; goto label_15b40c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b404: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B41C; return;
    }
label_15b40c:
    // 0x15b40c: 0xc056dee
    SET_GPR_U32(ctx, 31, 0x15b414);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetFlyFlys__FP3FLY4FLYS(rdram, ctx, runtime); return;
}


// Function: entry_15b414
// Address: 0x15b414 - 0x15b480

void entry_15b414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b414) {
        switch (ctx->pc) {
            case 0x15b41c: ctx->pc = 0; goto label_15b41c;
            case 0x15b450: ctx->pc = 0; goto label_15b450;
            case 0x15b470: ctx->pc = 0; goto label_15b470;
            case 0x15b478: ctx->pc = 0; goto label_15b478;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b414: 0x1000001e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B490; return;
    }
label_15b41c:
    // 0x15b41c: 0x26451858
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x15b420: 0xc6010668
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1640)); ctx->f[1] = *(float*)&val; }
    // 0x15b424: 0xc4a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b428: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b42c: 0x0
    // NOP
    // 0x15b430: 0x45020017
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        ctx->pc = 0x15B490; return;
    }
    // 0x15b438: 0x8e020568
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
    // 0x15b43c: 0x8e0305ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1452)));
    // 0x15b440: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15b444: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x15b448: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_15b450;
    }
label_15b450:
    // 0x15b450: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x15b454: 0xae040568
    WRITE32(ADD32(GPR_U32(ctx, 16), 1384), GPR_U32(ctx, 4));
    // 0x15b458: 0xc4a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b45c: 0x14800004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1640), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_15b470;
    }
    // 0x15b464: 0xc60c0660
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1632)); ctx->f[12] = *(float*)&val; }
    // 0x15b468: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1636)); ctx->f[13] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15b478;
    }
label_15b470:
    // 0x15b470: 0xc60c0658
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1624)); ctx->f[12] = *(float*)&val; }
    // 0x15b474: 0xc60d065c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1628)); ctx->f[13] = *(float*)&val; }
label_15b478:
    // 0x15b478: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b480);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b480
// Address: 0x15b480 - 0x15b4b8

void entry_15b480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b480) {
        switch (ctx->pc) {
            case 0x15b48c: ctx->pc = 0; goto label_15b48c;
            case 0x15b490: ctx->pc = 0; goto label_15b490;
            case 0x15b4b0: ctx->pc = 0; goto label_15b4b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b480: 0xc6010668
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1640)); ctx->f[1] = *(float*)&val; }
    // 0x15b484: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15b488: 0xe6010668
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1640), *(uint32_t*)&val); }
label_15b48c:
    // 0x15b48c: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
label_15b490:
    // 0x15b490: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15b494: 0x14620009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x15B4BC; return;
    }
    // 0x15b49c: 0x8e030554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x15b4a0: 0x10600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_15b4b0;
    }
    // 0x15b4a8: 0x14620005
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x15B4C0; return;
    }
label_15b4b0:
    // 0x15b4b0: 0xc056f1e
    SET_GPR_U32(ctx, 31, 0x15b4b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EmitFlyDroppings__FP3FLY(rdram, ctx, runtime); return;
}


// Function: entry_15b4b8
// Address: 0x15b4b8 - 0x15b4d0

void entry_15b4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b4b8) {
        switch (ctx->pc) {
            case 0x15b4bc: ctx->pc = 0; goto label_15b4bc;
            case 0x15b4c0: ctx->pc = 0; goto label_15b4c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b4b8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_15b4bc:
    // 0x15b4bc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_15b4c0:
    // 0x15b4c0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15b4c4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15b4c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderFlySelf__FP3FLYP2CMP2RO
// Address: 0x15b4d0 - 0x15b4f4

void entry_15b4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b4f4) {
        switch (ctx->pc) {
            case 0x15b51c: ctx->pc = 0; goto label_15b51c;
            case 0x15b530: ctx->pc = 0; goto label_15b530;
            case 0x15b590: ctx->pc = 0; goto label_15b590;
            case 0x15b5a0: ctx->pc = 0; goto label_15b5a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b4f4: 0x8e030554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x15b4f8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15b4fc: 0x10620034
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x15B5D0; return;
    }
    // 0x15b504: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15b51c;
    }
    // 0x15b50c: 0x50620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
        goto label_15b530;
    }
    // 0x15b514: 0x10000061
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B69C; return;
    }
label_15b51c:
    // 0x15b51c: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15b520: 0x50620052
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
        ctx->pc = 0x15B66C; return;
    }
    // 0x15b528: 0x1000005b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B698; return;
    }
label_15b530:
    // 0x15b530: 0xc6040558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1368)); ctx->f[4] = *(float*)&val; }
    // 0x15b534: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x15b538: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15b53c: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x15b540: 0x24622230
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8752));
    // 0x15b544: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x15b548: 0xc4430008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[3] = *(float*)&val; }
    // 0x15b54c: 0x46041081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[4]);
    // 0x15b550: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15b554: 0xc4642230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8752)); ctx->f[4] = *(float*)&val; }
    // 0x15b558: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x15b55c: 0xc4455c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x15b560: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x15b564: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x15b568: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x15b56c: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x15b570: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15b574: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x15b578: 0x46052034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b57c: 0x0
    // NOP
    // 0x15b580: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_15b590;
    }
    // 0x15b588: 0x10000005
    ctx->f[4] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15b5a0;
    }
label_15b590:
    // 0x15b590: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b594: 0x0
    // NOP
    // 0x15b598: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[4] = FPU_MOV_S(ctx->f[2]);
        goto label_15b5a0;
    }
label_15b5a0:
    // 0x15b5a0: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x15b5a4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15b5a8: 0x8e0705d0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1488)));
    // 0x15b5ac: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15b5b0: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x15b5b4: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x15b5b8: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x15b5bc: 0x8c4300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 160)));
    // 0x15b5c0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15b5c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15b5c8
// Address: 0x15b5c8 - 0x15b690

void entry_15b5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b5c8) {
        switch (ctx->pc) {
            case 0x15b5d0: ctx->pc = 0; goto label_15b5d0;
            case 0x15b634: ctx->pc = 0; goto label_15b634;
            case 0x15b644: ctx->pc = 0; goto label_15b644;
            case 0x15b66c: ctx->pc = 0; goto label_15b66c;
            case 0x15b680: ctx->pc = 0; goto label_15b680;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b5c8: 0x10000051
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B710; return;
    }
label_15b5d0:
    // 0x15b5d0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15b5d4: 0xc6040558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1368)); ctx->f[4] = *(float*)&val; }
    // 0x15b5d8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x15b5dc: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15b5e0: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x15b5e4: 0x24622240
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8768));
    // 0x15b5e8: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x15b5ec: 0xc4430008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[3] = *(float*)&val; }
    // 0x15b5f0: 0x46041081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[4]);
    // 0x15b5f4: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15b5f8: 0xc4642240
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8768)); ctx->f[4] = *(float*)&val; }
    // 0x15b5fc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x15b600: 0xc4455c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x15b604: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x15b608: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x15b60c: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x15b610: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x15b614: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15b618: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x15b61c: 0x46052034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b620: 0x0
    // NOP
    // 0x15b624: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_15b634;
    }
    // 0x15b62c: 0x10000005
    ctx->f[4] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15b644;
    }
label_15b634:
    // 0x15b634: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b638: 0x0
    // NOP
    // 0x15b63c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[4] = FPU_MOV_S(ctx->f[2]);
        goto label_15b644;
    }
label_15b644:
    // 0x15b644: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x15b648: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15b64c: 0x8e020568
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
    // 0x15b650: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15b654: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x15b658: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x15b65c: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x15b660: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x15b664: 0x10000006
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1388)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15b680;
    }
label_15b66c:
    // 0x15b66c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15b670: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15b674: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x15b678: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x15b67c: 0x8c4405b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1456)));
label_15b680:
    // 0x15b680: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15b684: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x15b688: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15b690);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15b690
// Address: 0x15b690 - 0x15b70c

void entry_15b690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b690) {
        switch (ctx->pc) {
            case 0x15b698: ctx->pc = 0; goto label_15b698;
            case 0x15b69c: ctx->pc = 0; goto label_15b69c;
            case 0x15b6ec: ctx->pc = 0; goto label_15b6ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b690: 0x1000001f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B710; return;
    }
label_15b698:
    // 0x15b698: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_15b69c:
    // 0x15b69c: 0x14620013
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_15b6ec;
    }
    // 0x15b6a4: 0x8e030630
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1584)));
    // 0x15b6a8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15b6ac: 0x1062000f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_15b6ec;
    }
    // 0x15b6b4: 0xc6040558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1368)); ctx->f[4] = *(float*)&val; }
    // 0x15b6b8: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x15b6bc: 0xc602055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x15b6c0: 0x46040841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[4]);
    // 0x15b6c4: 0xc6030638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[3] = *(float*)&val; }
    // 0x15b6c8: 0x46041081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[4]);
    // 0x15b6cc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15b6d0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15b6d4: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x15b6d8: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x15b6dc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15b6e0: 0x0
    // NOP
    // 0x15b6e4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1588)));
        goto label_15b6ec;
    }
label_15b6ec:
    // 0x15b6ec: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x15b6f0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15b6f4: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x15b6f8: 0x8c44056c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1388)));
    // 0x15b6fc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15b700: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x15b704: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15b70c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15b70c
// Address: 0x15b70c - 0x15b720

void entry_15b70c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b70c) {
        switch (ctx->pc) {
            case 0x15b710: ctx->pc = 0; goto label_15b710;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b70c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_15b710:
    // 0x15b710: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15b714: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15b718: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FAbsorbFlyWkr__FP3FLYP3WKR
// Address: 0x15b720 - 0x15b74c

void entry_15b74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b74c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x15b750: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x15b754: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15b76c(rdram, ctx, runtime); return;
    }
    // 0x15b75c: 0xc60c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    // 0x15b760: 0x26050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 32));
    // 0x15b764: 0xc06f038
    SET_GPR_U32(ctx, 31, 0x15b76c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 48));
    ApplySoImpulse__FP2SOP6VECTORT1f(rdram, ctx, runtime); return;
}


// Function: entry_15b76c
// Address: 0x15b76c - 0x15b7a0

void entry_15b76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b76c: 0x8e2705d4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1492)));
    // 0x15b770: 0x10e0000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_15b7a0(rdram, ctx, runtime); return;
    }
    // 0x15b778: 0x7a020020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x15b77c: 0x7a060030
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x15b780: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x15b784: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x15b788: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x15b78c: 0x7fa60010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 6));
    // 0x15b790: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x15b794: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x15b798: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15b7a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15b7a0
// Address: 0x15b7a0 - 0x15b7b8

void entry_15b7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b7a0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15b7a4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15b7a8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15b7ac: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15b7b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetFlyFlys__FP3FLY4FLYS
// Address: 0x15b7b8 - 0x15b834

void entry_15b834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b834: 0x10000012
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1496)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15B880; return;
    }
    // 0x15b83c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15b840: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b844: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b848: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15b84c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x15b854);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_15b854
// Address: 0x15b854 - 0x15b864

void entry_15b854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b854: 0xae200568
    WRITE32(ADD32(GPR_U32(ctx, 17), 1384), GPR_U32(ctx, 0));
    // 0x15b858: 0xc62c0670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1648)); ctx->f[12] = *(float*)&val; }
    // 0x15b85c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b864);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1652)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b864
// Address: 0x15b864 - 0x15b8ec

void entry_15b864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b864) {
        switch (ctx->pc) {
            case 0x15b87c: ctx->pc = 0; goto label_15b87c;
            case 0x15b880: ctx->pc = 0; goto label_15b880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b864: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15b868: 0x24431858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x15b86c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15b870: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15b874: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15b878: 0xe6210680
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1664), *(uint32_t*)&val); }
label_15b87c:
    // 0x15b87c: 0x8e2405d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1496)));
label_15b880:
    // 0x15b880: 0x2402000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    // 0x15b884: 0x26831858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x15b888: 0x2e450007
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 18), 7));
    // 0x15b88c: 0xac820088
    WRITE32(ADD32(GPR_U32(ctx, 4), 136), GPR_U32(ctx, 2));
    // 0x15b890: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15b894: 0x10a000ea
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1372), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15BC40; return;
    }
    // 0x15b89c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x15b8a0: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x15b8a4: 0x2442a1f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294943216));
    // 0x15b8a8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15b8ac: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15b8b0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x15b8b8: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x15b8bc: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x15b8c0: 0x1243001c
    WRITE8(ADD32(GPR_U32(ctx, 17), 712), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x15B934; return;
    }
    // 0x15b8c8: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x15b8cc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x15b8d0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15b8d4: 0x263005f0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1520));
    // 0x15b8d8: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x15b8dc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x15b8e0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x15b8e4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b8ec);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b8ec
// Address: 0x15b8ec - 0x15b8fc

void entry_15b8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b8ec: 0xc62c0610
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1552)); ctx->f[12] = *(float*)&val; }
    // 0x15b8f0: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x15b8f4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b8fc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b8fc
// Address: 0x15b8fc - 0x15b90c

void entry_15b8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b8fc: 0xc62c0618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1560)); ctx->f[12] = *(float*)&val; }
    // 0x15b900: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x15b904: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b90c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1564)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b90c
// Address: 0x15b90c - 0x15b920

void entry_15b90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b90c: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x15b910: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x15b914: 0x46000386
    ctx->f[14] = FPU_MOV_S(ctx->f[0]);
    // 0x15b918: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x15b920);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_15b920
// Address: 0x15b920 - 0x15b9b0

void entry_15b920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b920) {
        switch (ctx->pc) {
            case 0x15b934: ctx->pc = 0; goto label_15b934;
            case 0x15b990: ctx->pc = 0; goto label_15b990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b920: 0xda2105f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1520)));
    // 0x15b924: 0xda220190
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 400)));
    // 0x15b928: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15b92c: 0x10000018
    WRITE128(ADD32(GPR_U32(ctx, 17), 1520), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15b990;
    }
label_15b934:
    // 0x15b934: 0xda220100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x15b938: 0x263305f0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 1520));
    // 0x15b93c: 0xda2105f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1520)));
    // 0x15b940: 0x26300600
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1536));
    // 0x15b944: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x15b948: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15b94c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15b950: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15b954: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x15b958: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15b95c: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15b960: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x15b964: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15b968: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x15b96c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x15b970: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x15b974: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x15b978: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x15b97c: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x15b980: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x15b984: 0x4be310d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x15b988: 0x10000016
    WRITE128(ADD32(GPR_U32(ctx, 17), 1536), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_15b9e4(rdram, ctx, runtime); return;
    }
label_15b990:
    // 0x15b990: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x15b994: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x15b998: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15b99c: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x15b9a0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x15b9a4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x15b9a8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b9b0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1536));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b9b0
// Address: 0x15b9b0 - 0x15b9c0

void entry_15b9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b9b0: 0xc62c0620
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1568)); ctx->f[12] = *(float*)&val; }
    // 0x15b9b4: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x15b9b8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b9c0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1572)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b9c0
// Address: 0x15b9c0 - 0x15b9d0

void entry_15b9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b9c0: 0xc62c0628
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1576)); ctx->f[12] = *(float*)&val; }
    // 0x15b9c4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x15b9c8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15b9d0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1580)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15b9d0
// Address: 0x15b9d0 - 0x15b9e4

void entry_15b9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15b9d0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x15b9d4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x15b9d8: 0x46000386
    ctx->f[14] = FPU_MOV_S(ctx->f[0]);
    // 0x15b9dc: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x15b9e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_15b9e4
// Address: 0x15b9e4 - 0x15ba78

void entry_15b9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15b9e4) {
        switch (ctx->pc) {
            case 0x15ba18: ctx->pc = 0; goto label_15ba18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15b9e4: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x15b9e8: 0x200502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15b9ec: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15b9f0: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x15b9f4: 0x27a90030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    // 0x15b9f8: 0x27ab0040
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 64));
    // 0x15b9fc: 0x27a8001c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 28));
    // 0x15ba00: 0x27a60018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 24));
    // 0x15ba04: 0x27a40014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 20));
    // 0x15ba08: 0x26230150
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 336));
    // 0x15ba0c: 0xa0682d
    SET_GPR_U64(ctx, 13, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x15ba10: 0x26220100
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 256));
    // 0x15ba14: 0x240c0002
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 2));
label_15ba18:
    // 0x15ba18: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x15ba1c: 0x258cffff
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 12), 4294967295));
    // 0x15ba20: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x15ba24: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x15ba28: 0xe5a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 13), 0), *(uint32_t*)&val); }
    // 0x15ba2c: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x15ba30: 0xe4810000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x15ba34: 0x25ad0010
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 13), 16));
    // 0x15ba38: 0x24840010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    // 0x15ba3c: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x15ba40: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x15ba44: 0xe4c00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 0), *(uint32_t*)&val); }
    // 0x15ba48: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x15ba4c: 0xc5400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 10), 0)); ctx->f[0] = *(float*)&val; }
    // 0x15ba50: 0x254a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4));
    // 0x15ba54: 0xe5000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 8), 0), *(uint32_t*)&val); }
    // 0x15ba58: 0x581ffef
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 16));
    if (GPR_S32(ctx, 12) >= 0) {
        goto label_15ba18;
    }
    // 0x15ba60: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x15ba64: 0xdc26a210
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 1), 4294943248)));
    // 0x15ba68: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15ba6c: 0xc0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x15ba70: 0xc04c316
    SET_GPR_U32(ctx, 31, 0x15ba78);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    LimitBezierMulti__Fie(rdram, ctx, runtime); return;
}


// Function: entry_15ba78
// Address: 0x15ba78 - 0x15bae8

void entry_15ba78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ba78: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x15ba7c: 0x24040006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15ba80: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x15ba84: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x15ba88: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x15ba8c: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x15ba90: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x15ba94: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15ba98: 0xc622055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[2] = *(float*)&val; }
    // 0x15ba9c: 0x8e230554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    // 0x15baa0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x15baa4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x15baa8: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15baac: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15bab0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15bab4: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x15bab8: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x15babc: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x15bac0: 0x1464005f
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 1372), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x15BC40; return;
    }
    // 0x15bac8: 0x5640005e
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1364), GPR_U32(ctx, 18));
        ctx->pc = 0x15BC44; return;
    }
    // 0x15bad0: 0xc62c0600
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1536)); ctx->f[12] = *(float*)&val; }
    // 0x15bad4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15bad8: 0x3c0143c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17352 << 16));
    // 0x15badc: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x15bae0: 0xc049d56
    SET_GPR_U32(ctx, 31, 0x15bae8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1540)); ctx->f[13] = *(float*)&val; }
    SetAloVelocityXYZ__FP3ALOfff(rdram, ctx, runtime); return;
}


// Function: entry_15bae8
// Address: 0x15bae8 - 0x15baf4

void entry_15bae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bae8: 0xc62c063c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1596)); ctx->f[12] = *(float*)&val; }
    // 0x15baec: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15baf4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1600)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15baf4
// Address: 0x15baf4 - 0x15bb4c

void entry_15baf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15baf4: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x15baf8: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15bafc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15bb00: 0x1000004f
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1672), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15BC40; return;
    }
    // 0x15bb08: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x15bb0c: 0x26300140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 320));
    // 0x15bb10: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x15bb14: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x15bb18: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x15bb1c: 0x2404003a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 58));
    // 0x15bb20: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x15bb24: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x15bb28: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x15bb2c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x15bb30: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x15bb34: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15bb38: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15bb3c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15bb40: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15bb44: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x15bb4c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_15bb4c
// Address: 0x15bb4c - 0x15bb64

void entry_15bb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bb4c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15bb50: 0x8e260690
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    // 0x15bb54: 0x8e270694
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1684)));
    // 0x15bb58: 0x24841ef0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    // 0x15bb5c: 0xc054804
    SET_GPR_U32(ctx, 31, 0x15bb64);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnDifficultyBreak(rdram, ctx, runtime); return;
}


// Function: entry_15bb64
// Address: 0x15bb64 - 0x15bb8c

void entry_15bb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bb64: 0xc620055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[0] = *(float*)&val; }
    // 0x15bb68: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x15bb6c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x15bb70: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15bb74: 0x10000032
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1372), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15BC40; return;
    }
    // 0x15bb7c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15bb80: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x15bb84: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15bb8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15bb8c
// Address: 0x15bb8c - 0x15bba4

void entry_15bb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bb8c: 0x1000002d
    WRITE32(ADD32(GPR_U32(ctx, 17), 1364), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15BC44; return;
    }
    // 0x15bb94: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15bb98: 0x26240110
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 272));
    // 0x15bb9c: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x15bba4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_15bba4
// Address: 0x15bba4 - 0x15bbb8

void entry_15bba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bba4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15bba8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15bbac: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x15bbb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15bbb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15bbb8
// Address: 0x15bbb8 - 0x15bbd4

void entry_15bbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bbb8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15bbbc: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x15bbc0: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x15bbc4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15bbc8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x15bbcc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15bbd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15bbd4
// Address: 0x15bbd4 - 0x15bbe8

void entry_15bbd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bbd4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15bbd8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15bbdc: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x15bbe0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15bbe8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15bbe8
// Address: 0x15bbe8 - 0x15bc00

void entry_15bbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bbe8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15bbec: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15bbf0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15bbf4: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15bbf8: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x15bc00);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_15bc00
// Address: 0x15bc00 - 0x15bc10

void entry_15bc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bc00: 0xc62c0658
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1624)); ctx->f[12] = *(float*)&val; }
    // 0x15bc04: 0xc62d065c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1628)); ctx->f[13] = *(float*)&val; }
    // 0x15bc08: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15bc10);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1384), GPR_U32(ctx, 0));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15bc10
// Address: 0x15bc10 - 0x15bc34

void entry_15bc10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bc10: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x15bc14: 0xc62c0650
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1616)); ctx->f[12] = *(float*)&val; }
    // 0x15bc18: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15bc1c: 0xc62d0654
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1620)); ctx->f[13] = *(float*)&val; }
    // 0x15bc20: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15bc24: 0xe6210668
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1640), *(uint32_t*)&val); }
    // 0x15bc28: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15bc2c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15bc34);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1644), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15bc34
// Address: 0x15bc34 - 0x15bc78

void entry_15bc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15bc34) {
        switch (ctx->pc) {
            case 0x15bc40: ctx->pc = 0; goto label_15bc40;
            case 0x15bc44: ctx->pc = 0; goto label_15bc44;
            case 0x15bc50: ctx->pc = 0; goto label_15bc50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15bc34: 0xc621055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x15bc38: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15bc3c: 0xe621055c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1372), *(uint32_t*)&val); }
label_15bc40:
    // 0x15bc40: 0xae320554
    WRITE32(ADD32(GPR_U32(ctx, 17), 1364), GPR_U32(ctx, 18));
label_15bc44:
    // 0x15bc44: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x15bc48: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15bc4c: 0xe6200558
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1368), *(uint32_t*)&val); }
label_15bc50:
    // 0x15bc50: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x15bc54: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15bc58: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15bc5c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15bc60: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15bc64: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15bc68: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x15bc6c: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x15bc70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EmitFlyDroppings__FP3FLY
// Address: 0x15bc78 - 0x15bccc

void entry_15bccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15bccc) {
        switch (ctx->pc) {
            case 0x15bcd4: ctx->pc = 0; goto label_15bcd4;
            case 0x15bcdc: ctx->pc = 0; goto label_15bcdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15bccc: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15bcdc;
    }
label_15bcd4:
    // 0x15bcd4: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x15bcd8: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
label_15bcdc:
    // 0x15bcdc: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x15bce0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15bce4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15bce8: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x15bcec: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x15bcf0: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x15bcf4: 0x8e060678
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1656)));
    // 0x15bcf8: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15bcfc: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x15bd00: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15bd04: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x15bd08: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x15bd0c: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x15bd10: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15bd18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15bd18
// Address: 0x15bd18 - 0x15bd24

void entry_15bd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bd18: 0xc60c0670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1648)); ctx->f[12] = *(float*)&val; }
    // 0x15bd1c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x15bd24);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1652)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_15bd24
// Address: 0x15bd24 - 0x15bd48

void entry_15bd24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15bd24) {
        switch (ctx->pc) {
            case 0x15bd34: ctx->pc = 0; goto label_15bd34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15bd24: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x15bd28: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15bd2c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15bd30: 0xe6010680
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1664), *(uint32_t*)&val); }
label_15bd34:
    // 0x15bd34: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15bd38: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15bd3c: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15bd40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFindFlyClosestLandingPos__FP3FLYP6VECTOR
// Address: 0x15bd48 - 0x15bda0

void entry_15bda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bda0: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x15bda4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15bda8: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x15bdac: 0x10400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15bdcc(rdram, ctx, runtime); return;
    }
    // 0x15bdb4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15bdb8: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x15bdbc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15bdc0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15bdc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15bdcc);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15bdcc
// Address: 0x15bdcc - 0x15be20

void entry_15bdcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bdcc: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15bdd0: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15bdd4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15bdd8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15bddc: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x15bde0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15bde4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15bde8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15bdec: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x15bdf0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x15bdf4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15bdf8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15bdfc: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15be00: 0x0
    // NOP
    // 0x15be04: 0x45000006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_15be20(rdram, ctx, runtime); return;
    }
    // 0x15be0c: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x15be10: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x15be14: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x15be18: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x15be20);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_15be20
// Address: 0x15be20 - 0x15be48

void entry_15be20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15be20) {
        switch (ctx->pc) {
            case 0x15be2c: ctx->pc = 0; goto label_15be2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15be20: 0x8e100038
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x15be24: 0x5600ffda
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x15BD90; return;
    }
label_15be2c:
    // 0x15be2c: 0xc680a218
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4294943256)); ctx->f[0] = *(float*)&val; }
    // 0x15be30: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15be34: 0x0
    // NOP
    // 0x15be38: 0x45000023
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x15BEC8; return;
    }
    // 0x15be40: 0xc063582
    SET_GPR_U32(ctx, 31, 0x15be48);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15be48
// Address: 0x15be48 - 0x15be78

void entry_15be48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15be48: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x15be4c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x15be50: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x15be54: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x15be58: 0x27a900b0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 176));
    // 0x15be5c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15be60: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x15be64: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15be68: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15be6c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15be70: 0xc077134
    SET_GPR_U32(ctx, 31, 0x15be78);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 180));
    IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_15be78
// Address: 0x15be78 - 0x15bea8

void entry_15be78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15be78: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15be7c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15be80: 0x8fa700b0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x15be84: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15be88: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x15be8c: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x15be90: 0x8fa800b4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x15be94: 0x27a90040
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 64));
    // 0x15be98: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x15be9c: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x15bea0: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x15bea8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_15bea8
// Address: 0x15bea8 - 0x15beb0

void entry_15bea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15bea8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x15beb0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15beb0
// Address: 0x15beb0 - 0x15bef0

void entry_15beb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15beb0) {
        switch (ctx->pc) {
            case 0x15bec4: ctx->pc = 0; goto label_15bec4;
            case 0x15bec8: ctx->pc = 0; goto label_15bec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15beb0: 0x12000004
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_15bec4;
    }
    // 0x15beb8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15bebc: 0x10000002
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15bec8;
    }
label_15bec4:
    // 0x15bec4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_15bec8:
    // 0x15bec8: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x15becc: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x15bed0: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x15bed4: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x15bed8: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x15bedc: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x15bee0: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x15bee4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15beec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15bef0; return;
}


// Function: FlysAttemptedFlyLanding__FP3FLY
// Address: 0x15bef0 - 0x15bf80

void entry_15bf80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15bf80) {
        switch (ctx->pc) {
            case 0x15bf94: ctx->pc = 0; goto label_15bf94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15bf80: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15bf84: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x15bf88: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15bf8c: 0x10000005
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1672), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15BFA4; return;
    }
label_15bf94:
    // 0x15bf94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15bf98: 0xc056dee
    SET_GPR_U32(ctx, 31, 0x15bfa0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetFlyFlys__FP3FLY4FLYS(rdram, ctx, runtime); return;
}


// Function: entry_15bfa0
// Address: 0x15bfa0 - 0x15bfc0

void entry_15bfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15bfa0) {
        switch (ctx->pc) {
            case 0x15bfa4: ctx->pc = 0; goto label_15bfa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15bfa0: 0x24110005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
label_15bfa4:
    // 0x15bfa4: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15bfa8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15bfac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15bfb0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15bfb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15bfbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15bfc0; return;
}


// Function: FShouldFlyFlee__FP3FLY
// Address: 0x15bfc0 - 0x15bfd4

void entry_15bfd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15bfd4) {
        switch (ctx->pc) {
            case 0x15c03c: ctx->pc = 0; goto label_15c03c;
            case 0x15c044: ctx->pc = 0; goto label_15c044;
            case 0x15c048: ctx->pc = 0; goto label_15c048;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15bfd4: 0x1040001b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15c044;
    }
    // 0x15bfdc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x15bfe0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15bfe4: 0xd8430140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x15bfe8: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x15bfec: 0x48a42000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x15bff0: 0xfba40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x15bff4: 0xd8420150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 336)));
    // 0x15bff8: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x15bffc: 0x4be410c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15c000: 0xc6010684
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1668)); ctx->f[1] = *(float*)&val; }
    // 0x15c004: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x15c008: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x15c00c: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x15c010: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15c014: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x15c018: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x15c01c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x15c020: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x15c024: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15c028: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15c02c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15c030: 0x0
    // NOP
    // 0x15c034: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_15c03c;
    }
label_15c03c:
    // 0x15c03c: 0x14600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_15c048;
    }
label_15c044:
    // 0x15c044: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_15c048:
    // 0x15c048: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15c04c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c050: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFilterFly__FPvP2SO
// Address: 0x15c058 - 0x15c0a0

void entry_15c0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c0f0: 0xc62c064c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1612)); ctx->f[12] = *(float*)&val; }
    // 0x15c0f4: 0x3c070016
    SET_GPR_U32(ctx, 7, ((uint32_t)22 << 16));
    // 0x15c0f8: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x15c0fc: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x15c100: 0x27aa0014
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 20));
    // 0x15c104: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15c108: 0x24e7c058
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294951000));
    // 0x15c10c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15c110: 0xc077134
    SET_GPR_U32(ctx, 31, 0x15c118);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_15c118
// Address: 0x15c118 - 0x15c14c

void entry_15c118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c118: 0x7a220140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x15c11c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15c120: 0xc621064c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1612)); ctx->f[1] = *(float*)&val; }
    // 0x15c124: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15c128: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x15c12c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15c130: 0x8fa70010
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c134: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15c138: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15c13c: 0x8fa80014
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x15c140: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x15c144: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x15c14c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_15c14c
// Address: 0x15c14c - 0x15c154

void entry_15c14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c14c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x15c154);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15c154
// Address: 0x15c154 - 0x15c178

void entry_15c154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c154) {
        switch (ctx->pc) {
            case 0x15c160: ctx->pc = 0; goto label_15c160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c154: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15c158: 0x2e020001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 1));
    // 0x15c15c: 0xe620066c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1644), *(uint32_t*)&val); }
label_15c160:
    // 0x15c160: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15c164: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15c168: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15c16c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c170: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartupFont__Fv
// Address: 0x15c178 - 0x15c188

void FUN_0015c188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c188) {
        switch (ctx->pc) {
            case 0x15c1ac: ctx->pc = 0; goto label_15c1ac;
            case 0x15c1b4: ctx->pc = 0; goto label_15c1b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c188: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15c18c: 0x10820007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_15c1ac;
    }
    // 0x15c194: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x15c198: 0x24422268
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 8808));
    // 0x15c19c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15c1a0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15c1a4: 0x14800003
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_15c1b4;
    }
label_15c1ac:
    // 0x15c1ac: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_15c1b4:
    // 0x15c1b4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15c1bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15c1c0; return;
}


// Function: FUN_0015c1c0
// Address: 0x15c1c0 - 0x15c200

void FUN_0015c1c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c1c0) {
        switch (ctx->pc) {
            case 0x15c1d4: ctx->pc = 0; goto label_15c1d4;
            case 0x15c1f4: ctx->pc = 0; goto label_15c1f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c1c0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x15c1c4: 0x14820003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_15c1d4;
    }
    // 0x15c1cc: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_15c1d4:
    // 0x15c1d4: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x15c1d8: 0x24422268
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 8808));
    // 0x15c1dc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15c1e0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15c1e4: 0x14400003
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15c1f4;
    }
    // 0x15c1ec: 0x3e00008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8828)));
    ctx->pc = GPR_U32(ctx, 31); return;
label_15c1f4:
    // 0x15c1f4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15c1fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15c200; return;
}


// Function: FUN_0015c200
// Address: 0x15c200 - 0x15c260

void FUN_0015c200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c200) {
        switch (ctx->pc) {
            case 0x15c220: ctx->pc = 0; goto label_15c220;
            case 0x15c238: ctx->pc = 0; goto label_15c238;
            case 0x15c244: ctx->pc = 0; goto label_15c244;
            case 0x15c24c: ctx->pc = 0; goto label_15c24c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c200: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15c204: 0x42600
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 24));
    // 0x15c208: 0x80622250
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 8784)));
    // 0x15c20c: 0x42603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 24));
    // 0x15c210: 0x10820009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_15c238;
    }
    // 0x15c218: 0x24662250
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 8784));
    // 0x15c21c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
label_15c220:
    // 0x15c220: 0x28a20005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 5));
    // 0x15c224: 0x10400007
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15c244;
    }
    // 0x15c22c: 0x80430000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15c230: 0x5483fffb
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_15c220;
    }
label_15c238:
    // 0x15c238: 0x28a20005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 5));
    // 0x15c23c: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15c24c;
    }
label_15c244:
    // 0x15c244: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_15c24c:
    // 0x15c24c: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x15c250: 0x24422268
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 8808));
    // 0x15c254: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15c258: 0x3e00008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CopyTo__5CFontP5CFont
// Address: 0x15c260 - 0x15c2bc

void entry_15c2bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c2bc: 0x8e020030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x15c2c0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c2c4: 0xae220030
    WRITE32(ADD32(GPR_U32(ctx, 17), 48), GPR_U32(ctx, 2));
    // 0x15c2c8: 0xde030038
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x15c2cc: 0xfe230038
    WRITE64(ADD32(GPR_U32(ctx, 17), 56), GPR_U64(ctx, 3));
    // 0x15c2d0: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x15c2d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c2d8: 0xae220040
    WRITE32(ADD32(GPR_U32(ctx, 17), 64), GPR_U32(ctx, 2));
    // 0x15c2dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c2e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetupDraw__5CFontP8CTextBoxP4GIFS
// Address: 0x15c2e8 - 0x15c378

void entry_15c378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c378: 0x12903c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) << (32 + 0));
    // 0x15c37c: 0x108438
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << 16);
    // 0x15c380: 0x118c3c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) << (32 + 16));
    // 0x15c384: 0x2708025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x15c388: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15c38c: 0x2128025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 18)));
    // 0x15c390: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x15c394: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15c39c);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15c39c
// Address: 0x15c39c - 0x15c3c0

void entry_15c39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c39c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15c3a0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15c3a4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15c3a8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c3ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c3b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c3b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15c3bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15c3c0; return;
}


// Function: CleanupDraw__5CFontP8CTextBoxP4GIFS
// Address: 0x15c3c0 - 0x15c3e8

void entry_15c3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c3e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15c3ec: 0x3c0600df
    SET_GPR_U32(ctx, 6, ((uint32_t)223 << 16));
    // 0x15c3f0: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15c3f4: 0x34c6027f
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 639));
    // 0x15c3f8: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15c3fc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15c404);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15c404
// Address: 0x15c404 - 0x15c418

void entry_15c404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c404: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c408: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c40c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15c414: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15c418; return;
}


// Function: DxFromPchz__5CFontPc
// Address: 0x15c418 - 0x15c478

void entry_15c478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c478) {
        switch (ctx->pc) {
            case 0x15c488: ctx->pc = 0; goto label_15c488;
            case 0x15c490: ctx->pc = 0; goto label_15c490;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c478: 0x82030000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15c47c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x15c480: 0x1460fff5
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15C458; return;
    }
label_15c488:
    // 0x15c488: 0x4600a006
    ctx->f[0] = FPU_MOV_S(ctx->f[20]);
    // 0x15c48c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_15c490:
    // 0x15c490: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c494: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c498: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x15c49c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15c4a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15c4a8; return;
}


// Function: DyWrapPchz__5CFontPcf
// Address: 0x15c4a8 - 0x15c4c8

void entry_15c4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c4c8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15c4cc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15c4d0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c4d4: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x15c4d8: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x15c4dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15c4e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15c4e8; return;
}


// Function: ClineWrapPchz__5CFontPcf
// Address: 0x15c4e8 - 0x15c56c

void entry_15c56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c56c) {
        switch (ctx->pc) {
            case 0x15c570: ctx->pc = 0; goto label_15c570;
            case 0x15c598: ctx->pc = 0; goto label_15c598;
            case 0x15c5c4: ctx->pc = 0; goto label_15c5c4;
            case 0x15c5d0: ctx->pc = 0; goto label_15c5d0;
            case 0x15c5ec: ctx->pc = 0; goto label_15c5ec;
            case 0x15c5f0: ctx->pc = 0; goto label_15c5f0;
            case 0x15c5fc: ctx->pc = 0; goto label_15c5fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c56c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
label_15c570:
    // 0x15c570: 0x4616a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15c574: 0x0
    // NOP
    // 0x15c578: 0x4503001d
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        goto label_15c5f0;
    }
    // 0x15c580: 0x4614a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15c584: 0x0
    // NOP
    // 0x15c588: 0x45000018
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_15c5ec;
    }
    // 0x15c590: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x15c594: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
label_15c598:
    // 0x15c598: 0x73102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x15c59c: 0x1440000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15c5d0;
    }
    // 0x15c5a4: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15c5a8: 0x10440009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_15c5d0;
    }
    // 0x15c5b0: 0x50460004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 6)) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        goto label_15c5c4;
    }
    // 0x15c5b8: 0x5445fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
        goto label_15c598;
    }
    // 0x15c5c0: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_15c5c4:
    // 0x15c5c4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x15c5c8: 0xa2040000
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 4));
    // 0x15c5cc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_15c5d0:
    // 0x15c5d0: 0x4616a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15c5d4: 0x0
    // NOP
    // 0x15c5d8: 0x45030005
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        goto label_15c5f0;
    }
    // 0x15c5e0: 0xa2140000
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 20));
    // 0x15c5e4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x15c5e8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
label_15c5ec:
    // 0x15c5ec: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
label_15c5f0:
    // 0x15c5f0: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15c5f4: 0x1440ffd2
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15C540; return;
    }
label_15c5fc:
    // 0x15c5fc: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15c600: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15c604: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15c608: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15c60c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c610: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c614: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c618: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x15c61c: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x15c620: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x15c624: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15c62c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15c630; return;
}


// Function: junk_0015C630
// Address: 0x15c630 - 0x15c638

void entry_15c6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c6a4) {
        switch (ctx->pc) {
            case 0x15c6bc: ctx->pc = 0; goto label_15c6bc;
            case 0x15c6f0: ctx->pc = 0; goto label_15c6f0;
            case 0x15c70c: ctx->pc = 0; goto label_15c70c;
            case 0x15c718: ctx->pc = 0; goto label_15c718;
            case 0x15c730: ctx->pc = 0; goto label_15c730;
            case 0x15c740: ctx->pc = 0; goto label_15c740;
            case 0x15c760: ctx->pc = 0; goto label_15c760;
            case 0x15c78c: ctx->pc = 0; goto label_15c78c;
            case 0x15c7a8: ctx->pc = 0; goto label_15c7a8;
            case 0x15c7c0: ctx->pc = 0; goto label_15c7c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c6a4: 0x8e620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15c6a8: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
        goto label_15c6bc;
    }
    // 0x15c6b0: 0xc6750004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[21] = *(float*)&val; }
    // 0x15c6b4: 0x10000022
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 76)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15c740;
    }
label_15c6bc:
    // 0x15c6bc: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15c6c0: 0xc6410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 72)); ctx->f[1] = *(float*)&val; }
    // 0x15c6c4: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15c6c8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x15c6cc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15c6d0: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15c6d4: 0x8e46004c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 76)));
    // 0x15c6d8: 0xc6630004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[3] = *(float*)&val; }
    // 0x15c6dc: 0x46010342
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15c6e0: 0x1040000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 12)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15c718;
    }
    // 0x15c6e8: 0x2405000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    // 0x15c6ec: 0x0
    // NOP
label_15c6f0:
    // 0x15c6f0: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15c6f4: 0x14450005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_15c70c;
    }
    // 0x15c6fc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x15c700: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15c704: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15c708: 0x46006b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[0]);
label_15c70c:
    // 0x15c70c: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15c710: 0x1440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15c6f0;
    }
label_15c718:
    // 0x15c718: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15c71c: 0x54e20004
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 2)) {
        ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[13]);
        goto label_15c730;
    }
    // 0x15c724: 0x46021800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x15c728: 0x10000005
    ctx->f[21] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15c740;
    }
label_15c730:
    // 0x15c730: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x15c734: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x15c738: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15c73c: 0x46001d40
    ctx->f[21] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
label_15c740:
    // 0x15c740: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15c744: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15c748: 0x10400046
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15C864; return;
    }
    // 0x15c750: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x15c754: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x15c758: 0x2417000a
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 10));
    // 0x15c75c: 0x0
    // NOP
label_15c760:
    // 0x15c760: 0x31600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 24));
    // 0x15c764: 0x21e03
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 2), 24));
    // 0x15c768: 0x14770008
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 23)) {
        goto label_15c78c;
    }
    // 0x15c770: 0xc6400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15c774: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15c778: 0xc6410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 72)); ctx->f[1] = *(float*)&val; }
    // 0x15c77c: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15c780: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15c784: 0x10000032
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15C850; return;
    }
label_15c78c:
    // 0x15c78c: 0x52800026
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 76)));
        ctx->pc = 0x15C828; return;
    }
    // 0x15c794: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x15c798: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15c7a8;
    }
    // 0x15c7a0: 0x1000001f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15C820; return;
    }
label_15c7a8:
    // 0x15c7a8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x15c7ac: 0x1060000f
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15C7EC; return;
    }
    // 0x15c7b4: 0x1077000d
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 23)) {
        ctx->pc = 0x15C7EC; return;
    }
    // 0x15c7bc: 0x8e42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 76)));
label_15c7c0:
    // 0x15c7c0: 0x82050000
    SET_GPR_S32(ctx, 5, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15c7c4: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x15c7c8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x15c7cc: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x15c7d0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15c7d8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15c7d8
// Address: 0x15c7d8 - 0x15c84c

void entry_15c7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c7d8) {
        switch (ctx->pc) {
            case 0x15c7ec: ctx->pc = 0; goto label_15c7ec;
            case 0x15c810: ctx->pc = 0; goto label_15c810;
            case 0x15c820: ctx->pc = 0; goto label_15c820;
            case 0x15c828: ctx->pc = 0; goto label_15c828;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c7d8: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15c7dc: 0x10400003
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15c7ec;
    }
    // 0x15c7e4: 0x5454fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 76)));
        ctx->pc = 0x15C7C0; return;
    }
label_15c7ec:
    // 0x15c7ec: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x15c7f0: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15c7f4: 0x54430006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[0] = *(float*)&val; }
        goto label_15c810;
    }
    // 0x15c7fc: 0xc6600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[0] = *(float*)&val; }
    // 0x15c800: 0xc6610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[1] = *(float*)&val; }
    // 0x15c804: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15c808: 0x10000005
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15c820;
    }
label_15c810:
    // 0x15c810: 0xc6610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[1] = *(float*)&val; }
    // 0x15c814: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x15c818: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x15c81c: 0x46000d00
    ctx->f[20] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_15c820:
    // 0x15c820: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15c824: 0x8e42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 76)));
label_15c828:
    // 0x15c828: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x15c82c: 0x82250000
    SET_GPR_S32(ctx, 5, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15c830: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x15c834: 0x84440030
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x15c838: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15c83c: 0x8c430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x15c840: 0x8e660010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x15c844: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15c84c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15c84c
// Address: 0x15c84c - 0x15c87c

void entry_15c84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15c84c) {
        switch (ctx->pc) {
            case 0x15c850: ctx->pc = 0; goto label_15c850;
            case 0x15c864: ctx->pc = 0; goto label_15c864;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15c84c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
label_15c850:
    // 0x15c850: 0x2a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x15c854: 0x8e46004c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 76)));
    // 0x15c858: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15c85c: 0x1440ffc0
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15C760; return;
    }
label_15c864:
    // 0x15c864: 0x84c40038
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 56)));
    // 0x15c868: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x15c86c: 0x8cc2003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 60)));
    // 0x15c870: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15c874: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15c87c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15c87c
// Address: 0x15c87c - 0x15c8b8

void entry_15c87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c87c: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15c880: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15c884: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15c888: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15c88c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15c890: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15c894: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15c898: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c89c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c8a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c8a4: 0xc7b600b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[22] = *(float*)&val; }
    // 0x15c8a8: 0xc7b500a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[21] = *(float*)&val; }
    // 0x15c8ac: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x15c8b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PushScaling__5CFontff
// Address: 0x15c8b8 - 0x15c900

void entry_15c95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c95c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x15c960: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15c964: 0x2463a220
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294943264));
    // 0x15c968: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15c96c: 0xae03004c
    WRITE32(ADD32(GPR_U32(ctx, 16), 76), GPR_U32(ctx, 3));
    // 0x15c970: 0xc05726c
    SET_GPR_U32(ctx, 31, 0x15c978);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CopyTo__8CFontBrxP8CFontBrx(rdram, ctx, runtime); return;
}


// Function: entry_15c978
// Address: 0x15c978 - 0x15c9b0

void entry_15c978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c978: 0xc6010044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[1] = *(float*)&val; }
    // 0x15c97c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15c980: 0xc6000048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[0] = *(float*)&val; }
    // 0x15c984: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x15c988: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c98c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x15c990: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15c994: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x15c998: 0xe6010044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x15c99c: 0xe6000048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 72), *(uint32_t*)&val); }
    // 0x15c9a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15c9a4: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x15c9a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CopyTo__8CFontBrxP8CFontBrx
// Address: 0x15c9b0 - 0x15c9cc

void entry_15c9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15c9cc: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x15c9d0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15c9d4: 0xae220050
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 2));
    // 0x15c9d8: 0x8e030054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x15c9dc: 0xae230054
    WRITE32(ADD32(GPR_U32(ctx, 17), 84), GPR_U32(ctx, 3));
    // 0x15c9e0: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x15c9e4: 0xae220058
    WRITE32(ADD32(GPR_U32(ctx, 17), 88), GPR_U32(ctx, 2));
    // 0x15c9e8: 0xde030060
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x15c9ec: 0xfe230060
    WRITE64(ADD32(GPR_U32(ctx, 17), 96), GPR_U64(ctx, 3));
    // 0x15c9f0: 0x8e020068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 104)));
    // 0x15c9f4: 0xae220068
    WRITE32(ADD32(GPR_U32(ctx, 17), 104), GPR_U32(ctx, 2));
    // 0x15c9f8: 0x8e03006c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 108)));
    // 0x15c9fc: 0xae23006c
    WRITE32(ADD32(GPR_U32(ctx, 17), 108), GPR_U32(ctx, 3));
    // 0x15ca00: 0x8e020070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 112)));
    // 0x15ca04: 0xae220070
    WRITE32(ADD32(GPR_U32(ctx, 17), 112), GPR_U32(ctx, 2));
    // 0x15ca08: 0x8e030074
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 116)));
    // 0x15ca0c: 0xae230074
    WRITE32(ADD32(GPR_U32(ctx, 17), 116), GPR_U32(ctx, 3));
    // 0x15ca10: 0x8e020078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 120)));
    // 0x15ca14: 0xae220078
    WRITE32(ADD32(GPR_U32(ctx, 17), 120), GPR_U32(ctx, 2));
    // 0x15ca18: 0x8e03007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 124)));
    // 0x15ca1c: 0xae23007c
    WRITE32(ADD32(GPR_U32(ctx, 17), 124), GPR_U32(ctx, 3));
    // 0x15ca20: 0x8e020080
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x15ca24: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ca28: 0xae220080
    WRITE32(ADD32(GPR_U32(ctx, 17), 128), GPR_U32(ctx, 2));
    // 0x15ca2c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ca30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FValid__8CFontBrxc
// Address: 0x15ca38 - 0x15ca4c

void entry_15ca4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ca4c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ca50: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x15ca54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15ca5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15ca60; return;
}


// Function: DxFromCh__8CFontBrxc
// Address: 0x15ca60 - 0x15ca7c

void entry_15ca7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ca7c) {
        switch (ctx->pc) {
            case 0x15ca94: ctx->pc = 0; goto label_15ca94;
            case 0x15caa4: ctx->pc = 0; goto label_15caa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ca7c: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 6)));
        goto label_15ca94;
    }
    // 0x15ca84: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15ca88: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15ca8c: 0x10000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15caa4;
    }
label_15ca94:
    // 0x15ca94: 0xc6010044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[1] = *(float*)&val; }
    // 0x15ca98: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15ca9c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15caa0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
label_15caa4:
    // 0x15caa4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15caa8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15caac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15cab0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FEnsureLoaded__8CFontBrxP4GIFS
// Address: 0x15cab8 - 0x15cafc

void entry_15cafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cafc: 0x8e050068
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 104)));
    // 0x15cb00: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cb04: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x15cb0c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 108)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15cb0c
// Address: 0x15cb0c - 0x15cb20

void entry_15cb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cb0c: 0x8e020054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x15cb10: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cb14: 0x8c460010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x15cb18: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x15cb20);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15cb20
// Address: 0x15cb20 - 0x15cb38

void entry_15cb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cb20: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x15cb24: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15cb4c(rdram, ctx, runtime); return;
    }
    // 0x15cb2c: 0x8e050070
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 112)));
    // 0x15cb30: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x15cb38);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 116)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15cb38
// Address: 0x15cb38 - 0x15cb4c

void entry_15cb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cb38: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x15cb3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cb40: 0x8c460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x15cb44: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x15cb4c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15cb4c
// Address: 0x15cb4c - 0x15cb54

void entry_15cb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cb4c: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x15cb54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15cb54
// Address: 0x15cb54 - 0x15cb88

void entry_15cb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15cb54) {
        switch (ctx->pc) {
            case 0x15cb68: ctx->pc = 0; goto label_15cb68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15cb54: 0x8e6422d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 8920)));
    // 0x15cb58: 0x8e030080
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x15cb5c: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x15cb60: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15cb64: 0xac820018
    WRITE32(ADD32(GPR_U32(ctx, 4), 24), GPR_U32(ctx, 2));
label_15cb68:
    // 0x15cb68: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15cb6c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15cb70: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15cb74: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15cb78: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15cb7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15cb80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetupDraw__8CFontBrxP8CTextBoxP4GIFS
// Address: 0x15cb88 - 0x15cba8

void entry_15cba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cba8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15cbac: 0xc0572ae
    SET_GPR_U32(ctx, 31, 0x15cbb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FEnsureLoaded__8CFontBrxP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15cbb4
// Address: 0x15cbb4 - 0x15cbcc

void entry_15cbb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cbb4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15cbb8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cbbc: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15cbc0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15cbc4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15cbcc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15cbcc
// Address: 0x15cbcc - 0x15cbe0

void entry_15cbcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cbcc: 0x12000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_15cbe0(rdram, ctx, runtime); return;
    }
    // 0x15cbd4: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x15cbd8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cbe0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cbe0
// Address: 0x15cbe0 - 0x15cc00

void entry_15cbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15cbe0) {
        switch (ctx->pc) {
            case 0x15cbf4: ctx->pc = 0; goto label_15cbf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15cbe0: 0x8e420030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 48)));
    // 0x15cbe4: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x15cbe8: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x15cbec: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 18), 56)));
        goto label_15cbf4;
    }
label_15cbf4:
    // 0x15cbf4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cbf8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cc00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cc00
// Address: 0x15cc00 - 0x15cc10

void entry_15cc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cc00: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cc04: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x15cc08: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cc10);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cc10
// Address: 0x15cc10 - 0x15cc20

void entry_15cc10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cc10: 0xde460060
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 18), 96)));
    // 0x15cc14: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cc18: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cc20);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cc20
// Address: 0x15cc20 - 0x15cc30

void entry_15cc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cc20: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cc24: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x15cc28: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cc30);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 96));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cc30
// Address: 0x15cc30 - 0x15cc40

void entry_15cc30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cc30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cc34: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x15cc38: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cc40);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cc40
// Address: 0x15cc40 - 0x15cc50

void entry_15cc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cc40: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cc44: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15cc48: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cc50);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 470));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cc50
// Address: 0x15cc50 - 0x15cc64

void entry_15cc50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cc50: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cc54: 0x3c060004
    SET_GPR_U32(ctx, 6, ((uint32_t)4 << 16));
    // 0x15cc58: 0x34c63431
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 13361));
    // 0x15cc5c: 0xc0585da
    SET_GPR_U32(ctx, 31, 0x15cc64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimList__4GIFSiUl(rdram, ctx, runtime); return;
}


// Function: entry_15cc64
// Address: 0x15cc64 - 0x15cc80

void entry_15cc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cc64: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15cc68: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15cc6c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15cc70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15cc74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15cc7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15cc80; return;
}


// Function: SwitchTex0__8CFontBrxP4GIFS
// Address: 0x15cc80 - 0x15cca0

void entry_15cca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cca0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15cca4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cca8: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15ccac: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15ccb0: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15ccb8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15ccb8
// Address: 0x15ccb8 - 0x15cccc

void entry_15ccb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ccb8: 0x12000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_15cccc(rdram, ctx, runtime); return;
    }
    // 0x15ccc0: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x15ccc4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15cccc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15cccc
// Address: 0x15cccc - 0x15ccdc

void entry_15cccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cccc: 0xde460060
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 18), 96)));
    // 0x15ccd0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15ccd4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15ccdc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15ccdc
// Address: 0x15ccdc - 0x15ccec

void entry_15ccdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ccdc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15cce0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15cce4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15ccec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 470));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15ccec
// Address: 0x15ccec - 0x15cd00

void entry_15ccec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ccec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15ccf0: 0x3c060004
    SET_GPR_U32(ctx, 6, ((uint32_t)4 << 16));
    // 0x15ccf4: 0x34c63431
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 13361));
    // 0x15ccf8: 0xc0585da
    SET_GPR_U32(ctx, 31, 0x15cd00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimList__4GIFSiUl(rdram, ctx, runtime); return;
}


// Function: entry_15cd00
// Address: 0x15cd00 - 0x15cd18

void entry_15cd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cd00: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15cd04: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15cd08: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15cd0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15cd10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DxDrawCh__8CFontBrxcffUiP4GIFS
// Address: 0x15cd18 - 0x15cd70

void entry_15cd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cd70: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15cd74: 0x1220006b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15CF24; return;
    }
    // 0x15cd7c: 0x96230006
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 6)));
    // 0x15cd80: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x15cd84: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15cd88: 0xc6030044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[3] = *(float*)&val; }
    // 0x15cd8c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x15cd90: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15cd94: 0xde020060
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x15cd98: 0xc6020048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[2] = *(float*)&val; }
    // 0x15cd9c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x15cda0: 0x217ba
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 30);
    // 0x15cda4: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x15cda8: 0x3042000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 15));
    // 0x15cdac: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x15cdb0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x15cdb4: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x15cdb8: 0x44a004
    SET_GPR_U32(ctx, 20, SLL32(GPR_U32(ctx, 4), GPR_U32(ctx, 2) & 0x1F));
    // 0x15cdbc: 0x4600c680
    ctx->f[26] = FPU_ADD_S(ctx->f[24], ctx->f[0]);
    // 0x15cdc0: 0x461a6036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[26])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15cdc4: 0x0
    // NOP
    // 0x15cdc8: 0x45000050
    ctx->f[25] = FPU_ADD_S(ctx->f[22], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        entry_15cf0c(rdram, ctx, runtime); return;
    }
    // 0x15cdd0: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x15cdd4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15cdd8: 0x4600c036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[24], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15cddc: 0x0
    // NOP
    // 0x15cde0: 0x4502004b
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 6)));
        ctx->pc = 0x15CF10; return;
    }
    // 0x15cde8: 0x46196036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[25])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15cdec: 0x0
    // NOP
    // 0x15cdf0: 0x45020047
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 6)));
        ctx->pc = 0x15CF10; return;
    }
    // 0x15cdf8: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x15cdfc: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x15ce00: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15ce04: 0x4600b036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15ce08: 0x0
    // NOP
    // 0x15ce0c: 0x4500003f
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 19), 24));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_15cf0c(rdram, ctx, runtime); return;
    }
    // 0x15ce14: 0x3c0200ff
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    // 0x15ce18: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x15ce1c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x15ce20: 0x30a501fe
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 510));
    // 0x15ce24: 0x2621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x15ce28: 0x52dc0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 23));
    // 0x15ce2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15ce30: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x15ce34: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x15ce38: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x15ce3c: 0xc0585fa
    SET_GPR_U32(ctx, 31, 0x15ce44);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    ListRGBAQ__4GIFSUif(rdram, ctx, runtime); return;
}


// Function: entry_15ce44
// Address: 0x15ce44 - 0x15ce70

void entry_15ce44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ce44: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x15ce48: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x15ce4c: 0x96260004
    SET_GPR_U32(ctx, 6, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x15ce50: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15ce54: 0x96250002
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 2)));
    // 0x15ce58: 0x2863023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 6)));
    // 0x15ce5c: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x15ce60: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x15ce64: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x15ce68: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15ce70);
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15ce70
// Address: 0x15ce70 - 0x15ceac

void entry_15ce70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ce70: 0x4614b002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[20]);
    // 0x15ce74: 0x8e070040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x15ce78: 0x4615c040
    ctx->f[1] = FPU_ADD_S(ctx->f[24], ctx->f[21]);
    // 0x15ce7c: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x15ce80: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x15ce84: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15ce88: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x15ce8c: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x15ce90: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x15ce94: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x15ce98: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x15ce9c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x15cea0: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x15cea4: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15ceac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15ceac
// Address: 0x15ceac - 0x15ced8

void entry_15ceac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ceac: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15ceb0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15ceb4: 0x96260004
    SET_GPR_U32(ctx, 6, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x15ceb8: 0x96250002
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 2)));
    // 0x15cebc: 0x96230006
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 6)));
    // 0x15cec0: 0xc23021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x15cec4: 0x2863023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 6)));
    // 0x15cec8: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x15cecc: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x15ced0: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15ced8);
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15ced8
// Address: 0x15ced8 - 0x15cf0c

void entry_15ced8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ced8: 0x4614cd02
    ctx->f[20] = FPU_MUL_S(ctx->f[25], ctx->f[20]);
    // 0x15cedc: 0x8e070040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x15cee0: 0x4615d540
    ctx->f[21] = FPU_ADD_S(ctx->f[26], ctx->f[21]);
    // 0x15cee4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15cee8: 0x4617a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[23]);
    // 0x15ceec: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x15cef0: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x15cef4: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x15cef8: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x15cefc: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x15cf00: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x15cf04: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15cf0c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15cf0c
// Address: 0x15cf0c - 0x15cf70

void entry_15cf0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15cf0c) {
        switch (ctx->pc) {
            case 0x15cf10: ctx->pc = 0; goto label_15cf10;
            case 0x15cf24: ctx->pc = 0; goto label_15cf24;
            case 0x15cf30: ctx->pc = 0; goto label_15cf30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15cf0c: 0x96220006
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 6)));
label_15cf10:
    // 0x15cf10: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15cf14: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15cf18: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15cf1c: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15cf30;
    }
label_15cf24:
    // 0x15cf24: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15cf28: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15cf2c: 0xc6000044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[0] = *(float*)&val; }
label_15cf30:
    // 0x15cf30: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x15cf34: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15cf38: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15cf3c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15cf40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15cf44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15cf48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15cf4c: 0xc7ba0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[26] = *(float*)&val; }
    // 0x15cf50: 0xc7b90088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[25] = *(float*)&val; }
    // 0x15cf54: 0xc7b80080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[24] = *(float*)&val; }
    // 0x15cf58: 0xc7b70078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[23] = *(float*)&val; }
    // 0x15cf5c: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x15cf60: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x15cf64: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x15cf68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0015cf70
// Address: 0x15cf70 - 0x15cfdc

void FUN_0015cf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cf70: 0x27bdff20
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967072));
    // 0x15cf74: 0x52e00
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 24));
    // 0x15cf78: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x15cf7c: 0x52e03
    SET_GPR_S32(ctx, 5, SRA32(GPR_S32(ctx, 5), 24));
    // 0x15cf80: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x15cf84: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x15cf88: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x15cf8c: 0xe0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x15cf90: 0xe7b900b8
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 184), *(uint32_t*)&val); }
    // 0x15cf94: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x15cf98: 0xe7b800b0
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x15cf9c: 0x46006e46
    ctx->f[25] = FPU_MOV_S(ctx->f[13]);
    // 0x15cfa0: 0x7fbf0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 31));
    // 0x15cfa4: 0x46006606
    ctx->f[24] = FPU_MOV_S(ctx->f[12]);
    // 0x15cfa8: 0x7fb70070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 23));
    // 0x15cfac: 0x7fb60060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 22));
    // 0x15cfb0: 0x7fb50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 21));
    // 0x15cfb4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x15cfb8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x15cfbc: 0xe7bc00d0
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 208), *(uint32_t*)&val); }
    // 0x15cfc0: 0xe7bb00c8
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 200), *(uint32_t*)&val); }
    // 0x15cfc4: 0xe7ba00c0
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 192), *(uint32_t*)&val); }
    // 0x15cfc8: 0xe7b700a8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 168), *(uint32_t*)&val); }
    // 0x15cfcc: 0xe7b600a0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 160), *(uint32_t*)&val); }
    // 0x15cfd0: 0xe7b50098
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 152), *(uint32_t*)&val); }
    // 0x15cfd4: 0xc0576ae
    SET_GPR_U32(ctx, 31, 0x15cfdc);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    PglyffFromCh__8CFontBrxc(rdram, ctx, runtime); return;
}


// Function: entry_15cfdc
// Address: 0x15cfdc - 0x15d0d4

void entry_15cfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15cfdc: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15cfe0: 0x10a000c1
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_15d2e8(rdram, ctx, runtime); return;
    }
    // 0x15cfe8: 0x8e880008
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x15cfec: 0xc6830048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 72)); ctx->f[3] = *(float*)&val; }
    // 0x15cff0: 0x44880800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 8);
    // 0x15cff4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15cff8: 0x94aa0006
    SET_GPR_U32(ctx, 10, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 6)));
    // 0x15cffc: 0xde820060
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x15d000: 0x448a0000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 10);
    // 0x15d004: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15d008: 0xc6820044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 68)); ctx->f[2] = *(float*)&val; }
    // 0x15d00c: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x15d010: 0x217ba
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 30);
    // 0x15d014: 0x4480d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 0);
    // 0x15d018: 0x3042000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 15));
    // 0x15d01c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x15d020: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x15d024: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x15d028: 0x4601c700
    ctx->f[28] = FPU_ADD_S(ctx->f[24], ctx->f[1]);
    // 0x15d02c: 0x434804
    SET_GPR_U32(ctx, 9, SLL32(GPR_U32(ctx, 3), GPR_U32(ctx, 2) & 0x1F));
    // 0x15d030: 0x461cd036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[26], ctx->f[28])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15d034: 0x0
    // NOP
    // 0x15d038: 0x450000ab
    ctx->f[27] = FPU_ADD_S(ctx->f[25], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        entry_15d2e8(rdram, ctx, runtime); return;
    }
    // 0x15d040: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x15d044: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15d048: 0x4600c036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[24], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15d04c: 0x0
    // NOP
    // 0x15d050: 0x450000a6
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x15D2EC; return;
    }
    // 0x15d058: 0x461bd036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[26], ctx->f[27])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15d05c: 0x0
    // NOP
    // 0x15d060: 0x450000a3
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x15D2F0; return;
    }
    // 0x15d068: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x15d06c: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x15d070: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x15d074: 0x4600c836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[25], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15d078: 0x0
    // NOP
    // 0x15d07c: 0x4500009c
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x15D2F0; return;
    }
    // 0x15d084: 0x94a40004
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x15d088: 0x94a50002
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 2)));
    // 0x15d08c: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x15d090: 0x881821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 8)));
    // 0x15d094: 0x8cc82258
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 8792)));
    // 0x15d098: 0xaa1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 10)));
    // 0x15d09c: 0x8ce6225c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 7), 8796)));
    // 0x15d0a0: 0x1242023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 9), GPR_U32(ctx, 4)));
    // 0x15d0a4: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x15d0a8: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x15d0ac: 0x1231823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 9), GPR_U32(ctx, 3)));
    // 0x15d0b0: 0x868821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x15d0b4: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x15d0b8: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x15d0bc: 0xa8a821
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 8)));
    // 0x15d0c0: 0x66b021
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x15d0c4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15d0c8: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d0cc: 0xc0572ae
    SET_GPR_U32(ctx, 31, 0x15d0d4);
    SET_GPR_U32(ctx, 23, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    FEnsureLoaded__8CFontBrxP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d0d4
// Address: 0x15d0d4 - 0x15d0ec

void entry_15d0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d0d4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15d0d8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d0dc: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15d0e0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15d0e4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15d0ec);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15d0ec
// Address: 0x15d0ec - 0x15d100

void entry_15d0ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d0ec: 0x12000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_15d100(rdram, ctx, runtime); return;
    }
    // 0x15d0f4: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x15d0f8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15d100);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15d100
// Address: 0x15d100 - 0x15d120

void entry_15d100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15d100) {
        switch (ctx->pc) {
            case 0x15d114: ctx->pc = 0; goto label_15d114;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15d100: 0x8e820030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 48)));
    // 0x15d104: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x15d108: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x15d10c: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 20), 56)));
        goto label_15d114;
    }
label_15d114:
    // 0x15d114: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d118: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15d120);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15d120
// Address: 0x15d120 - 0x15d144

void entry_15d120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d120: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x15d124: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x15d128: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x15d12c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d130: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x15d134: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x15d138: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x15d13c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15d144);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15d144
// Address: 0x15d144 - 0x15d164

void entry_15d144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d144: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x15d148: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x15d14c: 0xde860060
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x15d150: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d154: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x15d158: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x15d15c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15d164);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15d164
// Address: 0x15d164 - 0x15d174

void entry_15d164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d164: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d168: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x15d16c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15d174);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 96));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15d174
// Address: 0x15d174 - 0x15d184

void entry_15d174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d174: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d178: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x15d17c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15d184);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15d184
// Address: 0x15d184 - 0x15d194

void entry_15d184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d184: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d188: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d18c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15d194);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 468));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15d194
// Address: 0x15d194 - 0x15d1b4

void entry_15d194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d194: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x15d198: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15d19c: 0x34c63434
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 13364));
    // 0x15d1a0: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15d1a4: 0x34c63431
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 13361));
    // 0x15d1a8: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    // 0x15d1ac: 0xc0585da
    SET_GPR_U32(ctx, 31, 0x15d1b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AddPrimList__4GIFSiUl(rdram, ctx, runtime); return;
}


// Function: entry_15d1b4
// Address: 0x15d1b4 - 0x15d1e0

void entry_15d1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d1b4: 0x122e02
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 18), 24));
    // 0x15d1b8: 0x3c0200ff
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    // 0x15d1bc: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x15d1c0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x15d1c4: 0x30a501fe
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 510));
    // 0x15d1c8: 0x2421024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x15d1cc: 0x52dc0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 23));
    // 0x15d1d0: 0x4600d306
    ctx->f[12] = FPU_MOV_S(ctx->f[26]);
    // 0x15d1d4: 0x452825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x15d1d8: 0xc0585fa
    SET_GPR_U32(ctx, 31, 0x15d1e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ListRGBAQ__4GIFSUif(rdram, ctx, runtime); return;
}


// Function: entry_15d1e0
// Address: 0x15d1e0 - 0x15d1f0

void entry_15d1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d1e0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15d1e4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d1e8: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15d1f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15d1f0
// Address: 0x15d1f0 - 0x15d22c

void entry_15d1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d1f0: 0x4614d802
    ctx->f[0] = FPU_MUL_S(ctx->f[27], ctx->f[20]);
    // 0x15d1f4: 0x8e870040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x15d1f8: 0x4615c040
    ctx->f[1] = FPU_ADD_S(ctx->f[24], ctx->f[21]);
    // 0x15d1fc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d200: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d204: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x15d208: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x15d20c: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x15d210: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x15d214: 0x44101000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[2]);
    // 0x15d218: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x15d21c: 0x44120800
    SET_GPR_U32(ctx, 18, *(uint32_t*)&ctx->f[1]);
    // 0x15d220: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15d224: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15d22c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15d22c
// Address: 0x15d22c - 0x15d23c

void entry_15d22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d22c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15d230: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d234: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15d23c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15d23c
// Address: 0x15d23c - 0x15d268

void entry_15d23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d23c: 0x4614cd02
    ctx->f[20] = FPU_MUL_S(ctx->f[25], ctx->f[20]);
    // 0x15d240: 0x8e870040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x15d244: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15d248: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d24c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d250: 0x4617a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[23]);
    // 0x15d254: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x15d258: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x15d25c: 0x44110000
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[0]);
    // 0x15d260: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15d268);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15d268
// Address: 0x15d268 - 0x15d278

void entry_15d268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d268: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x15d26c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d270: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15d278);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15d278
// Address: 0x15d278 - 0x15d2a0

void entry_15d278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d278: 0x4615e540
    ctx->f[21] = FPU_ADD_S(ctx->f[28], ctx->f[21]);
    // 0x15d27c: 0x8e870040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x15d280: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d284: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d288: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d28c: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x15d290: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x15d294: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x15d298: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15d2a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15d2a0
// Address: 0x15d2a0 - 0x15d2b0

void entry_15d2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d2a0: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x15d2a4: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15d2a8: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15d2b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15d2b0
// Address: 0x15d2b0 - 0x15d2c8

void entry_15d2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d2b0: 0x8e870040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x15d2b4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d2b8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15d2bc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15d2c0: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15d2c8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15d2c8
// Address: 0x15d2c8 - 0x15d2e8

void entry_15d2c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d2c8: 0x8e83004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 76)));
    // 0x15d2cc: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x15d2d0: 0x24c62280
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8832));
    // 0x15d2d4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d2d8: 0x84640038
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x15d2dc: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x15d2e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15d2e8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15d2e8
// Address: 0x15d2e8 - 0x15d338

void entry_15d2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15d2e8) {
        switch (ctx->pc) {
            case 0x15d2ec: ctx->pc = 0; goto label_15d2ec;
            case 0x15d2f0: ctx->pc = 0; goto label_15d2f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15d2e8: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_15d2ec:
    // 0x15d2ec: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_15d2f0:
    // 0x15d2f0: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15d2f4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15d2f8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15d2fc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15d300: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15d304: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15d308: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15d30c: 0xc7bc00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[28] = *(float*)&val; }
    // 0x15d310: 0xc7bb00c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[27] = *(float*)&val; }
    // 0x15d314: 0xc7ba00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[26] = *(float*)&val; }
    // 0x15d318: 0xc7b900b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[25] = *(float*)&val; }
    // 0x15d31c: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x15d320: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x15d324: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x15d328: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x15d32c: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x15d330: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawPart__8CFontBrxffffffffUiP4GIFS
// Address: 0x15d338 - 0x15d3d4

void entry_15d3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d3d4: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x15d3d8: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x15d3dc: 0x4481f000
    *(uint32_t*)&ctx->f[30] = GPR_U32(ctx, 1);
    // 0x15d3e0: 0x4615b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[21]);
    // 0x15d3e4: 0x4615bdc2
    ctx->f[23] = FPU_MUL_S(ctx->f[23], ctx->f[21]);
    // 0x15d3e8: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x15d3ec: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x15d3f0: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x15d3f4: 0x4481f800
    *(uint32_t*)&ctx->f[31] = GPR_U32(ctx, 1);
    // 0x15d3f8: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x15d3fc: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x15d400: 0x4600b824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[23]);
    // 0x15d404: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x15d408: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15d410);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15d410
// Address: 0x15d410 - 0x15d444

void entry_15d410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d410: 0x461ea502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[30]);
    // 0x15d414: 0x8e270040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x15d418: 0x461dce40
    ctx->f[25] = FPU_ADD_S(ctx->f[25], ctx->f[29]);
    // 0x15d41c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d420: 0x461fa500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[31]);
    // 0x15d424: 0x4615ce42
    ctx->f[25] = FPU_MUL_S(ctx->f[25], ctx->f[21]);
    // 0x15d428: 0x4615a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x15d42c: 0x4600c824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[25]);
    // 0x15d430: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x15d434: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x15d438: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x15d43c: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15d444);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15d444
// Address: 0x15d444 - 0x15d464

void entry_15d444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d444: 0x4615d682
    ctx->f[26] = FPU_MUL_S(ctx->f[26], ctx->f[21]);
    // 0x15d448: 0x4615dec2
    ctx->f[27] = FPU_MUL_S(ctx->f[27], ctx->f[21]);
    // 0x15d44c: 0x4600d024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[26]);
    // 0x15d450: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x15d454: 0x4600d824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[27]);
    // 0x15d458: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x15d45c: 0xc058618
    SET_GPR_U32(ctx, 31, 0x15d464);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ListUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15d464
// Address: 0x15d464 - 0x15d498

void entry_15d464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d464: 0x461ec602
    ctx->f[24] = FPU_MUL_S(ctx->f[24], ctx->f[30]);
    // 0x15d468: 0x8e270040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x15d46c: 0x461de700
    ctx->f[28] = FPU_ADD_S(ctx->f[28], ctx->f[29]);
    // 0x15d470: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15d474: 0x461fc600
    ctx->f[24] = FPU_ADD_S(ctx->f[24], ctx->f[31]);
    // 0x15d478: 0x4615e702
    ctx->f[28] = FPU_MUL_S(ctx->f[28], ctx->f[21]);
    // 0x15d47c: 0x4615c602
    ctx->f[24] = FPU_MUL_S(ctx->f[24], ctx->f[21]);
    // 0x15d480: 0x4600e024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[28]);
    // 0x15d484: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x15d488: 0x4600c024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[24]);
    // 0x15d48c: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x15d490: 0xc058630
    SET_GPR_U32(ctx, 31, 0x15d498);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ListXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15d498
// Address: 0x15d498 - 0x15d4e0

void entry_15d498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d498: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15d49c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15d4a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15d4a4: 0xc7bf0088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[31] = *(float*)&val; }
    // 0x15d4a8: 0xc7be0080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[30] = *(float*)&val; }
    // 0x15d4ac: 0xc7bd0078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[29] = *(float*)&val; }
    // 0x15d4b0: 0xc7bc0070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[28] = *(float*)&val; }
    // 0x15d4b4: 0xc7bb0068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[27] = *(float*)&val; }
    // 0x15d4b8: 0xc7ba0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[26] = *(float*)&val; }
    // 0x15d4bc: 0xc7b90058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[25] = *(float*)&val; }
    // 0x15d4c0: 0xc7b80050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[24] = *(float*)&val; }
    // 0x15d4c4: 0xc7b70048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[23] = *(float*)&val; }
    // 0x15d4c8: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x15d4cc: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x15d4d0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x15d4d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15d4dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15d4e0; return;
}


// Function: EdgeRect__8CFontBrxP9CTextEdgeP8CTextBoxP4GIFS
// Address: 0x15d4e0 - 0x15d54c

void entry_15d54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d54c: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15d550: 0x12a000bf
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15D850; return;
    }
    // 0x15d558: 0xc66c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 16)); ctx->f[12] = *(float*)&val; }
    // 0x15d55c: 0xc66d0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 20)); ctx->f[13] = *(float*)&val; }
    // 0x15d560: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x15d568);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_15d568
// Address: 0x15d568 - 0x15d664

void entry_15d568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d568: 0xde420060
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 96)));
    // 0x15d56c: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15d570: 0xc6430044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 68)); ctx->f[3] = *(float*)&val; }
    // 0x15d574: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d578: 0x217ba
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 30);
    // 0x15d57c: 0xc69a0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 0)); ctx->f[26] = *(float*)&val; }
    // 0x15d580: 0x3042000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 15));
    // 0x15d584: 0x96b10006
    SET_GPR_U32(ctx, 17, (uint16_t)READ16(ADD32(GPR_U32(ctx, 21), 6)));
    // 0x15d588: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x15d58c: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x15d590: 0xc6970008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[23] = *(float*)&val; }
    // 0x15d594: 0xc6600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15d598: 0x508004
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), GPR_U32(ctx, 2) & 0x1F));
    // 0x15d59c: 0x96a30004
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x15d5a0: 0x4491c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 17);
    // 0x15d5a4: 0x4680c620
    ctx->f[24] = FPU_CVT_S_W(*(int32_t*)&ctx->f[24]);
    // 0x15d5a8: 0xc6420048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 72)); ctx->f[2] = *(float*)&val; }
    // 0x15d5ac: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x15d5b0: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x15d5b4: 0x4617d5c0
    ctx->f[23] = FPU_ADD_S(ctx->f[26], ctx->f[23]);
    // 0x15d5b8: 0xc69b0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[27] = *(float*)&val; }
    // 0x15d5bc: 0x2034823
    SET_GPR_U32(ctx, 9, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x15d5c0: 0xc699000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 12)); ctx->f[25] = *(float*)&val; }
    // 0x15d5c4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15d5c8: 0xc661000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 12)); ctx->f[1] = *(float*)&val; }
    // 0x15d5cc: 0x4482b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 2);
    // 0x15d5d0: 0x4680b5a0
    ctx->f[22] = FPU_CVT_S_W(*(int32_t*)&ctx->f[22]);
    // 0x15d5d4: 0x4619de40
    ctx->f[25] = FPU_ADD_S(ctx->f[27], ctx->f[25]);
    // 0x15d5d8: 0x2038023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x15d5dc: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x15d5e0: 0x96a70002
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 21), 2)));
    // 0x15d5e4: 0x4603c602
    ctx->f[24] = FPU_MUL_S(ctx->f[24], ctx->f[3]);
    // 0x15d5e8: 0x1301821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 16)));
    // 0x15d5ec: 0x4600bdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
    // 0x15d5f0: 0x8e46004c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 76)));
    // 0x15d5f4: 0x4601ce40
    ctx->f[25] = FPU_ADD_S(ctx->f[25], ctx->f[1]);
    // 0x15d5f8: 0x317c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 3), 31));
    // 0x15d5fc: 0x4602b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[2]);
    // 0x15d600: 0xf18821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 17)));
    // 0x15d604: 0x4600d681
    ctx->f[26] = FPU_SUB_S(ctx->f[26], ctx->f[0]);
    // 0x15d608: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15d60c: 0x4601dec1
    ctx->f[27] = FPU_SUB_S(ctx->f[27], ctx->f[1]);
    // 0x15d610: 0xf11021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 17)));
    // 0x15d614: 0x4618b800
    ctx->f[0] = FPU_ADD_S(ctx->f[23], ctx->f[24]);
    // 0x15d618: 0x84c40020
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x15d61c: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x15d620: 0x31843
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 1));
    // 0x15d624: 0x8cc80024
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 36)));
    // 0x15d628: 0x4616cf80
    ctx->f[30] = FPU_ADD_S(ctx->f[25], ctx->f[22]);
    // 0x15d62c: 0x4482a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 2);
    // 0x15d630: 0x4680ad60
    ctx->f[21] = FPU_CVT_S_W(*(int32_t*)&ctx->f[21]);
    // 0x15d634: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x15d638: 0x4483a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 3);
    // 0x15d63c: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x15d640: 0x2442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    // 0x15d644: 0x4487f800
    *(uint32_t*)&ctx->f[31] = GPR_U32(ctx, 7);
    // 0x15d648: 0x4680ffe0
    ctx->f[31] = FPU_CVT_S_W(*(int32_t*)&ctx->f[31]);
    // 0x15d64c: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15d650: 0x4489e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 9);
    // 0x15d654: 0x4680ef60
    ctx->f[29] = FPU_CVT_S_W(*(int32_t*)&ctx->f[29]);
    // 0x15d658: 0x4618d601
    ctx->f[24] = FPU_SUB_S(ctx->f[26], ctx->f[24]);
    // 0x15d65c: 0x100f809
    SET_GPR_U32(ctx, 31, 0x15d664);
    ctx->f[22] = FPU_SUB_S(ctx->f[27], ctx->f[22]);
    ctx->pc = GPR_U32(ctx, 8); return;
}


// Function: entry_15d664
// Address: 0x15d664 - 0x15d6a8

void entry_15d664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d664: 0x4490e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 16);
    // 0x15d668: 0x4680e720
    ctx->f[28] = FPU_CVT_S_W(*(int32_t*)&ctx->f[28]);
    // 0x15d66c: 0x44910000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 17);
    // 0x15d670: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15d674: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d678: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x15d67c: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x15d680: 0x4600d386
    ctx->f[14] = FPU_MOV_S(ctx->f[26]);
    // 0x15d684: 0x4600dbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[27]);
    // 0x15d688: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x15d68c: 0x4600fc06
    ctx->f[16] = FPU_MOV_S(ctx->f[31]);
    // 0x15d690: 0x4600ec46
    ctx->f[17] = FPU_MOV_S(ctx->f[29]);
    // 0x15d694: 0x4600ac86
    ctx->f[18] = FPU_MOV_S(ctx->f[21]);
    // 0x15d698: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d69c: 0x4600a4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[20]);
    // 0x15d6a0: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d6a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d6a8
// Address: 0x15d6a8 - 0x15d6d8

void entry_15d6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d6a8: 0xc7ae0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[14] = *(float*)&val; }
    // 0x15d6ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d6b0: 0xc7b20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[18] = *(float*)&val; }
    // 0x15d6b4: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x15d6b8: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d6bc: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x15d6c0: 0x4600dbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[27]);
    // 0x15d6c4: 0x4600ac06
    ctx->f[16] = FPU_MOV_S(ctx->f[21]);
    // 0x15d6c8: 0x4600ec46
    ctx->f[17] = FPU_MOV_S(ctx->f[29]);
    // 0x15d6cc: 0x4600a4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[20]);
    // 0x15d6d0: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d6d8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d6d8
// Address: 0x15d6d8 - 0x15d708

void entry_15d6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d6d8: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d6dc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d6e0: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x15d6e4: 0x4600cb46
    ctx->f[13] = FPU_MOV_S(ctx->f[25]);
    // 0x15d6e8: 0x4600d386
    ctx->f[14] = FPU_MOV_S(ctx->f[26]);
    // 0x15d6ec: 0x4600f3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[30]);
    // 0x15d6f0: 0x4600fc06
    ctx->f[16] = FPU_MOV_S(ctx->f[31]);
    // 0x15d6f4: 0x4600a446
    ctx->f[17] = FPU_MOV_S(ctx->f[20]);
    // 0x15d6f8: 0x4600ac86
    ctx->f[18] = FPU_MOV_S(ctx->f[21]);
    // 0x15d6fc: 0x4600e4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[28]);
    // 0x15d700: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d708);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d708
// Address: 0x15d708 - 0x15d738

void entry_15d708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d708: 0xc7ae0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[14] = *(float*)&val; }
    // 0x15d70c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d710: 0xc7b20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[18] = *(float*)&val; }
    // 0x15d714: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x15d718: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d71c: 0x4600cb46
    ctx->f[13] = FPU_MOV_S(ctx->f[25]);
    // 0x15d720: 0x4600f3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[30]);
    // 0x15d724: 0x4600ac06
    ctx->f[16] = FPU_MOV_S(ctx->f[21]);
    // 0x15d728: 0x4600a446
    ctx->f[17] = FPU_MOV_S(ctx->f[20]);
    // 0x15d72c: 0x4600e4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[28]);
    // 0x15d730: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d738);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d738
// Address: 0x15d738 - 0x15d768

void entry_15d738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d738: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d73c: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x15d740: 0x4600ec46
    ctx->f[17] = FPU_MOV_S(ctx->f[29]);
    // 0x15d744: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d748: 0x4600d306
    ctx->f[12] = FPU_MOV_S(ctx->f[26]);
    // 0x15d74c: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x15d750: 0x4600dbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[27]);
    // 0x15d754: 0x4600ac06
    ctx->f[16] = FPU_MOV_S(ctx->f[21]);
    // 0x15d758: 0x4600ac86
    ctx->f[18] = FPU_MOV_S(ctx->f[21]);
    // 0x15d75c: 0x4600a4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[20]);
    // 0x15d760: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d768);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d768
// Address: 0x15d768 - 0x15d798

void entry_15d768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d768: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d76c: 0x4600f3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[30]);
    // 0x15d770: 0x4600e4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[28]);
    // 0x15d774: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d778: 0x4600d306
    ctx->f[12] = FPU_MOV_S(ctx->f[26]);
    // 0x15d77c: 0x4600cb46
    ctx->f[13] = FPU_MOV_S(ctx->f[25]);
    // 0x15d780: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x15d784: 0x4600ac06
    ctx->f[16] = FPU_MOV_S(ctx->f[21]);
    // 0x15d788: 0x4600a446
    ctx->f[17] = FPU_MOV_S(ctx->f[20]);
    // 0x15d78c: 0x4600ac86
    ctx->f[18] = FPU_MOV_S(ctx->f[21]);
    // 0x15d790: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d798);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d798
// Address: 0x15d798 - 0x15d7c8

void entry_15d798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d798: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d79c: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x15d7a0: 0x4600fc06
    ctx->f[16] = FPU_MOV_S(ctx->f[31]);
    // 0x15d7a4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d7a8: 0x4600db46
    ctx->f[13] = FPU_MOV_S(ctx->f[27]);
    // 0x15d7ac: 0x4600d386
    ctx->f[14] = FPU_MOV_S(ctx->f[26]);
    // 0x15d7b0: 0x4600cbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[25]);
    // 0x15d7b4: 0x4600a446
    ctx->f[17] = FPU_MOV_S(ctx->f[20]);
    // 0x15d7b8: 0x4600ac86
    ctx->f[18] = FPU_MOV_S(ctx->f[21]);
    // 0x15d7bc: 0x4600a4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[20]);
    // 0x15d7c0: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d7c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d7c8
// Address: 0x15d7c8 - 0x15d7f8

void entry_15d7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d7c8: 0xc7ae0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[14] = *(float*)&val; }
    // 0x15d7cc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d7d0: 0xc7b20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[18] = *(float*)&val; }
    // 0x15d7d4: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x15d7d8: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d7dc: 0x4600db46
    ctx->f[13] = FPU_MOV_S(ctx->f[27]);
    // 0x15d7e0: 0x4600cbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[25]);
    // 0x15d7e4: 0x4600ac06
    ctx->f[16] = FPU_MOV_S(ctx->f[21]);
    // 0x15d7e8: 0x4600a446
    ctx->f[17] = FPU_MOV_S(ctx->f[20]);
    // 0x15d7ec: 0x4600a4c6
    ctx->f[19] = FPU_MOV_S(ctx->f[20]);
    // 0x15d7f0: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d7f8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d7f8
// Address: 0x15d7f8 - 0x15d828

void entry_15d7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d7f8: 0x4600ac06
    ctx->f[16] = FPU_MOV_S(ctx->f[21]);
    // 0x15d7fc: 0x4600a446
    ctx->f[17] = FPU_MOV_S(ctx->f[20]);
    // 0x15d800: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x15d804: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15d808: 0x4600d306
    ctx->f[12] = FPU_MOV_S(ctx->f[26]);
    // 0x15d80c: 0x4600db46
    ctx->f[13] = FPU_MOV_S(ctx->f[27]);
    // 0x15d810: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x15d814: 0x4600cbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[25]);
    // 0x15d818: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d81c: 0x46008486
    ctx->f[18] = FPU_MOV_S(ctx->f[16]);
    // 0x15d820: 0xc0574ce
    SET_GPR_U32(ctx, 31, 0x15d828);
    ctx->f[19] = FPU_MOV_S(ctx->f[17]);
    DrawPart__8CFontBrxffffffffUiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15d828
// Address: 0x15d828 - 0x15d830

void entry_15d828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d828: 0xc057240
    SET_GPR_U32(ctx, 31, 0x15d830);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_15d830
// Address: 0x15d830 - 0x15d84c

void entry_15d830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d830: 0x8e43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 76)));
    // 0x15d834: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15d838: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15d83c: 0x84640038
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x15d840: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x15d844: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15d84c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15d84c
// Address: 0x15d84c - 0x15d8a8

void entry_15d84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15d84c) {
        switch (ctx->pc) {
            case 0x15d850: ctx->pc = 0; goto label_15d850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15d84c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_15d850:
    // 0x15d850: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15d854: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15d858: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15d85c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15d860: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15d864: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15d868: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15d86c: 0xc7bf00e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[31] = *(float*)&val; }
    // 0x15d870: 0xc7be00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[30] = *(float*)&val; }
    // 0x15d874: 0xc7bd00d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[29] = *(float*)&val; }
    // 0x15d878: 0xc7bc00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[28] = *(float*)&val; }
    // 0x15d87c: 0xc7bb00c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[27] = *(float*)&val; }
    // 0x15d880: 0xc7ba00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[26] = *(float*)&val; }
    // 0x15d884: 0xc7b900b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[25] = *(float*)&val; }
    // 0x15d888: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x15d88c: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x15d890: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x15d894: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x15d898: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x15d89c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15d8a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15d8a8; return;
}


// Function: LoadFromBrx__8CFontBrxP18CBinaryInputStream
// Address: 0x15d8a8 - 0x15d8d0

void entry_15d8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15d8d0) {
        switch (ctx->pc) {
            case 0x15d92c: ctx->pc = 0; goto label_15d92c;
            case 0x15d930: ctx->pc = 0; goto label_15d930;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15d8d0: 0x93a60007
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 7)));
    // 0x15d8d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x15d8d8: 0x8c454504
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 17668)));
    // 0x15d8dc: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15d8e0: 0x97a40000
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15d8e4: 0x24632268
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8808));
    // 0x15d8e8: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x15d8ec: 0xae060050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 6));
    // 0x15d8f0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15d8f4: 0x42140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 5));
    // 0x15d8f8: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x15d8fc: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x15d900: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x15d904: 0x97a30002
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 2)));
    // 0x15d908: 0x10620008
    WRITE32(ADD32(GPR_U32(ctx, 16), 84), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_15d92c;
    }
    // 0x15d910: 0x97a30002
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 2)));
    // 0x15d914: 0x24040018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    // 0x15d918: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x15d91c: 0x641818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x15d920: 0x8ca2450c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 17676)));
    // 0x15d924: 0x10000002
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15d930;
    }
label_15d92c:
    // 0x15d92c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_15d930:
    // 0x15d930: 0x97a6000c
    SET_GPR_U32(ctx, 6, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x15d934: 0x93a50005
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 5)));
    // 0x15d938: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15d93c: 0x620c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 6), 3));
    // 0x15d940: 0x93a30004
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x15d944: 0x93a20006
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 6)));
    // 0x15d948: 0xae070058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 7));
    // 0x15d94c: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x15d950: 0xae050004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 5));
    // 0x15d954: 0xe6000048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 72), *(uint32_t*)&val); }
    // 0x15d958: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x15d95c: 0xae060078
    WRITE32(ADD32(GPR_U32(ctx, 16), 120), GPR_U32(ctx, 6));
    // 0x15d960: 0xc063540
    SET_GPR_U32(ctx, 31, 0x15d968);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_15d968
// Address: 0x15d968 - 0x15d980

void entry_15d968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d968: 0x8e050078
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 120)));
    // 0x15d96c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15d970: 0xae02007c
    WRITE32(ADD32(GPR_U32(ctx, 16), 124), GPR_U32(ctx, 2));
    // 0x15d974: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15d978: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x15d980);
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 3));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_15d980
// Address: 0x15d980 - 0x15d998

void entry_15d980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d980: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15d984: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15d988: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15d98c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15d994: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15d998; return;
}


// Function: PostLoad__8CFontBrxP3GSB
// Address: 0x15d998 - 0x15d9c0

void entry_15d9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d9c0: 0x8e030054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x15d9c4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15d9c8: 0xc05a362
    SET_GPR_U32(ctx, 31, 0x15d9d0);
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 10)));
    IgsAllocGsb__FP3GSBi(rdram, ctx, runtime); return;
}


// Function: entry_15d9d0
// Address: 0x15d9d0 - 0x15d9e0

void entry_15d9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d9d0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15d9d4: 0x8e040054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x15d9d8: 0xc05a3ec
    SET_GPR_U32(ctx, 31, 0x15d9e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    BuildBmpTex0__FP3BMPi(rdram, ctx, runtime); return;
}


// Function: entry_15d9e0
// Address: 0x15d9e0 - 0x15da00

void entry_15d9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15d9e0: 0x8e030054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x15d9e4: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x15d9e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15d9ec: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x15d9f0: 0xdc620018
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x15d9f4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15d9f8: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x15da00);
    WRITE64(ADD32(GPR_U32(ctx, 16), 96), GPR_U64(ctx, 2));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15da00
// Address: 0x15da00 - 0x15da10

void entry_15da00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15da00: 0x8e040054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x15da04: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15da08: 0xc05a422
    SET_GPR_U32(ctx, 31, 0x15da10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    BuildBmpGifs__FP3BMPiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15da10
// Address: 0x15da10 - 0x15da28

void entry_15da10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15da10: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15da14: 0x26050068
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 104));
    // 0x15da18: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15da1c: 0x2607006c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 108));
    // 0x15da20: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x15da28);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 7));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_15da28
// Address: 0x15da28 - 0x15da40

void entry_15da28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15da28: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x15da2c: 0x1040001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15DAA0; return;
    }
    // 0x15da34: 0x94450006
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 6)));
    // 0x15da38: 0xc05a362
    SET_GPR_U32(ctx, 31, 0x15da40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    IgsAllocGsb__FP3GSBi(rdram, ctx, runtime); return;
}


// Function: entry_15da40
// Address: 0x15da40 - 0x15da50

void entry_15da40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15da40: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15da44: 0x8e040058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x15da48: 0xc05a39e
    SET_GPR_U32(ctx, 31, 0x15da50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    BuildClutTex2__FP4CLUTi(rdram, ctx, runtime); return;
}


// Function: entry_15da50
// Address: 0x15da50 - 0x15da74

void entry_15da50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15da50: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x15da54: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15da58: 0xde030060
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x15da5c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15da60: 0xdc470010
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x15da64: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x15da68: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x15da6c: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x15da74);
    WRITE64(ADD32(GPR_U32(ctx, 16), 96), GPR_U64(ctx, 3));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15da74
// Address: 0x15da74 - 0x15da84

void entry_15da74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15da74: 0x8e040058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x15da78: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15da7c: 0xc05a3d2
    SET_GPR_U32(ctx, 31, 0x15da84);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    BuildClutGifs__FP4CLUTiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15da84
// Address: 0x15da84 - 0x15da9c

void entry_15da84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15da84: 0x26070074
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 116));
    // 0x15da88: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15da8c: 0x26050070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 112));
    // 0x15da90: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15da94: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x15da9c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 7));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_15da9c
// Address: 0x15da9c - 0x15dab8

void entry_15da9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15da9c) {
        switch (ctx->pc) {
            case 0x15daa0: ctx->pc = 0; goto label_15daa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15da9c: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
label_15daa0:
    // 0x15daa0: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x15daa4: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x15daa8: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x15daac: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x15dab0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PglyffFromCh__8CFontBrxc
// Address: 0x15dab8 - 0x15db28

void entry_15db68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15db68: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15db6c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15db70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15db74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15db7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15db80; return;
}


// Function: Reset__9CRichText
// Address: 0x15db80 - 0x15dbb8

void entry_15dddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15dddc: 0x10400023
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15DE6C; return;
    }
    // 0x15dde4: 0xc05726c
    SET_GPR_U32(ctx, 31, 0x15ddec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CopyTo__8CFontBrxP8CFontBrx(rdram, ctx, runtime); return;
}


// Function: entry_15ddec
// Address: 0x15ddec - 0x15debc

void entry_15ddec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ddec) {
        switch (ctx->pc) {
            case 0x15de6c: ctx->pc = 0; goto label_15de6c;
            case 0x15de90: ctx->pc = 0; goto label_15de90;
            case 0x15dea0: ctx->pc = 0; goto label_15dea0;
            case 0x15deac: ctx->pc = 0; goto label_15deac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ddec: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x15ddf0: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x15ddf4: 0x24420002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2));
    // 0x15ddf8: 0xc6050054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 84)); ctx->f[5] = *(float*)&val; }
    // 0x15ddfc: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x15de00: 0xc6020058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[2] = *(float*)&val; }
    // 0x15de04: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15de08: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15de0c: 0xc4630048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 72)); ctx->f[3] = *(float*)&val; }
    // 0x15de10: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x15de14: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15de18: 0xc6240048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[4] = *(float*)&val; }
    // 0x15de1c: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    // 0x15de20: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x15de24: 0x9202009f
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 159)));
    // 0x15de28: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x15de2c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x15de30: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x15de34: 0x46002942
    ctx->f[5] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x15de38: 0xe6020058
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 88), *(uint32_t*)&val); }
    // 0x15de3c: 0xe6050054
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
    // 0x15de40: 0x8a0300ab
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 171); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x15de44: 0x9a0300a8
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 168); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x15de48: 0xaba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15de4c: 0xbba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15de50: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x15de54: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x15de58: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x15de5c: 0xaa02009f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 159); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15de60: 0xba02009c
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 156); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15de64: 0x1000002e
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15DF20; return;
    }
label_15de6c:
    // 0x15de6c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x15de70: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15de74: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x15de78: 0x8a0600a7
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 167); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x15de7c: 0x9a0600a4
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 164); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x15de80: 0xaa06009f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 159); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15de84: 0xba06009c
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 156); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15de88: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15DF20; return;
    }
label_15de90:
    // 0x15de90: 0x80a20001
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 1)));
    // 0x15de94: 0x14430005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_15deac;
    }
    // 0x15de9c: 0x24a20001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 1));
label_15dea0:
    // 0x15dea0: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15dea4: 0x1000001e
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15DF20; return;
    }
label_15deac:
    // 0x15deac: 0x54530007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 2)));
        ctx->pc = 0x15DECC; return;
    }
    // 0x15deb4: 0xc057240
    SET_GPR_U32(ctx, 31, 0x15debc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_15debc
// Address: 0x15debc - 0x15df14

void entry_15debc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15debc) {
        switch (ctx->pc) {
            case 0x15dec0: ctx->pc = 0; goto label_15dec0;
            case 0x15decc: ctx->pc = 0; goto label_15decc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15debc: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_15dec0:
    // 0x15dec0: 0x24420002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2));
    // 0x15dec4: 0x10000016
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15DF20; return;
    }
label_15decc:
    // 0x15decc: 0x2442ffd0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967248));
    // 0x15ded0: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x15ded4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x15ded8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x15dedc: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x15dee0: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x15dee4: 0x2463ffd0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967248));
    // 0x15dee8: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15deec: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x15def0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15def4: 0xc44c0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[12] = *(float*)&val; }
    // 0x15def8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15defc: 0xc44d0048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[13] = *(float*)&val; }
    // 0x15df00: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x15df04: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15df08: 0x460d0b42
    ctx->f[13] = FPU_MUL_S(ctx->f[1], ctx->f[13]);
    // 0x15df0c: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x15df14);
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_15df14
// Address: 0x15df14 - 0x15df58

void entry_15df14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15df14) {
        switch (ctx->pc) {
            case 0x15df20: ctx->pc = 0; goto label_15df20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15df14: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x15df18: 0x24420003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3));
    // 0x15df1c: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_15df20:
    // 0x15df20: 0x5240ff3d
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x15DC18; return;
    }
    // 0x15df28: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x15df2c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15df30: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15df34: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x15df38: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15df3c: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    // 0x15df40: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15df44: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15df48: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15df4c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15df50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Cch__9CRichText
// Address: 0x15df58 - 0x15df74

void entry_15df74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15df74) {
        switch (ctx->pc) {
            case 0x15df78: ctx->pc = 0; goto label_15df78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15df74: 0x0
    // NOP
label_15df78:
    // 0x15df78: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x15df80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15df80
// Address: 0x15df80 - 0x15dfa0

void entry_15df80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15df80: 0x5440fffd
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        ctx->pc = 0x15DF78; return;
    }
    // 0x15df88: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15df8c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15df90: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15df94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15df98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Trim__9CRichTexti
// Address: 0x15dfa0 - 0x15dfbc

void entry_15dfbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15dfbc) {
        switch (ctx->pc) {
            case 0x15dfc0: ctx->pc = 0; goto label_15dfc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15dfbc: 0x0
    // NOP
label_15dfc0:
    // 0x15dfc0: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x15dfc8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15dfc8
// Address: 0x15dfc8 - 0x15dff8

void entry_15dfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15dfc8) {
        switch (ctx->pc) {
            case 0x15dfdc: ctx->pc = 0; goto label_15dfdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15dfc8: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_15dfdc;
    }
    // 0x15dfd0: 0x1600fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15DFC0; return;
    }
    // 0x15dfd8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_15dfdc:
    // 0x15dfdc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15dfe0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15dfe4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15dfe8: 0xa0400000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x15dfec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15dff4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15dff8; return;
}


// Function: Dx__9CRichText
// Address: 0x15dff8 - 0x15e014

void entry_15e014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e014) {
        switch (ctx->pc) {
            case 0x15e020: ctx->pc = 0; goto label_15e020;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e014: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E03C; return;
    }
    // 0x15e01c: 0x0
    // NOP
label_15e020:
    // 0x15e020: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15e024: 0x8cc2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x15e028: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x15e02c: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x15e030: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15e038);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15e038
// Address: 0x15e038 - 0x15e044

void entry_15e038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e038) {
        switch (ctx->pc) {
            case 0x15e03c: ctx->pc = 0; goto label_15e03c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e038: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
label_15e03c:
    // 0x15e03c: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x15e044);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e044
// Address: 0x15e044 - 0x15e068

void entry_15e044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e044: 0x5440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x15E020; return;
    }
    // 0x15e04c: 0x4600a006
    ctx->f[0] = FPU_MOV_S(ctx->f[20]);
    // 0x15e050: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15e054: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15e058: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x15e05c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15e064: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15e068; return;
}


// Function: ClineWrap__9CRichTextf
// Address: 0x15e068 - 0x15e0b4

void entry_15e0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e0b4) {
        switch (ctx->pc) {
            case 0x15e0c0: ctx->pc = 0; goto label_15e0c0;
            case 0x15e0d4: ctx->pc = 0; goto label_15e0d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e0b4: 0x1000002e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E170; return;
    }
    // 0x15e0bc: 0x0
    // NOP
label_15e0c0:
    // 0x15e0c0: 0x54520004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_15e0d4;
    }
    // 0x15e0c8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x15e0cc: 0x10000008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E0F0; return;
    }
label_15e0d4:
    // 0x15e0d4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15e0d8: 0x8cc2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x15e0dc: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x15e0e0: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x15e0e4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15e0ec);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15e0ec
// Address: 0x15e0ec - 0x15e178

void entry_15e0ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e0ec) {
        switch (ctx->pc) {
            case 0x15e0f0: ctx->pc = 0; goto label_15e0f0;
            case 0x15e118: ctx->pc = 0; goto label_15e118;
            case 0x15e144: ctx->pc = 0; goto label_15e144;
            case 0x15e154: ctx->pc = 0; goto label_15e154;
            case 0x15e170: ctx->pc = 0; goto label_15e170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e0ec: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
label_15e0f0:
    // 0x15e0f0: 0x4616a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15e0f4: 0x4501001e
    if ((ctx->fcr31 & 0x800000)) {
        goto label_15e170;
    }
    // 0x15e0fc: 0x4614a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15e100: 0x4500001b
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_15e170;
    }
    // 0x15e108: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x15e10c: 0x2443ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x15e110: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15e114: 0x0
    // NOP
label_15e118:
    // 0x15e118: 0x65102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x15e11c: 0x1440000d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15e154;
    }
    // 0x15e124: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x15e128: 0x1044000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_15e154;
    }
    // 0x15e130: 0x50540004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
        goto label_15e144;
    }
    // 0x15e138: 0x5453fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
        goto label_15e118;
    }
    // 0x15e140: 0x24620001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
label_15e144:
    // 0x15e144: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x15e148: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x15e14c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x15e150: 0xa0640000
    WRITE8(ADD32(GPR_U32(ctx, 3), 0), (uint8_t)GPR_U32(ctx, 4));
label_15e154:
    // 0x15e154: 0x4616a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x15e158: 0x45010005
    if ((ctx->fcr31 & 0x800000)) {
        goto label_15e170;
    }
    // 0x15e160: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x15e164: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x15e168: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x15e16c: 0xa0520000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 18));
label_15e170:
    // 0x15e170: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x15e178);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e178
// Address: 0x15e178 - 0x15e1b0

void entry_15e178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e178: 0x1440ffd1
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E0C0; return;
    }
    // 0x15e180: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15e184: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15e188: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15e18c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15e190: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15e194: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15e198: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x15e19c: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x15e1a0: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x15e1a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15e1ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15e1b0; return;
}


// Function: FUN_0015e1b0
// Address: 0x15e1b0 - 0x15e1d4

void FUN_0015e1b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e1b0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x15e1b4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x15e1b8: 0xe7b40010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x15e1bc: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x15e1c0: 0xc4540008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[20] = *(float*)&val; }
    // 0x15e1c4: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x15e1c8: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x15e1cc: 0xc05781a
    SET_GPR_U32(ctx, 31, 0x15e1d4);
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    ClineWrap__9CRichTextf(rdram, ctx, runtime); return;
}


// Function: entry_15e1d4
// Address: 0x15e1d4 - 0x15e1f0

void entry_15e1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e1d4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x15e1d8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15e1dc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15e1e0: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x15e1e4: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x15e1e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DxMaxLine__9CRichText
// Address: 0x15e1f0 - 0x15e21c

void entry_15e21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e21c) {
        switch (ctx->pc) {
            case 0x15e228: ctx->pc = 0; goto label_15e228;
            case 0x15e240: ctx->pc = 0; goto label_15e240;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e21c: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E25C; return;
    }
    // 0x15e224: 0x0
    // NOP
label_15e228:
    // 0x15e228: 0x54510005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_15e240;
    }
    // 0x15e230: 0x4614ad28
    ctx->f[20] = std::max(ctx->f[21], ctx->f[20]);
    // 0x15e234: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x15e238: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E25C; return;
    }
label_15e240:
    // 0x15e240: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15e244: 0x8cc2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x15e248: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x15e24c: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x15e250: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15e258);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15e258
// Address: 0x15e258 - 0x15e264

void entry_15e258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e258) {
        switch (ctx->pc) {
            case 0x15e25c: ctx->pc = 0; goto label_15e25c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e258: 0x4600ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
label_15e25c:
    // 0x15e25c: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x15e264);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e264
// Address: 0x15e264 - 0x15e290

void entry_15e264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e264: 0x1440fff0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E228; return;
    }
    // 0x15e26c: 0x4614ad28
    ctx->f[20] = std::max(ctx->f[21], ctx->f[20]);
    // 0x15e270: 0x4600a006
    ctx->f[0] = FPU_MOV_S(ctx->f[20]);
    // 0x15e274: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15e278: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15e27c: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x15e280: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x15e284: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15e28c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15e290; return;
}


// Function: GetExtents__9CRichTextPfT1f
// Address: 0x15e290 - 0x15e2b8

void entry_15e2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e2b8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15e2bc: 0xc05787c
    SET_GPR_U32(ctx, 31, 0x15e2c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DxMaxLine__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e2c4
// Address: 0x15e2c4 - 0x15e318

void entry_15e2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e2c4) {
        switch (ctx->pc) {
            case 0x15e2f0: ctx->pc = 0; goto label_15e2f0;
            case 0x15e2f8: ctx->pc = 0; goto label_15e2f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e2c4: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x15e2c8: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x15e2cc: 0x44911000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 17);
    // 0x15e2d0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x15e2d4: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15e2d8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15e2dc: 0xc4410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[1] = *(float*)&val; }
    // 0x15e2e0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15e2e4: 0x12400002
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_15e2f0;
    }
    // 0x15e2ec: 0xe6430000
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_15e2f0:
    // 0x15e2f0: 0x56600001
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
        goto label_15e2f8;
    }
label_15e2f8:
    // 0x15e2f8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15e2fc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15e300: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15e304: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15e308: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15e30c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15e314: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15e318; return;
}


// Function: Draw__9CRichTextP8CTextBoxT1P4GIFS
// Address: 0x15e318 - 0x15e378

void entry_15e378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e378: 0xc0576e0
    SET_GPR_U32(ctx, 31, 0x15e380);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Reset__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e380
// Address: 0x15e380 - 0x15e3ac

void entry_15e380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e380) {
        switch (ctx->pc) {
            case 0x15e388: ctx->pc = 0; goto label_15e388;
            case 0x15e398: ctx->pc = 0; goto label_15e398;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e380: 0x1000000f
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 256));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E3C0; return;
    }
label_15e388:
    // 0x15e388: 0x54a20003
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_15e398;
    }
    // 0x15e390: 0x1000000b
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E3C0; return;
    }
label_15e398:
    // 0x15e398: 0x8cc2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x15e39c: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x15e3a0: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x15e3a4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15e3ac);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15e3ac
// Address: 0x15e3ac - 0x15e3c8

void entry_15e3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e3ac) {
        switch (ctx->pc) {
            case 0x15e3c0: ctx->pc = 0; goto label_15e3c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e3ac: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x15e3b0: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x15e3b4: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x15e3b8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x15e3bc: 0xe4610000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
label_15e3c0:
    // 0x15e3c0: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x15e3c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e3c8
// Address: 0x15e3c8 - 0x15e460

void entry_15e3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e3c8) {
        switch (ctx->pc) {
            case 0x15e3e8: ctx->pc = 0; goto label_15e3e8;
            case 0x15e424: ctx->pc = 0; goto label_15e424;
            case 0x15e440: ctx->pc = 0; goto label_15e440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e3c8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15e3cc: 0x14a0ffee
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E388; return;
    }
    // 0x15e3d4: 0x8e250018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x15e3d8: 0x54a00003
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_15e3e8;
    }
    // 0x15e3e0: 0x10000017
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15e440;
    }
label_15e3e8:
    // 0x15e3e8: 0x26420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 1));
    // 0x15e3ec: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x15e3f0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x15e3f4: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15e3f8: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15e3fc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15e400: 0xc4610048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 72)); ctx->f[1] = *(float*)&val; }
    // 0x15e404: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15e408: 0x14a40006
    ctx->f[13] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 4)) {
        goto label_15e424;
    }
    // 0x15e410: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x15e414: 0xc621000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[1] = *(float*)&val; }
    // 0x15e418: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15e41c: 0x10000008
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15e440;
    }
label_15e424:
    // 0x15e424: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x15e428: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x15e42c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x15e430: 0x460d0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x15e434: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x15e438: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x15e43c: 0x46000d00
    ctx->f[20] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_15e440:
    // 0x15e440: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15e444: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15e448: 0x8a220013
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x15e44c: 0x9a220010
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x15e450: 0xaba20103
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 259); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15e454: 0xbba20100
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 256); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x15e458: 0xc0576ee
    SET_GPR_U32(ctx, 31, 0x15e460);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetBaseColor__9CRichTextG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_15e460
// Address: 0x15e460 - 0x15e474

void entry_15e460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e460: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x15e464: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x15e468: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15e46c: 0xc0576e0
    SET_GPR_U32(ctx, 31, 0x15e474);
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 2));
    Reset__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e474
// Address: 0x15e474 - 0x15e524

void entry_15e474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e474) {
        switch (ctx->pc) {
            case 0x15e480: ctx->pc = 0; goto label_15e480;
            case 0x15e4ac: ctx->pc = 0; goto label_15e4ac;
            case 0x15e4c8: ctx->pc = 0; goto label_15e4c8;
            case 0x15e4e4: ctx->pc = 0; goto label_15e4e4;
            case 0x15e4f8: ctx->pc = 0; goto label_15e4f8;
            case 0x15e4fc: ctx->pc = 0; goto label_15e4fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e474: 0x10000042
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E580; return;
    }
    // 0x15e47c: 0x0
    // NOP
label_15e480:
    // 0x15e480: 0x1642000a
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        goto label_15e4ac;
    }
    // 0x15e488: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x15e48c: 0x24170001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15e490: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x15e494: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15e498: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x15e49c: 0xc4410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[1] = *(float*)&val; }
    // 0x15e4a0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x15e4a4: 0x10000036
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E580; return;
    }
label_15e4ac:
    // 0x15e4ac: 0x12e00013
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_15e4fc;
    }
    // 0x15e4b4: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x15e4b8: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15e4c8;
    }
    // 0x15e4c0: 0x1000000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[21] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15e4f8;
    }
label_15e4c8:
    // 0x15e4c8: 0x145e0006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 30)) {
        goto label_15e4e4;
    }
    // 0x15e4d0: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x15e4d4: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x15e4d8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x15e4dc: 0x10000006
    ctx->f[21] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15e4f8;
    }
label_15e4e4:
    // 0x15e4e4: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x15e4e8: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x15e4ec: 0x460c0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x15e4f0: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x15e4f4: 0x46000d40
    ctx->f[21] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_15e4f8:
    // 0x15e4f8: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_15e4fc:
    // 0x15e4fc: 0x56a0000b
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 152)));
        ctx->pc = 0x15E52C; return;
    }
    // 0x15e504: 0x8e070008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15e508: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15e50c: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15e510: 0x8ce2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 76)));
    // 0x15e514: 0x84440020
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x15e518: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x15e51c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15e524);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15e524
// Address: 0x15e524 - 0x15e54c

void entry_15e524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e524) {
        switch (ctx->pc) {
            case 0x15e52c: ctx->pc = 0; goto label_15e52c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e524: 0x1000000a
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E550; return;
    }
label_15e52c:
    // 0x15e52c: 0x10400008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E550; return;
    }
    // 0x15e534: 0x8e060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15e538: 0x8cc2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x15e53c: 0x84440028
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x15e540: 0x8c43002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 44)));
    // 0x15e544: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15e54c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15e54c
// Address: 0x15e54c - 0x15e57c

void entry_15e54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e54c) {
        switch (ctx->pc) {
            case 0x15e550: ctx->pc = 0; goto label_15e550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e54c: 0xae000098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
label_15e550:
    // 0x15e550: 0x8e080008
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15e554: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x15e558: 0x8e06009c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    // 0x15e55c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15e560: 0x8d03004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x15e564: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x15e568: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15e56c: 0x84640030
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x15e570: 0x8c620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x15e574: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15e57c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15e57c
// Address: 0x15e57c - 0x15e588

void entry_15e57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e57c) {
        switch (ctx->pc) {
            case 0x15e580: ctx->pc = 0; goto label_15e580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e57c: 0x4600ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
label_15e580:
    // 0x15e580: 0xc0576f8
    SET_GPR_U32(ctx, 31, 0x15e588);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ChNext__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_15e588
// Address: 0x15e588 - 0x15e5b4

void entry_15e588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e588: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15e58c: 0x1640ffbc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E480; return;
    }
    // 0x15e594: 0x8e070008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15e598: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x15e59c: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15e5a0: 0x8ce2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 76)));
    // 0x15e5a4: 0x84440038
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x15e5a8: 0x8c43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 60)));
    // 0x15e5ac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15e5b4);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15e5b4
// Address: 0x15e5b4 - 0x15e5f0

void entry_15e5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e5b4: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x15e5b8: 0x7bbe0190
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x15e5bc: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x15e5c0: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x15e5c4: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x15e5c8: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x15e5cc: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x15e5d0: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x15e5d4: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x15e5d8: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x15e5dc: 0xc7b601c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 448)); ctx->f[22] = *(float*)&val; }
    // 0x15e5e0: 0xc7b501b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 440)); ctx->f[21] = *(float*)&val; }
    // 0x15e5e4: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x15e5e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 464));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostFontsLoad__Fv
// Address: 0x15e5f0 - 0x15e61c

void entry_15e61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e61c) {
        switch (ctx->pc) {
            case 0x15e638: ctx->pc = 0; goto label_15e638;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e61c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15e620: 0x8c622260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8800)));
    // 0x15e624: 0x1840000d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x15E65C; return;
    }
    // 0x15e62c: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x15e630: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15e634: 0x0
    // NOP
label_15e638:
    // 0x15e638: 0x8e442264
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8804)));
    // 0x15e63c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15e640: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x15e644: 0xc057666
    SET_GPR_U32(ctx, 31, 0x15e64c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 17)));
    PostLoad__8CFontBrxP3GSB(rdram, ctx, runtime); return;
}


// Function: entry_15e64c
// Address: 0x15e64c - 0x15e678

void entry_15e64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e64c) {
        switch (ctx->pc) {
            case 0x15e65c: ctx->pc = 0; goto label_15e65c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e64c: 0x8e622260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8800)));
    // 0x15e650: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x15e654: 0x1440fff8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 136));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E638; return;
    }
label_15e65c:
    // 0x15e65c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15e660: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15e664: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15e668: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15e66c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15e670: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0015E678
// Address: 0x15e678 - 0x15e6a8

void entry_15e894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e894: 0x26520048
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 72));
    // 0x15e898: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15e89c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x15e8a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4240));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_15e8a4
// Address: 0x15e8a4 - 0x15e8b4

void entry_15e8a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e8a4: 0x26730048
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 72));
    // 0x15e8a8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x15e8ac: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x15e8b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 184));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_15e8b4
// Address: 0x15e8b4 - 0x15e8e8

void entry_15e8b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e8b4: 0x26b50048
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 72));
    // 0x15e8b8: 0x3c020008
    SET_GPR_U32(ctx, 2, ((uint32_t)8 << 16));
    // 0x15e8bc: 0x3c030010
    SET_GPR_U32(ctx, 3, ((uint32_t)16 << 16));
    // 0x15e8c0: 0x2228821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x15e8c4: 0x3d4f021
    SET_GPR_U32(ctx, 30, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 20)));
    // 0x15e8c8: 0x2e3b821
    SET_GPR_U32(ctx, 23, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 3)));
    // 0x15e8cc: 0x2ec20002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), 2));
    // 0x15e8d0: 0x1440ffe9
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 72));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15E878; return;
    }
    // 0x15e8d8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15e8dc: 0x24050630
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1584));
    // 0x15e8e0: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x15e8e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8928));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_15e8e8
// Address: 0x15e8e8 - 0x15e8f8

void entry_15e8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e8e8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15e8ec: 0x24051090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4240));
    // 0x15e8f0: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x15e8f8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8944));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_15e8f8
// Address: 0x15e8f8 - 0x15e908

void entry_15e8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e8f8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15e8fc: 0x240500b8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 184));
    // 0x15e900: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x15e908);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8960));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_15e908
// Address: 0x15e908 - 0x15e91c

void entry_15e908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e908: 0x3c050016
    SET_GPR_U32(ctx, 5, ((uint32_t)22 << 16));
    // 0x15e90c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15e910: 0x24a5e6a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294960808));
    // 0x15e914: 0xc07da54
    SET_GPR_U32(ctx, 31, 0x15e91c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    AddIntcHandler(rdram, ctx, runtime); return;
}


// Function: entry_15e91c
// Address: 0x15e91c - 0x15e924

void entry_15e91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e91c: 0xc07db6a
    SET_GPR_U32(ctx, 31, 0x15e924);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    EnableIntc(rdram, ctx, runtime); return;
}


// Function: entry_15e924
// Address: 0x15e924 - 0x15e930

void entry_15e924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e924: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15e928: 0xc07889a
    SET_GPR_U32(ctx, 31, 0x15e930);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SemaCreate__Fii(rdram, ctx, runtime); return;
}


// Function: entry_15e930
// Address: 0x15e930 - 0x15e944

void entry_15e930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e930: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15e934: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15e938: 0xac6223b0
    WRITE32(ADD32(GPR_U32(ctx, 3), 9136), GPR_U32(ctx, 2));
    // 0x15e93c: 0xc07889a
    SET_GPR_U32(ctx, 31, 0x15e944);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    SemaCreate__Fii(rdram, ctx, runtime); return;
}


// Function: entry_15e944
// Address: 0x15e944 - 0x15e9c0

void entry_15e944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15e944) {
        switch (ctx->pc) {
            case 0x15e960: ctx->pc = 0; goto label_15e960;
            case 0x15e978: ctx->pc = 0; goto label_15e978;
            case 0x15e988: ctx->pc = 0; goto label_15e988;
            case 0x15e98c: ctx->pc = 0; goto label_15e98c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15e944: 0x3c03002c
    SET_GPR_U32(ctx, 3, ((uint32_t)44 << 16));
    // 0x15e948: 0x3c07edb8
    SET_GPR_U32(ctx, 7, ((uint32_t)60856 << 16));
    // 0x15e94c: 0x24683b00
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 3), 15104));
    // 0x15e950: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15e954: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15e958: 0x34e78320
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 33568));
    // 0x15e95c: 0xac6223b4
    WRITE32(ADD32(GPR_U32(ctx, 3), 9140), GPR_U32(ctx, 2));
label_15e960:
    // 0x15e960: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x15e964: 0x24030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 7));
    // 0x15e968: 0x42880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 4), 2));
    // 0x15e96c: 0x24860001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1));
    // 0x15e970: 0x30820001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 1));
    // 0x15e974: 0x0
    // NOP
label_15e978:
    // 0x15e978: 0x10400003
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15e988;
    }
    // 0x15e980: 0x10000002
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15e98c;
    }
label_15e988:
    // 0x15e988: 0x42042
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), 1));
label_15e98c:
    // 0x15e98c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x15e990: 0x461fff9
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 1));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_15e978;
    }
    // 0x15e998: 0x1051821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 5)));
    // 0x15e99c: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x15e9a0: 0x28a20100
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 256));
    // 0x15e9a4: 0x1440ffee
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_15e960;
    }
    // 0x15e9ac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x15e9b0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15e9b4: 0x24425958
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22872));
    // 0x15e9b8: 0xc07da88
    SET_GPR_U32(ctx, 31, 0x15e9c0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    StartThread(rdram, ctx, runtime); return;
}


// Function: entry_15e9c0
// Address: 0x15e9c0 - 0x15e9f0

void entry_15e9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15e9c0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x15e9c4: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x15e9c8: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15e9cc: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15e9d0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15e9d4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15e9d8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15e9dc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15e9e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15e9e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15e9e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OpenFrame__Fv
// Address: 0x15e9f0 - 0x15ea10

void entry_15ea10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ea10: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ea14: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x15ea1c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9140)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_15ea1c
// Address: 0x15ea1c - 0x15ea58

void entry_15ea1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ea1c) {
        switch (ctx->pc) {
            case 0x15ea50: ctx->pc = 0; goto label_15ea50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ea1c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x15ea20: 0x24040048
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 72));
    // 0x15ea24: 0x8cc22318
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 8984)));
    // 0x15ea28: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15ea2c: 0x24632320
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8992));
    // 0x15ea30: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x15ea34: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x15ea38: 0x2c450002
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x15ea3c: 0xacc22318
    WRITE32(ADD32(GPR_U32(ctx, 6), 8984), GPR_U32(ctx, 2));
    // 0x15ea40: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x15ea44: 0x14a00002
    WRITE32(ADD32(GPR_U32(ctx, 18), 8920), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_15ea50;
    }
    // 0x15ea4c: 0xacc02318
    WRITE32(ADD32(GPR_U32(ctx, 6), 8984), GPR_U32(ctx, 0));
label_15ea50:
    // 0x15ea50: 0xc057bfa
    SET_GPR_U32(ctx, 31, 0x15ea58);
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    ClearPendingFrame__FP3FRM(rdram, ctx, runtime); return;
}


// Function: entry_15ea58
// Address: 0x15ea58 - 0x15ea88

void entry_15ea58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ea58: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ea5c: 0x8e4322d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8920)));
    // 0x15ea60: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x15ea64: 0x26312280
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8832));
    // 0x15ea68: 0x8c660004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x15ea6c: 0x8c82021c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 540)));
    // 0x15ea70: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x15ea74: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15ea78: 0xac600018
    WRITE32(ADD32(GPR_U32(ctx, 3), 24), GPR_U32(ctx, 0));
    // 0x15ea7c: 0xac620044
    WRITE32(ADD32(GPR_U32(ctx, 3), 68), GPR_U32(ctx, 2));
    // 0x15ea80: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x15ea88);
    WRITE32(ADD32(GPR_U32(ctx, 3), 28), GPR_U32(ctx, 0));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15ea88
// Address: 0x15ea88 - 0x15eaa4

void entry_15ea88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ea88: 0x8e4222d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8920)));
    // 0x15ea8c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x15ea90: 0x261022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x15ea94: 0x3c050001
    SET_GPR_U32(ctx, 5, ((uint32_t)1 << 16));
    // 0x15ea98: 0x8c46000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x15ea9c: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x15eaa4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15eaa4
// Address: 0x15eaa4 - 0x15eabc

void entry_15eaa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eaa4: 0x8e4322d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8920)));
    // 0x15eaa8: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x15eaac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15eab0: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x15eab4: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x15eabc);
    WRITE32(ADD32(GPR_U32(ctx, 5), 8912), GPR_U32(ctx, 2));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15eabc
// Address: 0x15eabc - 0x15eac4

void entry_15eabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eabc: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x15eac4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15eac4
// Address: 0x15eac4 - 0x15eae0

void entry_15eac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eac4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15eac8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15eacc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ead0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ead4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15eadc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15eae0; return;
}


// Function: EnsureVu1Code__FP4VIFSPvT1
// Address: 0x15eae0 - 0x15eb10

void entry_15eb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eb10: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15eb14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15eb1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15eb20; return;
}


// Function: FinalizeFrameVifs__FP4VIFSPiPP2QW
// Address: 0x15eb20 - 0x15eb50

void entry_15eb50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eb50: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15eb54: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15eb58: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x15eb60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15eb60
// Address: 0x15eb60 - 0x15eb74

void entry_15eb60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eb60: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x15eb64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15eb68: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15eb6c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15eb74);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15eb74
// Address: 0x15eb74 - 0x15eb84

void entry_15eb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eb74: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15eb78: 0x24050061
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 97));
    // 0x15eb7c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15eb84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15eb84
// Address: 0x15eb84 - 0x15eb8c

void entry_15eb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eb84: 0xc058480
    SET_GPR_U32(ctx, 31, 0x15eb8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15eb8c
// Address: 0x15eb8c - 0x15eb94

void entry_15eb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eb8c: 0xc07b914
    SET_GPR_U32(ctx, 31, 0x15eb94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddVifFlush__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_15eb94
// Address: 0x15eb94 - 0x15eba0

void entry_15eb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eb94: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15eb98: 0xc07ba34
    SET_GPR_U32(ctx, 31, 0x15eba0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddVifGifs__4VIFSP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15eba0
// Address: 0x15eba0 - 0x15ebb8

void entry_15eba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eba0: 0x3c050021
    SET_GPR_U32(ctx, 5, ((uint32_t)33 << 16));
    // 0x15eba4: 0x3c060021
    SET_GPR_U32(ctx, 6, ((uint32_t)33 << 16));
    // 0x15eba8: 0x24a52160
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8544));
    // 0x15ebac: 0x24c65c50
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23632));
    // 0x15ebb0: 0xc057ab8
    SET_GPR_U32(ctx, 31, 0x15ebb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    EnsureVu1Code__FP4VIFSPvT1(rdram, ctx, runtime); return;
}


// Function: entry_15ebb8
// Address: 0x15ebb8 - 0x15ebc0

void entry_15ebb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ebb8: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x15ebc0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15ebc0
// Address: 0x15ebc0 - 0x15ebd0

void entry_15ebc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ebc0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15ebc4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15ebc8: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x15ebd0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15ebd0
// Address: 0x15ebd0 - 0x15ebf0

void entry_15ebd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ebd0: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x15ebd4: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x15ebd8: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x15ebdc: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x15ebe0: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x15ebe4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15ebec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15ebf0; return;
}


// Function: FinalizeFrameGifs__FP4GIFSPiPP2QW
// Address: 0x15ebf0 - 0x15ec20

void entry_15ec20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ec20: 0x24050061
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 97));
    // 0x15ec24: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15ec28: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15ec30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15ec30
// Address: 0x15ec30 - 0x15ec38

void entry_15ec30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ec30: 0xc058480
    SET_GPR_U32(ctx, 31, 0x15ec38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15ec38
// Address: 0x15ec38 - 0x15ec40

void entry_15ec38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ec38: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x15ec40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15ec40
// Address: 0x15ec40 - 0x15ec50

void entry_15ec40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ec40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15ec44: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15ec48: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x15ec50);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15ec50
// Address: 0x15ec50 - 0x15ec68

void entry_15ec50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ec50: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15ec54: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15ec58: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ec5c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ec60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloseFrame__Fv
// Address: 0x15ec68 - 0x15ec90

void entry_15ec90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ec90: 0x8e0522d8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8920)));
    // 0x15ec94: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15ec98: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15ec9c: 0xc057afc
    SET_GPR_U32(ctx, 31, 0x15eca4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8832));
    FinalizeFrameGifs__FP4GIFSPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15eca4
// Address: 0x15eca4 - 0x15ecd0

void entry_15eca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eca4: 0x8e0322d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8920)));
    // 0x15eca8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ecac: 0x244822e0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 8928));
    // 0x15ecb0: 0x69050007
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x15ecb4: 0x6d050000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x15ecb8: 0x8d060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x15ecbc: 0xb0650027
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ecc0: 0xb4650020
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ecc4: 0xac660028
    WRITE32(ADD32(GPR_U32(ctx, 3), 40), GPR_U32(ctx, 6));
    // 0x15ecc8: 0xc054910
    SET_GPR_U32(ctx, 31, 0x15ecd0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 8928));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15ecd0
// Address: 0x15ecd0 - 0x15ecfc

void entry_15ecd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ecd0: 0x8e0322d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8920)));
    // 0x15ecd4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ecd8: 0x244822f0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 8944));
    // 0x15ecdc: 0x69050007
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x15ece0: 0x6d050000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x15ece4: 0x8d060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x15ece8: 0xb0650033
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 51); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ecec: 0xb465002c
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 44); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ecf0: 0xac660034
    WRITE32(ADD32(GPR_U32(ctx, 3), 52), GPR_U32(ctx, 6));
    // 0x15ecf4: 0xc054910
    SET_GPR_U32(ctx, 31, 0x15ecfc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 8944));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15ecfc
// Address: 0x15ecfc - 0x15ed28

void entry_15ecfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ecfc: 0x8e0322d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8920)));
    // 0x15ed00: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ed04: 0x24482300
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 8960));
    // 0x15ed08: 0x69050007
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x15ed0c: 0x6d050000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x15ed10: 0x8d060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x15ed14: 0xb065003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 63); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ed18: 0xb4650038
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 56); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x15ed1c: 0xac660040
    WRITE32(ADD32(GPR_U32(ctx, 3), 64), GPR_U32(ctx, 6));
    // 0x15ed20: 0xc054910
    SET_GPR_U32(ctx, 31, 0x15ed28);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 8960));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15ed28
// Address: 0x15ed28 - 0x15ed40

void entry_15ed28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ed28: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ed2c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15ed30: 0x8c4423b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9136)));
    // 0x15ed34: 0xac6022d0
    WRITE32(ADD32(GPR_U32(ctx, 3), 8912), GPR_U32(ctx, 0));
    // 0x15ed38: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x15ed40);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8920), GPR_U32(ctx, 0));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_15ed40
// Address: 0x15ed40 - 0x15ed50

void entry_15ed40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ed40: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ed44: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ed48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PrepareGsForFrameRender__FP3FRM
// Address: 0x15ed50 - 0x15ed74

void entry_15ed74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ed74: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x15ed78: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15eda4(rdram, ctx, runtime); return;
    }
    // 0x15ed80: 0x8c454538
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 17720)));
    // 0x15ed84: 0x10a00007
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_15eda4(rdram, ctx, runtime); return;
    }
    // 0x15ed8c: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x15ed90: 0x34423010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 12304));
    // 0x15ed94: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x15ed98: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x15ed9c: 0xc080aa0
    SET_GPR_U32(ctx, 31, 0x15eda4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 7964)));
    sceDmaSend(rdram, ctx, runtime); return;
}


// Function: entry_15eda4
// Address: 0x15eda4 - 0x15edb8

void entry_15eda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15eda4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15eda8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15edac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15edb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15edb8; return;
}


// Function: check_anticrack_antigrab__Fv
// Address: 0x15edb8 - 0x15ee80

void entry_15eed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15eed4) {
        switch (ctx->pc) {
            case 0x15eed8: ctx->pc = 0; goto label_15eed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15eed4: 0x36103010
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 12304));
label_15eed8:
    // 0x15eed8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15eedc: 0xae9323b8
    WRITE32(ADD32(GPR_U32(ctx, 20), 9144), GPR_U32(ctx, 19));
    // 0x15eee0: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x15eee8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9136)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_15eee8
// Address: 0x15eee8 - 0x15ef24

void entry_15eee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15eee8) {
        switch (ctx->pc) {
            case 0x15ef1c: ctx->pc = 0; goto label_15ef1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15eee8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15eeec: 0x8ea32314
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 8980)));
    // 0x15eef0: 0x24842320
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8992));
    // 0x15eef4: 0xae8023b8
    WRITE32(ADD32(GPR_U32(ctx, 20), 9144), GPR_U32(ctx, 0));
    // 0x15eef8: 0x800013
    ctx->lo = GPR_U32(ctx, 4);
    // 0x15eefc: 0x70771000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 23); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x15ef00: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x15ef04: 0x2c650002
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 3), 2));
    // 0x15ef08: 0xaea32314
    WRITE32(ADD32(GPR_U32(ctx, 21), 8980), GPR_U32(ctx, 3));
    // 0x15ef0c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15ef10: 0x14a00002
    WRITE32(ADD32(GPR_U32(ctx, 17), 8988), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_15ef1c;
    }
    // 0x15ef18: 0xaec02314
    WRITE32(ADD32(GPR_U32(ctx, 22), 8980), GPR_U32(ctx, 0));
label_15ef1c:
    // 0x15ef1c: 0xc057b54
    SET_GPR_U32(ctx, 31, 0x15ef24);
    PrepareGsForFrameRender__FP3FRM(rdram, ctx, runtime); return;
}


// Function: entry_15ef24
// Address: 0x15ef24 - 0x15ef2c

void entry_15ef24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef24: 0xc05a13a
    SET_GPR_U32(ctx, 31, 0x15ef2c);
    RestoreGsBuffers__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15ef2c
// Address: 0x15ef2c - 0x15ef3c

void entry_15ef2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef2c: 0x8e22231c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8988)));
    // 0x15ef30: 0x8e441f18
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 7960)));
    // 0x15ef34: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x15ef3c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15ef3c
// Address: 0x15ef3c - 0x15ef54

void entry_15ef3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef3c: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
    // 0x15ef40: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15ef44: 0x8e22231c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8988)));
    // 0x15ef48: 0x8c641f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 7964)));
    // 0x15ef4c: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x15ef54);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15ef54
// Address: 0x15ef54 - 0x15ef5c

void entry_15ef54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef54: 0xc057cc8
    SET_GPR_U32(ctx, 31, 0x15ef5c);
    BlendPrevFrame__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15ef5c
// Address: 0x15ef5c - 0x15ef6c

void entry_15ef5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef5c: 0x8e441f18
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 7960)));
    // 0x15ef60: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15ef64: 0xc080b0e
    SET_GPR_U32(ctx, 31, 0x15ef6c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceDmaSync(rdram, ctx, runtime); return;
}


// Function: entry_15ef6c
// Address: 0x15ef6c - 0x15ef78

void entry_15ef6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef6c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15ef70: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x15ef78);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9140)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_15ef78
// Address: 0x15ef78 - 0x15ef80

void entry_15ef78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef78: 0xc05a0fa
    SET_GPR_U32(ctx, 31, 0x15ef80);
    SwapGsBuffers__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15ef80
// Address: 0x15ef80 - 0x15ef88

void entry_15ef80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ef80: 0x1000ffd5
    WRITE32(ADD32(GPR_U32(ctx, 30), 9932), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15EED8; return;
    }
    // Fall-through to next function
    ctx->pc = 0x15ef88; return;
}


// Function: RenderFrame__FP3FRMi
// Address: 0x15ef88 - 0x15efa4

void entry_15efa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15efa4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15efa8: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x15efac: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x15efb4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7960)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15efb4
// Address: 0x15efb4 - 0x15efd4

void entry_15efb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15efb4: 0x12000007
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_15efd4(rdram, ctx, runtime); return;
    }
    // 0x15efbc: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15efc0: 0x34423010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 12304));
    // 0x15efc4: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x15efc8: 0x8c641f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 7964)));
    // 0x15efcc: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x15efd4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15efd4
// Address: 0x15efd4 - 0x15efe8

void entry_15efd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15efd4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15efd8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15efdc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15efe0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearPendingFrame__FP3FRM
// Address: 0x15efe8 - 0x15f01c

void entry_15f01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f01c) {
        switch (ctx->pc) {
            case 0x15f060: ctx->pc = 0; goto label_15f060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f01c: 0x14400023
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 44));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F0AC; return;
    }
    // 0x15f024: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x15f028: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x15f02c: 0x8c43b314
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294947604)));
    // 0x15f030: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15f034: 0xac5db314
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294947604), GPR_U32(ctx, 29));
    // 0x15f038: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f03c: 0xafa3000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 3));
    // 0x15f040: 0x8e820020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x15f044: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x15f048: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x15f04c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15f050: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x15f054: 0x12000010
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F098; return;
    }
    // 0x15f05c: 0x0
    // NOP
label_15f060:
    // 0x15f060: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f064: 0xc054980
    SET_GPR_U32(ctx, 31, 0x15f06c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15f06c
// Address: 0x15f06c - 0x15f07c

void entry_15f06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f06c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x15f070: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f074: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x15f07c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7360));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15f07c
// Address: 0x15f07c - 0x15f0a0

void entry_15f07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f07c) {
        switch (ctx->pc) {
            case 0x15f098: ctx->pc = 0; goto label_15f098;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f07c: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x15f080: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x15f084: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15f088: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15f08c: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x15f090: 0x1600fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F060; return;
    }
label_15f098:
    // 0x15f098: 0xc054910
    SET_GPR_U32(ctx, 31, 0x15f0a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15f0a0
// Address: 0x15f0a0 - 0x15f0b8

void entry_15f0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f0a0) {
        switch (ctx->pc) {
            case 0x15f0ac: ctx->pc = 0; goto label_15f0ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f0a0: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x15f0a4: 0xaec2b314
    WRITE32(ADD32(GPR_U32(ctx, 22), 4294947604), GPR_U32(ctx, 2));
    // 0x15f0a8: 0x2684002c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 44));
label_15f0ac:
    // 0x15f0ac: 0x26930038
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 20), 56));
    // 0x15f0b0: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x15f0b8);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15f0b8
// Address: 0x15f0b8 - 0x15f110

void entry_15f0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f0b8) {
        switch (ctx->pc) {
            case 0x15f0f8: ctx->pc = 0; goto label_15f0f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f0b8: 0x14400027
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F158; return;
    }
    // 0x15f0c0: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x15f0c4: 0x8c43b314
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294947604)));
    // 0x15f0c8: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15f0cc: 0xac5db314
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294947604), GPR_U32(ctx, 29));
    // 0x15f0d0: 0xafa3000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 3));
    // 0x15f0d4: 0x8e82002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 44)));
    // 0x15f0d8: 0xafb20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
    // 0x15f0dc: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x15f0e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15f0e4: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x15f0e8: 0x12000017
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F148; return;
    }
    // 0x15f0f0: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x15f0f4: 0x0
    // NOP
label_15f0f8:
    // 0x15f0f8: 0x8e051088
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4232)));
    // 0x15f0fc: 0x10a00004
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_15f110(rdram, ctx, runtime); return;
    }
    // 0x15f104: 0x8ea45710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 22288)));
    // 0x15f108: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x15f110);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6988));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_15f110
// Address: 0x15f110 - 0x15f11c

void entry_15f110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f110: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f114: 0xc054980
    SET_GPR_U32(ctx, 31, 0x15f11c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15f11c
// Address: 0x15f11c - 0x15f12c

void entry_15f11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f11c: 0x8e245710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x15f120: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f124: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x15f12c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6976));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_15f12c
// Address: 0x15f12c - 0x15f150

void entry_15f12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f12c) {
        switch (ctx->pc) {
            case 0x15f148: ctx->pc = 0; goto label_15f148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f12c: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x15f130: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x15f134: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15f138: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15f13c: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x15f140: 0x1600ffed
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F0F8; return;
    }
label_15f148:
    // 0x15f148: 0xc054910
    SET_GPR_U32(ctx, 31, 0x15f150);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15f150
// Address: 0x15f150 - 0x15f160

void entry_15f150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f150) {
        switch (ctx->pc) {
            case 0x15f158: ctx->pc = 0; goto label_15f158;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f150: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x15f154: 0xaec2b314
    WRITE32(ADD32(GPR_U32(ctx, 22), 4294947604), GPR_U32(ctx, 2));
label_15f158:
    // 0x15f158: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x15f160);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_15f160
// Address: 0x15f160 - 0x15f1b4

void entry_15f160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f160) {
        switch (ctx->pc) {
            case 0x15f1a8: ctx->pc = 0; goto label_15f1a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f160: 0x14400022
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F1EC; return;
    }
    // 0x15f168: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x15f16c: 0x8e650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x15f170: 0x8c44b314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294947604)));
    // 0x15f174: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15f178: 0xafb30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 19));
    // 0x15f17c: 0xac5db314
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294947604), GPR_U32(ctx, 29));
    // 0x15f180: 0x8e820038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 56)));
    // 0x15f184: 0xafa4000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 4));
    // 0x15f188: 0x451821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x15f18c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15f190: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x15f194: 0xafb30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 19));
    // 0x15f198: 0x12000011
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F1E0; return;
    }
    // 0x15f1a0: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x15f1a4: 0x0
    // NOP
label_15f1a8:
    // 0x15f1a8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f1ac: 0xc054980
    SET_GPR_U32(ctx, 31, 0x15f1b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15f1b4
// Address: 0x15f1b4 - 0x15f1c4

void entry_15f1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f1b4: 0x8e245710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x15f1b8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f1bc: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x15f1c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7156));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_15f1c4
// Address: 0x15f1c4 - 0x15f210

void entry_15f1c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f1c4) {
        switch (ctx->pc) {
            case 0x15f1e0: ctx->pc = 0; goto label_15f1e0;
            case 0x15f1ec: ctx->pc = 0; goto label_15f1ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f1c4: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x15f1c8: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x15f1cc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x15f1d0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15f1d4: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x15f1d8: 0x1600fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F1A8; return;
    }
label_15f1e0:
    // 0x15f1e0: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x15f1e4: 0xaec2b314
    WRITE32(ADD32(GPR_U32(ctx, 22), 4294947604), GPR_U32(ctx, 2));
    // 0x15f1e8: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_15f1ec:
    // 0x15f1ec: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x15f1f0: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x15f1f4: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15f1f8: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15f1fc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15f200: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15f204: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15f208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FlushFrames__Fi
// Address: 0x15f210 - 0x15f248

void entry_15f248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f248) {
        switch (ctx->pc) {
            case 0x15f258: ctx->pc = 0; goto label_15f258;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f248: 0x2e030002
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 16), 2));
    // 0x15f24c: 0x1460fffc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9140)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F240; return;
    }
    // 0x15f254: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_15f258:
    // 0x15f258: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x15f260);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_15f260
// Address: 0x15f260 - 0x15f2ac

void entry_15f260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f260) {
        switch (ctx->pc) {
            case 0x15f270: ctx->pc = 0; goto label_15f270;
            case 0x15f2a0: ctx->pc = 0; goto label_15f2a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f260: 0x2e030002
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 16), 2));
    // 0x15f264: 0x1460fffc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9140)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F258; return;
    }
    // 0x15f26c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
label_15f270:
    // 0x15f270: 0x8c6223b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9144)));
    // 0x15f274: 0x0
    // NOP
    // 0x15f278: 0x0
    // NOP
    // 0x15f27c: 0x0
    // NOP
    // 0x15f280: 0x0
    // NOP
    // 0x15f284: 0x1040fffa
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15f270;
    }
    // 0x15f28c: 0x12600010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8988)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F2D0; return;
    }
    // 0x15f294: 0x1040000e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F2D0; return;
    }
    // 0x15f29c: 0x8e44231c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8988)));
label_15f2a0:
    // 0x15f2a0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15f2a4: 0xc057be2
    SET_GPR_U32(ctx, 31, 0x15f2ac);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    RenderFrame__FP3FRMi(rdram, ctx, runtime); return;
}


// Function: entry_15f2ac
// Address: 0x15f2ac - 0x15f2b4

void entry_15f2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f2ac: 0xc057cc8
    SET_GPR_U32(ctx, 31, 0x15f2b4);
    BlendPrevFrame__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15f2b4
// Address: 0x15f2b4 - 0x15f2bc

void entry_15f2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f2b4: 0xc05a0fa
    SET_GPR_U32(ctx, 31, 0x15f2bc);
    SwapGsBuffers__Fv(rdram, ctx, runtime); return;
}


// Function: entry_15f2bc
// Address: 0x15f2bc - 0x15f2e8

void entry_15f2bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f2bc) {
        switch (ctx->pc) {
            case 0x15f2d0: ctx->pc = 0; goto label_15f2d0;
            case 0x15f2e0: ctx->pc = 0; goto label_15f2e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f2bc: 0x601fff8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8988)));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x15F2A0; return;
    }
    // 0x15f2c4: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x15f2c8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15f2cc: 0xac4326cc
    WRITE32(ADD32(GPR_U32(ctx, 2), 9932), GPR_U32(ctx, 3));
label_15f2d0:
    // 0x15f2d0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15f2d4: 0x24502320
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 8992));
    // 0x15f2d8: 0x26110090
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 144));
    // 0x15f2dc: 0x0
    // NOP
label_15f2e0:
    // 0x15f2e0: 0xc057bfa
    SET_GPR_U32(ctx, 31, 0x15f2e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ClearPendingFrame__FP3FRM(rdram, ctx, runtime); return;
}


// Function: entry_15f2e8
// Address: 0x15f2e8 - 0x15f300

void entry_15f2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f2e8: 0x26100048
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 72));
    // 0x15f2ec: 0x211102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x15f2f0: 0x1440fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F2E0; return;
    }
    // 0x15f2f8: 0xc0647ac
    SET_GPR_U32(ctx, 31, 0x15f300);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    ClearPhase__F5PHASE(rdram, ctx, runtime); return;
}


// Function: entry_15f300
// Address: 0x15f300 - 0x15f320

void entry_15f300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f300: 0xae40231c
    WRITE32(ADD32(GPR_U32(ctx, 18), 8988), GPR_U32(ctx, 0));
    // 0x15f304: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15f308: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15f30c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15f310: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15f314: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15f318: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BlendPrevFrame__Fv
// Address: 0x15f320 - 0x15f344

void entry_15f344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f344: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x15f348: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f34c: 0xc0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x15f350: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x15f358);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 100));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15f358
// Address: 0x15f358 - 0x15f360

void entry_15f358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f358: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x15f360);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15f360
// Address: 0x15f360 - 0x15f374

void entry_15f360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f360: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f364: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15f368: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15f36c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15f374);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15f374
// Address: 0x15f374 - 0x15f3b0

void entry_15f374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f374) {
        switch (ctx->pc) {
            case 0x15f394: ctx->pc = 0; goto label_15f394;
            case 0x15f39c: ctx->pc = 0; goto label_15f39c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f374: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15f378: 0x8c6226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9920)));
    // 0x15f37c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x15f380: 0x10400004
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15f394;
    }
    // 0x15f388: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15f38c: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9712));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15f39c;
    }
label_15f394:
    // 0x15f394: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15f398: 0x24422500
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9472));
label_15f39c:
    // 0x15f39c: 0xdc530000
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15f3a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f3a4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15f3a8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f3b0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f3b0
// Address: 0x15f3b0 - 0x15f3d8

void entry_15f3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f3b0: 0x3c020f00
    SET_GPR_U32(ctx, 2, ((uint32_t)3840 << 16));
    // 0x15f3b4: 0x326601ff
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 19), 511));
    // 0x15f3b8: 0x2621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x15f3bc: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x15f3c0: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x15f3c4: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x15f3c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f3cc: 0xc33025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x15f3d0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f3d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 78));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f3d8
// Address: 0x15f3d8 - 0x15f444

void entry_15f3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f3d8) {
        switch (ctx->pc) {
            case 0x15f3f0: ctx->pc = 0; goto label_15f3f0;
            case 0x15f3f8: ctx->pc = 0; goto label_15f3f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f3d8: 0x8e0226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9920)));
    // 0x15f3dc: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x15f3e0: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_15f3f0;
    }
    // 0x15f3e8: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9456));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_15f3f8;
    }
label_15f3f0:
    // 0x15f3f0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15f3f4: 0x244225e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9696));
label_15f3f8:
    // 0x15f3f8: 0xdc460000
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15f3fc: 0x3407aa00
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 0), 43520));
    // 0x15f400: 0x73cb8
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 18);
    // 0x15f404: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f408: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x15f40c: 0x6143a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) >> 16);
    // 0x15f410: 0x61e3a
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 6) >> 24);
    // 0x15f414: 0x3042003f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 63));
    // 0x15f418: 0x30c601ff
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), 511));
    // 0x15f41c: 0x213b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 14);
    // 0x15f420: 0x63178
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 5);
    // 0x15f424: 0x3063003f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 63));
    // 0x15f428: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x15f42c: 0x31d38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 20);
    // 0x15f430: 0x24120008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 8));
    // 0x15f434: 0xc33025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x15f438: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15f43c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f444);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f444
// Address: 0x15f444 - 0x15f454

void entry_15f444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f444: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f448: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x15f44c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f454);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 97));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f454
// Address: 0x15f454 - 0x15f464

void entry_15f454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f454: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f458: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x15f45c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f464);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f464
// Address: 0x15f464 - 0x15f478

void entry_15f464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f464: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f468: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x15f46c: 0x34c60002
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 2));
    // 0x15f470: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f478);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f478
// Address: 0x15f478 - 0x15f490

void entry_15f478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f478: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f47c: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x15f480: 0x6303c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 0));
    // 0x15f484: 0x34c60064
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 100));
    // 0x15f488: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f490);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f490
// Address: 0x15f490 - 0x15f4b0

void entry_15f490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f490: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f494: 0x3c063f80
    SET_GPR_U32(ctx, 6, ((uint32_t)16256 << 16));
    // 0x15f498: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15f49c: 0x34c68080
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 32896));
    // 0x15f4a0: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15f4a4: 0x34c68080
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 32896));
    // 0x15f4a8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f4b0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f4b0
// Address: 0x15f4b0 - 0x15f4d0

void entry_15f4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f4b0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f4b4: 0x3c0600de
    SET_GPR_U32(ctx, 6, ((uint32_t)222 << 16));
    // 0x15f4b8: 0x34c60001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 1));
    // 0x15f4bc: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15f4c0: 0x34c6027f
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 639));
    // 0x15f4c4: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15f4c8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f4d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f4d0
// Address: 0x15f4d0 - 0x15f4e4

void entry_15f4d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f4d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f4d4: 0x24050156
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 342));
    // 0x15f4d8: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x15f4dc: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15f4e4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 67));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15f4e4
// Address: 0x15f4e4 - 0x15f508

void entry_15f4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f4e4) {
        switch (ctx->pc) {
            case 0x15f4f8: ctx->pc = 0; goto label_15f4f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f4e4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x15f4e8: 0x8c6226c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9928)));
    // 0x15f4ec: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x15f4f0: 0x2900b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 0));
    // 0x15f4f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_15f4f8:
    // 0x15f4f8: 0x112900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 4));
    // 0x15f4fc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x15f500: 0xc058532
    SET_GPR_U32(ctx, 31, 0x15f508);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 32));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15f508
// Address: 0x15f508 - 0x15f524

void entry_15f508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f508: 0x262506c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1728));
    // 0x15f50c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f510: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15f514: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15f518: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x15f51c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x15f524);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15f524
// Address: 0x15f524 - 0x15f534

void entry_15f524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f524: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f528: 0x102900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 16), 4));
    // 0x15f52c: 0xc058532
    SET_GPR_U32(ctx, 31, 0x15f534);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 3584));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_15f534
// Address: 0x15f534 - 0x15f550

void entry_15f534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f534: 0x262506e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1760));
    // 0x15f538: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f53c: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x15f540: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x15f544: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15f548: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x15f550);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_15f550
// Address: 0x15f550 - 0x15f570

void entry_15f550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f550: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f554: 0x2a220280
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 640));
    // 0x15f558: 0x1440ffe7
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F4F8; return;
    }
    // 0x15f560: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x15f564: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15f568: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15f570);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15f570
// Address: 0x15f570 - 0x15f58c

void entry_15f570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f570: 0x3c060f00
    SET_GPR_U32(ctx, 6, ((uint32_t)3840 << 16));
    // 0x15f574: 0x326201ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 511));
    // 0x15f578: 0x2663024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 19), GPR_U32(ctx, 6)));
    // 0x15f57c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f580: 0x463025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x15f584: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f58c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 78));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f58c
// Address: 0x15f58c - 0x15f5a8

void entry_15f58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f58c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f590: 0x3c0600df
    SET_GPR_U32(ctx, 6, ((uint32_t)223 << 16));
    // 0x15f594: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15f598: 0x34c6027f
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 639));
    // 0x15f59c: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x15f5a0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f5a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f5a8
// Address: 0x15f5a8 - 0x15f5bc

void entry_15f5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f5a8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f5ac: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x15f5b0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15f5b4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x15f5bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_15f5bc
// Address: 0x15f5bc - 0x15f5cc

void entry_15f5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f5bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x15f5c0: 0x24050061
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 97));
    // 0x15f5c4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x15f5cc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_15f5cc
// Address: 0x15f5cc - 0x15f5d4

void entry_15f5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f5cc: 0xc058480
    SET_GPR_U32(ctx, 31, 0x15f5d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15f5d4
// Address: 0x15f5d4 - 0x15f5dc

void entry_15f5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f5d4: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x15f5dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15f5dc
// Address: 0x15f5dc - 0x15f5e4

void entry_15f5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f5dc: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x15f5e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_15f5e4
// Address: 0x15f5e4 - 0x15f5f4

void entry_15f5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f5e4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x15f5e8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15f5ec: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x15f5f4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7964)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_15f5f4
// Address: 0x15f5f4 - 0x15f618

void entry_15f5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f5f4: 0x7bbf06c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1728)));
    // 0x15f5f8: 0x7bb406b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1712)));
    // 0x15f5fc: 0x7bb306a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1696)));
    // 0x15f600: 0x7bb20690
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1680)));
    // 0x15f604: 0x7bb10680
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x15f608: 0x7bb00670
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1648)));
    // 0x15f60c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1744));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15f614: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15f618; return;
}


// Function: FUN_0015f618
// Address: 0x15f618 - 0x15f63c

void FUN_0015f618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f618: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x15f61c: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x15f620: 0x14a20009
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        entry_15f648(rdram, ctx, runtime); return;
    }
    // 0x15f628: 0x10800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F64C; return;
    }
    // 0x15f630: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15f634: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x15f63c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8832));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_15f63c
// Address: 0x15f63c - 0x15f648

void entry_15f63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f63c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x15f640: 0xc07b8c6
    SET_GPR_U32(ctx, 31, 0x15f648);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8872));
    fn___4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_15f648
// Address: 0x15f648 - 0x15f658

void entry_15f648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f648) {
        switch (ctx->pc) {
            case 0x15f64c: ctx->pc = 0; goto label_15f64c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f648: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_15f64c:
    // 0x15f64c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15f654: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15f658; return;
}


// Function: FUN_0015f658
// Address: 0x15f658 - 0x15f66c

void FUN_0015f658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f658: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x15f65c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x15f660: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x15f664: 0xc057d86
    SET_GPR_U32(ctx, 31, 0x15f66c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    FUN_0015f618(rdram, ctx, runtime); return;
}


// Function: entry_15f66c
// Address: 0x15f66c - 0x15f678

void entry_15f66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f66c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15f670: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemergeSwObject__FP2SWP3ALO
// Address: 0x15f678 - 0x15f6c0

void entry_15f704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f704: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15f708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SplinterSwFreezeGroup__FP2SWP3ALO
// Address: 0x15f710 - 0x15f780

void entry_15f780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f780) {
        switch (ctx->pc) {
            case 0x15f78c: ctx->pc = 0; goto label_15f78c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f780: 0xae100054
    WRITE32(ADD32(GPR_U32(ctx, 16), 84), GPR_U32(ctx, 16));
    // 0x15f784: 0xae100064
    WRITE32(ADD32(GPR_U32(ctx, 16), 100), GPR_U32(ctx, 16));
    // 0x15f788: 0xae100060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 16));
label_15f78c:
    // 0x15f78c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15f790: 0xc057d9e
    SET_GPR_U32(ctx, 31, 0x15f798);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RemergeSwObject__FP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15f798
// Address: 0x15f798 - 0x15f7d8

void entry_15f798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f798) {
        switch (ctx->pc) {
            case 0x15f7b4: ctx->pc = 0; goto label_15f7b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f798: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x15f79c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x15f7a0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15f7a4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x15f7a8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x15f7ac: 0x1600fff0
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F770; return;
    }
label_15f7b4:
    // 0x15f7b4: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x15f7b8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15f7bc: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x15f7c0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15f7c4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15f7c8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15f7cc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15f7d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MergeSwGroup__FP2SWP3MRG
// Address: 0x15f7d8 - 0x15f820

void entry_15f820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f820) {
        switch (ctx->pc) {
            case 0x15f828: ctx->pc = 0; goto label_15f828;
            case 0x15f840: ctx->pc = 0; goto label_15f840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f820: 0x5040fff7
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        ctx->pc = 0x15F800; return;
    }
label_15f828:
    // 0x15f828: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x15f82c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x15f830: 0x10400016
    SET_GPR_U32(ctx, 19, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15F88C; return;
    }
    // 0x15f838: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x15f83c: 0x0
    // NOP
label_15f840:
    // 0x15f840: 0x118080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 17), 2));
    // 0x15f844: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x15f848: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x15f850);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_15f850
// Address: 0x15f850 - 0x15f878

void entry_15f850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15f850: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15f878(rdram, ctx, runtime); return;
    }
    // 0x15f858: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x15f85c: 0x2022821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x15f860: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x15f864: 0x8ca70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x15f868: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15f86c: 0x8ce60054
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 7), 84)));
    // 0x15f870: 0xc057db0
    SET_GPR_U32(ctx, 31, 0x15f878);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 84)));
    MergeSwFreezeGroups__FP2SWP3ALOT1(rdram, ctx, runtime); return;
}


// Function: entry_15f878
// Address: 0x15f878 - 0x15f8b0

void entry_15f878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f878) {
        switch (ctx->pc) {
            case 0x15f88c: ctx->pc = 0; goto label_15f88c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f878: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x15f87c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x15f880: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x15f884: 0x5440ffee
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x15F840; return;
    }
label_15f88c:
    // 0x15f88c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15f890: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15f894: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15f898: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15f89c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15f8a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15f8a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15f8ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15f8b0; return;
}


// Function: AddSwMergeGroup__FP2SWP3MRG
// Address: 0x15f8b0 - 0x15f920

void entry_15f920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f920) {
        switch (ctx->pc) {
            case 0x15f924: ctx->pc = 0; goto label_15f924;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f920: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_15f924:
    // 0x15f924: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15f92c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15f930; return;
}


// Function: RemoveFromArray__FPiPPvPv
// Address: 0x15f930 - 0x15f984

void entry_15f984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f984) {
        switch (ctx->pc) {
            case 0x15f990: ctx->pc = 0; goto label_15f990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f984: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15f988: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x15f98c: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
label_15f990:
    // 0x15f990: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15f994: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15f998: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveSwMergeGroup__FP2SWP3MRG
// Address: 0x15f9a0 - 0x15f9f8

void entry_15f9f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15f9f8) {
        switch (ctx->pc) {
            case 0x15fa08: ctx->pc = 0; goto label_15fa08;
            case 0x15fa10: ctx->pc = 0; goto label_15fa10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15f9f8: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x15f9fc: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x15fa00: 0x5440fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x15F9D8; return;
    }
label_15fa08:
    // 0x15fa08: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15fa0c: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_15fa10:
    // 0x15fa10: 0x204102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 4)));
    // 0x15fa14: 0x10400009
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15fa3c(rdram, ctx, runtime); return;
    }
    // 0x15fa1c: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x15fa20: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15fa24: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15fa28: 0x8c450054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x15fa2c: 0x10a0fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_15fa10;
    }
    // 0x15fa34: 0xc057dc4
    SET_GPR_U32(ctx, 31, 0x15fa3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SplinterSwFreezeGroup__FP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15fa3c
// Address: 0x15fa3c - 0x15fa58

void entry_15fa3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fa3c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15fa40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15fa44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15fa48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15fa4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15fa54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15fa58; return;
}


// Function: RemergeSwObjects__FP2SW
// Address: 0x15fa58 - 0x15faf0

void entry_15faf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15faf0) {
        switch (ctx->pc) {
            case 0x15faf8: ctx->pc = 0; goto label_15faf8;
            case 0x15fb08: ctx->pc = 0; goto label_15fb08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15faf0: 0x603fffb
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x15FAE0; return;
    }
label_15faf8:
    // 0x15faf8: 0x260182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x15fafc: 0x463ffe8
    if (GPR_S32(ctx, 3) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 7892)));
        ctx->pc = 0x15FAA0; return;
    }
    // 0x15fb04: 0xae401ed0
    WRITE32(ADD32(GPR_U32(ctx, 18), 7888), GPR_U32(ctx, 0));
label_15fb08:
    // 0x15fb08: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15fb0c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15fb10: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15fb14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15fb18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15fb1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15fb20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreezeAloHierarchy__FP3ALOi
// Address: 0x15fb28 - 0x15fb54

void entry_15fb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15fb54) {
        switch (ctx->pc) {
            case 0x15fb68: ctx->pc = 0; goto label_15fb68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15fb54: 0x8e100034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x15fb58: 0x1200000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15FB90; return;
    }
    // 0x15fb60: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15fb64: 0x0
    // NOP
label_15fb68:
    // 0x15fb68: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x15fb6c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x15fb70: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15fb80(rdram, ctx, runtime); return;
    }
    // 0x15fb78: 0xc057eca
    SET_GPR_U32(ctx, 31, 0x15fb80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FreezeAloHierarchy__FP3ALOi(rdram, ctx, runtime); return;
}


// Function: entry_15fb80
// Address: 0x15fb80 - 0x15fba0

void entry_15fb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15fb80) {
        switch (ctx->pc) {
            case 0x15fb90: ctx->pc = 0; goto label_15fb90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15fb80: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x15fb84: 0x5600fff8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x15FB68; return;
    }
    // 0x15fb8c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_15fb90:
    // 0x15fb90: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15fb94: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15fb98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAloFrozen__FP3ALOPi
// Address: 0x15fba0 - 0x15fbb8

void entry_15fbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fbf8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15fbfc: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x15fc00: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x15fc04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15fc08: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x15fc0c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15fc14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15fc14
// Address: 0x15fc14 - 0x15fc28

void entry_15fc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fc14: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15fc18: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15fc1c: 0x8cc30094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 148)));
    // 0x15fc20: 0x60f809
    SET_GPR_U32(ctx, 31, 0x15fc28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_15fc28
// Address: 0x15fc28 - 0x15fc74

void entry_15fc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15fc28) {
        switch (ctx->pc) {
            case 0x15fc40: ctx->pc = 0; goto label_15fc40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15fc28: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x15fc2c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x15fc30: 0x31df8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 23);
    // 0x15fc34: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x15fc38: 0x10000021
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_15fcc0(rdram, ctx, runtime); return;
    }
label_15fc40:
    // 0x15fc40: 0xde2302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x15fc44: 0x2402ffbf
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967231));
    // 0x15fc48: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x15fc4c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x15fc50: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x15fc54: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x15fc58: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15fc5c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15fc60: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x15fc64: 0xfe2302c8
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 3));
    // 0x15fc68: 0x8cc20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 144)));
    // 0x15fc6c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15fc74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 160));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15fc74
// Address: 0x15fc74 - 0x15fc88

void entry_15fc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fc74: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x15fc78: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x15fc7c: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x15fc80: 0x40f809
    SET_GPR_U32(ctx, 31, 0x15fc88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 176));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_15fc88
// Address: 0x15fc88 - 0x15fcc0

void entry_15fc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fc88: 0x8e2202ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 684)));
    // 0x15fc8c: 0x1040000c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15fcc0(rdram, ctx, runtime); return;
    }
    // 0x15fc94: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x15fc98: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x15fc9c: 0x24480014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 20));
    // 0x15fca0: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x15fca4: 0x2445001c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 28));
    // 0x15fca8: 0xc44e000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[14] = *(float*)&val; }
    // 0x15fcac: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15fcb0: 0xc44f0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[15] = *(float*)&val; }
    // 0x15fcb4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15fcb8: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x15fcc0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[16] = *(float*)&val; }
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_15fcc0
// Address: 0x15fcc0 - 0x15fcd8

void entry_15fcc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fcc0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15fcc4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15fcc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15fccc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15fcd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15fcd8; return;
}


// Function: FreezeSo__FP2SOi
// Address: 0x15fcd8 - 0x15fd10

void entry_15fd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fd10: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x15fd14: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x15fd18: 0x8e050540
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1344)));
    // 0x15fd1c: 0xfa010180
    WRITE128(ADD32(GPR_U32(ctx, 16), 384), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x15fd20: 0xc077042
    SET_GPR_U32(ctx, 31, 0x15fd28);
    WRITE128(ADD32(GPR_U32(ctx, 16), 368), _mm_castps_si128(ctx->vu0_vf[1]));
    FreeSwStsoList__FP2SWP4STSO(rdram, ctx, runtime); return;
}


// Function: entry_15fd28
// Address: 0x15fd28 - 0x15fd38

void entry_15fd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fd28: 0xae000540
    WRITE32(ADD32(GPR_U32(ctx, 16), 1344), GPR_U32(ctx, 0));
    // 0x15fd2c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15fd30: 0xc057eee
    SET_GPR_U32(ctx, 31, 0x15fd38);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FreezeAlo__FP3ALOi(rdram, ctx, runtime); return;
}


// Function: entry_15fd38
// Address: 0x15fd38 - 0x15fd4c

void entry_15fd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15fd38) {
        switch (ctx->pc) {
            case 0x15fd40: ctx->pc = 0; goto label_15fd40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15fd38: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15FD68; return;
    }
label_15fd40:
    // 0x15fd40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15fd44: 0xc057eee
    SET_GPR_U32(ctx, 31, 0x15fd4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FreezeAlo__FP3ALOi(rdram, ctx, runtime); return;
}


// Function: entry_15fd4c
// Address: 0x15fd4c - 0x15fd64

void entry_15fd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fd4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x15fd50: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15fd54: 0x8c850090
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 144)));
    // 0x15fd58: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x15fd5c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x15fd64);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 148)));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_15fd64
// Address: 0x15fd64 - 0x15fd78

void entry_15fd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15fd64) {
        switch (ctx->pc) {
            case 0x15fd68: ctx->pc = 0; goto label_15fd68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15fd64: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_15fd68:
    // 0x15fd68: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15fd6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15fd74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15fd78; return;
}


// Function: RefreezeSwObjects__FP2SW
// Address: 0x15fd78 - 0x15fea8

void entry_15fea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fea8: 0x26640060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 96));
    // 0x15feac: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x15feb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15feb4
// Address: 0x15feb4 - 0x15fed0

void entry_15feb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15feb4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15feb8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x15febc: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x15fec0: 0x10400011
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 108));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15ff08(rdram, ctx, runtime); return;
    }
    // 0x15fec8: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x15fed0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15fed0
// Address: 0x15fed0 - 0x15fee0

void entry_15fed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15fed0) {
        switch (ctx->pc) {
            case 0x15fed8: ctx->pc = 0; goto label_15fed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15fed0: 0x1000000e
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x15FF0C; return;
    }
label_15fed8:
    // 0x15fed8: 0xc057eca
    SET_GPR_U32(ctx, 31, 0x15fee0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FreezeAloHierarchy__FP3ALOi(rdram, ctx, runtime); return;
}


// Function: entry_15fee0
// Address: 0x15fee0 - 0x15feec

void entry_15fee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15fee0: 0x26640060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 96));
    // 0x15fee4: 0xc054980
    SET_GPR_U32(ctx, 31, 0x15feec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15feec
// Address: 0x15feec - 0x15ff08

void entry_15feec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15feec: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x15fef0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x15fef4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x15fef8: 0x10400003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 108));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_15ff08(rdram, ctx, runtime); return;
    }
    // 0x15ff00: 0xc054980
    SET_GPR_U32(ctx, 31, 0x15ff08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_15ff08
// Address: 0x15ff08 - 0x15ff58

void entry_15ff08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ff08) {
        switch (ctx->pc) {
            case 0x15ff0c: ctx->pc = 0; goto label_15ff0c;
            case 0x15ff1c: ctx->pc = 0; goto label_15ff1c;
            case 0x15ff28: ctx->pc = 0; goto label_15ff28;
            case 0x15ff34: ctx->pc = 0; goto label_15ff34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ff08: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
label_15ff0c:
    // 0x15ff0c: 0x551024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x15ff10: 0x541025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x15ff14: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x15ff18: 0x8e100058
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 88)));
label_15ff1c:
    // 0x15ff1c: 0x5600ffda
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
        ctx->pc = 0x15FE88; return;
    }
    // 0x15ff24: 0x8e520048
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 72)));
label_15ff28:
    // 0x15ff28: 0x5640ffa1
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 84)));
        ctx->pc = 0x15FDB0; return;
    }
    // 0x15ff30: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_15ff34:
    // 0x15ff34: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x15ff38: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x15ff3c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x15ff40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x15ff44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ff48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ff4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15ff54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15ff58; return;
}


// Function: UpdateSwBusyList__FP2SW
// Address: 0x15ff58 - 0x15ff6c

void entry_15ff6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ff6c: 0xc057f5e
    SET_GPR_U32(ctx, 31, 0x15ff74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_15ff74
// Address: 0x15ff74 - 0x15ff88

void entry_15ff74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ff74: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x15ff78: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x15ff7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x15ff84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x15ff88; return;
}


// Function: PostFrzgLoad__FP4FRZG
// Address: 0x15ff88 - 0x15ffb4

void entry_15ffb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x15ffb4: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x15ffb8: 0x8e140014
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x15ffbc: 0xc063540
    SET_GPR_U32(ctx, 31, 0x15ffc4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_15ffc4
// Address: 0x15ffc4 - 0x15ffe8

void entry_15ffc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ffc4) {
        switch (ctx->pc) {
            case 0x15ffd8: ctx->pc = 0; goto label_15ffd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ffc4: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x15ffc8: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x15ffcc: 0x18400015
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 56));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x160024; return;
    }
    // 0x15ffd4: 0x0
    // NOP
label_15ffd8:
    // 0x15ffd8: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x15ffdc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x15ffe0: 0xc056920
    SET_GPR_U32(ctx, 31, 0x15ffe8);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_15ffe8
// Address: 0x15ffe8 - 0x160030

void entry_15ffe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x15ffe8) {
        switch (ctx->pc) {
            case 0x160014: ctx->pc = 0; goto label_160014;
            case 0x160024: ctx->pc = 0; goto label_160024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x15ffe8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x15ffec: 0x50a00009
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
        goto label_160014;
    }
    // 0x15fff4: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x15fff8: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x15fffc: 0x21880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 2));
    // 0x160000: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x160004: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x160008: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x16000c: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x160010: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
label_160014:
    // 0x160014: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x160018: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x16001c: 0x1440ffee
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x15FFD8; return;
    }
label_160024:
    // 0x160024: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x160028: 0xc057e2c
    SET_GPR_U32(ctx, 31, 0x160030);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 88));
    AddSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime); return;
}


// Function: entry_160030
// Address: 0x160030 - 0x160050

void entry_15006c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15006c inside entry_15004c (0x15004c - 0x1500ac)
    ctx->pc = 0x15006c;
    entry_15004c(rdram, ctx, runtime);
}

void entry_150074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150074 inside entry_15004c (0x15004c - 0x1500ac)
    ctx->pc = 0x150074;
    entry_15004c(rdram, ctx, runtime);
}

void entry_150084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150084 inside entry_15004c (0x15004c - 0x1500ac)
    ctx->pc = 0x150084;
    entry_15004c(rdram, ctx, runtime);
}

void entry_150088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150088 inside entry_15004c (0x15004c - 0x1500ac)
    ctx->pc = 0x150088;
    entry_15004c(rdram, ctx, runtime);
}

void entry_1500e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1500e8 inside entry_1500e4 (0x1500e4 - 0x15011c)
    ctx->pc = 0x1500e8;
    entry_1500e4(rdram, ctx, runtime);
}

void entry_1502d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1502d8 inside AgeDartgunStuckDart__FP7DARTGUN (0x150298 - 0x1502e0)
    ctx->pc = 0x1502d8;
    AgeDartgunStuckDart__FP7DARTGUN(rdram, ctx, runtime);
}

void entry_150300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150300 inside entry_1502e0 (0x1502e0 - 0x150318)
    ctx->pc = 0x150300;
    entry_1502e0(rdram, ctx, runtime);
}

void entry_150308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150308 inside entry_1502e0 (0x1502e0 - 0x150318)
    ctx->pc = 0x150308;
    entry_1502e0(rdram, ctx, runtime);
}

void entry_15031c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15031c inside entry_150318 (0x150318 - 0x150338)
    ctx->pc = 0x15031c;
    entry_150318(rdram, ctx, runtime);
}

void entry_150320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150320 inside entry_150318 (0x150318 - 0x150338)
    ctx->pc = 0x150320;
    entry_150318(rdram, ctx, runtime);
}

void entry_150378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150378 inside PratGetDartgunRatTarget__FP7DARTGUN (0x150338 - 0x150384)
    ctx->pc = 0x150378;
    PratGetDartgunRatTarget__FP7DARTGUN(rdram, ctx, runtime);
}

void entry_1503a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1503a4 inside entry_150384 (0x150384 - 0x1503e0)
    ctx->pc = 0x1503a4;
    entry_150384(rdram, ctx, runtime);
}

void entry_1503b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1503b4 inside entry_150384 (0x150384 - 0x1503e0)
    ctx->pc = 0x1503b4;
    entry_150384(rdram, ctx, runtime);
}

void entry_1503b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1503b8 inside entry_150384 (0x150384 - 0x1503e0)
    ctx->pc = 0x1503b8;
    entry_150384(rdram, ctx, runtime);
}

void entry_150400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150400 inside AddDartgunRatTarget__FP7DARTGUN3OID (0x1503e0 - 0x150408)
    ctx->pc = 0x150400;
    AddDartgunRatTarget__FP7DARTGUN3OID(rdram, ctx, runtime);
}

void entry_15044c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15044c inside entry_15043c (0x15043c - 0x150458)
    ctx->pc = 0x15044c;
    entry_15043c(rdram, ctx, runtime);
}

void entry_150480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150480 inside entry_150458 (0x150458 - 0x1504e0)
    ctx->pc = 0x150480;
    entry_150458(rdram, ctx, runtime);
}

void entry_1504a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1504a0 inside entry_150458 (0x150458 - 0x1504e0)
    ctx->pc = 0x1504a0;
    entry_150458(rdram, ctx, runtime);
}

void entry_1504c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1504c8 inside entry_150458 (0x150458 - 0x1504e0)
    ctx->pc = 0x1504c8;
    entry_150458(rdram, ctx, runtime);
}

void entry_1504cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1504cc inside entry_150458 (0x150458 - 0x1504e0)
    ctx->pc = 0x1504cc;
    entry_150458(rdram, ctx, runtime);
}

void entry_1505c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1505c8 inside entry_1505b4 (0x1505b4 - 0x1505dc)
    ctx->pc = 0x1505c8;
    entry_1505b4(rdram, ctx, runtime);
}

void entry_1506b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1506b8 inside entry_1506b4 (0x1506b4 - 0x1506f0)
    ctx->pc = 0x1506b8;
    entry_1506b4(rdram, ctx, runtime);
}

void entry_1506bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1506bc inside entry_1506b4 (0x1506b4 - 0x1506f0)
    ctx->pc = 0x1506bc;
    entry_1506b4(rdram, ctx, runtime);
}

void entry_1506d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1506d0 inside entry_1506b4 (0x1506b4 - 0x1506f0)
    ctx->pc = 0x1506d0;
    entry_1506b4(rdram, ctx, runtime);
}

void entry_150720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150720 inside entry_150704 (0x150704 - 0x15072c)
    ctx->pc = 0x150720;
    entry_150704(rdram, ctx, runtime);
}

void entry_15073c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15073c inside entry_15072c (0x15072c - 0x150750)
    ctx->pc = 0x15073c;
    entry_15072c(rdram, ctx, runtime);
}

void entry_1507e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1507e0 inside SetDialogDialogs__FP6DIALOG7DIALOGS (0x150790 - 0x150840)
    ctx->pc = 0x1507e0;
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime);
}

void entry_150810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150810 inside SetDialogDialogs__FP6DIALOG7DIALOGS (0x150790 - 0x150840)
    ctx->pc = 0x150810;
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime);
}

void entry_15082c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15082c inside SetDialogDialogs__FP6DIALOG7DIALOGS (0x150790 - 0x150840)
    ctx->pc = 0x15082c;
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime);
}

void entry_15088c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15088c inside entry_150888 (0x150888 - 0x150894)
    ctx->pc = 0x15088c;
    entry_150888(rdram, ctx, runtime);
}

void entry_1508bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1508bc inside entry_1508b8 (0x1508b8 - 0x1508e8)
    ctx->pc = 0x1508bc;
    entry_1508b8(rdram, ctx, runtime);
}

void entry_150900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150900 inside entry_1508f8 (0x1508f8 - 0x15091c)
    ctx->pc = 0x150900;
    entry_1508f8(rdram, ctx, runtime);
}

void entry_150920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150920 inside entry_15091c (0x15091c - 0x150970)
    ctx->pc = 0x150920;
    entry_15091c(rdram, ctx, runtime);
}

void entry_150940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150940 inside entry_15091c (0x15091c - 0x150970)
    ctx->pc = 0x150940;
    entry_15091c(rdram, ctx, runtime);
}

void entry_150978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150978 inside entry_150970 (0x150970 - 0x1509bc)
    ctx->pc = 0x150978;
    entry_150970(rdram, ctx, runtime);
}

void entry_150990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150990 inside entry_150970 (0x150970 - 0x1509bc)
    ctx->pc = 0x150990;
    entry_150970(rdram, ctx, runtime);
}

void entry_150a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150a2c inside entry_150a24 (0x150a24 - 0x150a40)
    ctx->pc = 0x150a2c;
    entry_150a24(rdram, ctx, runtime);
}

void entry_150a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150a70 inside entry_150a64 (0x150a64 - 0x150a8c)
    ctx->pc = 0x150a70;
    entry_150a64(rdram, ctx, runtime);
}

void entry_150a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150a78 inside entry_150a64 (0x150a64 - 0x150a8c)
    ctx->pc = 0x150a78;
    entry_150a64(rdram, ctx, runtime);
}

void entry_150abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150abc inside entry_150ab8 (0x150ab8 - 0x150ae8)
    ctx->pc = 0x150abc;
    entry_150ab8(rdram, ctx, runtime);
}

void entry_150ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150ac8 inside entry_150ab8 (0x150ab8 - 0x150ae8)
    ctx->pc = 0x150ac8;
    entry_150ab8(rdram, ctx, runtime);
}

void entry_150b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150b50 inside entry_150b30 (0x150b30 - 0x150b80)
    ctx->pc = 0x150b50;
    entry_150b30(rdram, ctx, runtime);
}

void entry_150b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150b78 inside entry_150b30 (0x150b30 - 0x150b80)
    ctx->pc = 0x150b78;
    entry_150b30(rdram, ctx, runtime);
}

void entry_150b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150b88 inside entry_150b80 (0x150b80 - 0x150b98)
    ctx->pc = 0x150b88;
    entry_150b80(rdram, ctx, runtime);
}

void entry_150b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150b8c inside entry_150b80 (0x150b80 - 0x150b98)
    ctx->pc = 0x150b8c;
    entry_150b80(rdram, ctx, runtime);
}

void entry_150bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150bc8 inside entry_150bb4 (0x150bb4 - 0x150be4)
    ctx->pc = 0x150bc8;
    entry_150bb4(rdram, ctx, runtime);
}

void entry_150bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150bec inside entry_150be4 (0x150be4 - 0x150c4c)
    ctx->pc = 0x150bec;
    entry_150be4(rdram, ctx, runtime);
}

void entry_150bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150bf4 inside entry_150be4 (0x150be4 - 0x150c4c)
    ctx->pc = 0x150bf4;
    entry_150be4(rdram, ctx, runtime);
}

void entry_150bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150bf8 inside entry_150be4 (0x150be4 - 0x150c4c)
    ctx->pc = 0x150bf8;
    entry_150be4(rdram, ctx, runtime);
}

void entry_150ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150ca4 inside entry_150c9c (0x150c9c - 0x150ccc)
    ctx->pc = 0x150ca4;
    entry_150c9c(rdram, ctx, runtime);
}

void entry_150cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150cd4 inside entry_150ccc (0x150ccc - 0x150d44)
    ctx->pc = 0x150cd4;
    entry_150ccc(rdram, ctx, runtime);
}

void entry_150cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150cd8 inside entry_150ccc (0x150ccc - 0x150d44)
    ctx->pc = 0x150cd8;
    entry_150ccc(rdram, ctx, runtime);
}

void entry_150d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150d38 inside entry_150ccc (0x150ccc - 0x150d44)
    ctx->pc = 0x150d38;
    entry_150ccc(rdram, ctx, runtime);
}

void entry_150d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150d68 inside entry_150d44 (0x150d44 - 0x150d74)
    ctx->pc = 0x150d68;
    entry_150d44(rdram, ctx, runtime);
}

void entry_150d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150d6c inside entry_150d44 (0x150d44 - 0x150d74)
    ctx->pc = 0x150d6c;
    entry_150d44(rdram, ctx, runtime);
}

void entry_150da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150da8 inside entry_150da4 (0x150da4 - 0x150dc0)
    ctx->pc = 0x150da8;
    entry_150da4(rdram, ctx, runtime);
}

void entry_150e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150e50 inside entry_150e48 (0x150e48 - 0x150e74)
    ctx->pc = 0x150e50;
    entry_150e48(rdram, ctx, runtime);
}

void entry_150e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150e54 inside entry_150e48 (0x150e48 - 0x150e74)
    ctx->pc = 0x150e54;
    entry_150e48(rdram, ctx, runtime);
}

void entry_150e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150e7c inside entry_150e74 (0x150e74 - 0x150e9c)
    ctx->pc = 0x150e7c;
    entry_150e74(rdram, ctx, runtime);
}

void entry_150e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150e80 inside entry_150e74 (0x150e74 - 0x150e9c)
    ctx->pc = 0x150e80;
    entry_150e74(rdram, ctx, runtime);
}

void entry_150ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150ea0 inside entry_150e9c (0x150e9c - 0x150ed0)
    ctx->pc = 0x150ea0;
    entry_150e9c(rdram, ctx, runtime);
}

void entry_150ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150ebc inside entry_150e9c (0x150e9c - 0x150ed0)
    ctx->pc = 0x150ebc;
    entry_150e9c(rdram, ctx, runtime);
}

void entry_150ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150ef4 inside entry_150edc (0x150edc - 0x150f08)
    ctx->pc = 0x150ef4;
    entry_150edc(rdram, ctx, runtime);
}

void entry_150f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150f70 inside entry_150f68 (0x150f68 - 0x150f84)
    ctx->pc = 0x150f70;
    entry_150f68(rdram, ctx, runtime);
}

void entry_150f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150f74 inside entry_150f68 (0x150f68 - 0x150f84)
    ctx->pc = 0x150f74;
    entry_150f68(rdram, ctx, runtime);
}

void entry_150fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150fb4 inside entry_150fac (0x150fac - 0x150fd8)
    ctx->pc = 0x150fb4;
    entry_150fac(rdram, ctx, runtime);
}

void entry_150fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150fb8 inside entry_150fac (0x150fac - 0x150fd8)
    ctx->pc = 0x150fb8;
    entry_150fac(rdram, ctx, runtime);
}

void entry_150fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150fbc inside entry_150fac (0x150fac - 0x150fd8)
    ctx->pc = 0x150fbc;
    entry_150fac(rdram, ctx, runtime);
}

void entry_150fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x150fec inside entry_150fd8 (0x150fd8 - 0x151004)
    ctx->pc = 0x150fec;
    entry_150fd8(rdram, ctx, runtime);
}

void entry_151008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151008 inside entry_151004 (0x151004 - 0x151028)
    ctx->pc = 0x151008;
    entry_151004(rdram, ctx, runtime);
}

void entry_151080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151080 inside entry_151060 (0x151060 - 0x1510d4)
    ctx->pc = 0x151080;
    entry_151060(rdram, ctx, runtime);
}

void entry_151090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151090 inside entry_151060 (0x151060 - 0x1510d4)
    ctx->pc = 0x151090;
    entry_151060(rdram, ctx, runtime);
}

void entry_1510b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1510b0 inside entry_151060 (0x151060 - 0x1510d4)
    ctx->pc = 0x1510b0;
    entry_151060(rdram, ctx, runtime);
}

void entry_1510b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1510b4 inside entry_151060 (0x151060 - 0x1510d4)
    ctx->pc = 0x1510b4;
    entry_151060(rdram, ctx, runtime);
}

void entry_1510f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1510f0 inside entry_1510d4 (0x1510d4 - 0x151154)
    ctx->pc = 0x1510f0;
    entry_1510d4(rdram, ctx, runtime);
}

void entry_151108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151108 inside entry_1510d4 (0x1510d4 - 0x151154)
    ctx->pc = 0x151108;
    entry_1510d4(rdram, ctx, runtime);
}

void entry_151110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151110 inside entry_1510d4 (0x1510d4 - 0x151154)
    ctx->pc = 0x151110;
    entry_1510d4(rdram, ctx, runtime);
}

void entry_15111c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15111c inside entry_1510d4 (0x1510d4 - 0x151154)
    ctx->pc = 0x15111c;
    entry_1510d4(rdram, ctx, runtime);
}

void entry_151128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151128 inside entry_1510d4 (0x1510d4 - 0x151154)
    ctx->pc = 0x151128;
    entry_1510d4(rdram, ctx, runtime);
}

void entry_15112c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15112c inside entry_1510d4 (0x1510d4 - 0x151154)
    ctx->pc = 0x15112c;
    entry_1510d4(rdram, ctx, runtime);
}

void entry_151160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151160 inside entry_151154 (0x151154 - 0x1511b0)
    ctx->pc = 0x151160;
    entry_151154(rdram, ctx, runtime);
}

void entry_151190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151190 inside entry_151154 (0x151154 - 0x1511b0)
    ctx->pc = 0x151190;
    entry_151154(rdram, ctx, runtime);
}

void entry_1511d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1511d4 inside entry_1511c0 (0x1511c0 - 0x1511e8)
    ctx->pc = 0x1511d4;
    entry_1511c0(rdram, ctx, runtime);
}

void entry_1511e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1511e0 inside entry_1511c0 (0x1511c0 - 0x1511e8)
    ctx->pc = 0x1511e0;
    entry_1511c0(rdram, ctx, runtime);
}

void entry_1511f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1511f8 inside entry_1511e8 (0x1511e8 - 0x15124c)
    ctx->pc = 0x1511f8;
    entry_1511e8(rdram, ctx, runtime);
}

void entry_151204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151204 inside entry_1511e8 (0x1511e8 - 0x15124c)
    ctx->pc = 0x151204;
    entry_1511e8(rdram, ctx, runtime);
}

void entry_151224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151224 inside entry_1511e8 (0x1511e8 - 0x15124c)
    ctx->pc = 0x151224;
    entry_1511e8(rdram, ctx, runtime);
}

void entry_151288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151288 inside entry_151284 (0x151284 - 0x1512a8)
    ctx->pc = 0x151288;
    entry_151284(rdram, ctx, runtime);
}

void entry_15128c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15128c inside entry_151284 (0x151284 - 0x1512a8)
    ctx->pc = 0x15128c;
    entry_151284(rdram, ctx, runtime);
}

void entry_1512e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1512e8 inside entry_1512cc (0x1512cc - 0x151300)
    ctx->pc = 0x1512e8;
    entry_1512cc(rdram, ctx, runtime);
}

void entry_151354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151354 inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x151354;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_151358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151358 inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x151358;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_15137c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15137c inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x15137c;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_1513b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1513b0 inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x1513b0;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_1513e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1513e4 inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x1513e4;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_1513e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1513e8 inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x1513e8;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_151414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151414 inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x151414;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_151448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151448 inside FPauseDialog__FP6DIALOG (0x151300 - 0x151458)
    ctx->pc = 0x151448;
    FPauseDialog__FP6DIALOG(rdram, ctx, runtime);
}

void entry_151470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151470 inside entry_151458 (0x151458 - 0x151480)
    ctx->pc = 0x151470;
    entry_151458(rdram, ctx, runtime);
}

void entry_151498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151498 inside entry_151480 (0x151480 - 0x1514cc)
    ctx->pc = 0x151498;
    entry_151480(rdram, ctx, runtime);
}

void entry_1514bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1514bc inside entry_151480 (0x151480 - 0x1514cc)
    ctx->pc = 0x1514bc;
    entry_151480(rdram, ctx, runtime);
}

void entry_1514e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1514e0 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x1514e0;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_1514e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1514e4 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x1514e4;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_151518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151518 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x151518;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_15151c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15151c inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x15151c;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_151548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151548 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x151548;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_15154c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15154c inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x15154c;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_151574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151574 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x151574;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_15157c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15157c inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x15157c;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_1515f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1515f0 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x1515f0;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_151608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151608 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x151608;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_15165c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15165c inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x15165c;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_15167c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15167c inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x15167c;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_15168c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15168c inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x15168c;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_1516a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1516a0 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x1516a0;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_1516a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1516a8 inside entry_1514cc (0x1514cc - 0x1516c0)
    ctx->pc = 0x1516a8;
    entry_1514cc(rdram, ctx, runtime);
}

void entry_151700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151700 inside FUN_001516c0 (0x1516c0 - 0x151758)
    ctx->pc = 0x151700;
    FUN_001516c0(rdram, ctx, runtime);
}

void entry_15177c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15177c inside entry_151778 (0x151778 - 0x1517ac)
    ctx->pc = 0x15177c;
    entry_151778(rdram, ctx, runtime);
}

void entry_151790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151790 inside entry_151778 (0x151778 - 0x1517ac)
    ctx->pc = 0x151790;
    entry_151778(rdram, ctx, runtime);
}

void entry_1517b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1517b0 inside entry_1517ac (0x1517ac - 0x1517c0)
    ctx->pc = 0x1517b0;
    entry_1517ac(rdram, ctx, runtime);
}

void entry_1517f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1517f0 inside HandleDialogEvents__FP6DIALOG (0x1517c0 - 0x151804)
    ctx->pc = 0x1517f0;
    HandleDialogEvents__FP6DIALOG(rdram, ctx, runtime);
}

void entry_151830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151830 inside entry_151828 (0x151828 - 0x15184c)
    ctx->pc = 0x151830;
    entry_151828(rdram, ctx, runtime);
}

void entry_151850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151850 inside entry_15184c (0x15184c - 0x151860)
    ctx->pc = 0x151850;
    entry_15184c(rdram, ctx, runtime);
}

void entry_151890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151890 inside entry_151888 (0x151888 - 0x1518a8)
    ctx->pc = 0x151890;
    entry_151888(rdram, ctx, runtime);
}

void entry_1518ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1518ac inside entry_1518a8 (0x1518a8 - 0x1518b8)
    ctx->pc = 0x1518ac;
    entry_1518a8(rdram, ctx, runtime);
}

void entry_151940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151940 inside entry_1518f0 (0x1518f0 - 0x151994)
    ctx->pc = 0x151940;
    entry_1518f0(rdram, ctx, runtime);
}

void entry_151968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151968 inside entry_1518f0 (0x1518f0 - 0x151994)
    ctx->pc = 0x151968;
    entry_1518f0(rdram, ctx, runtime);
}

void entry_15198c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15198c inside entry_1518f0 (0x1518f0 - 0x151994)
    ctx->pc = 0x15198c;
    entry_1518f0(rdram, ctx, runtime);
}

void entry_151998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151998 inside entry_151994 (0x151994 - 0x1519a8)
    ctx->pc = 0x151998;
    entry_151994(rdram, ctx, runtime);
}

void entry_15199c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15199c inside entry_151994 (0x151994 - 0x1519a8)
    ctx->pc = 0x15199c;
    entry_151994(rdram, ctx, runtime);
}

void entry_1519d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1519d4 inside entry_1519d0 (0x1519d0 - 0x1519e0)
    ctx->pc = 0x1519d4;
    entry_1519d0(rdram, ctx, runtime);
}

void entry_151a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151a44 inside entry_151a20 (0x151a20 - 0x151a58)
    ctx->pc = 0x151a44;
    entry_151a20(rdram, ctx, runtime);
}

void entry_151a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151a48 inside entry_151a20 (0x151a20 - 0x151a58)
    ctx->pc = 0x151a48;
    entry_151a20(rdram, ctx, runtime);
}

void entry_151aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151aec inside OnDifficultyWorldPreLoad (0x151a88 - 0x151b34)
    ctx->pc = 0x151aec;
    OnDifficultyWorldPreLoad(rdram, ctx, runtime);
}

void entry_151af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151af8 inside OnDifficultyWorldPreLoad (0x151a88 - 0x151b34)
    ctx->pc = 0x151af8;
    OnDifficultyWorldPreLoad(rdram, ctx, runtime);
}

void entry_151b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151b18 inside OnDifficultyWorldPreLoad (0x151a88 - 0x151b34)
    ctx->pc = 0x151b18;
    OnDifficultyWorldPreLoad(rdram, ctx, runtime);
}

void entry_151b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151b20 inside OnDifficultyWorldPreLoad (0x151a88 - 0x151b34)
    ctx->pc = 0x151b20;
    OnDifficultyWorldPreLoad(rdram, ctx, runtime);
}

void entry_151b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151b54 inside entry_151b34 (0x151b34 - 0x151c84)
    ctx->pc = 0x151b54;
    entry_151b34(rdram, ctx, runtime);
}

void entry_151b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151b98 inside entry_151b34 (0x151b34 - 0x151c84)
    ctx->pc = 0x151b98;
    entry_151b34(rdram, ctx, runtime);
}

void entry_151bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151bd8 inside entry_151b34 (0x151b34 - 0x151c84)
    ctx->pc = 0x151bd8;
    entry_151b34(rdram, ctx, runtime);
}

void entry_151be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151be0 inside entry_151b34 (0x151b34 - 0x151c84)
    ctx->pc = 0x151be0;
    entry_151b34(rdram, ctx, runtime);
}

void entry_151bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151bf8 inside entry_151b34 (0x151b34 - 0x151c84)
    ctx->pc = 0x151bf8;
    entry_151b34(rdram, ctx, runtime);
}

void entry_151c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151c3c inside entry_151b34 (0x151b34 - 0x151c84)
    ctx->pc = 0x151c3c;
    entry_151b34(rdram, ctx, runtime);
}

void entry_151c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151c7c inside entry_151b34 (0x151b34 - 0x151c84)
    ctx->pc = 0x151c7c;
    entry_151b34(rdram, ctx, runtime);
}

void entry_151cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151cd0 inside entry_151c84 (0x151c84 - 0x151d08)
    ctx->pc = 0x151cd0;
    entry_151c84(rdram, ctx, runtime);
}

void entry_151cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151cfc inside entry_151c84 (0x151c84 - 0x151d08)
    ctx->pc = 0x151cfc;
    entry_151c84(rdram, ctx, runtime);
}

void entry_151d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151d00 inside entry_151c84 (0x151c84 - 0x151d08)
    ctx->pc = 0x151d00;
    entry_151c84(rdram, ctx, runtime);
}

void entry_151d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151d8c inside OnDifficultyWorldPostLoad (0x151d28 - 0x151dc8)
    ctx->pc = 0x151d8c;
    OnDifficultyWorldPostLoad(rdram, ctx, runtime);
}

void entry_151dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151dac inside OnDifficultyWorldPostLoad (0x151d28 - 0x151dc8)
    ctx->pc = 0x151dac;
    OnDifficultyWorldPostLoad(rdram, ctx, runtime);
}

void entry_151dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151dd4 inside entry_151dc8 (0x151dc8 - 0x151dec)
    ctx->pc = 0x151dd4;
    entry_151dc8(rdram, ctx, runtime);
}

void entry_151dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151dfc inside entry_151df8 (0x151df8 - 0x151e04)
    ctx->pc = 0x151dfc;
    entry_151df8(rdram, ctx, runtime);
}

void entry_151e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151e84 inside entry_151e64 (0x151e64 - 0x151eb8)
    ctx->pc = 0x151e84;
    entry_151e64(rdram, ctx, runtime);
}

void entry_151e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151e9c inside entry_151e64 (0x151e64 - 0x151eb8)
    ctx->pc = 0x151e9c;
    entry_151e64(rdram, ctx, runtime);
}

void entry_151f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151f3c inside OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT (0x151ed8 - 0x151f58)
    ctx->pc = 0x151f3c;
    OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT(rdram, ctx, runtime);
}

void entry_151f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151f40 inside OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT (0x151ed8 - 0x151f58)
    ctx->pc = 0x151f40;
    OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT(rdram, ctx, runtime);
}

void entry_151f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151f44 inside OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT (0x151ed8 - 0x151f58)
    ctx->pc = 0x151f44;
    OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT(rdram, ctx, runtime);
}

void entry_151fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151fb0 inside entry_151f58 (0x151f58 - 0x151fc8)
    ctx->pc = 0x151fb0;
    entry_151f58(rdram, ctx, runtime);
}

void entry_151fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x151fb4 inside entry_151f58 (0x151f58 - 0x151fc8)
    ctx->pc = 0x151fb4;
    entry_151f58(rdram, ctx, runtime);
}

void entry_152084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152084 inside OnDifficultyBreak (0x152010 - 0x1520a8)
    ctx->pc = 0x152084;
    OnDifficultyBreak(rdram, ctx, runtime);
}

void entry_15209c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15209c inside OnDifficultyBreak (0x152010 - 0x1520a8)
    ctx->pc = 0x15209c;
    OnDifficultyBreak(rdram, ctx, runtime);
}

void entry_1520bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1520bc inside entry_1520a8 (0x1520a8 - 0x152100)
    ctx->pc = 0x1520bc;
    entry_1520a8(rdram, ctx, runtime);
}

void entry_152108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152108 inside entry_152100 (0x152100 - 0x152188)
    ctx->pc = 0x152108;
    entry_152100(rdram, ctx, runtime);
}

void entry_152150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152150 inside entry_152100 (0x152100 - 0x152188)
    ctx->pc = 0x152150;
    entry_152100(rdram, ctx, runtime);
}

void entry_15217c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15217c inside entry_152100 (0x152100 - 0x152188)
    ctx->pc = 0x15217c;
    entry_152100(rdram, ctx, runtime);
}

void entry_152180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152180 inside entry_152100 (0x152100 - 0x152188)
    ctx->pc = 0x152180;
    entry_152100(rdram, ctx, runtime);
}

void entry_15218c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15218c inside entry_152188 (0x152188 - 0x152208)
    ctx->pc = 0x15218c;
    entry_152188(rdram, ctx, runtime);
}

void entry_1521c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1521c8 inside entry_152188 (0x152188 - 0x152208)
    ctx->pc = 0x1521c8;
    entry_152188(rdram, ctx, runtime);
}

void entry_1521ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1521ec inside entry_152188 (0x152188 - 0x152208)
    ctx->pc = 0x1521ec;
    entry_152188(rdram, ctx, runtime);
}

void entry_152200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152200 inside entry_152188 (0x152188 - 0x152208)
    ctx->pc = 0x152200;
    entry_152188(rdram, ctx, runtime);
}

void entry_152210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152210 inside entry_152208 (0x152208 - 0x15237c)
    ctx->pc = 0x152210;
    entry_152208(rdram, ctx, runtime);
}

void entry_152250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152250 inside entry_152208 (0x152208 - 0x15237c)
    ctx->pc = 0x152250;
    entry_152208(rdram, ctx, runtime);
}

void entry_152294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152294 inside entry_152208 (0x152208 - 0x15237c)
    ctx->pc = 0x152294;
    entry_152208(rdram, ctx, runtime);
}

void entry_1522d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1522d4 inside entry_152208 (0x152208 - 0x15237c)
    ctx->pc = 0x1522d4;
    entry_152208(rdram, ctx, runtime);
}

void entry_1522f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1522f0 inside entry_152208 (0x152208 - 0x15237c)
    ctx->pc = 0x1522f0;
    entry_152208(rdram, ctx, runtime);
}

void entry_152334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152334 inside entry_152208 (0x152208 - 0x15237c)
    ctx->pc = 0x152334;
    entry_152208(rdram, ctx, runtime);
}

void entry_152374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152374 inside entry_152208 (0x152208 - 0x15237c)
    ctx->pc = 0x152374;
    entry_152208(rdram, ctx, runtime);
}

void entry_152384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152384 inside entry_15237c (0x15237c - 0x152394)
    ctx->pc = 0x152384;
    entry_15237c(rdram, ctx, runtime);
}

void entry_152388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152388 inside entry_15237c (0x15237c - 0x152394)
    ctx->pc = 0x152388;
    entry_15237c(rdram, ctx, runtime);
}

void entry_1523ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1523ec inside entry_1523e0 (0x1523e0 - 0x152410)
    ctx->pc = 0x1523ec;
    entry_1523e0(rdram, ctx, runtime);
}

void entry_1524a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1524a4 inside entry_152490 (0x152490 - 0x1524ac)
    ctx->pc = 0x1524a4;
    entry_152490(rdram, ctx, runtime);
}

void entry_1524b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1524b8 inside entry_1524ac (0x1524ac - 0x1524d8)
    ctx->pc = 0x1524b8;
    entry_1524ac(rdram, ctx, runtime);
}

void entry_152510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152510 inside entry_1524f8 (0x1524f8 - 0x152518)
    ctx->pc = 0x152510;
    entry_1524f8(rdram, ctx, runtime);
}

void entry_152528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152528 inside entry_152518 (0x152518 - 0x152540)
    ctx->pc = 0x152528;
    entry_152518(rdram, ctx, runtime);
}

void entry_15257c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15257c inside entry_152574 (0x152574 - 0x152590)
    ctx->pc = 0x15257c;
    entry_152574(rdram, ctx, runtime);
}

void entry_152598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152598 inside entry_152590 (0x152590 - 0x1525a0)
    ctx->pc = 0x152598;
    entry_152590(rdram, ctx, runtime);
}

void entry_1525d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1525d8 inside entry_1525c4 (0x1525c4 - 0x1525f8)
    ctx->pc = 0x1525d8;
    entry_1525c4(rdram, ctx, runtime);
}

void entry_152638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152638 inside entry_15261c (0x15261c - 0x152654)
    ctx->pc = 0x152638;
    entry_15261c(rdram, ctx, runtime);
}

void entry_152658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152658 inside entry_152654 (0x152654 - 0x152678)
    ctx->pc = 0x152658;
    entry_152654(rdram, ctx, runtime);
}

void entry_15265c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15265c inside entry_152654 (0x152654 - 0x152678)
    ctx->pc = 0x15265c;
    entry_152654(rdram, ctx, runtime);
}

void entry_152668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152668 inside entry_152654 (0x152654 - 0x152678)
    ctx->pc = 0x152668;
    entry_152654(rdram, ctx, runtime);
}

void entry_152684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152684 inside entry_152678 (0x152678 - 0x15269c)
    ctx->pc = 0x152684;
    entry_152678(rdram, ctx, runtime);
}

void entry_152688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152688 inside entry_152678 (0x152678 - 0x15269c)
    ctx->pc = 0x152688;
    entry_152678(rdram, ctx, runtime);
}

void entry_1526a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1526a8 inside entry_15269c (0x15269c - 0x1526d0)
    ctx->pc = 0x1526a8;
    entry_15269c(rdram, ctx, runtime);
}

void entry_1526ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1526ac inside entry_15269c (0x15269c - 0x1526d0)
    ctx->pc = 0x1526ac;
    entry_15269c(rdram, ctx, runtime);
}

void entry_152704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152704 inside entry_1526ec (0x1526ec - 0x152720)
    ctx->pc = 0x152704;
    entry_1526ec(rdram, ctx, runtime);
}

void entry_15270c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15270c inside entry_1526ec (0x1526ec - 0x152720)
    ctx->pc = 0x15270c;
    entry_1526ec(rdram, ctx, runtime);
}

void entry_152788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152788 inside entry_152780 (0x152780 - 0x152790)
    ctx->pc = 0x152788;
    entry_152780(rdram, ctx, runtime);
}

void entry_1527c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1527c4 inside entry_1527c0 (0x1527c0 - 0x1527d8)
    ctx->pc = 0x1527c4;
    entry_1527c0(rdram, ctx, runtime);
}

void entry_1527e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1527e8 inside CPvDl__FP2DL (0x1527d8 - 0x152810)
    ctx->pc = 0x1527e8;
    CPvDl__FP2DL(rdram, ctx, runtime);
}

void entry_152804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152804 inside CPvDl__FP2DL (0x1527d8 - 0x152810)
    ctx->pc = 0x152804;
    CPvDl__FP2DL(rdram, ctx, runtime);
}

void entry_152a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152a20 inside entry_152a04 (0x152a04 - 0x152a38)
    ctx->pc = 0x152a20;
    entry_152a04(rdram, ctx, runtime);
}

void entry_152a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152a30 inside entry_152a04 (0x152a04 - 0x152a38)
    ctx->pc = 0x152a30;
    entry_152a04(rdram, ctx, runtime);
}

void entry_152a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152a94 inside entry_152a7c (0x152a7c - 0x152ab8)
    ctx->pc = 0x152a94;
    entry_152a7c(rdram, ctx, runtime);
}

void entry_152aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152aa4 inside entry_152a7c (0x152a7c - 0x152ab8)
    ctx->pc = 0x152aa4;
    entry_152a7c(rdram, ctx, runtime);
}

void entry_152abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152abc inside entry_152ab8 (0x152ab8 - 0x152ac4)
    ctx->pc = 0x152abc;
    entry_152ab8(rdram, ctx, runtime);
}

void entry_152bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152bb8 inside entry_152bb4 (0x152bb4 - 0x152c18)
    ctx->pc = 0x152bb8;
    entry_152bb4(rdram, ctx, runtime);
}

void entry_152c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152c00 inside entry_152bb4 (0x152bb4 - 0x152c18)
    ctx->pc = 0x152c00;
    entry_152bb4(rdram, ctx, runtime);
}

void entry_152c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152c48 inside entry_152c44 (0x152c44 - 0x152ca0)
    ctx->pc = 0x152c48;
    entry_152c44(rdram, ctx, runtime);
}

void entry_152c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152c8c inside entry_152c44 (0x152c44 - 0x152ca0)
    ctx->pc = 0x152c8c;
    entry_152c44(rdram, ctx, runtime);
}

void entry_152da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152da0 inside EndDmaCnt__4DMAS (0x152d70 - 0x152de0)
    ctx->pc = 0x152da0;
    EndDmaCnt__4DMAS(rdram, ctx, runtime);
}

void entry_152dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152dc4 inside EndDmaCnt__4DMAS (0x152d70 - 0x152de0)
    ctx->pc = 0x152dc4;
    EndDmaCnt__4DMAS(rdram, ctx, runtime);
}

void entry_152e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x152e0c inside entry_152de0 (0x152de0 - 0x152e18)
    ctx->pc = 0x152e0c;
    entry_152de0(rdram, ctx, runtime);
}

void entry_1531b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1531b0 inside entry_153194 (0x153194 - 0x1531c0)
    ctx->pc = 0x1531b0;
    entry_153194(rdram, ctx, runtime);
}

void entry_15341c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15341c inside entry_1533f4 (0x1533f4 - 0x153468)
    ctx->pc = 0x15341c;
    entry_1533f4(rdram, ctx, runtime);
}

void entry_1534d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1534d0 inside entry_1534c0 (0x1534c0 - 0x1534e8)
    ctx->pc = 0x1534d0;
    entry_1534c0(rdram, ctx, runtime);
}

void entry_1534f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1534f8 inside entry_1534e8 (0x1534e8 - 0x153508)
    ctx->pc = 0x1534f8;
    entry_1534e8(rdram, ctx, runtime);
}

void entry_153668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153668 inside entry_153650 (0x153650 - 0x15368c)
    ctx->pc = 0x153668;
    entry_153650(rdram, ctx, runtime);
}

void entry_1536a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1536a8 inside entry_153698 (0x153698 - 0x1536c8)
    ctx->pc = 0x1536a8;
    entry_153698(rdram, ctx, runtime);
}

void entry_1536f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1536f0 inside AppendDzgDz__FP3DZGP2DZ (0x1536c8 - 0x153764)
    ctx->pc = 0x1536f0;
    AppendDzgDz__FP3DZGP2DZ(rdram, ctx, runtime);
}

void entry_153748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153748 inside AppendDzgDz__FP3DZGP2DZ (0x1536c8 - 0x153764)
    ctx->pc = 0x153748;
    AppendDzgDz__FP3DZGP2DZ(rdram, ctx, runtime);
}

void entry_153758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153758 inside AppendDzgDz__FP3DZGP2DZ (0x1536c8 - 0x153764)
    ctx->pc = 0x153758;
    AppendDzgDz__FP3DZGP2DZ(rdram, ctx, runtime);
}

void entry_1537e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1537e0 inside FillDzgDz__FP3DZGiP2DZiPP2XPPiPPP2SO (0x153780 - 0x15380c)
    ctx->pc = 0x1537e0;
    FillDzgDz__FP3DZGiP2DZiPP2XPPiPPP2SO(rdram, ctx, runtime);
}

void entry_153864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153864 inside entry_153860 (0x153860 - 0x153880)
    ctx->pc = 0x153864;
    entry_153860(rdram, ctx, runtime);
}

void entry_1538a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1538a0 inside entry_153880 (0x153880 - 0x153940)
    ctx->pc = 0x1538a0;
    entry_153880(rdram, ctx, runtime);
}

void entry_1538e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1538e0 inside entry_153880 (0x153880 - 0x153940)
    ctx->pc = 0x1538e0;
    entry_153880(rdram, ctx, runtime);
}

void entry_153918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153918 inside entry_153880 (0x153880 - 0x153940)
    ctx->pc = 0x153918;
    entry_153880(rdram, ctx, runtime);
}

void entry_153930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153930 inside entry_153880 (0x153880 - 0x153940)
    ctx->pc = 0x153930;
    entry_153880(rdram, ctx, runtime);
}

void entry_153948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153948 inside entry_153940 (0x153940 - 0x1539a4)
    ctx->pc = 0x153948;
    entry_153940(rdram, ctx, runtime);
}

void entry_15394c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15394c inside entry_153940 (0x153940 - 0x1539a4)
    ctx->pc = 0x15394c;
    entry_153940(rdram, ctx, runtime);
}

void entry_153954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153954 inside entry_153940 (0x153940 - 0x1539a4)
    ctx->pc = 0x153954;
    entry_153940(rdram, ctx, runtime);
}

void entry_153994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153994 inside entry_153940 (0x153940 - 0x1539a4)
    ctx->pc = 0x153994;
    entry_153940(rdram, ctx, runtime);
}

void entry_1539c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1539c0 inside entry_1539a4 (0x1539a4 - 0x153a50)
    ctx->pc = 0x1539c0;
    entry_1539a4(rdram, ctx, runtime);
}

void entry_153a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153a1c inside entry_1539a4 (0x1539a4 - 0x153a50)
    ctx->pc = 0x153a1c;
    entry_1539a4(rdram, ctx, runtime);
}

void entry_153a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153a94 inside entry_153a88 (0x153a88 - 0x153b0c)
    ctx->pc = 0x153a94;
    entry_153a88(rdram, ctx, runtime);
}

void entry_153aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153aa0 inside entry_153a88 (0x153a88 - 0x153b0c)
    ctx->pc = 0x153aa0;
    entry_153a88(rdram, ctx, runtime);
}

void entry_153ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153ab0 inside entry_153a88 (0x153a88 - 0x153b0c)
    ctx->pc = 0x153ab0;
    entry_153a88(rdram, ctx, runtime);
}

void entry_153ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153ac0 inside entry_153a88 (0x153a88 - 0x153b0c)
    ctx->pc = 0x153ac0;
    entry_153a88(rdram, ctx, runtime);
}

void entry_153af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153af4 inside entry_153a88 (0x153a88 - 0x153b0c)
    ctx->pc = 0x153af4;
    entry_153a88(rdram, ctx, runtime);
}

void entry_153afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153afc inside entry_153a88 (0x153a88 - 0x153b0c)
    ctx->pc = 0x153afc;
    entry_153a88(rdram, ctx, runtime);
}

void entry_153b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153b18 inside entry_153b0c (0x153b0c - 0x153b44)
    ctx->pc = 0x153b18;
    entry_153b0c(rdram, ctx, runtime);
}

void entry_153b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153b30 inside entry_153b0c (0x153b0c - 0x153b44)
    ctx->pc = 0x153b30;
    entry_153b0c(rdram, ctx, runtime);
}

void entry_153b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153b58 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153b58;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153b70 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153b70;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153b94 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153b94;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153bb4 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153bb4;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153c00 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153c00;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153c54 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153c54;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153c8c inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153c8c;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153c90 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153c90;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153c98 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153c98;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153cb8 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153cb8;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153cf4 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153cf4;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153d00 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153d00;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153d18 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153d18;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153d54 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153d54;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153d60 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153d60;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153d70 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153d70;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153da0 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153da0;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153db0 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153db0;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153dd0 inside entry_153b44 (0x153b44 - 0x153e08)
    ctx->pc = 0x153dd0;
    entry_153b44(rdram, ctx, runtime);
}

void entry_153e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153e58 inside entry_153e54 (0x153e54 - 0x153e60)
    ctx->pc = 0x153e58;
    entry_153e54(rdram, ctx, runtime);
}

void entry_153e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153e98 inside entry_153e94 (0x153e94 - 0x153ec0)
    ctx->pc = 0x153e98;
    entry_153e94(rdram, ctx, runtime);
}

void entry_153e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153e9c inside entry_153e94 (0x153e94 - 0x153ec0)
    ctx->pc = 0x153e9c;
    entry_153e94(rdram, ctx, runtime);
}

void entry_153ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153ea4 inside entry_153e94 (0x153e94 - 0x153ec0)
    ctx->pc = 0x153ea4;
    entry_153e94(rdram, ctx, runtime);
}

void entry_153f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153f48 inside SolveDzg__FP3DZGiiPP2XPPiPPP2SO (0x153ec0 - 0x153f80)
    ctx->pc = 0x153f48;
    SolveDzg__FP3DZGiiPP2XPPiPPP2SO(rdram, ctx, runtime);
}

void entry_153f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153f84 inside entry_153f80 (0x153f80 - 0x153f8c)
    ctx->pc = 0x153f84;
    entry_153f80(rdram, ctx, runtime);
}

void entry_153fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153fa8 inside entry_153f98 (0x153f98 - 0x153fcc)
    ctx->pc = 0x153fa8;
    entry_153f98(rdram, ctx, runtime);
}

void entry_153fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153fc0 inside entry_153f98 (0x153f98 - 0x153fcc)
    ctx->pc = 0x153fc0;
    entry_153f98(rdram, ctx, runtime);
}

void entry_153fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153fd8 inside entry_153fcc (0x153fcc - 0x154048)
    ctx->pc = 0x153fd8;
    entry_153fcc(rdram, ctx, runtime);
}

void entry_153ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x153ff0 inside entry_153fcc (0x153fcc - 0x154048)
    ctx->pc = 0x153ff0;
    entry_153fcc(rdram, ctx, runtime);
}

void entry_15400c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15400c inside entry_153fcc (0x153fcc - 0x154048)
    ctx->pc = 0x15400c;
    entry_153fcc(rdram, ctx, runtime);
}

void entry_154014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154014 inside entry_153fcc (0x153fcc - 0x154048)
    ctx->pc = 0x154014;
    entry_153fcc(rdram, ctx, runtime);
}

void entry_15404c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15404c inside entry_154048 (0x154048 - 0x154054)
    ctx->pc = 0x15404c;
    entry_154048(rdram, ctx, runtime);
}

void entry_15405c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15405c inside entry_154054 (0x154054 - 0x154088)
    ctx->pc = 0x15405c;
    entry_154054(rdram, ctx, runtime);
}

void entry_1540e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1540e8 inside SolveDzgFric__FP3DZGiiPP2XPPiPPP2SOf (0x154088 - 0x154100)
    ctx->pc = 0x1540e8;
    SolveDzgFric__FP3DZGiiPP2XPPiPPP2SOf(rdram, ctx, runtime);
}

void entry_154138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154138 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x154138;
    entry_154100(rdram, ctx, runtime);
}

void entry_1541b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1541b0 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x1541b0;
    entry_154100(rdram, ctx, runtime);
}

void entry_1541f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1541f0 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x1541f0;
    entry_154100(rdram, ctx, runtime);
}

void entry_1541f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1541f8 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x1541f8;
    entry_154100(rdram, ctx, runtime);
}

void entry_154254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154254 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x154254;
    entry_154100(rdram, ctx, runtime);
}

void entry_154258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154258 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x154258;
    entry_154100(rdram, ctx, runtime);
}

void entry_154264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154264 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x154264;
    entry_154100(rdram, ctx, runtime);
}

void entry_1542e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1542e0 inside entry_154100 (0x154100 - 0x1542ec)
    ctx->pc = 0x1542e0;
    entry_154100(rdram, ctx, runtime);
}

void entry_15431c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15431c inside entry_154318 (0x154318 - 0x154334)
    ctx->pc = 0x15431c;
    entry_154318(rdram, ctx, runtime);
}

void entry_15433c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15433c inside entry_154334 (0x154334 - 0x154370)
    ctx->pc = 0x15433c;
    entry_154334(rdram, ctx, runtime);
}

void entry_1543f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1543f0 inside entry_1543d4 (0x1543d4 - 0x154404)
    ctx->pc = 0x1543f0;
    entry_1543d4(rdram, ctx, runtime);
}

void entry_154410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154410 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x154410;
    entry_154404(rdram, ctx, runtime);
}

void entry_154430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154430 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x154430;
    entry_154404(rdram, ctx, runtime);
}

void entry_154458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154458 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x154458;
    entry_154404(rdram, ctx, runtime);
}

void entry_1544b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1544b0 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x1544b0;
    entry_154404(rdram, ctx, runtime);
}

void entry_154508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154508 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x154508;
    entry_154404(rdram, ctx, runtime);
}

void entry_154518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154518 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x154518;
    entry_154404(rdram, ctx, runtime);
}

void entry_15452c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15452c inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x15452c;
    entry_154404(rdram, ctx, runtime);
}

void entry_154540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154540 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x154540;
    entry_154404(rdram, ctx, runtime);
}

void entry_154588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154588 inside entry_154404 (0x154404 - 0x1545c8)
    ctx->pc = 0x154588;
    entry_154404(rdram, ctx, runtime);
}

void entry_1546e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1546e4 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x1546e4;
    entry_15468c(rdram, ctx, runtime);
}

void entry_1546ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1546ec inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x1546ec;
    entry_15468c(rdram, ctx, runtime);
}

void entry_154744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154744 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x154744;
    entry_15468c(rdram, ctx, runtime);
}

void entry_1547a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1547a0 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x1547a0;
    entry_15468c(rdram, ctx, runtime);
}

void entry_1547a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1547a8 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x1547a8;
    entry_15468c(rdram, ctx, runtime);
}

void entry_154804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154804 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x154804;
    entry_15468c(rdram, ctx, runtime);
}

void entry_154808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154808 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x154808;
    entry_15468c(rdram, ctx, runtime);
}

void entry_154810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154810 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x154810;
    entry_15468c(rdram, ctx, runtime);
}

void entry_154820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154820 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x154820;
    entry_15468c(rdram, ctx, runtime);
}

void entry_154834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154834 inside entry_15468c (0x15468c - 0x15483c)
    ctx->pc = 0x154834;
    entry_15468c(rdram, ctx, runtime);
}

void entry_1548f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1548f0 inside entry_1548cc (0x1548cc - 0x154900)
    ctx->pc = 0x1548f0;
    entry_1548cc(rdram, ctx, runtime);
}

void entry_154940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154940 inside entry_154934 (0x154934 - 0x15495c)
    ctx->pc = 0x154940;
    entry_154934(rdram, ctx, runtime);
}

void entry_154970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154970 inside entry_15495c (0x15495c - 0x154994)
    ctx->pc = 0x154970;
    entry_15495c(rdram, ctx, runtime);
}

void entry_15498c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15498c inside entry_15495c (0x15495c - 0x154994)
    ctx->pc = 0x15498c;
    entry_15495c(rdram, ctx, runtime);
}

void entry_154a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154a58 inside entry_154a2c (0x154a2c - 0x154aac)
    ctx->pc = 0x154a58;
    entry_154a2c(rdram, ctx, runtime);
}

void entry_154a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154a84 inside entry_154a2c (0x154a2c - 0x154aac)
    ctx->pc = 0x154a84;
    entry_154a2c(rdram, ctx, runtime);
}

void entry_154b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154b18 inside entry_154aac (0x154aac - 0x154b4c)
    ctx->pc = 0x154b18;
    entry_154aac(rdram, ctx, runtime);
}

void entry_154b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154b3c inside entry_154aac (0x154aac - 0x154b4c)
    ctx->pc = 0x154b3c;
    entry_154aac(rdram, ctx, runtime);
}

void entry_154b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154b60 inside entry_154b4c (0x154b4c - 0x154c10)
    ctx->pc = 0x154b60;
    entry_154b4c(rdram, ctx, runtime);
}

void entry_154b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154b90 inside entry_154b4c (0x154b4c - 0x154c10)
    ctx->pc = 0x154b90;
    entry_154b4c(rdram, ctx, runtime);
}

void entry_154bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154bb8 inside entry_154b4c (0x154b4c - 0x154c10)
    ctx->pc = 0x154bb8;
    entry_154b4c(rdram, ctx, runtime);
}

void entry_154ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154ce8 inside entry_154cd4 (0x154cd4 - 0x154cfc)
    ctx->pc = 0x154ce8;
    entry_154cd4(rdram, ctx, runtime);
}

void entry_154d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154d0c inside entry_154cfc (0x154cfc - 0x154d18)
    ctx->pc = 0x154d0c;
    entry_154cfc(rdram, ctx, runtime);
}

void entry_154d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154d40 inside entry_154d24 (0x154d24 - 0x154d64)
    ctx->pc = 0x154d40;
    entry_154d24(rdram, ctx, runtime);
}

void entry_154d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154d58 inside entry_154d24 (0x154d24 - 0x154d64)
    ctx->pc = 0x154d58;
    entry_154d24(rdram, ctx, runtime);
}

void entry_154dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154dd8 inside entry_154d7c (0x154d7c - 0x154e20)
    ctx->pc = 0x154dd8;
    entry_154d7c(rdram, ctx, runtime);
}

void entry_154e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154e14 inside entry_154d7c (0x154d7c - 0x154e20)
    ctx->pc = 0x154e14;
    entry_154d7c(rdram, ctx, runtime);
}

void entry_154e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154e48 inside entry_154e20 (0x154e20 - 0x154ee0)
    ctx->pc = 0x154e48;
    entry_154e20(rdram, ctx, runtime);
}

void entry_154e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154e90 inside entry_154e20 (0x154e20 - 0x154ee0)
    ctx->pc = 0x154e90;
    entry_154e20(rdram, ctx, runtime);
}

void entry_154e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154e9c inside entry_154e20 (0x154e20 - 0x154ee0)
    ctx->pc = 0x154e9c;
    entry_154e20(rdram, ctx, runtime);
}

void entry_154eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154eb4 inside entry_154e20 (0x154e20 - 0x154ee0)
    ctx->pc = 0x154eb4;
    entry_154e20(rdram, ctx, runtime);
}

void entry_154f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154f38 inside entry_154f30 (0x154f30 - 0x154f40)
    ctx->pc = 0x154f38;
    entry_154f30(rdram, ctx, runtime);
}

void entry_154f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154f6c inside entry_154f40 (0x154f40 - 0x154f98)
    ctx->pc = 0x154f6c;
    entry_154f40(rdram, ctx, runtime);
}

void entry_154f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x154f7c inside entry_154f40 (0x154f40 - 0x154f98)
    ctx->pc = 0x154f7c;
    entry_154f40(rdram, ctx, runtime);
}

void entry_15501c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15501c inside entry_155018 (0x155018 - 0x155034)
    ctx->pc = 0x15501c;
    entry_155018(rdram, ctx, runtime);
}

void entry_155164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155164 inside entry_155104 (0x155104 - 0x15516c)
    ctx->pc = 0x155164;
    entry_155104(rdram, ctx, runtime);
}

void entry_1551d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1551d0 inside entry_1551cc (0x1551cc - 0x1551e8)
    ctx->pc = 0x1551d0;
    entry_1551cc(rdram, ctx, runtime);
}

void entry_1551ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1551ec inside entry_1551e8 (0x1551e8 - 0x155204)
    ctx->pc = 0x1551ec;
    entry_1551e8(rdram, ctx, runtime);
}

void entry_15521c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15521c inside entry_155214 (0x155214 - 0x155238)
    ctx->pc = 0x15521c;
    entry_155214(rdram, ctx, runtime);
}

void entry_155248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155248 inside entry_155238 (0x155238 - 0x155254)
    ctx->pc = 0x155248;
    entry_155238(rdram, ctx, runtime);
}

void entry_15524c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15524c inside entry_155238 (0x155238 - 0x155254)
    ctx->pc = 0x15524c;
    entry_155238(rdram, ctx, runtime);
}

void entry_1552a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1552a0 inside entry_155288 (0x155288 - 0x155344)
    ctx->pc = 0x1552a0;
    entry_155288(rdram, ctx, runtime);
}

void entry_1552d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1552d0 inside entry_155288 (0x155288 - 0x155344)
    ctx->pc = 0x1552d0;
    entry_155288(rdram, ctx, runtime);
}

void entry_1552d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1552d8 inside entry_155288 (0x155288 - 0x155344)
    ctx->pc = 0x1552d8;
    entry_155288(rdram, ctx, runtime);
}

void entry_1552f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1552f4 inside entry_155288 (0x155288 - 0x155344)
    ctx->pc = 0x1552f4;
    entry_155288(rdram, ctx, runtime);
}

void entry_1552f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1552f8 inside entry_155288 (0x155288 - 0x155344)
    ctx->pc = 0x1552f8;
    entry_155288(rdram, ctx, runtime);
}

void entry_15531c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15531c inside entry_155288 (0x155288 - 0x155344)
    ctx->pc = 0x15531c;
    entry_155288(rdram, ctx, runtime);
}

void entry_15532c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15532c inside entry_155288 (0x155288 - 0x155344)
    ctx->pc = 0x15532c;
    entry_155288(rdram, ctx, runtime);
}

void entry_155358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155358 inside entry_155344 (0x155344 - 0x15536c)
    ctx->pc = 0x155358;
    entry_155344(rdram, ctx, runtime);
}

void entry_155384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155384 inside entry_15536c (0x15536c - 0x15538c)
    ctx->pc = 0x155384;
    entry_15536c(rdram, ctx, runtime);
}

void entry_155394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155394 inside entry_15538c (0x15538c - 0x1553a8)
    ctx->pc = 0x155394;
    entry_15538c(rdram, ctx, runtime);
}

void entry_1553d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1553d8 inside entry_1553d0 (0x1553d0 - 0x1553f0)
    ctx->pc = 0x1553d8;
    entry_1553d0(rdram, ctx, runtime);
}

void entry_1553f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1553f4 inside entry_1553f0 (0x1553f0 - 0x15551c)
    ctx->pc = 0x1553f4;
    entry_1553f0(rdram, ctx, runtime);
}

void entry_155468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155468 inside entry_1553f0 (0x1553f0 - 0x15551c)
    ctx->pc = 0x155468;
    entry_1553f0(rdram, ctx, runtime);
}

void entry_15546c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15546c inside entry_1553f0 (0x1553f0 - 0x15551c)
    ctx->pc = 0x15546c;
    entry_1553f0(rdram, ctx, runtime);
}

void entry_15547c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15547c inside entry_1553f0 (0x1553f0 - 0x15551c)
    ctx->pc = 0x15547c;
    entry_1553f0(rdram, ctx, runtime);
}

void entry_1554d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1554d4 inside entry_1553f0 (0x1553f0 - 0x15551c)
    ctx->pc = 0x1554d4;
    entry_1553f0(rdram, ctx, runtime);
}

void entry_1554f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1554f4 inside entry_1553f0 (0x1553f0 - 0x15551c)
    ctx->pc = 0x1554f4;
    entry_1553f0(rdram, ctx, runtime);
}

void entry_155504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155504 inside entry_1553f0 (0x1553f0 - 0x15551c)
    ctx->pc = 0x155504;
    entry_1553f0(rdram, ctx, runtime);
}

void entry_155558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155558 inside entry_15554c (0x15554c - 0x15564c)
    ctx->pc = 0x155558;
    entry_15554c(rdram, ctx, runtime);
}

void entry_155650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155650 inside entry_15564c (0x15564c - 0x15565c)
    ctx->pc = 0x155650;
    entry_15564c(rdram, ctx, runtime);
}

void entry_155668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155668 inside entry_155664 (0x155664 - 0x155678)
    ctx->pc = 0x155668;
    entry_155664(rdram, ctx, runtime);
}

void entry_1556b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1556b8 inside entry_1556b0 (0x1556b0 - 0x1556d0)
    ctx->pc = 0x1556b8;
    entry_1556b0(rdram, ctx, runtime);
}

void entry_1556d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1556d4 inside entry_1556d0 (0x1556d0 - 0x1556e8)
    ctx->pc = 0x1556d4;
    entry_1556d0(rdram, ctx, runtime);
}

void entry_1556d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1556d8 inside entry_1556d0 (0x1556d0 - 0x1556e8)
    ctx->pc = 0x1556d8;
    entry_1556d0(rdram, ctx, runtime);
}

void entry_155748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155748 inside entry_155744 (0x155744 - 0x155778)
    ctx->pc = 0x155748;
    entry_155744(rdram, ctx, runtime);
}

void entry_15574c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15574c inside entry_155744 (0x155744 - 0x155778)
    ctx->pc = 0x15574c;
    entry_155744(rdram, ctx, runtime);
}

void entry_155760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155760 inside entry_155744 (0x155744 - 0x155778)
    ctx->pc = 0x155760;
    entry_155744(rdram, ctx, runtime);
}

void entry_1557a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1557a0 inside entry_15579c (0x15579c - 0x1557b8)
    ctx->pc = 0x1557a0;
    entry_15579c(rdram, ctx, runtime);
}

void entry_1557c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1557c4 inside PemitterEnsureEmitter__FP7EMITTER4ENSK (0x1557b8 - 0x1557d0)
    ctx->pc = 0x1557c4;
    PemitterEnsureEmitter__FP7EMITTER4ENSK(rdram, ctx, runtime);
}

void entry_1558e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1558e8 inside ModifyEmitterParticles__FP7EMITTER (0x155868 - 0x1559a0)
    ctx->pc = 0x1558e8;
    ModifyEmitterParticles__FP7EMITTER(rdram, ctx, runtime);
}

void entry_155908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155908 inside ModifyEmitterParticles__FP7EMITTER (0x155868 - 0x1559a0)
    ctx->pc = 0x155908;
    ModifyEmitterParticles__FP7EMITTER(rdram, ctx, runtime);
}

void entry_155950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155950 inside ModifyEmitterParticles__FP7EMITTER (0x155868 - 0x1559a0)
    ctx->pc = 0x155950;
    ModifyEmitterParticles__FP7EMITTER(rdram, ctx, runtime);
}

void entry_155968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155968 inside ModifyEmitterParticles__FP7EMITTER (0x155868 - 0x1559a0)
    ctx->pc = 0x155968;
    ModifyEmitterParticles__FP7EMITTER(rdram, ctx, runtime);
}

void entry_155998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155998 inside ModifyEmitterParticles__FP7EMITTER (0x155868 - 0x1559a0)
    ctx->pc = 0x155998;
    ModifyEmitterParticles__FP7EMITTER(rdram, ctx, runtime);
}

void entry_1559c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1559c4 inside entry_1559a0 (0x1559a0 - 0x1559f8)
    ctx->pc = 0x1559c4;
    entry_1559a0(rdram, ctx, runtime);
}

void entry_1559f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1559f0 inside entry_1559a0 (0x1559a0 - 0x1559f8)
    ctx->pc = 0x1559f0;
    entry_1559a0(rdram, ctx, runtime);
}

void entry_155a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155a1c inside entry_1559f8 (0x1559f8 - 0x155a50)
    ctx->pc = 0x155a1c;
    entry_1559f8(rdram, ctx, runtime);
}

void entry_155a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155a48 inside entry_1559f8 (0x1559f8 - 0x155a50)
    ctx->pc = 0x155a48;
    entry_1559f8(rdram, ctx, runtime);
}

void entry_155a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155a74 inside entry_155a50 (0x155a50 - 0x155ab0)
    ctx->pc = 0x155a74;
    entry_155a50(rdram, ctx, runtime);
}

void entry_155a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155a84 inside entry_155a50 (0x155a50 - 0x155ab0)
    ctx->pc = 0x155a84;
    entry_155a50(rdram, ctx, runtime);
}

void entry_155a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155a94 inside entry_155a50 (0x155a50 - 0x155ab0)
    ctx->pc = 0x155a94;
    entry_155a50(rdram, ctx, runtime);
}

void entry_155a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155a98 inside entry_155a50 (0x155a50 - 0x155ab0)
    ctx->pc = 0x155a98;
    entry_155a50(rdram, ctx, runtime);
}

void entry_155b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155b28 inside entry_155b08 (0x155b08 - 0x155b3c)
    ctx->pc = 0x155b28;
    entry_155b08(rdram, ctx, runtime);
}

void entry_155b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155b98 inside entry_155b3c (0x155b3c - 0x155c18)
    ctx->pc = 0x155b98;
    entry_155b3c(rdram, ctx, runtime);
}

void entry_155ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155ba4 inside entry_155b3c (0x155b3c - 0x155c18)
    ctx->pc = 0x155ba4;
    entry_155b3c(rdram, ctx, runtime);
}

void entry_155bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155bb4 inside entry_155b3c (0x155b3c - 0x155c18)
    ctx->pc = 0x155bb4;
    entry_155b3c(rdram, ctx, runtime);
}

void entry_155c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155c08 inside entry_155b3c (0x155b3c - 0x155c18)
    ctx->pc = 0x155c08;
    entry_155b3c(rdram, ctx, runtime);
}

void entry_155c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155c10 inside entry_155b3c (0x155b3c - 0x155c18)
    ctx->pc = 0x155c10;
    entry_155b3c(rdram, ctx, runtime);
}

void entry_155c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155c4c inside entry_155c18 (0x155c18 - 0x155ccc)
    ctx->pc = 0x155c4c;
    entry_155c18(rdram, ctx, runtime);
}

void entry_155cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155cb8 inside entry_155c18 (0x155c18 - 0x155ccc)
    ctx->pc = 0x155cb8;
    entry_155c18(rdram, ctx, runtime);
}

void entry_155cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155cd4 inside entry_155ccc (0x155ccc - 0x155ce0)
    ctx->pc = 0x155cd4;
    entry_155ccc(rdram, ctx, runtime);
}

void entry_155d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155d0c inside entry_155d08 (0x155d08 - 0x155d14)
    ctx->pc = 0x155d0c;
    entry_155d08(rdram, ctx, runtime);
}

void entry_155d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155d28 inside entry_155d14 (0x155d14 - 0x155d60)
    ctx->pc = 0x155d28;
    entry_155d14(rdram, ctx, runtime);
}

void entry_155d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155d4c inside entry_155d14 (0x155d14 - 0x155d60)
    ctx->pc = 0x155d4c;
    entry_155d14(rdram, ctx, runtime);
}

void entry_155d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155d68 inside entry_155d60 (0x155d60 - 0x155d7c)
    ctx->pc = 0x155d68;
    entry_155d60(rdram, ctx, runtime);
}

void entry_155dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155dac inside entry_155da8 (0x155da8 - 0x155db4)
    ctx->pc = 0x155dac;
    entry_155da8(rdram, ctx, runtime);
}

void entry_155dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155dbc inside entry_155db4 (0x155db4 - 0x155e50)
    ctx->pc = 0x155dbc;
    entry_155db4(rdram, ctx, runtime);
}

void entry_155e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155e08 inside entry_155db4 (0x155db4 - 0x155e50)
    ctx->pc = 0x155e08;
    entry_155db4(rdram, ctx, runtime);
}

void entry_155e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155e40 inside entry_155db4 (0x155db4 - 0x155e50)
    ctx->pc = 0x155e40;
    entry_155db4(rdram, ctx, runtime);
}

void entry_155e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155e58 inside entry_155e50 (0x155e50 - 0x155e7c)
    ctx->pc = 0x155e58;
    entry_155e50(rdram, ctx, runtime);
}

void entry_155e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155e5c inside entry_155e50 (0x155e50 - 0x155e7c)
    ctx->pc = 0x155e5c;
    entry_155e50(rdram, ctx, runtime);
}

void entry_155e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155e68 inside entry_155e50 (0x155e50 - 0x155e7c)
    ctx->pc = 0x155e68;
    entry_155e50(rdram, ctx, runtime);
}

void entry_155ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155ea8 inside entry_155e7c (0x155e7c - 0x155eb8)
    ctx->pc = 0x155ea8;
    entry_155e7c(rdram, ctx, runtime);
}

void entry_155ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155ec0 inside entry_155eb8 (0x155eb8 - 0x155ee8)
    ctx->pc = 0x155ec0;
    entry_155eb8(rdram, ctx, runtime);
}

void entry_155efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155efc inside entry_155ee8 (0x155ee8 - 0x155f04)
    ctx->pc = 0x155efc;
    entry_155ee8(rdram, ctx, runtime);
}

void entry_155f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155f08 inside entry_155f04 (0x155f04 - 0x155f28)
    ctx->pc = 0x155f08;
    entry_155f04(rdram, ctx, runtime);
}

void entry_155f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155f48 inside FUN_00155f28 (0x155f28 - 0x155f78)
    ctx->pc = 0x155f48;
    FUN_00155f28(rdram, ctx, runtime);
}

void entry_155f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155f70 inside FUN_00155f28 (0x155f28 - 0x155f78)
    ctx->pc = 0x155f70;
    FUN_00155f28(rdram, ctx, runtime);
}

void entry_155fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155fd4 inside FPausedEmitter__FP7EMITTER (0x155fb0 - 0x156000)
    ctx->pc = 0x155fd4;
    FPausedEmitter__FP7EMITTER(rdram, ctx, runtime);
}

void entry_155ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x155ff8 inside FPausedEmitter__FP7EMITTER (0x155fb0 - 0x156000)
    ctx->pc = 0x155ff8;
    FPausedEmitter__FP7EMITTER(rdram, ctx, runtime);
}

void entry_15601c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15601c inside entry_156014 (0x156014 - 0x156024)
    ctx->pc = 0x15601c;
    entry_156014(rdram, ctx, runtime);
}

void entry_156028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156028 inside entry_156024 (0x156024 - 0x156030)
    ctx->pc = 0x156028;
    entry_156024(rdram, ctx, runtime);
}

void entry_1560b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1560b4 inside entry_1560b0 (0x1560b0 - 0x1560c4)
    ctx->pc = 0x1560b4;
    entry_1560b0(rdram, ctx, runtime);
}

void entry_1560c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1560c8 inside entry_1560c4 (0x1560c4 - 0x1560dc)
    ctx->pc = 0x1560c8;
    entry_1560c4(rdram, ctx, runtime);
}

void entry_1560ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1560ec inside entry_1560dc (0x1560dc - 0x1560f4)
    ctx->pc = 0x1560ec;
    entry_1560dc(rdram, ctx, runtime);
}

void entry_156148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156148 inside entry_156140 (0x156140 - 0x156158)
    ctx->pc = 0x156148;
    entry_156140(rdram, ctx, runtime);
}

void entry_156160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156160 inside entry_156158 (0x156158 - 0x156178)
    ctx->pc = 0x156160;
    entry_156158(rdram, ctx, runtime);
}

void entry_156164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156164 inside entry_156158 (0x156158 - 0x156178)
    ctx->pc = 0x156164;
    entry_156158(rdram, ctx, runtime);
}

void entry_1561e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1561e0 inside entry_1561b4 (0x1561b4 - 0x156218)
    ctx->pc = 0x1561e0;
    entry_1561b4(rdram, ctx, runtime);
}

void entry_156204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156204 inside entry_1561b4 (0x1561b4 - 0x156218)
    ctx->pc = 0x156204;
    entry_1561b4(rdram, ctx, runtime);
}

void entry_15633c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15633c inside entry_15632c (0x15632c - 0x156400)
    ctx->pc = 0x15633c;
    entry_15632c(rdram, ctx, runtime);
}

void entry_156368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156368 inside entry_15632c (0x15632c - 0x156400)
    ctx->pc = 0x156368;
    entry_15632c(rdram, ctx, runtime);
}

void entry_1563a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1563a8 inside entry_15632c (0x15632c - 0x156400)
    ctx->pc = 0x1563a8;
    entry_15632c(rdram, ctx, runtime);
}

void entry_1563ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1563ec inside entry_15632c (0x15632c - 0x156400)
    ctx->pc = 0x1563ec;
    entry_15632c(rdram, ctx, runtime);
}

void entry_156488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156488 inside entry_156440 (0x156440 - 0x1564c4)
    ctx->pc = 0x156488;
    entry_156440(rdram, ctx, runtime);
}

void entry_1564b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1564b4 inside entry_156440 (0x156440 - 0x1564c4)
    ctx->pc = 0x1564b4;
    entry_156440(rdram, ctx, runtime);
}

void entry_1564bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1564bc inside entry_156440 (0x156440 - 0x1564c4)
    ctx->pc = 0x1564bc;
    entry_156440(rdram, ctx, runtime);
}

void entry_1564f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1564f4 inside entry_1564e4 (0x1564e4 - 0x15652c)
    ctx->pc = 0x1564f4;
    entry_1564e4(rdram, ctx, runtime);
}

void entry_156604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156604 inside entry_156574 (0x156574 - 0x15664c)
    ctx->pc = 0x156604;
    entry_156574(rdram, ctx, runtime);
}

void entry_156674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156674 inside entry_15666c (0x15666c - 0x156688)
    ctx->pc = 0x156674;
    entry_15666c(rdram, ctx, runtime);
}

void entry_15668c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15668c inside entry_156688 (0x156688 - 0x1566c8)
    ctx->pc = 0x15668c;
    entry_156688(rdram, ctx, runtime);
}

void entry_156844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156844 inside entry_15683c (0x15683c - 0x15686c)
    ctx->pc = 0x156844;
    entry_15683c(rdram, ctx, runtime);
}

void entry_156874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156874 inside entry_15686c (0x15686c - 0x156890)
    ctx->pc = 0x156874;
    entry_15686c(rdram, ctx, runtime);
}

void entry_156938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156938 inside entry_1568ec (0x1568ec - 0x1569e4)
    ctx->pc = 0x156938;
    entry_1568ec(rdram, ctx, runtime);
}

void entry_156964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156964 inside entry_1568ec (0x1568ec - 0x1569e4)
    ctx->pc = 0x156964;
    entry_1568ec(rdram, ctx, runtime);
}

void entry_156968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156968 inside entry_1568ec (0x1568ec - 0x1569e4)
    ctx->pc = 0x156968;
    entry_1568ec(rdram, ctx, runtime);
}

void entry_1569c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1569c4 inside entry_1568ec (0x1568ec - 0x1569e4)
    ctx->pc = 0x1569c4;
    entry_1568ec(rdram, ctx, runtime);
}

void entry_1569d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1569d0 inside entry_1568ec (0x1568ec - 0x1569e4)
    ctx->pc = 0x1569d0;
    entry_1568ec(rdram, ctx, runtime);
}

void entry_156a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156a2c inside entry_156a24 (0x156a24 - 0x156a5c)
    ctx->pc = 0x156a2c;
    entry_156a24(rdram, ctx, runtime);
}

void entry_156a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156a38 inside entry_156a24 (0x156a24 - 0x156a5c)
    ctx->pc = 0x156a38;
    entry_156a24(rdram, ctx, runtime);
}

void entry_156aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156aec inside entry_156acc (0x156acc - 0x156b80)
    ctx->pc = 0x156aec;
    entry_156acc(rdram, ctx, runtime);
}

void entry_156afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156afc inside entry_156acc (0x156acc - 0x156b80)
    ctx->pc = 0x156afc;
    entry_156acc(rdram, ctx, runtime);
}

void entry_156b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156b5c inside entry_156acc (0x156acc - 0x156b80)
    ctx->pc = 0x156b5c;
    entry_156acc(rdram, ctx, runtime);
}

void entry_156b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156b68 inside entry_156acc (0x156acc - 0x156b80)
    ctx->pc = 0x156b68;
    entry_156acc(rdram, ctx, runtime);
}

void entry_156b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156b78 inside entry_156acc (0x156acc - 0x156b80)
    ctx->pc = 0x156b78;
    entry_156acc(rdram, ctx, runtime);
}

void entry_156be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156be8 inside entry_156ba8 (0x156ba8 - 0x156c6c)
    ctx->pc = 0x156be8;
    entry_156ba8(rdram, ctx, runtime);
}

void entry_156c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156c14 inside entry_156ba8 (0x156ba8 - 0x156c6c)
    ctx->pc = 0x156c14;
    entry_156ba8(rdram, ctx, runtime);
}

void entry_156c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156c18 inside entry_156ba8 (0x156ba8 - 0x156c6c)
    ctx->pc = 0x156c18;
    entry_156ba8(rdram, ctx, runtime);
}

void entry_156d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156d28 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156d28;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156d2c inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156d2c;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156d30 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156d30;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156d50 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156d50;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156d60 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156d60;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156d6c inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156d6c;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156d84 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156d84;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156df8 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156df8;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156e28 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156e28;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156e2c inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156e2c;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156e30 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156e30;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156e34 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156e34;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156e80 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156e80;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156e90 inside entry_156c80 (0x156c80 - 0x156eac)
    ctx->pc = 0x156e90;
    entry_156c80(rdram, ctx, runtime);
}

void entry_156f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156f80 inside entry_156f60 (0x156f60 - 0x156fa0)
    ctx->pc = 0x156f80;
    entry_156f60(rdram, ctx, runtime);
}

void entry_156fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156fb0 inside entry_156fa0 (0x156fa0 - 0x156fc8)
    ctx->pc = 0x156fb0;
    entry_156fa0(rdram, ctx, runtime);
}

void entry_156ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156ff8 inside CalculateEmitvx__FiP2LMiP6EMITVX (0x156fc8 - 0x157028)
    ctx->pc = 0x156ff8;
    CalculateEmitvx__FiP2LMiP6EMITVX(rdram, ctx, runtime);
}

void entry_156ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x156ffc inside CalculateEmitvx__FiP2LMiP6EMITVX (0x156fc8 - 0x157028)
    ctx->pc = 0x156ffc;
    CalculateEmitvx__FiP2LMiP6EMITVX(rdram, ctx, runtime);
}

void entry_157010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157010 inside CalculateEmitvx__FiP2LMiP6EMITVX (0x156fc8 - 0x157028)
    ctx->pc = 0x157010;
    CalculateEmitvx__FiP2LMiP6EMITVX(rdram, ctx, runtime);
}

void entry_1570f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1570f8 inside ChooseEmitVelocity__FP6EMITVXffP2LMP6VECTORiT4 (0x157098 - 0x157150)
    ctx->pc = 0x1570f8;
    ChooseEmitVelocity__FP6EMITVXffP2LMP6VECTORiT4(rdram, ctx, runtime);
}

void entry_15717c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15717c inside entry_15716c (0x15716c - 0x157190)
    ctx->pc = 0x15717c;
    entry_15716c(rdram, ctx, runtime);
}

void entry_157304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157304 inside entry_1572c8 (0x1572c8 - 0x157320)
    ctx->pc = 0x157304;
    entry_1572c8(rdram, ctx, runtime);
}

void entry_157384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157384 inside EmitRips__FP5EMITBP5EMITGiP6VECTORT3PfT5 (0x157320 - 0x15739c)
    ctx->pc = 0x157384;
    EmitRips__FP5EMITBP5EMITGiP6VECTORT3PfT5(rdram, ctx, runtime);
}

void entry_1573c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1573c0 inside entry_15739c (0x15739c - 0x1573c8)
    ctx->pc = 0x1573c0;
    entry_15739c(rdram, ctx, runtime);
}

void entry_1573f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1573f8 inside entry_1573ec (0x1573ec - 0x15741c)
    ctx->pc = 0x1573f8;
    entry_1573ec(rdram, ctx, runtime);
}

void entry_157404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157404 inside entry_1573ec (0x1573ec - 0x15741c)
    ctx->pc = 0x157404;
    entry_1573ec(rdram, ctx, runtime);
}

void entry_157464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157464 inside entry_157434 (0x157434 - 0x1574bc)
    ctx->pc = 0x157464;
    entry_157434(rdram, ctx, runtime);
}

void entry_157470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157470 inside entry_157434 (0x157434 - 0x1574bc)
    ctx->pc = 0x157470;
    entry_157434(rdram, ctx, runtime);
}

void entry_1574c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1574c8 inside entry_1574bc (0x1574bc - 0x157500)
    ctx->pc = 0x1574c8;
    entry_1574bc(rdram, ctx, runtime);
}

void entry_1574ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1574ec inside entry_1574bc (0x1574bc - 0x157500)
    ctx->pc = 0x1574ec;
    entry_1574bc(rdram, ctx, runtime);
}

void entry_157544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157544 inside entry_157540 (0x157540 - 0x157558)
    ctx->pc = 0x157544;
    entry_157540(rdram, ctx, runtime);
}

void entry_15755c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15755c inside entry_157558 (0x157558 - 0x157578)
    ctx->pc = 0x15755c;
    entry_157558(rdram, ctx, runtime);
}

void entry_157584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157584 inside entry_157578 (0x157578 - 0x15758c)
    ctx->pc = 0x157584;
    entry_157578(rdram, ctx, runtime);
}

void entry_1575a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1575a8 inside entry_1575a4 (0x1575a4 - 0x1575d8)
    ctx->pc = 0x1575a8;
    entry_1575a4(rdram, ctx, runtime);
}

void entry_157638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157638 inside EmitBlips__FP5EMITBP5EMITGiP6VECTORT3PfT5T3T3 (0x1575d8 - 0x157674)
    ctx->pc = 0x157638;
    EmitBlips__FP5EMITBP5EMITGiP6VECTORT3PfT5T3T3(rdram, ctx, runtime);
}

void entry_15766c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15766c inside EmitBlips__FP5EMITBP5EMITGiP6VECTORT3PfT5T3T3 (0x1575d8 - 0x157674)
    ctx->pc = 0x15766c;
    EmitBlips__FP5EMITBP5EMITGiP6VECTORT3PfT5T3T3(rdram, ctx, runtime);
}

void entry_157698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157698 inside entry_157674 (0x157674 - 0x1576a0)
    ctx->pc = 0x157698;
    entry_157674(rdram, ctx, runtime);
}

void entry_1576d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1576d0 inside entry_1576c4 (0x1576c4 - 0x15778c)
    ctx->pc = 0x1576d0;
    entry_1576c4(rdram, ctx, runtime);
}

void entry_1576d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1576d8 inside entry_1576c4 (0x1576c4 - 0x15778c)
    ctx->pc = 0x1576d8;
    entry_1576c4(rdram, ctx, runtime);
}

void entry_157758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157758 inside entry_1576c4 (0x1576c4 - 0x15778c)
    ctx->pc = 0x157758;
    entry_1576c4(rdram, ctx, runtime);
}

void entry_1577c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1577c4 inside entry_15779c (0x15779c - 0x1577d8)
    ctx->pc = 0x1577c4;
    entry_15779c(rdram, ctx, runtime);
}

void entry_1577dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1577dc inside entry_1577d8 (0x1577d8 - 0x1577fc)
    ctx->pc = 0x1577dc;
    entry_1577d8(rdram, ctx, runtime);
}

void entry_157858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157858 inside entry_1577fc (0x1577fc - 0x157880)
    ctx->pc = 0x157858;
    entry_1577fc(rdram, ctx, runtime);
}

void entry_157888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157888 inside entry_157880 (0x157880 - 0x157970)
    ctx->pc = 0x157888;
    entry_157880(rdram, ctx, runtime);
}

void entry_15788c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15788c inside entry_157880 (0x157880 - 0x157970)
    ctx->pc = 0x15788c;
    entry_157880(rdram, ctx, runtime);
}

void entry_1578b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1578b8 inside entry_157880 (0x157880 - 0x157970)
    ctx->pc = 0x1578b8;
    entry_157880(rdram, ctx, runtime);
}

void entry_157948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157948 inside entry_157880 (0x157880 - 0x157970)
    ctx->pc = 0x157948;
    entry_157880(rdram, ctx, runtime);
}

void entry_15794c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15794c inside entry_157880 (0x157880 - 0x157970)
    ctx->pc = 0x15794c;
    entry_157880(rdram, ctx, runtime);
}

void entry_15797c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15797c inside entry_157970 (0x157970 - 0x1579b0)
    ctx->pc = 0x15797c;
    entry_157970(rdram, ctx, runtime);
}

void entry_157980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157980 inside entry_157970 (0x157970 - 0x1579b0)
    ctx->pc = 0x157980;
    entry_157970(rdram, ctx, runtime);
}

void entry_157a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157a40 inside entry_157a30 (0x157a30 - 0x157a5c)
    ctx->pc = 0x157a40;
    entry_157a30(rdram, ctx, runtime);
}

void entry_157b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157b30 inside entry_157a9c (0x157a9c - 0x157b50)
    ctx->pc = 0x157b30;
    entry_157a9c(rdram, ctx, runtime);
}

void entry_157b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157b60 inside entry_157b50 (0x157b50 - 0x157b88)
    ctx->pc = 0x157b60;
    entry_157b50(rdram, ctx, runtime);
}

void entry_157c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157c00 inside entry_157bdc (0x157bdc - 0x157c24)
    ctx->pc = 0x157c00;
    entry_157bdc(rdram, ctx, runtime);
}

void entry_157c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157c30 inside entry_157c24 (0x157c24 - 0x157c44)
    ctx->pc = 0x157c30;
    entry_157c24(rdram, ctx, runtime);
}

void entry_157c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157c70 inside entry_157c44 (0x157c44 - 0x157cac)
    ctx->pc = 0x157c70;
    entry_157c44(rdram, ctx, runtime);
}

void entry_157ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157ce0 inside entry_157cdc (0x157cdc - 0x157e00)
    ctx->pc = 0x157ce0;
    entry_157cdc(rdram, ctx, runtime);
}

void entry_157d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157d78 inside entry_157cdc (0x157cdc - 0x157e00)
    ctx->pc = 0x157d78;
    entry_157cdc(rdram, ctx, runtime);
}

void entry_157d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157d90 inside entry_157cdc (0x157cdc - 0x157e00)
    ctx->pc = 0x157d90;
    entry_157cdc(rdram, ctx, runtime);
}

void entry_157dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157dbc inside entry_157cdc (0x157cdc - 0x157e00)
    ctx->pc = 0x157dbc;
    entry_157cdc(rdram, ctx, runtime);
}

void entry_157e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157e78 inside entry_157e70 (0x157e70 - 0x157e98)
    ctx->pc = 0x157e78;
    entry_157e70(rdram, ctx, runtime);
}

void entry_157ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157ea0 inside entry_157e98 (0x157e98 - 0x157ed0)
    ctx->pc = 0x157ea0;
    entry_157e98(rdram, ctx, runtime);
}

void entry_157ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157ea8 inside entry_157e98 (0x157e98 - 0x157ed0)
    ctx->pc = 0x157ea8;
    entry_157e98(rdram, ctx, runtime);
}

void entry_157f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x157f68 inside entry_157f50 (0x157f50 - 0x157fc4)
    ctx->pc = 0x157f68;
    entry_157f50(rdram, ctx, runtime);
}

void entry_158068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158068 inside StockSplashBig__FP6VECTORfP2SO (0x157ff8 - 0x1580c4)
    ctx->pc = 0x158068;
    StockSplashBig__FP6VECTORfP2SO(rdram, ctx, runtime);
}

void entry_1580a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1580a8 inside StockSplashBig__FP6VECTORfP2SO (0x157ff8 - 0x1580c4)
    ctx->pc = 0x1580a8;
    StockSplashBig__FP6VECTORfP2SO(rdram, ctx, runtime);
}

void entry_1580ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1580ac inside StockSplashBig__FP6VECTORfP2SO (0x157ff8 - 0x1580c4)
    ctx->pc = 0x1580ac;
    StockSplashBig__FP6VECTORfP2SO(rdram, ctx, runtime);
}

void entry_1580b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1580b0 inside StockSplashBig__FP6VECTORfP2SO (0x157ff8 - 0x1580c4)
    ctx->pc = 0x1580b0;
    StockSplashBig__FP6VECTORfP2SO(rdram, ctx, runtime);
}

void entry_1580d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1580d4 inside entry_1580c4 (0x1580c4 - 0x158108)
    ctx->pc = 0x1580d4;
    entry_1580c4(rdram, ctx, runtime);
}

void entry_15817c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15817c inside entry_15815c (0x15815c - 0x158198)
    ctx->pc = 0x15817c;
    entry_15815c(rdram, ctx, runtime);
}

void entry_158180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158180 inside entry_15815c (0x15815c - 0x158198)
    ctx->pc = 0x158180;
    entry_15815c(rdram, ctx, runtime);
}

void entry_1581f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1581f4 inside entry_1581f0 (0x1581f0 - 0x158288)
    ctx->pc = 0x1581f4;
    entry_1581f0(rdram, ctx, runtime);
}

void entry_158238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158238 inside entry_1581f0 (0x1581f0 - 0x158288)
    ctx->pc = 0x158238;
    entry_1581f0(rdram, ctx, runtime);
}

void entry_158240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158240 inside entry_1581f0 (0x1581f0 - 0x158288)
    ctx->pc = 0x158240;
    entry_1581f0(rdram, ctx, runtime);
}

void entry_158258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158258 inside entry_1581f0 (0x1581f0 - 0x158288)
    ctx->pc = 0x158258;
    entry_1581f0(rdram, ctx, runtime);
}

void entry_15825c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15825c inside entry_1581f0 (0x1581f0 - 0x158288)
    ctx->pc = 0x15825c;
    entry_1581f0(rdram, ctx, runtime);
}

void entry_1582e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1582e4 inside entry_1582e0 (0x1582e0 - 0x158340)
    ctx->pc = 0x1582e4;
    entry_1582e0(rdram, ctx, runtime);
}

void entry_158310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158310 inside entry_1582e0 (0x1582e0 - 0x158340)
    ctx->pc = 0x158310;
    entry_1582e0(rdram, ctx, runtime);
}

void entry_158328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158328 inside entry_1582e0 (0x1582e0 - 0x158340)
    ctx->pc = 0x158328;
    entry_1582e0(rdram, ctx, runtime);
}

void entry_1583b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1583b4 inside entry_158340 (0x158340 - 0x1583e8)
    ctx->pc = 0x1583b4;
    entry_158340(rdram, ctx, runtime);
}

void entry_1583bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1583bc inside entry_158340 (0x158340 - 0x1583e8)
    ctx->pc = 0x1583bc;
    entry_158340(rdram, ctx, runtime);
}

void entry_158458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158458 inside SetEmitdvEmitb__FP6EMITDVP5EMITB (0x1583e8 - 0x158480)
    ctx->pc = 0x158458;
    SetEmitdvEmitb__FP6EMITDVP5EMITB(rdram, ctx, runtime);
}

void entry_158464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158464 inside SetEmitdvEmitb__FP6EMITDVP5EMITB (0x1583e8 - 0x158480)
    ctx->pc = 0x158464;
    SetEmitdvEmitb__FP6EMITDVP5EMITB(rdram, ctx, runtime);
}

void entry_158550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158550 inside entry_158548 (0x158548 - 0x158574)
    ctx->pc = 0x158550;
    entry_158548(rdram, ctx, runtime);
}

void entry_158554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158554 inside entry_158548 (0x158548 - 0x158574)
    ctx->pc = 0x158554;
    entry_158548(rdram, ctx, runtime);
}

void entry_15855c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15855c inside entry_158548 (0x158548 - 0x158574)
    ctx->pc = 0x15855c;
    entry_158548(rdram, ctx, runtime);
}

void entry_158668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158668 inside CalculateExplTransform__FP4EXPLP6VECTORP7MATRIX3 (0x158630 - 0x158730)
    ctx->pc = 0x158668;
    CalculateExplTransform__FP4EXPLP6VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_158718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158718 inside CalculateExplTransform__FP4EXPLP6VECTORP7MATRIX3 (0x158630 - 0x158730)
    ctx->pc = 0x158718;
    CalculateExplTransform__FP4EXPLP6VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_158818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158818 inside entry_158808 (0x158808 - 0x158820)
    ctx->pc = 0x158818;
    entry_158808(rdram, ctx, runtime);
}

void entry_158890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158890 inside entry_158868 (0x158868 - 0x1588e8)
    ctx->pc = 0x158890;
    entry_158868(rdram, ctx, runtime);
}

void entry_1588ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1588ac inside entry_158868 (0x158868 - 0x1588e8)
    ctx->pc = 0x1588ac;
    entry_158868(rdram, ctx, runtime);
}

void entry_1588bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1588bc inside entry_158868 (0x158868 - 0x1588e8)
    ctx->pc = 0x1588bc;
    entry_158868(rdram, ctx, runtime);
}

void entry_1588c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1588c4 inside entry_158868 (0x158868 - 0x1588e8)
    ctx->pc = 0x1588c4;
    entry_158868(rdram, ctx, runtime);
}

void entry_1588d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1588d8 inside entry_158868 (0x158868 - 0x1588e8)
    ctx->pc = 0x1588d8;
    entry_158868(rdram, ctx, runtime);
}

void entry_158908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158908 inside entry_1588fc (0x1588fc - 0x158914)
    ctx->pc = 0x158908;
    entry_1588fc(rdram, ctx, runtime);
}

void entry_158938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158938 inside entry_158914 (0x158914 - 0x158980)
    ctx->pc = 0x158938;
    entry_158914(rdram, ctx, runtime);
}

void entry_15893c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15893c inside entry_158914 (0x158914 - 0x158980)
    ctx->pc = 0x15893c;
    entry_158914(rdram, ctx, runtime);
}

void entry_158944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158944 inside entry_158914 (0x158914 - 0x158980)
    ctx->pc = 0x158944;
    entry_158914(rdram, ctx, runtime);
}

void entry_158954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158954 inside entry_158914 (0x158914 - 0x158980)
    ctx->pc = 0x158954;
    entry_158914(rdram, ctx, runtime);
}

void entry_1589b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1589b0 inside entry_1589a4 (0x1589a4 - 0x1589c4)
    ctx->pc = 0x1589b0;
    entry_1589a4(rdram, ctx, runtime);
}

void entry_1589f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1589f0 inside entry_1589d8 (0x1589d8 - 0x158a10)
    ctx->pc = 0x1589f0;
    entry_1589d8(rdram, ctx, runtime);
}

void entry_158a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158a38 inside BindExplg__FP5EXPLG (0x158a10 - 0x158a54)
    ctx->pc = 0x158a38;
    BindExplg__FP5EXPLG(rdram, ctx, runtime);
}

void entry_158a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158a58 inside entry_158a54 (0x158a54 - 0x158a80)
    ctx->pc = 0x158a58;
    entry_158a54(rdram, ctx, runtime);
}

void entry_158a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158a68 inside entry_158a54 (0x158a54 - 0x158a80)
    ctx->pc = 0x158a68;
    entry_158a54(rdram, ctx, runtime);
}

void entry_158ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158ab8 inside ExplodeExplgExplso__FP5EXPLGP6EXPLSO (0x158a80 - 0x158ad0)
    ctx->pc = 0x158ab8;
    ExplodeExplgExplso__FP5EXPLGP6EXPLSO(rdram, ctx, runtime);
}

void entry_158ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158ae0 inside entry_158ad0 (0x158ad0 - 0x158b00)
    ctx->pc = 0x158ae0;
    entry_158ad0(rdram, ctx, runtime);
}

void entry_158bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158bc0 inside entry_158bbc (0x158bbc - 0x158bd8)
    ctx->pc = 0x158bc0;
    entry_158bbc(rdram, ctx, runtime);
}

void entry_158cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158cbc inside BindExplo__FP5EXPLO (0x158c60 - 0x158cc4)
    ctx->pc = 0x158cbc;
    BindExplo__FP5EXPLO(rdram, ctx, runtime);
}

void entry_158ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158ce8 inside entry_158ce4 (0x158ce4 - 0x158d00)
    ctx->pc = 0x158ce8;
    entry_158ce4(rdram, ctx, runtime);
}

void entry_158d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158d10 inside entry_158d00 (0x158d00 - 0x158d1c)
    ctx->pc = 0x158d10;
    entry_158d00(rdram, ctx, runtime);
}

void entry_158d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158d14 inside entry_158d00 (0x158d00 - 0x158d1c)
    ctx->pc = 0x158d14;
    entry_158d00(rdram, ctx, runtime);
}

void entry_158dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158dfc inside entry_158df8 (0x158df8 - 0x158e10)
    ctx->pc = 0x158dfc;
    entry_158df8(rdram, ctx, runtime);
}

void entry_158e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158e84 inside entry_158e68 (0x158e68 - 0x158e8c)
    ctx->pc = 0x158e84;
    entry_158e68(rdram, ctx, runtime);
}

void entry_158eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158eac inside entry_158ea8 (0x158ea8 - 0x158ec4)
    ctx->pc = 0x158eac;
    entry_158ea8(rdram, ctx, runtime);
}

void entry_158ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158ec8 inside entry_158ec4 (0x158ec4 - 0x158ee0)
    ctx->pc = 0x158ec8;
    entry_158ec4(rdram, ctx, runtime);
}

void entry_158ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158ef8 inside entry_158ef0 (0x158ef0 - 0x158f10)
    ctx->pc = 0x158ef8;
    entry_158ef0(rdram, ctx, runtime);
}

void entry_158efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158efc inside entry_158ef0 (0x158ef0 - 0x158f10)
    ctx->pc = 0x158efc;
    entry_158ef0(rdram, ctx, runtime);
}

void entry_158f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158f50 inside entry_158f48 (0x158f48 - 0x158f68)
    ctx->pc = 0x158f50;
    entry_158f48(rdram, ctx, runtime);
}

void entry_158f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158f6c inside entry_158f68 (0x158f68 - 0x158f80)
    ctx->pc = 0x158f6c;
    entry_158f68(rdram, ctx, runtime);
}

void entry_158f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158f70 inside entry_158f68 (0x158f68 - 0x158f80)
    ctx->pc = 0x158f70;
    entry_158f68(rdram, ctx, runtime);
}

void entry_158fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x158fe0 inside entry_158fc4 (0x158fc4 - 0x159024)
    ctx->pc = 0x158fe0;
    entry_158fc4(rdram, ctx, runtime);
}

void entry_15904c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15904c inside entry_159048 (0x159048 - 0x159068)
    ctx->pc = 0x15904c;
    entry_159048(rdram, ctx, runtime);
}

void entry_159094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159094 inside entry_15908c (0x15908c - 0x1590a0)
    ctx->pc = 0x159094;
    entry_15908c(rdram, ctx, runtime);
}

void entry_1590d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1590d4 inside FireExplsExplso__FP5EXPLSP6EXPLSO (0x1590a0 - 0x159110)
    ctx->pc = 0x1590d4;
    FireExplsExplso__FP5EXPLSP6EXPLSO(rdram, ctx, runtime);
}

void entry_159108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159108 inside FireExplsExplso__FP5EXPLSP6EXPLSO (0x1590a0 - 0x159110)
    ctx->pc = 0x159108;
    FireExplsExplso__FP5EXPLSP6EXPLSO(rdram, ctx, runtime);
}

void entry_159118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159118 inside entry_159110 (0x159110 - 0x159190)
    ctx->pc = 0x159118;
    entry_159110(rdram, ctx, runtime);
}

void entry_159134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159134 inside entry_159110 (0x159110 - 0x159190)
    ctx->pc = 0x159134;
    entry_159110(rdram, ctx, runtime);
}

void entry_15914c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15914c inside entry_159110 (0x159110 - 0x159190)
    ctx->pc = 0x15914c;
    entry_159110(rdram, ctx, runtime);
}

void entry_159168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159168 inside entry_159110 (0x159110 - 0x159190)
    ctx->pc = 0x159168;
    entry_159110(rdram, ctx, runtime);
}

void entry_159184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159184 inside entry_159110 (0x159110 - 0x159190)
    ctx->pc = 0x159184;
    entry_159110(rdram, ctx, runtime);
}

void entry_1591c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1591c0 inside entry_1591a4 (0x1591a4 - 0x15926c)
    ctx->pc = 0x1591c0;
    entry_1591a4(rdram, ctx, runtime);
}

void entry_159204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159204 inside entry_1591a4 (0x1591a4 - 0x15926c)
    ctx->pc = 0x159204;
    entry_1591a4(rdram, ctx, runtime);
}

void entry_159228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159228 inside entry_1591a4 (0x1591a4 - 0x15926c)
    ctx->pc = 0x159228;
    entry_1591a4(rdram, ctx, runtime);
}

void entry_159234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159234 inside entry_1591a4 (0x1591a4 - 0x15926c)
    ctx->pc = 0x159234;
    entry_1591a4(rdram, ctx, runtime);
}

void entry_1592cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1592cc inside entry_1592c8 (0x1592c8 - 0x159340)
    ctx->pc = 0x1592cc;
    entry_1592c8(rdram, ctx, runtime);
}

void entry_1592f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1592f8 inside entry_1592c8 (0x1592c8 - 0x159340)
    ctx->pc = 0x1592f8;
    entry_1592c8(rdram, ctx, runtime);
}

void entry_159310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159310 inside entry_1592c8 (0x1592c8 - 0x159340)
    ctx->pc = 0x159310;
    entry_1592c8(rdram, ctx, runtime);
}

void entry_159330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159330 inside entry_1592c8 (0x1592c8 - 0x159340)
    ctx->pc = 0x159330;
    entry_1592c8(rdram, ctx, runtime);
}

void entry_159334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159334 inside entry_1592c8 (0x1592c8 - 0x159340)
    ctx->pc = 0x159334;
    entry_1592c8(rdram, ctx, runtime);
}

void entry_1593d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1593d0 inside entry_159340 (0x159340 - 0x159420)
    ctx->pc = 0x1593d0;
    entry_159340(rdram, ctx, runtime);
}

void entry_1593d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1593d4 inside entry_159340 (0x159340 - 0x159420)
    ctx->pc = 0x1593d4;
    entry_159340(rdram, ctx, runtime);
}

void entry_159408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159408 inside entry_159340 (0x159340 - 0x159420)
    ctx->pc = 0x159408;
    entry_159340(rdram, ctx, runtime);
}

void entry_1594d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1594d4 inside entry_1594b8 (0x1594b8 - 0x1594fc)
    ctx->pc = 0x1594d4;
    entry_1594b8(rdram, ctx, runtime);
}

void entry_1594dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1594dc inside entry_1594b8 (0x1594b8 - 0x1594fc)
    ctx->pc = 0x1594dc;
    entry_1594b8(rdram, ctx, runtime);
}

void entry_1594e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1594e4 inside entry_1594b8 (0x1594b8 - 0x1594fc)
    ctx->pc = 0x1594e4;
    entry_1594b8(rdram, ctx, runtime);
}

void entry_159530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159530 inside entry_159524 (0x159524 - 0x159554)
    ctx->pc = 0x159530;
    entry_159524(rdram, ctx, runtime);
}

void entry_159540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159540 inside entry_159524 (0x159524 - 0x159554)
    ctx->pc = 0x159540;
    entry_159524(rdram, ctx, runtime);
}

void entry_159560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159560 inside entry_159554 (0x159554 - 0x159588)
    ctx->pc = 0x159560;
    entry_159554(rdram, ctx, runtime);
}

void entry_159564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159564 inside entry_159554 (0x159554 - 0x159588)
    ctx->pc = 0x159564;
    entry_159554(rdram, ctx, runtime);
}

void entry_1595e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1595e8 inside FireSwTimedExplodeStyles__FP2SW (0x159588 - 0x15960c)
    ctx->pc = 0x1595e8;
    FireSwTimedExplodeStyles__FP2SW(rdram, ctx, runtime);
}

void entry_159628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159628 inside entry_159624 (0x159624 - 0x159680)
    ctx->pc = 0x159628;
    entry_159624(rdram, ctx, runtime);
}

void entry_159640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159640 inside entry_159624 (0x159624 - 0x159680)
    ctx->pc = 0x159640;
    entry_159624(rdram, ctx, runtime);
}

void entry_159720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159720 inside entry_1596fc (0x1596fc - 0x159760)
    ctx->pc = 0x159720;
    entry_1596fc(rdram, ctx, runtime);
}

void entry_159724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159724 inside entry_1596fc (0x1596fc - 0x159760)
    ctx->pc = 0x159724;
    entry_1596fc(rdram, ctx, runtime);
}

void entry_159730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159730 inside entry_1596fc (0x1596fc - 0x159760)
    ctx->pc = 0x159730;
    entry_1596fc(rdram, ctx, runtime);
}

void entry_159740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159740 inside entry_1596fc (0x1596fc - 0x159760)
    ctx->pc = 0x159740;
    entry_1596fc(rdram, ctx, runtime);
}

void entry_1597b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1597b8 inside SetEyesEyess__FP4EYES5EYESS (0x159770 - 0x159814)
    ctx->pc = 0x1597b8;
    SetEyesEyess__FP4EYES5EYESS(rdram, ctx, runtime);
}

void entry_1597c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1597c8 inside SetEyesEyess__FP4EYES5EYESS (0x159770 - 0x159814)
    ctx->pc = 0x1597c8;
    SetEyesEyess__FP4EYES5EYESS(rdram, ctx, runtime);
}

void entry_159830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159830 inside entry_159814 (0x159814 - 0x159838)
    ctx->pc = 0x159830;
    entry_159814(rdram, ctx, runtime);
}

void entry_159840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159840 inside entry_159838 (0x159838 - 0x159890)
    ctx->pc = 0x159840;
    entry_159838(rdram, ctx, runtime);
}

void entry_159864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159864 inside entry_159838 (0x159838 - 0x159890)
    ctx->pc = 0x159864;
    entry_159838(rdram, ctx, runtime);
}

void entry_159868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159868 inside entry_159838 (0x159838 - 0x159890)
    ctx->pc = 0x159868;
    entry_159838(rdram, ctx, runtime);
}

void entry_159874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159874 inside entry_159838 (0x159838 - 0x159890)
    ctx->pc = 0x159874;
    entry_159838(rdram, ctx, runtime);
}

void entry_1598d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1598d8 inside UpdateEyes__FP4EYESf (0x159890 - 0x1599c4)
    ctx->pc = 0x1598d8;
    UpdateEyes__FP4EYESf(rdram, ctx, runtime);
}

void entry_1598f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1598f0 inside UpdateEyes__FP4EYESf (0x159890 - 0x1599c4)
    ctx->pc = 0x1598f0;
    UpdateEyes__FP4EYESf(rdram, ctx, runtime);
}

void entry_159918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159918 inside UpdateEyes__FP4EYESf (0x159890 - 0x1599c4)
    ctx->pc = 0x159918;
    UpdateEyes__FP4EYESf(rdram, ctx, runtime);
}

void entry_159968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159968 inside UpdateEyes__FP4EYESf (0x159890 - 0x1599c4)
    ctx->pc = 0x159968;
    UpdateEyes__FP4EYESf(rdram, ctx, runtime);
}

void entry_15998c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15998c inside UpdateEyes__FP4EYESf (0x159890 - 0x1599c4)
    ctx->pc = 0x15998c;
    UpdateEyes__FP4EYESf(rdram, ctx, runtime);
}

void entry_1599bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1599bc inside UpdateEyes__FP4EYESf (0x159890 - 0x1599c4)
    ctx->pc = 0x1599bc;
    UpdateEyes__FP4EYESf(rdram, ctx, runtime);
}

void entry_1599f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1599f0 inside entry_1599ec (0x1599ec - 0x159a00)
    ctx->pc = 0x1599f0;
    entry_1599ec(rdram, ctx, runtime);
}

void entry_159a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159a34 inside entry_159a2c (0x159a2c - 0x159a48)
    ctx->pc = 0x159a34;
    entry_159a2c(rdram, ctx, runtime);
}

void entry_159a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159a4c inside entry_159a48 (0x159a48 - 0x159a5c)
    ctx->pc = 0x159a4c;
    entry_159a48(rdram, ctx, runtime);
}

void entry_159abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159abc inside entry_159a9c (0x159a9c - 0x159ad0)
    ctx->pc = 0x159abc;
    entry_159a9c(rdram, ctx, runtime);
}

void entry_159b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159b10 inside entry_159b04 (0x159b04 - 0x159b54)
    ctx->pc = 0x159b10;
    entry_159b04(rdram, ctx, runtime);
}

void entry_159b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159b64 inside entry_159b5c (0x159b5c - 0x159b98)
    ctx->pc = 0x159b64;
    entry_159b5c(rdram, ctx, runtime);
}

void entry_159b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159b68 inside entry_159b5c (0x159b5c - 0x159b98)
    ctx->pc = 0x159b68;
    entry_159b5c(rdram, ctx, runtime);
}

void entry_159b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159b9c inside entry_159b98 (0x159b98 - 0x159bb0)
    ctx->pc = 0x159b9c;
    entry_159b98(rdram, ctx, runtime);
}

void entry_159ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159ba0 inside entry_159b98 (0x159b98 - 0x159bb0)
    ctx->pc = 0x159ba0;
    entry_159b98(rdram, ctx, runtime);
}

void entry_159c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159c00 inside entry_159bf8 (0x159bf8 - 0x159c0c)
    ctx->pc = 0x159c00;
    entry_159bf8(rdram, ctx, runtime);
}

void entry_159c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159c10 inside entry_159c0c (0x159c0c - 0x159c28)
    ctx->pc = 0x159c10;
    entry_159c0c(rdram, ctx, runtime);
}

void entry_159c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159c64 inside entry_159c5c (0x159c5c - 0x159c74)
    ctx->pc = 0x159c64;
    entry_159c5c(rdram, ctx, runtime);
}

void entry_159c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159c78 inside entry_159c74 (0x159c74 - 0x159c8c)
    ctx->pc = 0x159c78;
    entry_159c74(rdram, ctx, runtime);
}

void entry_159d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159d80 inside FUN_00159d00 (0x159d00 - 0x159de8)
    ctx->pc = 0x159d80;
    FUN_00159d00(rdram, ctx, runtime);
}

void entry_159dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159dc0 inside FUN_00159d00 (0x159d00 - 0x159de8)
    ctx->pc = 0x159dc0;
    FUN_00159d00(rdram, ctx, runtime);
}

void entry_159df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159df0 inside entry_159de8 (0x159de8 - 0x159ec4)
    ctx->pc = 0x159df0;
    entry_159de8(rdram, ctx, runtime);
}

void entry_159e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159e14 inside entry_159de8 (0x159de8 - 0x159ec4)
    ctx->pc = 0x159e14;
    entry_159de8(rdram, ctx, runtime);
}

void entry_159e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159e30 inside entry_159de8 (0x159de8 - 0x159ec4)
    ctx->pc = 0x159e30;
    entry_159de8(rdram, ctx, runtime);
}

void entry_159eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159eb4 inside entry_159de8 (0x159de8 - 0x159ec4)
    ctx->pc = 0x159eb4;
    entry_159de8(rdram, ctx, runtime);
}

void entry_159eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159eb8 inside entry_159de8 (0x159de8 - 0x159ec4)
    ctx->pc = 0x159eb8;
    entry_159de8(rdram, ctx, runtime);
}

void entry_159ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159ebc inside entry_159de8 (0x159de8 - 0x159ec4)
    ctx->pc = 0x159ebc;
    entry_159de8(rdram, ctx, runtime);
}

void entry_159ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159ec8 inside entry_159ec4 (0x159ec4 - 0x159ed0)
    ctx->pc = 0x159ec8;
    entry_159ec4(rdram, ctx, runtime);
}

void entry_159f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159f14 inside entry_159f10 (0x159f10 - 0x159f20)
    ctx->pc = 0x159f14;
    entry_159f10(rdram, ctx, runtime);
}

void entry_159fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159fb4 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x159fb4;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_159fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159fdc inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x159fdc;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_159fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x159fe8 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x159fe8;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a008 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a008;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a074 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a074;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a088 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a088;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a0c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a0c4 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a0c4;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a0e8 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a0e8;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a0f8 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a0f8;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a100 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a100;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a110 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a110;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a114 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a114;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a124 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a124;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a130 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a130;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a140 inside MatchSwObject__FP2LOiiiT0iPiPP2LOT6 (0x159f48 - 0x15a150)
    ctx->pc = 0x15a140;
    MatchSwObject__FP2LOiiiT0iPiPP2LOT6(rdram, ctx, runtime);
}

void entry_15a15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a15c inside entry_15a150 (0x15a150 - 0x15a198)
    ctx->pc = 0x15a15c;
    entry_15a150(rdram, ctx, runtime);
}

void entry_15a170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a170 inside entry_15a150 (0x15a150 - 0x15a198)
    ctx->pc = 0x15a170;
    entry_15a150(rdram, ctx, runtime);
}

void entry_15a17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a17c inside entry_15a150 (0x15a150 - 0x15a198)
    ctx->pc = 0x15a17c;
    entry_15a150(rdram, ctx, runtime);
}

void entry_15a180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a180 inside entry_15a150 (0x15a150 - 0x15a198)
    ctx->pc = 0x15a180;
    entry_15a150(rdram, ctx, runtime);
}

void entry_15a184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a184 inside entry_15a150 (0x15a150 - 0x15a198)
    ctx->pc = 0x15a184;
    entry_15a150(rdram, ctx, runtime);
}

void entry_15a21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a21c inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a21c;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a23c inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a23c;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a240 inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a240;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a260 inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a260;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a284 inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a284;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a2a0 inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a2a0;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a2a8 inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a2a8;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a2ac inside entry_15a1e4 (0x15a1e4 - 0x15a2c4)
    ctx->pc = 0x15a2ac;
    entry_15a1e4(rdram, ctx, runtime);
}

void entry_15a2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a2d8 inside entry_15a2c4 (0x15a2c4 - 0x15a32c)
    ctx->pc = 0x15a2d8;
    entry_15a2c4(rdram, ctx, runtime);
}

void entry_15a308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a308 inside entry_15a2c4 (0x15a2c4 - 0x15a32c)
    ctx->pc = 0x15a308;
    entry_15a2c4(rdram, ctx, runtime);
}

void entry_15a340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a340 inside entry_15a32c (0x15a32c - 0x15a37c)
    ctx->pc = 0x15a340;
    entry_15a32c(rdram, ctx, runtime);
}

void entry_15a354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a354 inside entry_15a32c (0x15a32c - 0x15a37c)
    ctx->pc = 0x15a354;
    entry_15a32c(rdram, ctx, runtime);
}

void entry_15a380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a380 inside entry_15a37c (0x15a37c - 0x15a418)
    ctx->pc = 0x15a380;
    entry_15a37c(rdram, ctx, runtime);
}

void entry_15a388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a388 inside entry_15a37c (0x15a37c - 0x15a418)
    ctx->pc = 0x15a388;
    entry_15a37c(rdram, ctx, runtime);
}

void entry_15a3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a3b0 inside entry_15a37c (0x15a37c - 0x15a418)
    ctx->pc = 0x15a3b0;
    entry_15a37c(rdram, ctx, runtime);
}

void entry_15a3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a3d0 inside entry_15a37c (0x15a37c - 0x15a418)
    ctx->pc = 0x15a3d0;
    entry_15a37c(rdram, ctx, runtime);
}

void entry_15a3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a3e4 inside entry_15a37c (0x15a37c - 0x15a418)
    ctx->pc = 0x15a3e4;
    entry_15a37c(rdram, ctx, runtime);
}

void entry_15a3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a3e8 inside entry_15a37c (0x15a37c - 0x15a418)
    ctx->pc = 0x15a3e8;
    entry_15a37c(rdram, ctx, runtime);
}

void entry_15a4cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a4cc inside FIsCidDerivedFrom__F3CIDT0 (0x15a4b8 - 0x15a4f0)
    ctx->pc = 0x15a4cc;
    FIsCidDerivedFrom__F3CIDT0(rdram, ctx, runtime);
}

void entry_15a4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a4e8 inside FIsCidDerivedFrom__F3CIDT0 (0x15a4b8 - 0x15a4f0)
    ctx->pc = 0x15a4e8;
    FIsCidDerivedFrom__F3CIDT0(rdram, ctx, runtime);
}

void entry_15a54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a54c inside CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO (0x15a4f0 - 0x15a590)
    ctx->pc = 0x15a54c;
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime);
}

void entry_15a570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a570 inside CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO (0x15a4f0 - 0x15a590)
    ctx->pc = 0x15a570;
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime);
}

void entry_15a588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a588 inside CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO (0x15a4f0 - 0x15a590)
    ctx->pc = 0x15a588;
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime);
}

void entry_15a5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a5b0 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a5b0;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a5c8 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a5c8;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a5d4 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a5d4;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a5d8 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a5d8;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a5e8 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a5e8;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a618 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a618;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a620 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a620;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a630 inside entry_15a5a8 (0x15a5a8 - 0x15a638)
    ctx->pc = 0x15a630;
    entry_15a5a8(rdram, ctx, runtime);
}

void entry_15a658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a658 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a658;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a664 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a664;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a678 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a678;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a69c inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a69c;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a6bc inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a6bc;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a6c0 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a6c0;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a6e8 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a6e8;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a70c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a70c inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a70c;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a71c inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a71c;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a720 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a720;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a728 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a728;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a738 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a738;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a758 inside entry_15a638 (0x15a638 - 0x15a77c)
    ctx->pc = 0x15a758;
    entry_15a638(rdram, ctx, runtime);
}

void entry_15a78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a78c inside entry_15a77c (0x15a77c - 0x15a7a0)
    ctx->pc = 0x15a78c;
    entry_15a77c(rdram, ctx, runtime);
}

void entry_15a7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a7a8 inside entry_15a7a0 (0x15a7a0 - 0x15a838)
    ctx->pc = 0x15a7a8;
    entry_15a7a0(rdram, ctx, runtime);
}

void entry_15a7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a7d0 inside entry_15a7a0 (0x15a7a0 - 0x15a838)
    ctx->pc = 0x15a7d0;
    entry_15a7a0(rdram, ctx, runtime);
}

void entry_15a7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a7ec inside entry_15a7a0 (0x15a7a0 - 0x15a838)
    ctx->pc = 0x15a7ec;
    entry_15a7a0(rdram, ctx, runtime);
}

void entry_15a7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a7f0 inside entry_15a7a0 (0x15a7a0 - 0x15a838)
    ctx->pc = 0x15a7f0;
    entry_15a7a0(rdram, ctx, runtime);
}

void entry_15a804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a804 inside entry_15a7a0 (0x15a7a0 - 0x15a838)
    ctx->pc = 0x15a804;
    entry_15a7a0(rdram, ctx, runtime);
}

void entry_15a808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a808 inside entry_15a7a0 (0x15a7a0 - 0x15a838)
    ctx->pc = 0x15a808;
    entry_15a7a0(rdram, ctx, runtime);
}

void entry_15a878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a878 inside PaloFindLoCommonParent__FP2LOT0 (0x15a868 - 0x15a8b0)
    ctx->pc = 0x15a878;
    PaloFindLoCommonParent__FP2LOT0(rdram, ctx, runtime);
}

void entry_15a880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a880 inside PaloFindLoCommonParent__FP2LOT0 (0x15a868 - 0x15a8b0)
    ctx->pc = 0x15a880;
    PaloFindLoCommonParent__FP2LOT0(rdram, ctx, runtime);
}

void entry_15a898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a898 inside PaloFindLoCommonParent__FP2LOT0 (0x15a868 - 0x15a8b0)
    ctx->pc = 0x15a898;
    PaloFindLoCommonParent__FP2LOT0(rdram, ctx, runtime);
}

void entry_15a8a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15a8a4 inside PaloFindLoCommonParent__FP2LOT0 (0x15a868 - 0x15a8b0)
    ctx->pc = 0x15a8a4;
    PaloFindLoCommonParent__FP2LOT0(rdram, ctx, runtime);
}

void entry_15aad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15aad0 inside entry_15aac8 (0x15aac8 - 0x15aae0)
    ctx->pc = 0x15aad0;
    entry_15aac8(rdram, ctx, runtime);
}

void entry_15aad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15aad4 inside entry_15aac8 (0x15aac8 - 0x15aae0)
    ctx->pc = 0x15aad4;
    entry_15aac8(rdram, ctx, runtime);
}

void entry_15ac60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ac60 inside entry_15ac5c (0x15ac5c - 0x15ac70)
    ctx->pc = 0x15ac60;
    entry_15ac5c(rdram, ctx, runtime);
}

void entry_15aca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15aca8 inside entry_15ac84 (0x15ac84 - 0x15acf4)
    ctx->pc = 0x15aca8;
    entry_15ac84(rdram, ctx, runtime);
}

void entry_15acc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15acc0 inside entry_15ac84 (0x15ac84 - 0x15acf4)
    ctx->pc = 0x15acc0;
    entry_15ac84(rdram, ctx, runtime);
}

void entry_15ace8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ace8 inside entry_15ac84 (0x15ac84 - 0x15acf4)
    ctx->pc = 0x15ace8;
    entry_15ac84(rdram, ctx, runtime);
}

void entry_15ad24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ad24 inside entry_15ad08 (0x15ad08 - 0x15ad48)
    ctx->pc = 0x15ad24;
    entry_15ad08(rdram, ctx, runtime);
}

void entry_15ad34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ad34 inside entry_15ad08 (0x15ad08 - 0x15ad48)
    ctx->pc = 0x15ad34;
    entry_15ad08(rdram, ctx, runtime);
}

void entry_15ae08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ae08 inside entry_15ae00 (0x15ae00 - 0x15ae14)
    ctx->pc = 0x15ae08;
    entry_15ae00(rdram, ctx, runtime);
}

void entry_15ae2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ae2c inside entry_15ae28 (0x15ae28 - 0x15ae38)
    ctx->pc = 0x15ae2c;
    entry_15ae28(rdram, ctx, runtime);
}

void entry_15ae6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ae6c inside entry_15ae64 (0x15ae64 - 0x15aea4)
    ctx->pc = 0x15ae6c;
    entry_15ae64(rdram, ctx, runtime);
}

void entry_15aea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15aea8 inside entry_15aea4 (0x15aea4 - 0x15aeb0)
    ctx->pc = 0x15aea8;
    entry_15aea4(rdram, ctx, runtime);
}

void entry_15af20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15af20 inside entry_15af10 (0x15af10 - 0x15af28)
    ctx->pc = 0x15af20;
    entry_15af10(rdram, ctx, runtime);
}

void entry_15b108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b108 inside entry_15b104 (0x15b104 - 0x15b128)
    ctx->pc = 0x15b108;
    entry_15b104(rdram, ctx, runtime);
}

void entry_15b1c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b1c0 inside entry_15b1b4 (0x15b1b4 - 0x15b1c8)
    ctx->pc = 0x15b1c0;
    entry_15b1b4(rdram, ctx, runtime);
}

void entry_15b1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b1cc inside entry_15b1c8 (0x15b1c8 - 0x15b26c)
    ctx->pc = 0x15b1cc;
    entry_15b1c8(rdram, ctx, runtime);
}

void entry_15b1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b1f0 inside entry_15b1c8 (0x15b1c8 - 0x15b26c)
    ctx->pc = 0x15b1f0;
    entry_15b1c8(rdram, ctx, runtime);
}

void entry_15b208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b208 inside entry_15b1c8 (0x15b1c8 - 0x15b26c)
    ctx->pc = 0x15b208;
    entry_15b1c8(rdram, ctx, runtime);
}

void entry_15b20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b20c inside entry_15b1c8 (0x15b1c8 - 0x15b26c)
    ctx->pc = 0x15b20c;
    entry_15b1c8(rdram, ctx, runtime);
}

void entry_15b224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b224 inside entry_15b1c8 (0x15b1c8 - 0x15b26c)
    ctx->pc = 0x15b224;
    entry_15b1c8(rdram, ctx, runtime);
}

void entry_15b270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b270 inside entry_15b26c (0x15b26c - 0x15b2bc)
    ctx->pc = 0x15b270;
    entry_15b26c(rdram, ctx, runtime);
}

void entry_15b284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b284 inside entry_15b26c (0x15b26c - 0x15b2bc)
    ctx->pc = 0x15b284;
    entry_15b26c(rdram, ctx, runtime);
}

void entry_15b290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b290 inside entry_15b26c (0x15b26c - 0x15b2bc)
    ctx->pc = 0x15b290;
    entry_15b26c(rdram, ctx, runtime);
}

void entry_15b2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b2dc inside entry_15b2d4 (0x15b2d4 - 0x15b2e8)
    ctx->pc = 0x15b2dc;
    entry_15b2d4(rdram, ctx, runtime);
}

void entry_15b2f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b2f4 inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b2f4;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b2f8 inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b2f8;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b2fc inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b2fc;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b34c inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b34c;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b360 inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b360;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b364 inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b364;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b374 inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b374;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b378 inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b378;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b37c inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b37c;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b3c8 inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b3c8;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b3ec inside entry_15b2e8 (0x15b2e8 - 0x15b3f4)
    ctx->pc = 0x15b3ec;
    entry_15b2e8(rdram, ctx, runtime);
}

void entry_15b40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b40c inside entry_15b404 (0x15b404 - 0x15b414)
    ctx->pc = 0x15b40c;
    entry_15b404(rdram, ctx, runtime);
}

void entry_15b41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b41c inside entry_15b414 (0x15b414 - 0x15b480)
    ctx->pc = 0x15b41c;
    entry_15b414(rdram, ctx, runtime);
}

void entry_15b450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b450 inside entry_15b414 (0x15b414 - 0x15b480)
    ctx->pc = 0x15b450;
    entry_15b414(rdram, ctx, runtime);
}

void entry_15b470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b470 inside entry_15b414 (0x15b414 - 0x15b480)
    ctx->pc = 0x15b470;
    entry_15b414(rdram, ctx, runtime);
}

void entry_15b478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b478 inside entry_15b414 (0x15b414 - 0x15b480)
    ctx->pc = 0x15b478;
    entry_15b414(rdram, ctx, runtime);
}

void entry_15b48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b48c inside entry_15b480 (0x15b480 - 0x15b4b8)
    ctx->pc = 0x15b48c;
    entry_15b480(rdram, ctx, runtime);
}

void entry_15b490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b490 inside entry_15b480 (0x15b480 - 0x15b4b8)
    ctx->pc = 0x15b490;
    entry_15b480(rdram, ctx, runtime);
}

void entry_15b4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b4b0 inside entry_15b480 (0x15b480 - 0x15b4b8)
    ctx->pc = 0x15b4b0;
    entry_15b480(rdram, ctx, runtime);
}

void entry_15b4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b4bc inside entry_15b4b8 (0x15b4b8 - 0x15b4d0)
    ctx->pc = 0x15b4bc;
    entry_15b4b8(rdram, ctx, runtime);
}

void entry_15b4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b4c0 inside entry_15b4b8 (0x15b4b8 - 0x15b4d0)
    ctx->pc = 0x15b4c0;
    entry_15b4b8(rdram, ctx, runtime);
}

void entry_15b51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b51c inside entry_15b4f4 (0x15b4f4 - 0x15b5c8)
    ctx->pc = 0x15b51c;
    entry_15b4f4(rdram, ctx, runtime);
}

void entry_15b530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b530 inside entry_15b4f4 (0x15b4f4 - 0x15b5c8)
    ctx->pc = 0x15b530;
    entry_15b4f4(rdram, ctx, runtime);
}

void entry_15b590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b590 inside entry_15b4f4 (0x15b4f4 - 0x15b5c8)
    ctx->pc = 0x15b590;
    entry_15b4f4(rdram, ctx, runtime);
}

void entry_15b5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b5a0 inside entry_15b4f4 (0x15b4f4 - 0x15b5c8)
    ctx->pc = 0x15b5a0;
    entry_15b4f4(rdram, ctx, runtime);
}

void entry_15b5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b5d0 inside entry_15b5c8 (0x15b5c8 - 0x15b690)
    ctx->pc = 0x15b5d0;
    entry_15b5c8(rdram, ctx, runtime);
}

void entry_15b634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b634 inside entry_15b5c8 (0x15b5c8 - 0x15b690)
    ctx->pc = 0x15b634;
    entry_15b5c8(rdram, ctx, runtime);
}

void entry_15b644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b644 inside entry_15b5c8 (0x15b5c8 - 0x15b690)
    ctx->pc = 0x15b644;
    entry_15b5c8(rdram, ctx, runtime);
}

void entry_15b66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b66c inside entry_15b5c8 (0x15b5c8 - 0x15b690)
    ctx->pc = 0x15b66c;
    entry_15b5c8(rdram, ctx, runtime);
}

void entry_15b680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b680 inside entry_15b5c8 (0x15b5c8 - 0x15b690)
    ctx->pc = 0x15b680;
    entry_15b5c8(rdram, ctx, runtime);
}

void entry_15b698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b698 inside entry_15b690 (0x15b690 - 0x15b70c)
    ctx->pc = 0x15b698;
    entry_15b690(rdram, ctx, runtime);
}

void entry_15b69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b69c inside entry_15b690 (0x15b690 - 0x15b70c)
    ctx->pc = 0x15b69c;
    entry_15b690(rdram, ctx, runtime);
}

void entry_15b6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b6ec inside entry_15b690 (0x15b690 - 0x15b70c)
    ctx->pc = 0x15b6ec;
    entry_15b690(rdram, ctx, runtime);
}

void entry_15b710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b710 inside entry_15b70c (0x15b70c - 0x15b720)
    ctx->pc = 0x15b710;
    entry_15b70c(rdram, ctx, runtime);
}

void entry_15b87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b87c inside entry_15b864 (0x15b864 - 0x15b8ec)
    ctx->pc = 0x15b87c;
    entry_15b864(rdram, ctx, runtime);
}

void entry_15b880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b880 inside entry_15b864 (0x15b864 - 0x15b8ec)
    ctx->pc = 0x15b880;
    entry_15b864(rdram, ctx, runtime);
}

void entry_15b934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b934 inside entry_15b920 (0x15b920 - 0x15b9b0)
    ctx->pc = 0x15b934;
    entry_15b920(rdram, ctx, runtime);
}

void entry_15b990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15b990 inside entry_15b920 (0x15b920 - 0x15b9b0)
    ctx->pc = 0x15b990;
    entry_15b920(rdram, ctx, runtime);
}

void entry_15ba18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ba18 inside entry_15b9e4 (0x15b9e4 - 0x15ba78)
    ctx->pc = 0x15ba18;
    entry_15b9e4(rdram, ctx, runtime);
}

void entry_15bc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bc40 inside entry_15bc34 (0x15bc34 - 0x15bc78)
    ctx->pc = 0x15bc40;
    entry_15bc34(rdram, ctx, runtime);
}

void entry_15bc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bc44 inside entry_15bc34 (0x15bc34 - 0x15bc78)
    ctx->pc = 0x15bc44;
    entry_15bc34(rdram, ctx, runtime);
}

void entry_15bc50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bc50 inside entry_15bc34 (0x15bc34 - 0x15bc78)
    ctx->pc = 0x15bc50;
    entry_15bc34(rdram, ctx, runtime);
}

void entry_15bcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bcd4 inside entry_15bccc (0x15bccc - 0x15bd18)
    ctx->pc = 0x15bcd4;
    entry_15bccc(rdram, ctx, runtime);
}

void entry_15bcdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bcdc inside entry_15bccc (0x15bccc - 0x15bd18)
    ctx->pc = 0x15bcdc;
    entry_15bccc(rdram, ctx, runtime);
}

void entry_15bd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bd34 inside entry_15bd24 (0x15bd24 - 0x15bd48)
    ctx->pc = 0x15bd34;
    entry_15bd24(rdram, ctx, runtime);
}

void entry_15bd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bd90 inside FFindFlyClosestLandingPos__FP3FLYP6VECTOR (0x15bd48 - 0x15bda0)
    ctx->pc = 0x15bd90;
    FFindFlyClosestLandingPos__FP3FLYP6VECTOR(rdram, ctx, runtime);
}

void entry_15be2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15be2c inside entry_15be20 (0x15be20 - 0x15be48)
    ctx->pc = 0x15be2c;
    entry_15be20(rdram, ctx, runtime);
}

void entry_15bec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bec4 inside entry_15beb0 (0x15beb0 - 0x15bef0)
    ctx->pc = 0x15bec4;
    entry_15beb0(rdram, ctx, runtime);
}

void entry_15bec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bec8 inside entry_15beb0 (0x15beb0 - 0x15bef0)
    ctx->pc = 0x15bec8;
    entry_15beb0(rdram, ctx, runtime);
}

void entry_15bf10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bf10 inside FlysAttemptedFlyLanding__FP3FLY (0x15bef0 - 0x15bf80)
    ctx->pc = 0x15bf10;
    FlysAttemptedFlyLanding__FP3FLY(rdram, ctx, runtime);
}

void entry_15bf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bf2c inside FlysAttemptedFlyLanding__FP3FLY (0x15bef0 - 0x15bf80)
    ctx->pc = 0x15bf2c;
    FlysAttemptedFlyLanding__FP3FLY(rdram, ctx, runtime);
}

void entry_15bf94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bf94 inside entry_15bf80 (0x15bf80 - 0x15bfa0)
    ctx->pc = 0x15bf94;
    entry_15bf80(rdram, ctx, runtime);
}

void entry_15bfa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15bfa4 inside entry_15bfa0 (0x15bfa0 - 0x15bfc0)
    ctx->pc = 0x15bfa4;
    entry_15bfa0(rdram, ctx, runtime);
}

void entry_15c03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c03c inside entry_15bfd4 (0x15bfd4 - 0x15c058)
    ctx->pc = 0x15c03c;
    entry_15bfd4(rdram, ctx, runtime);
}

void entry_15c044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c044 inside entry_15bfd4 (0x15bfd4 - 0x15c058)
    ctx->pc = 0x15c044;
    entry_15bfd4(rdram, ctx, runtime);
}

void entry_15c048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c048 inside entry_15bfd4 (0x15bfd4 - 0x15c058)
    ctx->pc = 0x15c048;
    entry_15bfd4(rdram, ctx, runtime);
}

void entry_15c080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c080 inside FFilterFly__FPvP2SO (0x15c058 - 0x15c0a0)
    ctx->pc = 0x15c080;
    FFilterFly__FPvP2SO(rdram, ctx, runtime);
}

void entry_15c088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c088 inside FFilterFly__FPvP2SO (0x15c058 - 0x15c0a0)
    ctx->pc = 0x15c088;
    FFilterFly__FPvP2SO(rdram, ctx, runtime);
}

void entry_15c160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c160 inside entry_15c154 (0x15c154 - 0x15c178)
    ctx->pc = 0x15c160;
    entry_15c154(rdram, ctx, runtime);
}

void entry_15c1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c1ac inside FUN_0015c188 (0x15c188 - 0x15c1c0)
    ctx->pc = 0x15c1ac;
    FUN_0015c188(rdram, ctx, runtime);
}

void entry_15c1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c1b4 inside FUN_0015c188 (0x15c188 - 0x15c1c0)
    ctx->pc = 0x15c1b4;
    FUN_0015c188(rdram, ctx, runtime);
}

void entry_15c1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c1d4 inside FUN_0015c1c0 (0x15c1c0 - 0x15c200)
    ctx->pc = 0x15c1d4;
    FUN_0015c1c0(rdram, ctx, runtime);
}

void entry_15c1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c1f4 inside FUN_0015c1c0 (0x15c1c0 - 0x15c200)
    ctx->pc = 0x15c1f4;
    FUN_0015c1c0(rdram, ctx, runtime);
}

void entry_15c220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c220 inside FUN_0015c200 (0x15c200 - 0x15c260)
    ctx->pc = 0x15c220;
    FUN_0015c200(rdram, ctx, runtime);
}

void entry_15c238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c238 inside FUN_0015c200 (0x15c200 - 0x15c260)
    ctx->pc = 0x15c238;
    FUN_0015c200(rdram, ctx, runtime);
}

void entry_15c244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c244 inside FUN_0015c200 (0x15c200 - 0x15c260)
    ctx->pc = 0x15c244;
    FUN_0015c200(rdram, ctx, runtime);
}

void entry_15c24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c24c inside FUN_0015c200 (0x15c200 - 0x15c260)
    ctx->pc = 0x15c24c;
    FUN_0015c200(rdram, ctx, runtime);
}

void entry_15c440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c440 inside DxFromPchz__5CFontPc (0x15c418 - 0x15c478)
    ctx->pc = 0x15c440;
    DxFromPchz__5CFontPc(rdram, ctx, runtime);
}

void entry_15c458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c458 inside DxFromPchz__5CFontPc (0x15c418 - 0x15c478)
    ctx->pc = 0x15c458;
    DxFromPchz__5CFontPc(rdram, ctx, runtime);
}

void entry_15c488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c488 inside entry_15c478 (0x15c478 - 0x15c4a8)
    ctx->pc = 0x15c488;
    entry_15c478(rdram, ctx, runtime);
}

void entry_15c490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c490 inside entry_15c478 (0x15c478 - 0x15c4a8)
    ctx->pc = 0x15c490;
    entry_15c478(rdram, ctx, runtime);
}

void entry_15c540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c540 inside ClineWrapPchz__5CFontPcf (0x15c4e8 - 0x15c56c)
    ctx->pc = 0x15c540;
    ClineWrapPchz__5CFontPcf(rdram, ctx, runtime);
}

void entry_15c55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c55c inside ClineWrapPchz__5CFontPcf (0x15c4e8 - 0x15c56c)
    ctx->pc = 0x15c55c;
    ClineWrapPchz__5CFontPcf(rdram, ctx, runtime);
}

void entry_15c570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c570 inside entry_15c56c (0x15c56c - 0x15c630)
    ctx->pc = 0x15c570;
    entry_15c56c(rdram, ctx, runtime);
}

void entry_15c598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c598 inside entry_15c56c (0x15c56c - 0x15c630)
    ctx->pc = 0x15c598;
    entry_15c56c(rdram, ctx, runtime);
}

void entry_15c5c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c5c4 inside entry_15c56c (0x15c56c - 0x15c630)
    ctx->pc = 0x15c5c4;
    entry_15c56c(rdram, ctx, runtime);
}

void entry_15c5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c5d0 inside entry_15c56c (0x15c56c - 0x15c630)
    ctx->pc = 0x15c5d0;
    entry_15c56c(rdram, ctx, runtime);
}

void entry_15c5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c5ec inside entry_15c56c (0x15c56c - 0x15c630)
    ctx->pc = 0x15c5ec;
    entry_15c56c(rdram, ctx, runtime);
}

void entry_15c5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c5f0 inside entry_15c56c (0x15c56c - 0x15c630)
    ctx->pc = 0x15c5f0;
    entry_15c56c(rdram, ctx, runtime);
}

void entry_15c5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c5fc inside entry_15c56c (0x15c56c - 0x15c630)
    ctx->pc = 0x15c5fc;
    entry_15c56c(rdram, ctx, runtime);
}

void entry_15c6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c6bc inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c6bc;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c6f0 inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c6f0;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c70c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c70c inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c70c;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c718 inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c718;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c730 inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c730;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c740 inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c740;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c760 inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c760;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c78c inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c78c;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c7a8 inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c7a8;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c7c0 inside entry_15c6a4 (0x15c6a4 - 0x15c7d8)
    ctx->pc = 0x15c7c0;
    entry_15c6a4(rdram, ctx, runtime);
}

void entry_15c7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c7ec inside entry_15c7d8 (0x15c7d8 - 0x15c84c)
    ctx->pc = 0x15c7ec;
    entry_15c7d8(rdram, ctx, runtime);
}

void entry_15c810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c810 inside entry_15c7d8 (0x15c7d8 - 0x15c84c)
    ctx->pc = 0x15c810;
    entry_15c7d8(rdram, ctx, runtime);
}

void entry_15c820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c820 inside entry_15c7d8 (0x15c7d8 - 0x15c84c)
    ctx->pc = 0x15c820;
    entry_15c7d8(rdram, ctx, runtime);
}

void entry_15c828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c828 inside entry_15c7d8 (0x15c7d8 - 0x15c84c)
    ctx->pc = 0x15c828;
    entry_15c7d8(rdram, ctx, runtime);
}

void entry_15c850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c850 inside entry_15c84c (0x15c84c - 0x15c87c)
    ctx->pc = 0x15c850;
    entry_15c84c(rdram, ctx, runtime);
}

void entry_15c864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15c864 inside entry_15c84c (0x15c84c - 0x15c87c)
    ctx->pc = 0x15c864;
    entry_15c84c(rdram, ctx, runtime);
}

void entry_15ca94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ca94 inside entry_15ca7c (0x15ca7c - 0x15cab8)
    ctx->pc = 0x15ca94;
    entry_15ca7c(rdram, ctx, runtime);
}

void entry_15caa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15caa4 inside entry_15ca7c (0x15ca7c - 0x15cab8)
    ctx->pc = 0x15caa4;
    entry_15ca7c(rdram, ctx, runtime);
}

void entry_15cb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15cb68 inside entry_15cb54 (0x15cb54 - 0x15cb88)
    ctx->pc = 0x15cb68;
    entry_15cb54(rdram, ctx, runtime);
}

void entry_15cbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15cbf4 inside entry_15cbe0 (0x15cbe0 - 0x15cc00)
    ctx->pc = 0x15cbf4;
    entry_15cbe0(rdram, ctx, runtime);
}

void entry_15cf10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15cf10 inside entry_15cf0c (0x15cf0c - 0x15cf70)
    ctx->pc = 0x15cf10;
    entry_15cf0c(rdram, ctx, runtime);
}

void entry_15cf24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15cf24 inside entry_15cf0c (0x15cf0c - 0x15cf70)
    ctx->pc = 0x15cf24;
    entry_15cf0c(rdram, ctx, runtime);
}

void entry_15cf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15cf30 inside entry_15cf0c (0x15cf0c - 0x15cf70)
    ctx->pc = 0x15cf30;
    entry_15cf0c(rdram, ctx, runtime);
}

void entry_15d114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15d114 inside entry_15d100 (0x15d100 - 0x15d120)
    ctx->pc = 0x15d114;
    entry_15d100(rdram, ctx, runtime);
}

void entry_15d2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15d2ec inside entry_15d2e8 (0x15d2e8 - 0x15d338)
    ctx->pc = 0x15d2ec;
    entry_15d2e8(rdram, ctx, runtime);
}

void entry_15d2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15d2f0 inside entry_15d2e8 (0x15d2e8 - 0x15d338)
    ctx->pc = 0x15d2f0;
    entry_15d2e8(rdram, ctx, runtime);
}

void entry_15d850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15d850 inside entry_15d84c (0x15d84c - 0x15d8a8)
    ctx->pc = 0x15d850;
    entry_15d84c(rdram, ctx, runtime);
}

void entry_15d92c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15d92c inside entry_15d8d0 (0x15d8d0 - 0x15d968)
    ctx->pc = 0x15d92c;
    entry_15d8d0(rdram, ctx, runtime);
}

void entry_15d930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15d930 inside entry_15d8d0 (0x15d8d0 - 0x15d968)
    ctx->pc = 0x15d930;
    entry_15d8d0(rdram, ctx, runtime);
}

void entry_15daa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15daa0 inside entry_15da9c (0x15da9c - 0x15dab8)
    ctx->pc = 0x15daa0;
    entry_15da9c(rdram, ctx, runtime);
}

void entry_15dad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dad8 inside PglyffFromCh__8CFontBrxc (0x15dab8 - 0x15db28)
    ctx->pc = 0x15dad8;
    PglyffFromCh__8CFontBrxc(rdram, ctx, runtime);
}

void entry_15db04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15db04 inside PglyffFromCh__8CFontBrxc (0x15dab8 - 0x15db28)
    ctx->pc = 0x15db04;
    PglyffFromCh__8CFontBrxc(rdram, ctx, runtime);
}

void entry_15db10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15db10 inside PglyffFromCh__8CFontBrxc (0x15dab8 - 0x15db28)
    ctx->pc = 0x15db10;
    PglyffFromCh__8CFontBrxc(rdram, ctx, runtime);
}

void entry_15db1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15db1c inside PglyffFromCh__8CFontBrxc (0x15dab8 - 0x15db28)
    ctx->pc = 0x15db1c;
    PglyffFromCh__8CFontBrxc(rdram, ctx, runtime);
}

void entry_15dc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dc18 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dc18;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dc40 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dc40;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dc88 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dc88;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dca8 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dca8;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dcc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dcc4 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dcc4;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dce0 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dce0;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dcf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dcf8 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dcf8;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dd1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dd1c inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dd1c;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dd30 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dd30;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dd88 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dd88;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15dda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dda4 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15dda4;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15ddd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ddd4 inside ChNext__9CRichText (0x15dbe0 - 0x15dddc)
    ctx->pc = 0x15ddd4;
    ChNext__9CRichText(rdram, ctx, runtime);
}

void entry_15de6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15de6c inside entry_15ddec (0x15ddec - 0x15debc)
    ctx->pc = 0x15de6c;
    entry_15ddec(rdram, ctx, runtime);
}

void entry_15de90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15de90 inside entry_15ddec (0x15ddec - 0x15debc)
    ctx->pc = 0x15de90;
    entry_15ddec(rdram, ctx, runtime);
}

void entry_15dea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dea0 inside entry_15ddec (0x15ddec - 0x15debc)
    ctx->pc = 0x15dea0;
    entry_15ddec(rdram, ctx, runtime);
}

void entry_15deac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15deac inside entry_15ddec (0x15ddec - 0x15debc)
    ctx->pc = 0x15deac;
    entry_15ddec(rdram, ctx, runtime);
}

void entry_15dec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dec0 inside entry_15debc (0x15debc - 0x15df14)
    ctx->pc = 0x15dec0;
    entry_15debc(rdram, ctx, runtime);
}

void entry_15decc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15decc inside entry_15debc (0x15debc - 0x15df14)
    ctx->pc = 0x15decc;
    entry_15debc(rdram, ctx, runtime);
}

void entry_15df20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15df20 inside entry_15df14 (0x15df14 - 0x15df58)
    ctx->pc = 0x15df20;
    entry_15df14(rdram, ctx, runtime);
}

void entry_15df78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15df78 inside entry_15df74 (0x15df74 - 0x15df80)
    ctx->pc = 0x15df78;
    entry_15df74(rdram, ctx, runtime);
}

void entry_15dfc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dfc0 inside entry_15dfbc (0x15dfbc - 0x15dfc8)
    ctx->pc = 0x15dfc0;
    entry_15dfbc(rdram, ctx, runtime);
}

void entry_15dfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15dfdc inside entry_15dfc8 (0x15dfc8 - 0x15dff8)
    ctx->pc = 0x15dfdc;
    entry_15dfc8(rdram, ctx, runtime);
}

void entry_15e020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e020 inside entry_15e014 (0x15e014 - 0x15e038)
    ctx->pc = 0x15e020;
    entry_15e014(rdram, ctx, runtime);
}

void entry_15e03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e03c inside entry_15e038 (0x15e038 - 0x15e044)
    ctx->pc = 0x15e03c;
    entry_15e038(rdram, ctx, runtime);
}

void entry_15e0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e0c0 inside entry_15e0b4 (0x15e0b4 - 0x15e0ec)
    ctx->pc = 0x15e0c0;
    entry_15e0b4(rdram, ctx, runtime);
}

void entry_15e0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e0d4 inside entry_15e0b4 (0x15e0b4 - 0x15e0ec)
    ctx->pc = 0x15e0d4;
    entry_15e0b4(rdram, ctx, runtime);
}

void entry_15e0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e0f0 inside entry_15e0ec (0x15e0ec - 0x15e178)
    ctx->pc = 0x15e0f0;
    entry_15e0ec(rdram, ctx, runtime);
}

void entry_15e118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e118 inside entry_15e0ec (0x15e0ec - 0x15e178)
    ctx->pc = 0x15e118;
    entry_15e0ec(rdram, ctx, runtime);
}

void entry_15e144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e144 inside entry_15e0ec (0x15e0ec - 0x15e178)
    ctx->pc = 0x15e144;
    entry_15e0ec(rdram, ctx, runtime);
}

void entry_15e154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e154 inside entry_15e0ec (0x15e0ec - 0x15e178)
    ctx->pc = 0x15e154;
    entry_15e0ec(rdram, ctx, runtime);
}

void entry_15e170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e170 inside entry_15e0ec (0x15e0ec - 0x15e178)
    ctx->pc = 0x15e170;
    entry_15e0ec(rdram, ctx, runtime);
}

void entry_15e228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e228 inside entry_15e21c (0x15e21c - 0x15e258)
    ctx->pc = 0x15e228;
    entry_15e21c(rdram, ctx, runtime);
}

void entry_15e240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e240 inside entry_15e21c (0x15e21c - 0x15e258)
    ctx->pc = 0x15e240;
    entry_15e21c(rdram, ctx, runtime);
}

void entry_15e25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e25c inside entry_15e258 (0x15e258 - 0x15e264)
    ctx->pc = 0x15e25c;
    entry_15e258(rdram, ctx, runtime);
}

void entry_15e2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e2f0 inside entry_15e2c4 (0x15e2c4 - 0x15e318)
    ctx->pc = 0x15e2f0;
    entry_15e2c4(rdram, ctx, runtime);
}

void entry_15e2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e2f8 inside entry_15e2c4 (0x15e2c4 - 0x15e318)
    ctx->pc = 0x15e2f8;
    entry_15e2c4(rdram, ctx, runtime);
}

void entry_15e388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e388 inside entry_15e380 (0x15e380 - 0x15e3ac)
    ctx->pc = 0x15e388;
    entry_15e380(rdram, ctx, runtime);
}

void entry_15e398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e398 inside entry_15e380 (0x15e380 - 0x15e3ac)
    ctx->pc = 0x15e398;
    entry_15e380(rdram, ctx, runtime);
}

void entry_15e3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e3c0 inside entry_15e3ac (0x15e3ac - 0x15e3c8)
    ctx->pc = 0x15e3c0;
    entry_15e3ac(rdram, ctx, runtime);
}

void entry_15e3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e3e8 inside entry_15e3c8 (0x15e3c8 - 0x15e460)
    ctx->pc = 0x15e3e8;
    entry_15e3c8(rdram, ctx, runtime);
}

void entry_15e424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e424 inside entry_15e3c8 (0x15e3c8 - 0x15e460)
    ctx->pc = 0x15e424;
    entry_15e3c8(rdram, ctx, runtime);
}

void entry_15e440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e440 inside entry_15e3c8 (0x15e3c8 - 0x15e460)
    ctx->pc = 0x15e440;
    entry_15e3c8(rdram, ctx, runtime);
}

void entry_15e480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e480 inside entry_15e474 (0x15e474 - 0x15e524)
    ctx->pc = 0x15e480;
    entry_15e474(rdram, ctx, runtime);
}

void entry_15e4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e4ac inside entry_15e474 (0x15e474 - 0x15e524)
    ctx->pc = 0x15e4ac;
    entry_15e474(rdram, ctx, runtime);
}

void entry_15e4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e4c8 inside entry_15e474 (0x15e474 - 0x15e524)
    ctx->pc = 0x15e4c8;
    entry_15e474(rdram, ctx, runtime);
}

void entry_15e4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e4e4 inside entry_15e474 (0x15e474 - 0x15e524)
    ctx->pc = 0x15e4e4;
    entry_15e474(rdram, ctx, runtime);
}

void entry_15e4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e4f8 inside entry_15e474 (0x15e474 - 0x15e524)
    ctx->pc = 0x15e4f8;
    entry_15e474(rdram, ctx, runtime);
}

void entry_15e4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e4fc inside entry_15e474 (0x15e474 - 0x15e524)
    ctx->pc = 0x15e4fc;
    entry_15e474(rdram, ctx, runtime);
}

void entry_15e52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e52c inside entry_15e524 (0x15e524 - 0x15e54c)
    ctx->pc = 0x15e52c;
    entry_15e524(rdram, ctx, runtime);
}

void entry_15e550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e550 inside entry_15e54c (0x15e54c - 0x15e57c)
    ctx->pc = 0x15e550;
    entry_15e54c(rdram, ctx, runtime);
}

void entry_15e580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e580 inside entry_15e57c (0x15e57c - 0x15e588)
    ctx->pc = 0x15e580;
    entry_15e57c(rdram, ctx, runtime);
}

void entry_15e638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e638 inside entry_15e61c (0x15e61c - 0x15e64c)
    ctx->pc = 0x15e638;
    entry_15e61c(rdram, ctx, runtime);
}

void entry_15e65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e65c inside entry_15e64c (0x15e64c - 0x15e678)
    ctx->pc = 0x15e65c;
    entry_15e64c(rdram, ctx, runtime);
}

void entry_15e6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e6d8 inside VU1_Interrupt__Fi (0x15e6a8 - 0x15e810)
    ctx->pc = 0x15e6d8;
    VU1_Interrupt__Fi(rdram, ctx, runtime);
}

void entry_15e720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e720 inside VU1_Interrupt__Fi (0x15e6a8 - 0x15e810)
    ctx->pc = 0x15e720;
    VU1_Interrupt__Fi(rdram, ctx, runtime);
}

void entry_15e730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e730 inside VU1_Interrupt__Fi (0x15e6a8 - 0x15e810)
    ctx->pc = 0x15e730;
    VU1_Interrupt__Fi(rdram, ctx, runtime);
}

void entry_15e774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e774 inside VU1_Interrupt__Fi (0x15e6a8 - 0x15e810)
    ctx->pc = 0x15e774;
    VU1_Interrupt__Fi(rdram, ctx, runtime);
}

void entry_15e798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e798 inside VU1_Interrupt__Fi (0x15e6a8 - 0x15e810)
    ctx->pc = 0x15e798;
    VU1_Interrupt__Fi(rdram, ctx, runtime);
}

void entry_15e7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e7dc inside VU1_Interrupt__Fi (0x15e6a8 - 0x15e810)
    ctx->pc = 0x15e7dc;
    VU1_Interrupt__Fi(rdram, ctx, runtime);
}

void entry_15e878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e878 inside StartupFrame__Fv (0x15e810 - 0x15e894)
    ctx->pc = 0x15e878;
    StartupFrame__Fv(rdram, ctx, runtime);
}

void entry_15e960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e960 inside entry_15e944 (0x15e944 - 0x15e9c0)
    ctx->pc = 0x15e960;
    entry_15e944(rdram, ctx, runtime);
}

void entry_15e978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e978 inside entry_15e944 (0x15e944 - 0x15e9c0)
    ctx->pc = 0x15e978;
    entry_15e944(rdram, ctx, runtime);
}

void entry_15e988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e988 inside entry_15e944 (0x15e944 - 0x15e9c0)
    ctx->pc = 0x15e988;
    entry_15e944(rdram, ctx, runtime);
}

void entry_15e98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15e98c inside entry_15e944 (0x15e944 - 0x15e9c0)
    ctx->pc = 0x15e98c;
    entry_15e944(rdram, ctx, runtime);
}

void entry_15ea50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ea50 inside entry_15ea1c (0x15ea1c - 0x15ea58)
    ctx->pc = 0x15ea50;
    entry_15ea1c(rdram, ctx, runtime);
}

void entry_15edd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15edd8 inside check_anticrack_antigrab__Fv (0x15edb8 - 0x15ee80)
    ctx->pc = 0x15edd8;
    check_anticrack_antigrab__Fv(rdram, ctx, runtime);
}

void entry_15ee64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ee64 inside check_anticrack_antigrab__Fv (0x15edb8 - 0x15ee80)
    ctx->pc = 0x15ee64;
    check_anticrack_antigrab__Fv(rdram, ctx, runtime);
}

void entry_15ee74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ee74 inside check_anticrack_antigrab__Fv (0x15edb8 - 0x15ee80)
    ctx->pc = 0x15ee74;
    check_anticrack_antigrab__Fv(rdram, ctx, runtime);
}

void entry_15eed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15eed8 inside entry_15eed4 (0x15eed4 - 0x15eee8)
    ctx->pc = 0x15eed8;
    entry_15eed4(rdram, ctx, runtime);
}

void entry_15ef1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ef1c inside entry_15eee8 (0x15eee8 - 0x15ef24)
    ctx->pc = 0x15ef1c;
    entry_15eee8(rdram, ctx, runtime);
}

void entry_15f060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f060 inside entry_15f01c (0x15f01c - 0x15f06c)
    ctx->pc = 0x15f060;
    entry_15f01c(rdram, ctx, runtime);
}

void entry_15f098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f098 inside entry_15f07c (0x15f07c - 0x15f0a0)
    ctx->pc = 0x15f098;
    entry_15f07c(rdram, ctx, runtime);
}

void entry_15f0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f0ac inside entry_15f0a0 (0x15f0a0 - 0x15f0b8)
    ctx->pc = 0x15f0ac;
    entry_15f0a0(rdram, ctx, runtime);
}

void entry_15f0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f0f8 inside entry_15f0b8 (0x15f0b8 - 0x15f110)
    ctx->pc = 0x15f0f8;
    entry_15f0b8(rdram, ctx, runtime);
}

void entry_15f148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f148 inside entry_15f12c (0x15f12c - 0x15f150)
    ctx->pc = 0x15f148;
    entry_15f12c(rdram, ctx, runtime);
}

void entry_15f158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f158 inside entry_15f150 (0x15f150 - 0x15f160)
    ctx->pc = 0x15f158;
    entry_15f150(rdram, ctx, runtime);
}

void entry_15f1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f1a8 inside entry_15f160 (0x15f160 - 0x15f1b4)
    ctx->pc = 0x15f1a8;
    entry_15f160(rdram, ctx, runtime);
}

void entry_15f1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f1e0 inside entry_15f1c4 (0x15f1c4 - 0x15f210)
    ctx->pc = 0x15f1e0;
    entry_15f1c4(rdram, ctx, runtime);
}

void entry_15f1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f1ec inside entry_15f1c4 (0x15f1c4 - 0x15f210)
    ctx->pc = 0x15f1ec;
    entry_15f1c4(rdram, ctx, runtime);
}

void entry_15f240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f240 inside FlushFrames__Fi (0x15f210 - 0x15f248)
    ctx->pc = 0x15f240;
    FlushFrames__Fi(rdram, ctx, runtime);
}

void entry_15f258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f258 inside entry_15f248 (0x15f248 - 0x15f260)
    ctx->pc = 0x15f258;
    entry_15f248(rdram, ctx, runtime);
}

void entry_15f270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f270 inside entry_15f260 (0x15f260 - 0x15f2ac)
    ctx->pc = 0x15f270;
    entry_15f260(rdram, ctx, runtime);
}

void entry_15f2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f2a0 inside entry_15f260 (0x15f260 - 0x15f2ac)
    ctx->pc = 0x15f2a0;
    entry_15f260(rdram, ctx, runtime);
}

void entry_15f2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f2d0 inside entry_15f2bc (0x15f2bc - 0x15f2e8)
    ctx->pc = 0x15f2d0;
    entry_15f2bc(rdram, ctx, runtime);
}

void entry_15f2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f2e0 inside entry_15f2bc (0x15f2bc - 0x15f2e8)
    ctx->pc = 0x15f2e0;
    entry_15f2bc(rdram, ctx, runtime);
}

void entry_15f394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f394 inside entry_15f374 (0x15f374 - 0x15f3b0)
    ctx->pc = 0x15f394;
    entry_15f374(rdram, ctx, runtime);
}

void entry_15f39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f39c inside entry_15f374 (0x15f374 - 0x15f3b0)
    ctx->pc = 0x15f39c;
    entry_15f374(rdram, ctx, runtime);
}

void entry_15f3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f3f0 inside entry_15f3d8 (0x15f3d8 - 0x15f444)
    ctx->pc = 0x15f3f0;
    entry_15f3d8(rdram, ctx, runtime);
}

void entry_15f3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f3f8 inside entry_15f3d8 (0x15f3d8 - 0x15f444)
    ctx->pc = 0x15f3f8;
    entry_15f3d8(rdram, ctx, runtime);
}

void entry_15f4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f4f8 inside entry_15f4e4 (0x15f4e4 - 0x15f508)
    ctx->pc = 0x15f4f8;
    entry_15f4e4(rdram, ctx, runtime);
}

void entry_15f64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f64c inside entry_15f648 (0x15f648 - 0x15f658)
    ctx->pc = 0x15f64c;
    entry_15f648(rdram, ctx, runtime);
}

void entry_15f6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f6b4 inside RemergeSwObject__FP2SWP3ALO (0x15f678 - 0x15f6c0)
    ctx->pc = 0x15f6b4;
    RemergeSwObject__FP2SWP3ALO(rdram, ctx, runtime);
}

void entry_15f6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f6e0 inside MergeSwFreezeGroups__FP2SWP3ALOT1 (0x15f6c0 - 0x15f704)
    ctx->pc = 0x15f6e0;
    MergeSwFreezeGroups__FP2SWP3ALOT1(rdram, ctx, runtime);
}

void entry_15f6fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f6fc inside MergeSwFreezeGroups__FP2SWP3ALOT1 (0x15f6c0 - 0x15f704)
    ctx->pc = 0x15f6fc;
    MergeSwFreezeGroups__FP2SWP3ALOT1(rdram, ctx, runtime);
}

void entry_15f770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f770 inside SplinterSwFreezeGroup__FP2SWP3ALO (0x15f710 - 0x15f780)
    ctx->pc = 0x15f770;
    SplinterSwFreezeGroup__FP2SWP3ALO(rdram, ctx, runtime);
}

void entry_15f78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f78c inside entry_15f780 (0x15f780 - 0x15f798)
    ctx->pc = 0x15f78c;
    entry_15f780(rdram, ctx, runtime);
}

void entry_15f7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f7b4 inside entry_15f798 (0x15f798 - 0x15f7d8)
    ctx->pc = 0x15f7b4;
    entry_15f798(rdram, ctx, runtime);
}

void entry_15f800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f800 inside MergeSwGroup__FP2SWP3MRG (0x15f7d8 - 0x15f820)
    ctx->pc = 0x15f800;
    MergeSwGroup__FP2SWP3MRG(rdram, ctx, runtime);
}

void entry_15f828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f828 inside entry_15f820 (0x15f820 - 0x15f850)
    ctx->pc = 0x15f828;
    entry_15f820(rdram, ctx, runtime);
}

void entry_15f840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f840 inside entry_15f820 (0x15f820 - 0x15f850)
    ctx->pc = 0x15f840;
    entry_15f820(rdram, ctx, runtime);
}

void entry_15f88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f88c inside entry_15f878 (0x15f878 - 0x15f8b0)
    ctx->pc = 0x15f88c;
    entry_15f878(rdram, ctx, runtime);
}

void entry_15f8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f8d8 inside AddSwMergeGroup__FP2SWP3MRG (0x15f8b0 - 0x15f920)
    ctx->pc = 0x15f8d8;
    AddSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime);
}

void entry_15f904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f904 inside AddSwMergeGroup__FP2SWP3MRG (0x15f8b0 - 0x15f920)
    ctx->pc = 0x15f904;
    AddSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime);
}

void entry_15f918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f918 inside AddSwMergeGroup__FP2SWP3MRG (0x15f8b0 - 0x15f920)
    ctx->pc = 0x15f918;
    AddSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime);
}

void entry_15f924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f924 inside entry_15f920 (0x15f920 - 0x15f930)
    ctx->pc = 0x15f924;
    entry_15f920(rdram, ctx, runtime);
}

void entry_15f958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f958 inside RemoveFromArray__FPiPPvPv (0x15f930 - 0x15f984)
    ctx->pc = 0x15f958;
    RemoveFromArray__FPiPPvPv(rdram, ctx, runtime);
}

void entry_15f990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f990 inside entry_15f984 (0x15f984 - 0x15f9a0)
    ctx->pc = 0x15f990;
    entry_15f984(rdram, ctx, runtime);
}

void entry_15f9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15f9d8 inside RemoveSwMergeGroup__FP2SWP3MRG (0x15f9a0 - 0x15f9f8)
    ctx->pc = 0x15f9d8;
    RemoveSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime);
}

void entry_15fa08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fa08 inside entry_15f9f8 (0x15f9f8 - 0x15fa3c)
    ctx->pc = 0x15fa08;
    entry_15f9f8(rdram, ctx, runtime);
}

void entry_15fa10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fa10 inside entry_15f9f8 (0x15f9f8 - 0x15fa3c)
    ctx->pc = 0x15fa10;
    entry_15f9f8(rdram, ctx, runtime);
}

void entry_15faa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15faa0 inside RemergeSwObjects__FP2SW (0x15fa58 - 0x15faf0)
    ctx->pc = 0x15faa0;
    RemergeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fae0 inside RemergeSwObjects__FP2SW (0x15fa58 - 0x15faf0)
    ctx->pc = 0x15fae0;
    RemergeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15faf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15faf8 inside entry_15faf0 (0x15faf0 - 0x15fb28)
    ctx->pc = 0x15faf8;
    entry_15faf0(rdram, ctx, runtime);
}

void entry_15fb08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fb08 inside entry_15faf0 (0x15faf0 - 0x15fb28)
    ctx->pc = 0x15fb08;
    entry_15faf0(rdram, ctx, runtime);
}

void entry_15fb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fb68 inside entry_15fb54 (0x15fb54 - 0x15fb80)
    ctx->pc = 0x15fb68;
    entry_15fb54(rdram, ctx, runtime);
}

void entry_15fb90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fb90 inside entry_15fb80 (0x15fb80 - 0x15fba0)
    ctx->pc = 0x15fb90;
    entry_15fb80(rdram, ctx, runtime);
}

void entry_15fc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fc40 inside entry_15fc28 (0x15fc28 - 0x15fc74)
    ctx->pc = 0x15fc40;
    entry_15fc28(rdram, ctx, runtime);
}

void entry_15fd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fd40 inside entry_15fd38 (0x15fd38 - 0x15fd4c)
    ctx->pc = 0x15fd40;
    entry_15fd38(rdram, ctx, runtime);
}

void entry_15fd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fd68 inside entry_15fd64 (0x15fd64 - 0x15fd78)
    ctx->pc = 0x15fd68;
    entry_15fd64(rdram, ctx, runtime);
}

void entry_15fdb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fdb0 inside RefreezeSwObjects__FP2SW (0x15fd78 - 0x15fea8)
    ctx->pc = 0x15fdb0;
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fdd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fdd8 inside RefreezeSwObjects__FP2SW (0x15fd78 - 0x15fea8)
    ctx->pc = 0x15fdd8;
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fdf8 inside RefreezeSwObjects__FP2SW (0x15fd78 - 0x15fea8)
    ctx->pc = 0x15fdf8;
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fe50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fe50 inside RefreezeSwObjects__FP2SW (0x15fd78 - 0x15fea8)
    ctx->pc = 0x15fe50;
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fe58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fe58 inside RefreezeSwObjects__FP2SW (0x15fd78 - 0x15fea8)
    ctx->pc = 0x15fe58;
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fe5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fe5c inside RefreezeSwObjects__FP2SW (0x15fd78 - 0x15fea8)
    ctx->pc = 0x15fe5c;
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fe88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fe88 inside RefreezeSwObjects__FP2SW (0x15fd78 - 0x15fea8)
    ctx->pc = 0x15fe88;
    RefreezeSwObjects__FP2SW(rdram, ctx, runtime);
}

void entry_15fed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15fed8 inside entry_15fed0 (0x15fed0 - 0x15fee0)
    ctx->pc = 0x15fed8;
    entry_15fed0(rdram, ctx, runtime);
}

void entry_15ff0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ff0c inside entry_15ff08 (0x15ff08 - 0x15ff58)
    ctx->pc = 0x15ff0c;
    entry_15ff08(rdram, ctx, runtime);
}

void entry_15ff1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ff1c inside entry_15ff08 (0x15ff08 - 0x15ff58)
    ctx->pc = 0x15ff1c;
    entry_15ff08(rdram, ctx, runtime);
}

void entry_15ff28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ff28 inside entry_15ff08 (0x15ff08 - 0x15ff58)
    ctx->pc = 0x15ff28;
    entry_15ff08(rdram, ctx, runtime);
}

void entry_15ff34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ff34 inside entry_15ff08 (0x15ff08 - 0x15ff58)
    ctx->pc = 0x15ff34;
    entry_15ff08(rdram, ctx, runtime);
}

void entry_15ffd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x15ffd8 inside entry_15ffc4 (0x15ffc4 - 0x15ffe8)
    ctx->pc = 0x15ffd8;
    entry_15ffc4(rdram, ctx, runtime);
}

